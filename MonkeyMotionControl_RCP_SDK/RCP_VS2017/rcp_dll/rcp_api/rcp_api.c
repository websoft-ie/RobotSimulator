/********************************************************************************
 * This file is part of the RCP SDK Release 6.62.0
 * Copyright (C) 2009-2018 RED.COM, LLC.  All rights reserved.
 *
 * For technical support please email rcpsdk@red.com.
 *
 * "Source Code" means the accompanying software in any form preferred for making
 * modifications. "Source Code" does not include the accompanying strlcat.c and
 * strlcpy.c software and examples/qt/common/qt/serial software.
 * 
 * "Binary Code" means machine-readable Source Code in binary form.
 * 
 * "Approved Recipients" means only those recipients of the Source Code who have
 * entered into the RCP SDK License Agreement with RED.COM, LLC. All
 * other recipients are not authorized to possess, modify, use, or distribute the
 * Source Code.
 *
 * RED.COM, LLC hereby grants Approved Recipients the rights to modify this
 * Source Code, create derivative works based on this Source Code, and distribute
 * the modified/derivative works only as Binary Code in its binary form. Approved
 * Recipients may not distribute the Source Code or any modification or derivative
 * work of the Source Code. Redistributions of Binary Code must reproduce this
 * copyright notice, this list of conditions, and the following disclaimer in the
 * documentation or other materials provided with the distribution. RED.COM, LLC
 * may not be used to endorse or promote Binary Code redistributions without
 * specific prior written consent from RED.COM, LLC. 
 *
 * The only exception to the above licensing requirements is any recipient may use,
 * copy, modify, and distribute in any format the strlcat.c and strlcpy.c software
 * in accordance with the provisions required by the license associated therewith;
 * provided, however, that the modifications are solely to the strlcat.c and
 * strlcpy.c software and do not include any other portion of the Source Code.
 * 
 * THE ACCOMPANYING SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE RED.COM, LLC, ANY OTHER COPYRIGHT HOLDERS, OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER
 * IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 ********************************************************************************/

/********************************************************************************
 * RCP API
 ********************************************************************************
 * This file is an amalgamation of many separate C source files from the RCP API.
 * By combining all the individual C source files into this single large file,
 * the entire source code can be compiled as a single translation unit.
 *
 * This file is all you need to compile the RCP API.  To use the RCP API in other
 * programs, you need this file and the "rcp_api.h" header file that defines
 * the programming interface of the RCP API.
 ********************************************************************************/

#define RCP_API_PRIVATE static

/********** Begin file: rcp_types_public.h **************************************/
#ifndef RCP_TYPES_PUBLIC_H
#define RCP_TYPES_PUBLIC_H

#include <stdint.h>

#define ALLOWED_NAME_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -=[];',./!@#$%^&*()_+{}:<>?"
#define ALLOWED_SCENE_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-"
#define ALLOWED_SHOT_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789*"
#define ALLOWED_COMM_NAME_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
#define ALLOWED_AUDIO_CHANNEL_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
#define ALLOWED_HOST_IP_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-."
#define ALLOWED_SSID_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -=[];',./!@#$%^&*()_+{}:<>?\""
#define ALLOWED_WEP_PW_CHARS "ABCDEF0123456789"
#define ALLOWED_WPA_PW_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -=[];',./!@#$%^&*()_+{}:<>?\"\\`|"
#define ALLOWED_LENS_NAME_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -=[];',./!@#$%^&*()_+{}:<>?"
#define ALLOWED_LENS_SERIAL_CHARS "0123456789"

#define BATTERY_INVALID_VALUE           (-1)
#define BATTERY_RUNTIME_WARNING_MINUTES (10)
#define BATTERY_RUNTIME_LOW_MINUTES     (5)
#define BATTERY_RUNTIME_MAX_MINUTES     (600)

/* RCP: CSPACE */
typedef enum {
    COLORSPACE_REC709 = 1,
    COLORSPACE_REDCOLOR2 = 6,
    COLORSPACE_REDCOLOR3 = 8,
    COLORSPACE_DRAGONCOLOR = 9,
    COLORSPACE_ACES = 10,
    COLORSPACE_REDCOLOR4 = 11,
    COLORSPACE_DRAGONCOLOR2 = 12,
    COLORSPACE_REC2020 = 13,
    COLORSPACE_ACES_AP1 = 14,
    COLORSPACE_RWGRGB = 15,
    COLORSPACE_P3 = 16,
    COLORSPACE_MAX,
    COLORSPACE_UNDEFINED = 255
} colorspace_t;

/* RCP: GSPACE */
typedef enum {
    GAMMACURVE_REDLOGFILM = 9,
    GAMMACURVE_REDGAMMA2 = 10,
    GAMMACURVE_REDGAMMA3 = 11,
    GAMMACURVE_REDGAMMA4 = 12,
    GAMMACURVE_ACESPROXY = 13,
    GAMMACURVE_LOG3G12 = 14,
    GAMMACURVE_HDR2084 = 15,
    GAMMACURVE_BT1886 = 16,
    GAMMACURVE_ACESCC = 17,
    GAMMACURVE_LOG3G10 = 18,
    GAMMACURVE_MAX,
    GAMMACURVE_UNDEFINED = 255
} gammaspace_t;

/* RCP: CLPDIR */
typedef enum
{
    PLAYER_DIRECTION_DEFAULT,
    PLAYER_DIRECTION_FWD,
    PLAYER_DIRECTION_REV
} player_direction_t;

/* RCP: LOOP */
typedef enum
{
    PLAYER_NO_LOOP,
    PLAYER_LOOP,
    PLAYER_LOOP_LIST
} player_loop_t;

/* RCP: FORMAT2 */
typedef enum
{
    RESOLUTION_8K = 0,
    RESOLUTION_6P5K,
    RESOLUTION_2K,
    RESOLUTION_3K,
    RESOLUTION_3P5K,
    RESOLUTION_4K,
    RESOLUTION_4P5K,
    RESOLUTION_5K,
    RESOLUTION_1K,
    RESOLUTION_6K,
    RESOLUTION_5P5K,
    RESOLUTION_2P5K,
    RESOLUTION_7K,
    RESOLUTION_7P5K,
    RESOLUTION_UNKNOWN,
    RESOLUTION_MAX
} resolution_t;

/* RCP: FORMAT2 */
typedef enum
{
    AR_3_2,
    AR_4_3,
    AR_5_4,
    AR_16_9,
    AR_2_1,
    AR_2_4_1,
    AR_FF,
    AR_720P,
    AR_1080P,
    AR_1_22_1,
    AR_6_5,
    AR_4_1,
    AR_8_1,
    AR_1_1,
    AR_14_9,
    AR_1_7_1,
    AR_8_9,
    AR_1_2_1,
    AR_UNKNOWN,
    AR_MAX
} aspect_ratio_t;

/* RCP: FORMAT2 */
typedef enum
{
    ANA_OFF = 0,
    ANA_2 = 1,
    ANA_1_3 = 2,
    ANA_1_25 = 3,
    ANA_1_6 = 4,
    ANA_1_8 = 5,
    ANA_1_5 = 6,
    ANA_MAX
} anamorphic_t;

/* RCP: HDRMODE */
typedef enum
{
    HDR_MODE_OFF,
    HDR_MODE_HDRX
} hdr_mode_t;

/* RCP: OGTMODE */
typedef enum
{
    OPEN_GATE_MODE_DONT_ALLOW,
    OPEN_GATE_MODE_ALLOW
} open_gate_mode_t;

/* RCP: OGTSTATE */
typedef enum
{
    OPEN_GATE_STATE_OFF,
    OPEN_GATE_STATE_ACTIVE
} open_gate_state_t;

/* RCP: LENSFDMD */
typedef enum {
    FOCUS_DISTANCE_MODE_METRIC,
    FOCUS_DISTANCE_MODE_IMPERIAL
} focus_distance_mode_t;

/* RCP: SHMODE */
typedef enum {
    SHUTTER_MODE_ABSOLUTE,
    SHUTTER_MODE_RELATIVE
} shutter_mode_t;

/* RCP: SHDISP */
typedef enum {
    SHUTTER_TIME,
    SHUTTER_ANGLE
} shutter_display_t;

/* RCP: SYNC */
typedef enum {  /* actual shutter sync state. */
    SYNC_STATE_NONE,          /*  grey */
    SYNC_STATE_NO_LOCK,       /*  red */
    SYNC_STATE_GENLOCK        /*  green */
} sync_state_t;

/* RCP: GENLOC */
typedef enum {
    GENLOCK_STATE_NONE,      /*  grey - no signal detected */
    GENLOCK_STATE_PRESENT,   /*  red - signal detected but not locked */
    GENLOCK_STATE_LOCKED,     /*  green - monitors locked to genlock signal. */
    GENLOCK_STATE_CROSSLOCKED /*  yellow - genlock in does not match monitor rate, but gennum can cross lock */
} genlock_state_t;

/* RCP: FALSEC */
typedef enum {
    FALSE_COLOR_MODE_NONE,
    FALSE_COLOR_MODE_EXPOSURE,
    FALSE_COLOR_MODE_VIDEO,
    FALSE_COLOR_MODE_FOCUS,
    FALSE_COLOR_MODE_EDGE,
    FALSE_COLOR_MODE_GIO_SCOPE,
    FALSE_COLOR_MODE_PEAKING,
    FALSE_COLOR_MODE_COUNT
} false_color_mode_t;

/* RCP: PWRSRC */
typedef enum {
    POWER_SOURCE_REAR_BAT_1,
    POWER_SOURCE_REAR_BAT_2,
    POWER_SOURCE_REAR_BAT_3,
    POWER_SOURCE_REAR_BAT_4,
    POWER_SOURCE_SH_BAT,
    POWER_SOURCE_DC_JACK_BAT,   /* Battery */
    POWER_SOURCE_DC_JACK_AC,    /* AC Adaptor (ElPac) */
    POWER_SOURCE_DEPRECATED_1,
    POWER_SOURCE_DEPRECATED_2,
    POWER_SOURCE_VMOUNT,
    POWER_SOURCE_DC_JACK_28V,   /* XL 28V DC IN */
    POWER_SOURCE_COUNT
} power_source_t;

/* RCP: RECORD (S) */
typedef enum {
    SET_RECORD_STATE_STOP,
    SET_RECORD_STATE_START,
    SET_RECORD_STATE_TOGGLE,
    SET_RECORD_STATE_START_PRE_RECORD
} set_record_state_t;

/* RCP: RECORD (G and C) */
typedef enum {
    RECORD_STATE_NOT_RECORDING,
    RECORD_STATE_RECORDING,
    RECORD_STATE_FINALIZING,
    RECORD_STATE_PRE_RECORDING,
    RECORD_STATE_ENCODING,
    RECORD_STATE_COUNT
} record_state_t;

/* RCP: TETHERED SERVER (G and C) */
typedef enum {
    TETHERED_SERVER_STATE_NOT_RECORDING,
    TETHERED_SERVER_STATE_RECORDING
} tethered_server_state_t;

/* RCP: PLAYBACK (S) */
typedef enum {
    SET_PLAYBACK_STATE_STOP,
    SET_PLAYBACK_STATE_START,
    SET_PLAYBACK_STATE_TOGGLE
} set_playback_state_t;

/* RCP: PLAYBACK (G and C) */
typedef enum {
    PLAYBACK_STATE_NOT_IN_PLAYBACK,
    PLAYBACK_STATE_IN_PLAYBACK,
    PLAYBACK_STATE_COUNT
} playback_state_t;

/* RCP: CAMPOS */
typedef enum {
    CAM_POS_LEFT,
    CAM_POS_CENTER,
    CAM_POS_RIGHT,
    CAM_POS_A,
    CAM_POS_B,
/* CAM_POS_CENTER */
    CAM_POS_D,
    CAM_POS_E,
    CAM_POS_F,
    CAM_POS_G,
    CAM_POS_H,
    CAM_POS_I,
    CAM_POS_J,
    CAM_POS_K,
/* CAM_POS_LEFT */
    CAM_POS_M,
    CAM_POS_N,
    CAM_POS_O,
    CAM_POS_P,
    CAM_POS_Q,
/* CAM_POS_RIGHT */
    CAM_POS_S,
    CAM_POS_T,
    CAM_POS_U,
    CAM_POS_V,
    CAM_POS_W,
    CAM_POS_X,
    CAM_POS_Y,
    CAM_POS_Z
} cam_pos_t;

/* RCP: TPATTERN */
typedef enum
{
    MONITOR_TEST_PATTERN_NONE,
    MONITOR_TEST_PATTERN_CHIP_CHART,
    MONITOR_TEST_PATTERN_SMPTE_BAR,
    MONITOR_TEST_PATTERN_LUMA_RAMP,
    MONITOR_TEST_PATTERN_COUNT
} monitor_test_pattern_t;

/* RCP: SELISO, SELSH */
typedef enum {
    LIST_SELECT_NEXT,
    LIST_SELECT_PREVIOUS,
    LIST_SELECT_FIRST,
    LIST_SELECT_LAST
} list_select_t;

/* RCP: TCJAM */
typedef enum {
    TC_SYNC_STATE_NOT_PRESENT,       /* no analog LTC timecode being detected */
    TC_SYNC_STATE_PRESENT_NOT_USED,  /* analog LTC signal is being received, but not being used */
    TC_SYNC_STATE_PRESENT_USED       /* analog LTC signal is being received and TC is jamsynced to it */
} tc_sync_state_t;

/* RCP: FRPRMODE */
typedef enum {
    FRAME_PROCESSING_INVALID = -1,
    FRAME_PROCESSING_OFF,
    FRAME_PROCESSING_SUM,
    FRAME_PROCESSING_AVG
} frame_processing_t;

/* RCP: BATTMODE */
typedef enum {
    BATTERY_DISPLAY_MODE_PERCENT,
    BATTERY_DISPLAY_MODE_TOTAL_TIME,
    BATTERY_DISPLAY_MODE_VOLTAGE
} battery_display_mode_t;

/* RCP: RAWMODE */
typedef enum {
    RAW_MODE_OFF,
    RAW_MODE_ON,
    RAW_MODE_COUNT
} raw_mode_t;

/* RCP: LOGVIEWMODE */
typedef enum {
    LOG_VIEW_MODE_OFF,
    LOG_VIEW_MODE_ON,
    LOG_VIEW_MODE_COUNT
} log_view_mode_t;

/* RCP: MEDIAMOD */
typedef enum
{
    MEDIA_DISPLAY_PERCENTAGE,
    MEDIA_DISPLAY_TIME
} media_display_t;

/* RCP: RECMODE */
typedef enum {
    RECORD_MODE_CONTINUOUS,
    RECORD_MODE_TIMELAPSE,
    RECORD_MODE_FRAME_TRIGGER,
    RECORD_MODE_RAMP,
    RECORD_MODE_EXTERNAL,
    RECORD_MODE_STREAM,
    RECORD_MODE_BURST,
    RECORD_MODE_MULTI_SHOT,
    RECORD_MODE_MOTION_PLUS_STILLS,
    RECORD_MODE_PREVIEW_OVERDRIVE,
    RECORD_MODE_COUNT
} record_mode_t;

/* RCP: HDRXMONX */
typedef enum
{
    HDR_TRACK_A,
    HDR_TRACK_X
} hdr_track_t;

typedef enum
{
    KEY_ACTION_KEY_DISABLED = 1,
    KEY_ACTION_SLOT_SET_ISO = 2,
    KEY_ACTION_SLOT_SET_COLOR_TEMP = 3,
    KEY_ACTION_SLOT_SET_SHUTTER = 4,
    KEY_ACTION_SLOT_SET_APERTURE = 5,
    KEY_ACTION_RECORD_TOGGLE = 6,
    KEY_ACTION_MAGNIFY_TOGGLE = 7,
    KEY_ACTION_WB_AUTO_CALC = 8,
    KEY_ACTION_NAVIGATION_SELECT = 9,
    KEY_ACTION_EJECT_MEDIA = 10,
    KEY_ACTION_AF_START = 11,
    KEY_ACTION_NAVIGATION_LEFT = 12,
    KEY_ACTION_NAVIGATION_RIGHT = 13,
    KEY_ACTION_NAVIGATION_MENU = 14,
    KEY_ACTION_SHOW_DIALOG = 15,
    KEY_ACTION_VIDEO_CHECK_TOGGLE = 16,
    KEY_ACTION_SLOT_NEXT_VALUE = 17,
    KEY_ACTION_SLOT_PREVIOUS_VALUE = 18,
    KEY_ACTION_SHUTDOWN = 19,
    KEY_ACTION_AF_MODE_CYCLE = 20,
    KEY_ACTION_EXPOSURE_CHECK_TOGGLE = 21,
    KEY_ACTION_AF_CENTER_WINDOW = 22,
    KEY_ACTION_LCD_BRAIN_BR_UP = 23,
    KEY_ACTION_LCD_BRAIN_BR_DOWN = 24,
    KEY_ACTION_SLOT_SET_FPS = 25,
    KEY_ACTION_SLOT_SET_FORMAT = 26,
    KEY_ACTION_SLOT_SET_REDCODE = 27,
    KEY_ACTION_LCD_TOGGLE_LOCK = 28,
    KEY_ACTION_EVF_BRAIN_CYCLE_MODE = 29,
    KEY_ACTION_RECORD_START = 30,
    KEY_ACTION_RECORD_STOP = 31,
    KEY_ACTION_SH_TOGGLE_BACKLIGHT = 32,
    KEY_ACTION_NAVIGATION_UP = 33,
    KEY_ACTION_NAVIGATION_DOWN = 34,
    KEY_ACTION_NAVIGATION_CW = 35,
    KEY_ACTION_NAVIGATION_CCW = 36,
    KEY_ACTION_CAMERA_MODE_STILLS = 37,
    KEY_ACTION_CAMERA_MODE_MOTION = 38,
    KEY_ACTION_RAW_CHECK_TOGGLE = 39,
    KEY_ACTION_HDR_MODE_TOGGLE = 40,
    KEY_ACTION_DISPLAY_CHECK_MODE_CYCLE = 41,
    KEY_ACTION_PLAYBACK_PREVIEW_TOGGLE = 42,
    KEY_ACTION_ZEBRA_1_TOGGLE = 43,
    KEY_ACTION_ZEBRA_2_TOGGLE = 44,
    KEY_ACTION_ZEBRA_1_2_TOGGLE = 45,
    KEY_ACTION_SHUTTER_MODE_TOGGLE = 46,
    KEY_ACTION_SHUTTER_ANGLE_ABS_REL_MODE_TOGGLE = 47,
    KEY_ACTION_TC_DISPLAY_MODE_TOGGLE = 48,
    /* Deprecated - 49 */
    KEY_ACTION_AF_ONE_SHOT = 50,
    KEY_ACTION_SOUND_SHUTTER = 51,
    KEY_ACTION_SOUND_OTHER = 52,
    KEY_ACTION_AF_TOGGLE_WINDOW_SIZE = 53,
    KEY_ACTION_EVF_REAR_CYCLE_MODE = 54,
    KEY_ACTION_EDGE_FOCUS_CHECK_TOGGLE = 55,
    KEY_ACTION_FOCUS_CHECK_TOGGLE = 56,
    KEY_ACTION_IRIS_OPEN = 57,
    KEY_ACTION_IRIS_CLOSE = 58,
    KEY_ACTION_FOCUS_NEAR = 59,
    KEY_ACTION_FOCUS_FAR = 60,
    KEY_ACTION_GO_TO_PLAYBACK = 61,
    KEY_ACTION_GO_TO_PREVIEW = 62,
    /* Deprecated - 63 */
    KEY_ACTION_STROBE_TRIGGER = 64,
    KEY_ACTION_APPLY_LOOK = 65,
    KEY_ACTION_LCD_REAR_BR_UP = 66,
    KEY_ACTION_LCD_REAR_BR_DOWN = 67,
    KEY_ACTION_SH_TOGGLE_KEY_LOCK = 68,
    KEY_ACTION_APPLY_PRESET = 69,
    KEY_ACTION_MAGNIFY_ON = 70,
    KEY_ACTION_MAGNIFY_OFF = 71,
    KEY_ACTION_PLAYBACK_PLAY_PAUSE = 72,
    KEY_ACTION_PLAYBACK_STEP_FORWARD = 73,
    KEY_ACTION_PLAYBACK_STEP_BACKWARD = 74,
    KEY_ACTION_PLAYBACK_NEXT_CLIP = 75,
    KEY_ACTION_PLAYBACK_PREV_CLIP = 76,
    KEY_ACTION_PLAYBACK_SET_IN_POINT = 77,
    KEY_ACTION_PLAYBACK_SET_OUT_POINT = 78,
    KEY_ACTION_PLAYBACK_TOGGLE_LOOP = 79,
    KEY_ACTION_PLAYBACK_TOGGLE_DIRECTION = 80,
    KEY_ACTION_PLAYBACK_CYCLE_SPEED = 81,
    KEY_ACTION_INTEGRATION_TIME_INCREASE = 82,
    KEY_ACTION_INTEGRATION_TIME_DECREASE = 83,
    KEY_ACTION_ISO_INCREASE = 84,
    KEY_ACTION_ISO_DECREASE = 85,
    KEY_ACTION_SAVE_UI_SCREENSHOT_TO_MEDIA = 86,
    KEY_ACTION_LCD_BRAIN_CYCLE_MODE = 87,
    KEY_ACTION_HDMI_BRAIN_CYCLE_MODE = 88,
    KEY_ACTION_HDSDI_BRAIN_CYCLE_MODE = 89,
    KEY_ACTION_LCD_REAR_CYCLE_MODE = 90,
    KEY_ACTION_HDSDI_PVW_PRO_I_O_CYCLE_MODE = 91,
    KEY_ACTION_HDSDI_PGM_PRO_I_O_CYCLE_MODE = 92,
    KEY_ACTION_POWER_OUT_PRO_I_O_GPIO_ENABLE = 93,
    KEY_ACTION_POWER_OUT_PRO_I_O_GPIO_DISABLE = 94,
    KEY_ACTION_POWER_OUT_PRO_I_O_GPIO_TOGGLE = 95,
    KEY_ACTION_POWER_OUT_PRO_I_O_PWR_ENABLE = 96,
    KEY_ACTION_POWER_OUT_PRO_I_O_PWR_DISABLE = 97,
    KEY_ACTION_POWER_OUT_PRO_I_O_PWR_TOGGLE = 98,
    KEY_ACTION_POWER_OUT_PRO_I_O_AUX_ENABLE = 99,
    KEY_ACTION_POWER_OUT_PRO_I_O_AUX_DISABLE = 100,
    KEY_ACTION_POWER_OUT_PRO_I_O_AUX_TOGGLE = 101,
    KEY_ACTION_RECORD_FRAME_TRIGGER = 102,
    KEY_ACTION_RECORD_START_SPEED_RAMP_A = 103,
    KEY_ACTION_EVF_BRAIN_BR_UP = 104,
    KEY_ACTION_EVF_BRAIN_BR_DOWN = 105,
    KEY_ACTION_EVF_REAR_BR_UP = 106,
    KEY_ACTION_EVF_REAR_BR_DOWN = 107,
    KEY_ACTION_RECORD_START_PRE_RECORD = 108,
    KEY_ACTION_POWER_OUT_PLUS_1_PWR_ENABLE = 109,
    KEY_ACTION_POWER_OUT_PLUS_1_PWR_DISABLE = 110,
    KEY_ACTION_POWER_OUT_PLUS_1_PWR_TOGGLE = 111,
    KEY_ACTION_POWER_SAVE_ENTER_LOW_POWER_PREVIEW = 112,
    KEY_ACTION_POWER_SAVE_ENTER_SLEEP = 113,
    KEY_ACTION_RECORD_START_SPEED_RAMP_B = 114,
    KEY_ACTION_RECORD_START_SPEED_RAMP_C = 115,
    KEY_ACTION_RECORD_START_SPEED_RAMP_D = 116,
    KEY_ACTION_RECORD_START_SPEED_RAMP_RESET = 117,
    KEY_ACTION_SHUTTER_ND_075 = 118,
    KEY_ACTION_SHUTTER_ND_100 = 119,
    KEY_ACTION_SHUTTER_ND_150 = 120,
    KEY_ACTION_SHUTTER_ND_225 = 121,
    KEY_ACTION_SHUTTER_ND_300 = 122,
    KEY_ACTION_SHUTTER_ANTIALIAS_1944_360 = 123,
    KEY_ACTION_SHUTTER_ND_ONLY = 124,
    KEY_ACTION_TOGGLE_RETURN_FEED = 125,
    KEY_ACTION_SHUTTER_INCREMENT_ND_PLUS_010 = 126,
    KEY_ACTION_SHUTTER_DECREMENT_ND_MINUS_010 = 127,
    KEY_ACTION_SHUTTER_ND_050 = 128,
    KEY_ACTION_SHUTTER_SQUARE_180_360 = 129,
    /* free - 130 */
    KEY_ACTION_AF_RACK_TO_A = 131,
    KEY_ACTION_AF_RACK_TO_B = 132,
    KEY_ACTION_AF_RACK_TO_C = 133,
    KEY_ACTION_AF_RACK_TO_D = 134,
    /* free - 135 */
    KEY_ACTION_SAVE_LOG = 136,
    KEY_ACTION_MARK_SNAPSHOT = 137,
    KEY_ACTION_TOGGLE_OVERLAYS_BRAIN_LCD = 138,
    KEY_ACTION_TOGGLE_OVERLAYS_BRAIN_EVF = 139,
    KEY_ACTION_TOGGLE_OVERLAYS_BRAIN_HDMI = 140,
    KEY_ACTION_TOGGLE_OVERLAYS_BRAIN_HDSDI = 141,
    KEY_ACTION_TOGGLE_OVERLAYS_REAR_LCD = 142,
    KEY_ACTION_TOGGLE_OVERLAYS_REAR_EVF = 143,
    KEY_ACTION_TOGGLE_OVERLAYS_REAR_HDSDI_1 = 144,
    KEY_ACTION_TOGGLE_OVERLAYS_REAR_HDSDI_2 = 145,
    KEY_ACTION_RUN_SCRIPT = 146,
    KEY_ACTION_NEXT_TAGGED_FRAME = 147,
    KEY_ACTION_PREV_TAGGED_FRAME = 148,
    KEY_ACTION_AE_CALC = 149,
    KEY_ACTION_AE_EV_UP = 150,
    KEY_ACTION_AE_EV_DOWN = 151,
    KEY_ACTION_HDR_TRACK_TOGGLE = 152,
    KEY_ACTION_HORIZON_ENABLE = 153,
    KEY_ACTION_HORIZON_DISABLE = 154,
    KEY_ACTION_HORIZON_TOGGLE = 155,
    KEY_ACTION_AE_MODE_OFF = 156,
    KEY_ACTION_AE_MODE_SINGLE_SHOT = 157,
    KEY_ACTION_AE_MODE_PREVIEW_ONLY = 158,
    KEY_ACTION_AE_MODE_PREVIEW_RECORD = 159,
    KEY_ACTION_AE_MODE_TOGGLE = 160,
    KEY_ACTION_AE_ZONE_SPOT = 161,
    KEY_ACTION_AE_ZONE_CENTER = 162,
    KEY_ACTION_AE_ZONE_AVERAGE = 163,
    KEY_ACTION_AE_ZONE_TOGGLE = 164,
    KEY_ACTION_RECORD_START_MARK_FRAME = 165,
    KEY_ACTION_RECORD_MULTISHOT_STOP = 166,
    KEY_ACTION_APERTURE_PRIORITY_ENABLE_TOGGLE = 167,
    KEY_ACTION_ALGO_TRIGGER = 168,
    KEY_ACTION_GIO_SCOPE_TOGGLE = 169,
    KEY_ACTION_PEAKING_TOGGLE = 170,
    /* free - 171 */
    KEY_ACTION_CAMERA_MODE_TOGGLE = 172,
    KEY_ACTION_SH_KEY_1 = 173,
    KEY_ACTION_SH_KEY_2 = 174,
    KEY_ACTION_SH_KEY_3 = 175,
    KEY_ACTION_SH_KEY_4 = 176,
    KEY_ACTION_RECORD_MULTISHOT_START = 177,
    KEY_ACTION_AUDIO_CH1_GAIN_INCREMENT = 178,
    KEY_ACTION_AUDIO_CH1_GAIN_DECREMENT = 179,
    KEY_ACTION_AUDIO_CH2_GAIN_INCREMENT = 180,
    KEY_ACTION_AUDIO_CH2_GAIN_DECREMENT = 181,
    KEY_ACTION_AUDIO_CH3_GAIN_INCREMENT = 182,
    KEY_ACTION_AUDIO_CH3_GAIN_DECREMENT = 183,
    KEY_ACTION_AUDIO_CH4_GAIN_INCREMENT = 184,
    KEY_ACTION_AUDIO_CH4_GAIN_DECREMENT = 185,
    KEY_ACTION_AF_SET_RACK_A = 186,
    KEY_ACTION_AF_SET_RACK_B = 187,
    KEY_ACTION_AF_SET_RACK_C = 188,
    KEY_ACTION_AF_SET_RACK_D = 189,
    KEY_ACTION_LCD3_BR_UP = 190,
    KEY_ACTION_LCD3_BR_DOWN = 191,
    KEY_ACTION_LCD3_CYCLE_MODE = 192,
    KEY_ACTION_TOGGLE_OVERLAYS_LCD3 = 193,
    KEY_ACTION_EVF3_BR_UP = 194,
    KEY_ACTION_EVF3_BR_DOWN = 195,
    KEY_ACTION_EVF3_CYCLE_MODE = 196,
    KEY_ACTION_TOGGLE_OVERLAYS_EVF3 = 197,
    KEY_ACTION_APERTURE_FINE_ADJUSTMENT_OPEN = 198,
    KEY_ACTION_APERTURE_FINE_ADJUSTMENT_CLOSE = 199,
    KEY_ACTION_SENSOR_SENSITIVITY_TOGGLE = 200,
    KEY_ACTION_COUNT
} key_action_t;

typedef enum
{
    TAG_INFO_TAG_TYPE_NONE = 0,
    TAG_INFO_TAG_TYPE_STILL = 1
} tag_info_tag_type_t;

typedef struct
{
    uint64_t frame;
    tag_info_tag_type_t type;
    char tod_timecode[14];
} tag_info_t;

/* RCP: MMNDMODE */
typedef enum
{
    MOTION_MOUNT_DISPLAY_ND,
    MOTION_MOUNT_DISPLAY_OD,
    MOTION_MOUNT_DISPLAY_FSTOP
} motion_mount_display_mode_t;

/* RCP: MMMODE */
typedef enum {
    MOTION_MOUNT_SHUTTER_MODE_ND_ONLY,
    MOTION_MOUNT_SHUTTER_MODE_SOFT,
    MOTION_MOUNT_SHUTTER_MODE_SQUARE
} motion_mount_shutter_mode_t;

/* RCP: RIGSTATE */
typedef enum
{
    METADATA_STATUS_DISABLED,
    METADATA_STATUS_ENABLED_INVALID,
    METADATA_STATUS_ENABLED_VALID
} metadata_status_t;

/* RCP: NWSTAT */
typedef enum
{
    GIGE_STATUS_DISABLED,
    GIGE_STATUS_ERROR,
    GIGE_STATUS_OK,
    GIGE_STATUS_WARNING
} gige_status_t;

/* RCP: LCDM, HDMIM, HDSDIM, PLCDM, PHDSDI1M, PHDSDI2M, EVFM, REVFM */
typedef enum
{
    MONITOR_MODE_OVERLAY,
    MONITOR_MODE_CLEAN,
    MONITOR_MODE_MIRROR_BRAIN_LCD,
    MONITOR_MODE_MIRROR_BRAIN_EVF,
    MONITOR_MODE_MIRROR_BRAIN_HDMI,
    MONITOR_MODE_MIRROR_BRAIN_HDSDI,
    MONITOR_MODE_MIRROR_REAR_LCD,
    MONITOR_MODE_MIRROR_REAR_EVF,
    MONITOR_MODE_MIRROR_PROIO_HDSDI_1,
    MONITOR_MODE_MIRROR_PROIO_HDSDI_2,
    MONITOR_MODE_DEPRECATED_1,
    MONITOR_MODE_MIRROR_BRAIN_LCD3,
    MONITOR_MODE_MIRROR_BRAIN_EVF3,
    MONITOR_MODE_CLONE_PROIO_HDSDI_1,
    MONITOR_MODE_CLONE_PROIO_HDSDI_2,
    MONITOR_MODE_UHD
} monitor_mode_t;

/* RCP: MAGNIFY */
typedef enum {
    MAGNIFY_MODE_OFF,
    MAGNIFY_MODE_ON,
    MAGNIFY_MODE_COUNT
} magnify_mode_t;

/* RCP: AFMODE */
typedef enum
{
    AF_MODE_MANUAL,
    AF_MODE_CONFIRM,
    AF_MODE_PRIORITY,
    AF_MODE_CONTINUOUS,
    AF_MODE_TOUCH_TRACK,
    AF_MODE_RACK,
    AF_MODE_FAST,
    AF_MODE_COUNT
} af_mode_t;


/* RCP: AFZONE */
typedef enum
{
    AF_FOCUSZONE_CENTER,
    AF_FOCUSZONE_SPOT,
    AF_FOCUSZONE_COUNT
} af_focuszone_t;

/* RCP: FSMODE */
typedef enum {
    FAN_MODE_MANUAL,                                    /* Manual Mode */
    FAN_MODE_AUTO,
    FAN_MODE_CONTROL_LOOP = 6,                          /* Adaptive Mode */
    FAN_MODE_LOW_NOISE_PREVIEW_RECORD,                  /* Quiet Mode */
    FAN_MODE_ADAPTIVE_PREVIEW_LOW_NOISE_RECORD = 9      /* Adaptive Preview Quiet Record Mode */

} fan_mode_t;

/* RCP: AEMODE */
typedef enum {
    AE_MODE_OFF,
    AE_MODE_SINGLESHOT,
    AE_MODE_CONTINUOUS_PREVIEW,
    AE_MODE_CONTINUOUS_RECORD,
    AE_MODE_TOGGLE
} ae_mode_t;

/* RCP: CALSTAT */
typedef enum {
    CAL_STATUS_MINUS_LEVEL_3,
    CAL_STATUS_MINUS_LEVEL_2,
    CAL_STATUS_MINUS_LEVEL_1,
    CAL_STATUS_OK,
    CAL_STATUS_PLUS_LEVEL_1,
    CAL_STATUS_PLUS_LEVEL_2,
    CAL_STATUS_PLUS_LEVEL_3
} cal_status_t;

/* RCP: LDISPM */
typedef enum
{
    APERTURE_LIST_1_3,
    APERTURE_LIST_1_4
} aperture_list_t;

/* RCP: VUSRC */
typedef enum {
    VU_METER_SOURCE_PRE_MIXER,
    VU_METER_SOURCE_POST_MIXER
} vu_meter_source_t;

/* RCP: HISTTYPE */
typedef enum
{
    HISTOGRAM_TYPE_RGB,
    HISTOGRAM_TYPE_LUMA
} histogram_type_t;

/* RCP: MMMISOND */
typedef enum
{
    MOTION_MOUNT_ISO_PULL_DISABLE,
    MOTION_MOUNT_ISO_PULL_ENABLE
} motion_mount_iso_pull_t;

/* RCP: SHRCKDST */
typedef enum
{
    FOCUS_RACK_SHOW_DISTANCE_DISABLE,
    FOCUS_RACK_SHOW_DISTANCE_ENABLE
} focus_rack_show_distance_t;

/* RCP: TCDMODE */
typedef enum {
    TC_DISPLAY_TOD,
    TC_DISPLAY_EDGE
} tc_display_t;

/* RCP: TCDFMODE */
typedef enum {
    TC_DISPLAY_DROP_FRAME,
    TC_DISPLAY_NON_DROP_FRAME
} tc_drop_frame_display_t;

/* RCP: TCSOURCE */
typedef enum
{
    TC_SOURCE_USER,
    TC_SOURCE_BRAIN,
    TC_SOURCE_REAR_MODULE,
    TC_SOURCE_INTERNAL
} tc_source_t;

/* RCP: F0MODE, F1MODE, F2MODE */
typedef enum
{
    GUIDE_ASPECT_RATIO_ABSOLUTE = -3,
    GUIDE_ASPECT_RATIO_USER = -2,
    GUIDE_ASPECT_RATIO_OFF = -1,
    GUIDE_ASPECT_RATIO_FULL = 0,
    GUIDE_ASPECT_RATIO_4__3 = 1333333,
    GUIDE_ASPECT_RATIO_16__9 = 1777778,
    GUIDE_ASPECT_RATIO_1_85__1 = 1850000,
    GUIDE_ASPECT_RATIO_1_9__1 = 1896296,
    GUIDE_ASPECT_RATIO_2_4__1 = 2400000
} guide_aspect_ratio_t;

/* RCP: F0LNST, F1LNST, F2LNST */
typedef enum
{
    GUIDE_LINE_STYLE_SOLID,
    GUIDE_LINE_STYLE_DASHED,
    GUIDE_LINE_STYLE_BRACKET,
    GUIDE_LINE_STYLE_NONE,
    GUIDE_LINE_STYLE_COUNT
} guide_line_style_t;

/* RCP: AFCNFRMS */
typedef enum
{
    FOCUS_ASSIST_NONE,
    FOCUS_ASSIST_CIRCLE,
    FOCUS_ASSIST_BAR,
    FOCUS_ASSIST_PIE
} focus_assist_type_t;

/* RCP: AEMETERM */
typedef enum {
    AE_METERING_AVERAGE,
    AE_METERING_CENTER_WEIGHTED,
    AE_METERING_SPOT,
    AE_METERING_EVALUATIVE,
    AE_METERING_TOGGLE
} ae_metering_t;

/* RCP: AESPEED */
typedef enum {
    AE_SPEED_SLOW,
    AE_SPEED_NORMAL,
    AE_SPEED_FAST
} ae_speed_t;

/* RCP: AESELECT */
typedef enum {
    AE_SELECTION_LIST_ONLY_SAVE,
    AE_SELECTION_LIST_ONLY_CLOSEST,
    AE_SELECTION_FREE
} ae_selection_t;

/* RCP: AEEXPRI */
typedef enum {
    AE_EXPOSURE_PRIORITY_M,
    AE_EXPOSURE_PRIORITY_A,
    AE_EXPOSURE_PRIORITY_AV,
    AE_EXPOSURE_PRIORITY_TV
} ae_exposure_priority_t;

/* RCP: CH12SRC, CH34SRC */
typedef enum {
    AUDIO_CHANNEL_SOURCE_NONE,
    AUDIO_CHANNEL_SOURCE_CAM_ANALOG12,
    AUDIO_CHANNEL_SOURCE_PRO_IO_ANALOG12,
    AUDIO_CHANNEL_SOURCE_PRO_IO_DIGITAL12,
    AUDIO_CHANNEL_SOURCE_PRO_IO_DIGITAL34
} audio_channel_source_t;

/* RCP: CH1MODE, CH2MODE, CH3MODE, CH4MODE */
typedef enum {
    AUDIO_CHANNEL_MODE_OFF,
    AUDIO_CHANNEL_MODE_DYN_MIC,       /* for analog input, Unbalanced Dynamic Microphone */
    AUDIO_CHANNEL_MODE_48V_MIC,       /* for analog input, Balanced Mic with Phantom Power !!Should not be set Directly !!! */
    AUDIO_CHANNEL_MODE_AES_LOCK,      /* for digital input, AS Locked (Not supported in current HW) */
    AUDIO_CHANNEL_MODE_AES_FREE,      /* for digital input, AES Free-Running */
    AUDIO_CHANNEL_MODE_LINE,          /* Analog Line(0dBu) in (Only supported on Pro I/O) */
    AUDIO_CHANNEL_MODE_BAL_MIC,       /* Balanced Mic without Phantom Power */
    AUDIO_CHANNEL_MODE_LINE_1         /* Analog Line(0VU) in (Only supported on Pro I/O) */
} audio_channel_mode_t;

typedef enum {
    NOTIFICATION_PROGRESS_NONE,
    NOTIFICATION_PROGRESS_NORMAL,
    NOTIFICATION_PROGRESS_INFINITE
} notification_progress_t;

typedef enum {
    NOTIFICATION_SEVERITY_NOTE,
    NOTIFICATION_SEVERITY_WARNING,
    NOTIFICATION_SEVERITY_ERROR
} notification_severity_t;

typedef enum
{
    NOTIFICATION_STYLE_POPUP,
    NOTIFICATION_STYLE_STATUS
} notification_style_t;

/* RCP: SHSYNC */
typedef enum {
    SYNC_MODE_OFF,
    SYNC_MODE_TRI_LEVEL,   /* requires external tri-level source, aka Genlcok */
    SYNC_MODE_SHUTTER,     /* external single pulses in, double pulse to sensor, aka MoCo */
    SYNC_MODE_DEPRECATED_1,
    SYNC_MODE_DEPRECATED_2,
    SYNC_MODE_DEPRECATED_3,
    SYNC_MODE_COUNT,
    SYNC_MODE_INVALID = SYNC_MODE_COUNT
} sync_mode_t;

/* RCP: GPIN */
typedef enum {
    GPI_FUNCTION_EXTERNAL_SYNCI,
    GPI_FUNCTION_GP_INPUT
} gpi_function_t;

/* RCP: GPOUT */
typedef enum {
    GPO_FUNCTION_EXTERNAL_SYNCO,
    GPO_FUNCTION_GP_OUTPUT
} gpo_function_t;

/* RCP: GENSRC */
typedef enum
{
    GENLOCK_SOURCE_BRAIN,
    GENLOCK_SOURCE_REAR_MODULE
} genlock_source_t;

typedef enum {
    RCP_MENU_NODE_TYPE_BRANCH,
    RCP_MENU_NODE_TYPE_ACTION_LEAF,
    RCP_MENU_NODE_TYPE_CURVE_LEAF,
    RCP_MENU_NODE_TYPE_ENABLE_LEAF,
    RCP_MENU_NODE_TYPE_IP_ADDRESS_LEAF,
    RCP_MENU_NODE_TYPE_LIST_LEAF,
    RCP_MENU_NODE_TYPE_NUMBER_LEAF,
    RCP_MENU_NODE_TYPE_TEXT_LEAF,
    RCP_MENU_NODE_TYPE_ORDERED_LIST_LEAF,
    RCP_MENU_NODE_TYPE_DATETIME_LEAF,
    RCP_MENU_NODE_TYPE_TIMECODE_LEAF,
    RCP_MENU_NODE_TYPE_STATUS_LEAF,
    RCP_MENU_NODE_TYPE_MULTI_ACTION_LIST_LEAF,
    RCP_MENU_NODE_TYPE_NOT_YET_SUPPORTED_LEAF,
    RCP_MENU_NODE_TYPE_CLIP_LIST_LEAF,
    RCP_MENU_NODE_TYPE_GIO_SCOPE_LEAF,
    RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF
} rcp_menu_node_type_t;

typedef enum {
    RCP_MENU_NODE_FILTER_NONE = 0,
    RCP_MENU_NODE_FILTER_RECORD_ONLY = 1,
    RCP_MENU_NODE_FILTER_PLAYBACK_ONLY = 2,
    RCP_MENU_NODE_FILTER_RECORD_AND_PLAYBACK = RCP_MENU_NODE_FILTER_RECORD_ONLY | RCP_MENU_NODE_FILTER_PLAYBACK_ONLY
} rcp_menu_node_filter_t;

typedef enum {
    RCP_MENU_ACTION_NODE_PERFORM_ACTION,
    RCP_MENU_ACTION_NODE_CANCEL_ACTION
} rcp_menu_action_node_t;

/* RCP: HORIZON */
typedef enum
{
    UI_ENABLE_HORIZON_DISABLED,
    UI_ENABLE_HORIZON_ENABLED,
    UI_ENABLE_HORIZON_TOGGLE
} ui_enable_horizon_t;

/* RCP: BEEPREC, BEEPSTOP, BEEPTAGS */
typedef enum
{
    AUDIO_SIGNAL_NONE,
    AUDIO_SIGNAL_BEEP,
    AUDIO_SIGNAL_BEEP_2,
    AUDIO_SIGNAL_BEEP_ASC,
    AUDIO_SIGNAL_BEEP_DES,
    AUDIO_SIGNAL_MONEY,
    AUDIO_SIGNAL_SHUTTER,
    AUDIO_SIGNAL_COUNT
} audio_signal_t;

/* RCP: SERPROTO */
typedef enum {
    UART_PROTOCOL_NONE = 0,
    UART_PROTOCOL_ET = 1,
    UART_PROTOCOL_TA = 2,
    UART_PROTOCOL_DEPRECIATED_1 = 3,
    UART_PROTOCOL_SERIAL_SHELL = 4,
    UART_PROTOCOL_RCP = 5,
    UART_PROTOCOL_RCP_3D_METADATA = 6,
    UART_PROTOCOL_RCP_CAM_TO_CAM = 7,
    UART_PROTOCOL_COOKE_I = 8,
    UART_PROTOCOL_PRESTON = 9
} uart_protocol_t;

/* RCP: HDMIR, HDSDIR, PHDSDI1R, PHDSDI2R */
typedef enum
{
    MONITOR_RESOLUTION_480,
    MONITOR_RESOLUTION_600,
    MONITOR_RESOLUTION_720,
    MONITOR_RESOLUTION_784,
    MONITOR_RESOLUTION_1080,
    MONITOR_RESOLUTION_360,
    MONITOR_RESOLUTION_1200,
    MONITOR_RESOLUTION_768,
    MONITOR_RESOLUTION_848,
    MONITOR_RESOLUTION_480P,
    MONITOR_RESOLUTION_720_NO_PD,
    MONITOR_RESOLUTION_UHD,
    MONITOR_RESOLUTION_1200_2,
    MONITOR_RESOLUTION_COUNT
} monitor_resolution_t;

typedef enum
{
    FREQUENCY_AUTO,
    FREQUENCY_23_98 = 24000,
    FREQUENCY_24 = 24024,
    FREQUENCY_25 = 25025,
    FREQUENCY_29_97 = 30000,
    FREQUENCY_30 = 30030,
    FREQUENCY_48 = 48048,
    FREQUENCY_50 = 50050,
    FREQUENCY_59_94 = 60000,
    FREQUENCY_60 = 60060
} monitor_frequency_t;

/* RCP: AF_ZONE_COLOR, GUIDE_FRAME_0_COLOR, GUIDE_FRAME_1_COLOR */
/* GUIDE_FRAME_2_COLOR, GUIDE_CENTER_COLOR, GUIDE_GRID_COLOR, GUIDE_LOOKAROUND_COLOR */
typedef enum {
    FRAMEGUIDE_COLOR_BLACK,
    FRAMEGUIDE_COLOR_RED,
    FRAMEGUIDE_COLOR_BLUE,
    FRAMEGUIDE_COLOR_GREEN,
    FRAMEGUIDE_COLOR_YELLOW,
    FRAMEGUIDE_COLOR_MAGENTA,
    FRAMEGUIDE_COLOR_CYAN,
    FRAMEGUIDE_COLOR_DARKGRAY,
    FRAMEGUIDE_COLOR_WHITE,
    FRAMEGUIDE_COLOR_DEFAULT,
    FRAMEGUIDE_COLOR_COUNT
} frameguide_color_t;

/* RCP: AWBMODE */
typedef enum {
    AWB_MODE_OFF,
    AWB_MODE_SINGLESHOT,
    AWB_MODE_COUNT
} awb_mode_t;

/* RCP: TARGET */
typedef enum {
    RCP_TARGET_ALL,
    RCP_TARGET_NONE,
    RCP_TARGET_CUSTOM
} rcp_target_t;

typedef enum {
    MEDIA_LOC_ACTIVE,
    MEDIA_LOC_SIDE,
    MEDIA_LOC_REAR
} media_loc_t;

/* RCP: LCDCV, HDMICV, HDSDICV, PLCDCV */
/*      PHDSD1CV, PHDSD2CV, EVFCV, REVFCV */
typedef enum
{
    MONITOR_CURVE_NEUTRAL,
    MONITOR_CURVE_GRADED,
    MONITOR_CURVE_PRIMARY_ACESCC,
    MONITOR_CURVE_PRIMARY_BT1886,
    MONITOR_CURVE_PRIMARY_HDR2084,
    MONITOR_CURVE_PRIMARY_LOG3G10,
    MONITOR_CURVE_PRIMARY_REDGAMMA2,
    MONITOR_CURVE_PRIMARY_REDGAMMA3,
    MONITOR_CURVE_PRIMARY_REDGAMMA4,
    MONITOR_CURVE_PRIMARY_REDLOGFILM,
    MONITOR_CURVE_PRIMARY_REC709,
    MONITOR_CURVE_3DLUT,
    MONITOR_CURVE_3DLUT_ACESCC_SDR,
    MONITOR_CURVE_3DLUT_BT1886_SDR,
    MONITOR_CURVE_3DLUT_HDR2084_SDR,
    MONITOR_CURVE_3DLUT_LOG3G10_SDR,
    MONITOR_CURVE_3DLUT_REDLOGFILM_SDR,
    MONITOR_CURVE_3DLUT_REC709_SDR,
    MONITOR_CURVE_COUNT
} monitor_curve_t;

/* RCP: DROPREG */
typedef enum
{
    DROP_REGION_START,
    DROP_REGION_END
} drop_region_t;

typedef enum
{
    RCP_INTERFACE_UNKNOWN,
    RCP_INTERFACE_BRAIN_SERIAL,
    RCP_INTERFACE_BRAIN_GIGABIT_ETHERNET,
    RCP_INTERFACE_REDLINK_BRIDGE,
    RCP_INTERFACE_BRAIN_WIFI,
    RCP_INTERFACE_REDMOTE_REDLINK,
    RCP_INTERFACE_INTERNAL,
    RCP_INTERFACE_COUNT
} rcp_interface_t;

/* RCP: CNA1STA */
typedef enum
{
    RCP_CNA1_STATUS_DISABLED,           /* interface is turned off */
    RCP_CNA1_STATUS_UNCONFIGURED,       /* no IP configured */
    RCP_CNA1_STATUS_CONNECTING,         /* trying to connect */
    RCP_CNA1_STATUS_CONNECTED,          /* connected and operating */
    RCP_CNA1_STATUS_ERROR               /* something is broken */
} rcp_cna1_status_t;

/* RCP: WLANSTAT */
typedef enum {
    WL_STATUS_OFFLINE,          /* Offline */
    WL_STATUS_SEARCHING,        /* Searching for infrastructure network */
    WL_STATUS_CONNECTING,       /* Connecting to infrastructure network or establishing ad-hoc network */
    WL_STATUS_CONNECTED,        /* Connected to infrastructure network or ad-hoc network established */
    WL_STATUS_LOST,             /* Has lost its infrastructure connection - will try to re-connect */
    WL_STATUS_ERROR             /* Has failed to establish an infrastructure network connection */
} wl_status_t;

/* RCP: MTMST0, MTMST1, MTMST2 */
typedef enum {
    MC_MOTOR_STATUS_UNCONNECTED = 0, /* No Motor Connected */
    MC_MOTOR_STATUS_ERROR = 1,       /* Error */
    MC_MOTOR_STATUS_IDLE = 2,        /* Motor is Idle */
    MC_MOTOR_STATUS_MOVING = 3,      /* Motor is Moving */
    MC_MOTOR_STATUS_HOMING = 4       /* Motor is searching homing position */
} mc_motor_status_t;

/* RCP: RMSTATE */
typedef enum {
    REDMOTE_CONNECTED_STATE_NOT_CONNECTED,      /* REDMOTE is not connected */
    REDMOTE_CONNECTED_STATE_CONNECTED           /* REDMOTE is connected */
} redmote_connected_state_t;

typedef enum {
    CAMERA_CAPTURE_MODE_MOTION = 2,
    CAMERA_CAPTURE_MODE_STILLS = 4
} camera_capture_mode_t;

typedef enum
{
    PRIMARY_STORAGE_LOCAL,
    PRIMARY_STORAGE_NETWORK,
    PRIMARY_STORAGE_EXTERNAL,
    PRIMARY_STORAGE_COUNT
} primary_storage_t;

typedef enum
{
    MONITOR_NULL = -1,
    MONITOR_BRAIN_LCD = 0,
    MONITOR_BRAIN_EVF,
    MONITOR_BRAIN_HDMI,
    MONITOR_BRAIN_HDSDI,
    MONITOR_REAR_LCD,
    MONITOR_REAR_EVF,
    MONITOR_REAR_HDSDI_1,
    MONITOR_REAR_HDSDI_2,
    MONITOR_BRAIN_LCD3,
    MONITOR_BRAIN_EVF3,
    MONITOR_REAR_UHDSDI_1,
    MONITOR_REAR_UHDSDI_2,
    MONITOR_COUNT
} monitor_t;

typedef enum {
    VIDEO_CODEC_PRORES_4444 = 0,
    VIDEO_CODEC_PRORES_4444XQ,
    VIDEO_CODEC_PRORES_422HQ,
    VIDEO_CODEC_PRORES_422,
    VIDEO_CODEC_PRORES_422LT,
    VIDEO_CODEC_DNX_444,
    VIDEO_CODEC_DNX_HQX,
    VIDEO_CODEC_DNX_HQ,
    VIDEO_CODEC_DNX_SQ,
    VIDEO_CODEC_DNX_LB,
    VIDEO_CODEC_COUNT
} video_codec_t;

typedef enum {
    FILE_FORMAT_REDCODE_RAW,
    FILE_FORMAT_QUICKTIME,
    FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME,
    FILE_FORMAT_MXF,
    FILE_FORMAT_REDCODE_RAW_PLUS_MXF,
    FILE_FORMAT_COUNT
} file_format_t;

typedef enum {
    FILE_FORMAT_TYPE_RAW,
    FILE_FORMAT_TYPE_BAKED,
    FILE_FORMAT_TYPE_COUNT
} file_format_type_t;

typedef enum {
    CODEC_RESOLUTION_2K = 0,
    CODEC_RESOLUTION_4K,
    CODEC_RESOLUTION_COUNT
} codec_resolution_t;

typedef enum {
    HW_CAP_COLOR_SENSOR = 0,
    HW_CAP_WIFI = 1,
    HW_CAP_FIZ = 2,
    HW_CAP_GIG_ETHERNET = 3,
    HW_CAP_TETHERING = 4,
    HW_CAP_SIDE_UI = 5,
    HW_CAP_ND_CONTROL = 6,
    HW_CAP_3D_LUT = 7,
    HW_CAP_MON_BRAIN_LCD_EVF = 8,
    HW_CAP_SW = 9,
    HW_CAP_MON_BRAIN_HDMI = 10,
    HW_CAP_MON_BRAIN_HDSDI = 11,
    HW_CAP_MON_REAR_LCD_EVF = 12,
    HW_CAP_WIRELESS_HAND_CONTROLLER = 13,
    HW_CAP_MON_REAR_HDSDI_1 = 14,
    HW_CAP_MON_REAR_HDSDI_2 = 15,
    HW_CAP_CONTROL_UART = 16,
    HW_CAP_REDMOTE_COMM = 17,
    HW_CAP_PRORES = 18,
    HW_CAP_HEADPHONE = 19,
    HW_CAP_AUDIO_OUT = 20,
    HW_CAP_MONITOR_WITH_AUDIO = 21,
    HW_CAP_AUDIO_PHANTOM_POWER = 22,
    HW_CAP_AUDIO_LIMITER = 23,
    HW_CAP_TIMECODE_IN = 24,
    HW_CAP_TIMECODE_OUT = 25,
    HW_CAP_GENLOCK = 26,
    HW_CAP_GPI = 27,
    HW_CAP_GPO = 28,
    HW_CAP_SYNC_IN = 29,
    HW_CAP_SYNC_OUT = 30,
    HW_CAP_GPI_SYNC_IN_MUXED = 31,
    HW_CAP_GPO_SYNC_OUT_MUXED = 32,
    HW_CAP_PRO_IO_GPI_A = 33,
    HW_CAP_PRO_IO_GPI_B = 34,
    HW_CAP_PRO_IO_SW_1 = 35,
    HW_CAP_PRO_IO_SW_2 = 36,
    HW_CAP_LCD_EVF_2_HDMI_MUX = 37,
    HW_CAP_SIDE_HANDLE = 38,
    HW_CAP_POWER_OUT_PRO_IO_GPIO = 39,
    HW_CAP_POWER_OUT_PRO_IO_PWR = 40,
    HW_CAP_POWER_OUT_PRO_IO_AUX = 41,
    HW_CAP_POWER_OUT_PLUS_ONE_PWR = 42,
    HW_CAP_POWER_OUT_BAT_AUX = 43,
    HW_CAP_POWER_OUT_BAT_AUX_WITH_ENABLE = 44,
    HW_CAP_POWER_OUT_JETPACK_USB = 45,
    HW_CAP_MULTI_MONITOR_FEEDS = 46,
    HW_CAP_MON_BRAIN_LCD_EVF_MULTI_FEEDS = 47,
    HW_CAP_MON_BRAIN_HDMI_MULTI_FEEDS = 48,
    HW_CAP_MON_BRAIN_HDSDI_MULTI_FEEDS = 49,
    HW_CAP_MON_REAR_LCD_EVF_MULTI_FEEDS = 50,
    HW_CAP_MON_REAR_HDSDI_1_MULTI_FEEDS = 51,
    HW_CAP_MON_REAR_HDSDI_2_MULTI_FEEDS = 52,
    HW_CAP_SSD_TALLY_LIGHT = 53,
    HW_CAP_STROBE = 54,
    HW_CAP_MULTI_MONITOR_FEED_0 = 55,
    HW_CAP_MULTI_MONITOR_FEED_1 = 56,
    HW_CAP_MULTI_MONITOR_FEED_1_AND_3D_LUT = 57,
    HW_CAP_POWER_OUT_REAR_PTAP = 58,
    HW_CAP_CONTROL_UART_2 = 59,
    HW_CAP_POWER_OUT_REAR_AUX = 60,
    HW_CAP_POWER_OUT_TIMECODE = 61,
    HW_CAP_SW_2 = 62,
    HW_CAP_AUDIO_MODE_NO_UI_CONTROL_12 = 63,
    HW_CAP_AUDIO_MODE_UI_CONTROL_12 = 64,
    HW_CAP_AUDIO_MODE_UI_CONTROL_34 = 65,
    HW_CAP_WEAPON_SIDE_HANDLE = 66,
    HW_CAP_MON_LCD3_EVF3 = 67,
    HW_CAP_MON_LCD3_EVF3_MULTI_FEEDS = 68,
    HW_CAP_AUDIO_CAM_MIC_12 = 69,
    HW_CAP_AUDIO_REAR_ANALOG_12 = 70,
    HW_CAP_AUDIO_REAR_DIGITAL_12 = 71,
    HW_CAP_AUDIO_REAR_DIGITAL_34 = 72,
    HW_CAP_THIRD_PARTY_OLPFS = 73,
    HW_CAP_PL_POWER = 74,
    HW_CAP_PL_DETECT = 75,
    HW_CAP_GENLOCK_MUXED = 76,
    HW_CAP_AUDIO_MODE_NO_UI_CONTROL_34 = 77,
    HW_CAP_TOP_MODULE_RECORD_BUTTON = 78,
    HW_CAP_SIDE_MODULE_FOCUS_WHEEL = 79,
    HW_CAP_SIDE_MODULE_KEYS = 80,
    HW_CAP_SIDE_MODULE_RECORD = 81,
    HW_CAP_SIDE_MODULE_NAVIGATION = 82,
    HW_CAP_INTERNAL_AMBIENT = 83,
    HW_CAP_COLOR_SCIENCE_IPP2 = 84,
    HW_CAP_PRESTON_FIZ = 85,
    HW_CAP_SIDE_UI_LEFT = 86,
    HW_CAP_SIDE_UI_RIGHT = 87,
    HW_CAP_MON_REAR_UHDSDI_1 = 88,
    HW_CAP_MON_REAR_UHDSDI_2 = 89,
    HW_CAP_RETURN_FEED = 90,
    HW_CAP_MON_BRAIN_LCD_EVF_RETURN_FEED = 91,
    HW_CAP_MON_BRAIN_HDMI_RETURN_FEED = 92,
    HW_CAP_MON_BRAIN_HDSDI_RETURN_FEED = 93,
    HW_CAP_MON_REAR_LCD_EVF_RETURN_FEED = 94,
    HW_CAP_MON_REAR_HDSDI_1_RETURN_FEED = 95,
    HW_CAP_MON_REAR_HDSDI_2_RETURN_FEED = 96,
    HW_CAP_MON_LCD3_EVF3_RETURN_FEED = 97,
    HW_CAP_MON_REAR_UHDSDI_1_2_SHARED = 98,
    HW_CAP_FRAME_PROCESSING = 99,
    HW_CAP_ANAMORPHIC = 100,
    HW_CAP_LOOKAROUND = 101,
    HW_CAP_ALLOW_ISO_CALIBRATION1 = 102,
    HW_CAP_DROP_FRAME_TIMECODE = 103,
    HW_CAP_SENSOR_FLIP = 105,
    HW_CAP_SENSOR_SENSITIVITY = 107,
    HW_CAP_SENSOR_SYNC = 108,
    HW_CAP_AUDIO_IN_GAIN_CONTROL_12 = 109,
    HW_CAP_AUDIO_IN_GAIN_CONTROL_34 = 110,
    HW_CAP_BRAIN_FUNCTION_KEY_4 = 112,


    HW_CAP_COUNT
} hw_cap_t;

typedef enum {
    WL_MODE_DISABLED,
    WL_MODE_AD_HOC,
    WL_MODE_INFRASTRUCTURE
} wl_mode_t;

typedef enum {
    WL_ENCRYPTION_NONE,
    WL_ENCRYPTION_WEP,
    WL_ENCRYPTION_WPA,
    WL_ENCRYPTION_WPA2
} wl_encryption_t;

typedef enum {
    WL_ERROR_NO_ERROR,
    WL_ERROR_WRONG_PASSPHRASE,
    WL_ERROR_WRONG_ENCRYPTION,
    WL_ERROR_CONNECTION_FAILED,
    WL_ERROR_UNKNOWN_ERROR,
    WL_ERROR_INVALID_WEP_PW,
    WL_ERROR_INVALID_IP_ADDR,
    WL_ERROR_INVALID_ADHOC_PW
} wl_error_t;

typedef enum {
    MULTI_ACTION_LIST_LEAF_PROPERTY_CLOSE_ON_ACTION = 0x10000,

    MULTI_ACTION_LIST_LEAF_ENABLE_MASK = 0x0f,
    MULTI_ACTION_LIST_LEAF_PROPERTY_MASK = 0xf0,
    MULTI_ACTION_LIST_LEAF_ENABLE_BIT_MASK = 0xffff,
    MULTI_ACTION_LIST_LEAF_PROPERTY_BIT_MASK = 0x000f0000,

    MULTI_ACTION_LIST_LEAF_PROPERTY_BIT_SHIFT = 12
} multi_action_list_leaf_property_t;

/* RCP: PWRSAVE */
typedef enum {
    POWER_SAVE_STATE_NORMAL,
    POWER_SAVE_STATE_LEVEL_1,
    POWER_SAVE_STATE_LEVEL_2,
    POWER_SAVE_STATE_LEVEL_3
} power_save_state_t;

typedef enum
{
    RFTP_SUCCESS,                               /* No error */
    RFTP_TRANSFER_COMPLETE,                     /* No error, file transfer completed */
    RFTP_ERROR_FILE_NOT_FOUND,                  /* File not found (when retrieving a remote file) */
    RFTP_ERROR_FILE_EXISTS,                     /* File already exists (when sending a local file) */
    RFTP_ERROR_NO_READ_PERMISSION,              /* Read permission denied (when retrieving a remote file) */
    RFTP_ERROR_NO_WRITE_PERMISSION,             /* Write permission denied (when sending a local file) */
    RFTP_ERROR_INVALID_PATH,                    /* Invalid path specified (when sending a local file to the wrong directory, getting a directory listing for a directory that does not exist, etc.) */
    RFTP_ERROR_NOT_ENOUGH_SPACE,                /* File receiver doesn't have enough space */
    RFTP_ERROR_UNABLE_TO_CREATE_FILE,           /* Other file creation errors */
    RFTP_ERROR_TETHERED_TRANSFER_IN_PROGRESS,   /* A tethered transfer is already in progress (when retrieving another file using tethering) */
    RFTP_ERROR_INTERNAL,                        /* Internal error  */
    RFTP_ERROR_TRANSFERS_PAUSED                 /* A tethered transfer is requested while transfers are paused */
} rftp_error_t;

typedef enum
{
    RFTP_PERMISSION_DIRECTORY = 0x01,
    RFTP_PERMISSION_READ = 0x02,
    RFTP_PERMISSION_WRITE = 0x04
} rftp_permission_t;

typedef enum
{
    RFTP_TYPE_NONE,
    RFTP_TYPE_STORE,
    RFTP_TYPE_RETRIEVE,
    RFTP_TYPE_ABORT_STORE,
    RFTP_TYPE_ABORT_RETRIEVE,
    RFTP_TYPE_DELETE,
    RFTP_TYPE_LIST
} rftp_type_t;

typedef enum
{
    VIDEO_SOURCE_GRADED,
    VIDEO_SOURCE_SPLIT_CURVE_RLF,
    VIDEO_SOURCE_ACES,
    VIDEO_SOURCE_ACES_AND_SPLIT_CURVE,
    VIDEO_SOURCE_SPLIT_CURVE_LOG3G12,
    VIDEO_SOURCE_DEPRECATED_0,
    VIDEO_SOURCE_DEPRECATED_1,
    VIDEO_SOURCE_SLOG3,
    VIDEO_SOURCE_SPLIT_CURVE_SLOG3,
    VIDEO_SOURCE_SPLIT_CURVE_LOG3G10,
    VIDEO_SOURCE_ACESCC_ACESAP1,
    VIDEO_SOURCE_LOG3G10_DRAGONCOLOR,
    VIDEO_SOURCE_LOG3G10_DRAGONCOLOR2,
    VIDEO_SOURCE_LOG3G10_REC709,
    VIDEO_SOURCE_LOG3G10_REC709NK,
    VIDEO_SOURCE_LOG3G10_REC2020,
    VIDEO_SOURCE_LOG3G10_REDCOLOR2,
    VIDEO_SOURCE_LOG3G10_REDCOLOR3,
    VIDEO_SOURCE_LOG3G10_REDCOLOR4,
    VIDEO_SOURCE_LOG3G10_RWGRGB,
    VIDEO_SOURCE_3DLUT,
    VIDEO_SOURCE_COUNT
} video_source_t;

typedef enum
{
    MONITOR_FEED_0,
    MONITOR_FEED_1,
    MONITOR_FEED_COUNT
} monitor_feed_t;

typedef enum
{
    REDCODE_RAW_RECORD_STATE_OFF,
    REDCODE_RAW_RECORD_STATE_OK,
    REDCODE_RAW_RECORD_STATE_ERROR,
    REDCODE_RAW_RECORD_STATE_COUNT
} redcode_raw_record_state_t;

typedef enum
{
    QUICKTIME_RECORD_STATE_OFF,
    QUICKTIME_RECORD_STATE_OK,
    QUICKTIME_RECORD_STATE_ERROR,
    QUICKTIME_RECORD_STATE_WARNING,
    QUICKTIME_RECORD_STATE_COUNT
} quicktime_record_state_t;

typedef enum
{
    MXF_RECORD_STATE_OFF,
    MXF_RECORD_STATE_OK,
    MXF_RECORD_STATE_ERROR,
    MXF_RECORD_STATE_WARNING,
    MXF_RECORD_STATE_COUNT
} mxf_record_state_t;

typedef enum {
    FLAT_UI_CONTROL_MODE_LOCAL,
    FLAT_UI_CONTROL_MODE_REMOTE
} flat_ui_control_mode_t;

typedef enum {
    SENSOR_SCAN_DIRECTION_NORMAL,
    SENSOR_SCAN_DIRECTION_ROTATED,
    SENSOR_SCAN_DIRECTION_COUNT
} sensor_scan_direction_t;

typedef enum
{
    HDMI_MUX_LCD_EVF,
    HDMI_MUX_HDMI
} hdmi_mux_t;

/* ZEBRA1M, ZEBRA2M */
typedef enum
{
    ZEBRA_MODE_VIDEO,
    ZEBRA_MODE_RAW,
    ZEBRA_MODE_COUNT
} zebra_mode_t;

typedef enum
{
    ZEBRA_PATTERN_BACK,
    ZEBRA_PATTERN_FORWARD,
    ZEBRA_PATTERN_FILL
} zebra_pattern_t;

typedef enum {
    ZEBRA_COLOR_BLACK,
    ZEBRA_COLOR_RED,
    ZEBRA_COLOR_BLUE,
    ZEBRA_COLOR_GREEN,
    ZEBRA_COLOR_YELLOW,
    ZEBRA_COLOR_MAGENTA,
    ZEBRA_COLOR_CYAN,
    ZEBRA_COLOR_DARKGRAY,
    ZEBRA_COLOR_WHITE
} zebra_color_t;

typedef enum
{
    HDMI_VENDOR_NONE = 0,
    HDMI_VENDOR_ATOMOS,
    HDMI_VENDOR_TERADEK,
    HDMI_VENDOR_COUNT
} hdmi_vendor_t;

/* PLDETECT */
typedef enum
{
    PL_DETECT_DISABLE = 0,
    PL_DETECT_RETRY = 5,
    PL_DETECT_ENABLE = 255
} pl_detect_t;

typedef enum
{
    POWER_OUT_PROPERTY_UNSUPPORTED = 0,
    POWER_OUT_PROPERTY_ENABLE      = (1 << 0),
    POWER_OUT_PROPERTY_CURRENT     = (1 << 1),
    POWER_OUT_PROPERTY_STATUS      = (1 << 2),
    POWER_OUT_PROPERTY_DEFAULT_OFF = (1 << 3),
    POWER_OUT_PROPERTY_NO_UI       = (1 << 4),

    POWER_OUT_PROPERTY_RESET = POWER_OUT_PROPERTY_ENABLE | POWER_OUT_PROPERTY_STATUS
} power_out_property_t;

typedef enum
{
    MENU_LABEL_FULL,
    MENU_LABEL_PARENT,
    MENU_LABEL_CHILD,
    MENU_LABEL_FROM_LIST_VAL_WITH_INDEX,
    MENU_LABEL_COUNT
} menu_label_t;

/* RCP: MEDAGCII, */
typedef struct
{
    int32_t index;
    char clip_name[20];
    char clip_date[12];
    char clip_time[10];
    int32_t sensor_fps;
    char edge_start_timecode[14];
    char edge_end_timecode[14];
    char tod_start_timecode[14];
    char tod_end_timecode[14];
    int has_r3d;
    int has_qt;
    int has_mxf;
    char duration[12];
    record_mode_t record_mode;
    char compression[5];
    char format[30];
    char project_fps[20];
    char iso[20];
    char kelvin[20];
    char tint[20];
    char num_frames[10];
    camera_capture_mode_t camera_mode;
    char sensor_fps_str[20];
    tc_drop_frame_display_t drop_frame_display_mode;
    char thumbnail_path[256];
    char display_clip_name[10];
} extended_clipinfo_t;

typedef enum
{
    COLOR_SCIENCE_FLUT,
    COLOR_SCIENCE_IPP2,
    COLOR_SCIENCE_COUNT
} color_science_t;

typedef enum
{
    IMAGE_PIPELINE_MODE_LEGACY,
    IMAGE_PIPELINE_MODE_IPP2,
    IMAGE_PIPELINE_MODE_CUSTOM,
    IMAGE_PIPELINE_MODE_COUNT
} image_pipeline_mode_t;

typedef enum
{
    SIDE_UI_PAGE_OFF,
    SIDE_UI_PAGE_ON
} side_ui_page_t;

typedef enum
{
    SIDE_UI_AUTO_HOME_NEVER,
    SIDE_UI_AUTO_HOME_ON_RECORD,
    SIDE_UI_AUTO_HOME_ON_TIMEOUT
} side_ui_auto_home_t;

typedef enum
{
    MAIN_OUTPUT_PRESET_CAMERA_DEFAULT = -1,
    MAIN_OUTPUT_PRESET_ACES_PROXY = 0,
    MAIN_OUTPUT_PRESET_BT1886,
    MAIN_OUTPUT_PRESET_HDR,
    MAIN_OUTPUT_PRESET_HDR2084,
    MAIN_OUTPUT_PRESET_HDR_400,
    MAIN_OUTPUT_PRESET_HDR_1K,
    MAIN_OUTPUT_PRESET_HDR_2K,
    MAIN_OUTPUT_PRESET_HDR_4K,
    MAIN_OUTPUT_PRESET_LOG3G10,
    MAIN_OUTPUT_PRESET_REC709,
    MAIN_OUTPUT_PRESET_REDGAMMA2,
    MAIN_OUTPUT_PRESET_REDGAMMA3,
    MAIN_OUTPUT_PRESET_REDGAMMA4,
    MAIN_OUTPUT_PRESET_REDLOGFILM,
    MAIN_OUTPUT_PRESET_SDR,
    MAIN_OUTPUT_PRESET_SDR_REC709,
    MAIN_OUTPUT_PRESET_SDR_REC709_NO_KNEE,
    MAIN_OUTPUT_PRESET_USER,
    MAIN_OUTPUT_PRESET_RLF_TO_3DLUT,
    MAIN_OUTPUT_PRESET_IPP2A,
    MAIN_OUTPUT_PRESET_COUNT
} main_output_preset_t;

/* RCP: DPLCD, DPHDMI, DPHDSDI, DPRLCD  */
/*      DPDSD1, DPPHDSD2, DPEVF, DPREVF */
/*      DPLCD3, DPEVF3                  */
typedef enum
{
    DISPLAY_PRESET_CAMERA_DEFAULT = -1,
    DISPLAY_PRESET_ACES_PROXY = 0,
    DISPLAY_PRESET_FLUT_BT1886,
    DISPLAY_PRESET_FLUT_HDR2084,
    DISPLAY_PRESET_FLUT_LOG3G10,
    DISPLAY_PRESET_FLUT_REDGAMMA2,
    DISPLAY_PRESET_FLUT_REDGAMMA3,
    DISPLAY_PRESET_FLUT_REDGAMMA4,
    DISPLAY_PRESET_FLUT_REDLOGFILM,
    DISPLAY_PRESET_MAIN_HDR,
    DISPLAY_PRESET_MAIN_HDR_400,
    DISPLAY_PRESET_MAIN_HDR_1K,
    DISPLAY_PRESET_MAIN_HDR_2K,
    DISPLAY_PRESET_MAIN_HDR_4K,
    DISPLAY_PRESET_MAIN_SDR,
    DISPLAY_PRESET_MAIN_SDR_REC709,
    DISPLAY_PRESET_MAIN_SDR_REC709_NO_KNEE,
    DISPLAY_PRESET_RWGRGB_HDR,
    DISPLAY_PRESET_RWGRGB_HDR_400,
    DISPLAY_PRESET_RWGRGB_HDR_1K,
    DISPLAY_PRESET_RWGRGB_HDR_2K,
    DISPLAY_PRESET_RWGRGB_HDR_4K,
    DISPLAY_PRESET_RWGRGB_SDR,
    DISPLAY_PRESET_RWGRGB_SDR_REC709,
    DISPLAY_PRESET_RWGRGB_SDR_REC709_NO_KNEE,
    DISPLAY_PRESET_USER,
    DISPLAY_PRESET_RWGRGB_LOG3G10,
    DISPLAY_PRESET_RLF_TO_3DLUT,
    DISPLAY_PRESET_MAIN_HLG,
    DISPLAY_PRESET_RWGRGB_HLG,
    DISPLAY_PRESET_COUNT
} display_preset_t;

typedef enum
{
    OUTPUT_TRANSFORM_CAMERA_DEFAULT = -1,
    OUTPUT_TRANSFORM_ACES_AP1 = 0,
    OUTPUT_TRANSFORM_DRAGONCOLOR,
    OUTPUT_TRANSFORM_DRAGONCOLOR2,
    OUTPUT_TRANSFORM_P3,
    OUTPUT_TRANSFORM_REC709,
    OUTPUT_TRANSFORM_REC2020,
    OUTPUT_TRANSFORM_REDCOLOR2,
    OUTPUT_TRANSFORM_REDCOLOR3,
    OUTPUT_TRANSFORM_REDCOLOR4,
    OUTPUT_TRANSFORM_RWGRGB,
    OUTPUT_TRANSFORM_NONE,
    OUTPUT_TRANSFORM_CUSTOM,
    OUTPUT_TRANSFORM_IPP2A,
    OUTPUT_TRANSFORM_COUNT
} output_transform_t;

typedef enum
{
    POWER_IN_PROPERTY_NONE = 0,
    POWER_IN_PROPERTY_VOLTAGE = (1 << 0),
    POWER_IN_PROPERTY_PERCENT = (1 << 1),
    POWER_IN_PROPERTY_RUNTIME = (1 << 2),
    POWER_IN_PROPERTY_CURRENT = (1 << 3),
    POWER_IN_PROPERTY_PRESENT = (1 << 4)
} power_in_property_t;

typedef enum
{
    OUTPUT_TONE_MAP_LOW_CONTRAST,
    OUTPUT_TONE_MAP_MEDIUM_CONTRAST,
    OUTPUT_TONE_MAP_HIGH_CONTRAST,
    OUTPUT_TONE_MAP_NONE,
    OUTPUT_TONE_MAP_COUNT
} output_tone_map_t;

typedef enum
{
    RETURN_FEED_DISABLED,
    RETURN_FEED_ON,
    RETURN_FEED_NO_SIGNAL,
    RETURN_FEED_INVALID_SIGNAL,
    RETURN_FEED_INVALID_CAMERA_FORMAT
} return_feed_status_t;

typedef enum
{
    ROLL_OFF_NONE,
    ROLL_OFF_HARD,
    ROLL_OFF_MEDIUM,
    ROLL_OFF_SOFT,
    ROLL_OFF_VERY_SOFT,
    ROLL_OFF_COUNT
} roll_off_t;

typedef enum
{
    SENSOR_SENSITIVITY_LOW_LIGHT,
    SENSOR_SENSITIVITY_STANDARD
} sensor_sensitivity_t;

/* RCP: CGMARK */
typedef enum
{
    GUIDE_MARKER_TYPE_CROSS_HAIR,
    GUIDE_MARKER_TYPE_SMALL_DOT,
    GUIDE_MARKER_TYPE_MEDIUM_DOT,
    GUIDE_MARKER_TYPE_COUNT
} guide_marker_type_t;

typedef enum
{
    POWER_IN_TYPE_DC = 0,
    POWER_IN_TYPE_BAT = 1,
    POWER_IN_TYPE_BRICK = 2,
    POWER_IN_TYPE_REDVOLT = 3,
    POWER_IN_TYPE_REDVOLT_XL = 4,
    POWER_IN_TYPE_GOLD_MOUNT = 5,
    POWER_IN_TYPE_V_MOUNT = 6,
    POWER_IN_TYPE_DXLHSM_DC = 7,
    POWER_IN_TYPE_DXLHSM_BAT = 8,
    POWER_IN_TYPE_DC_WIDE_VOLTAGE = 9,
    POWER_IN_TYPE_COUNT
} power_in_type_t;

#endif
/********** End file: rcp_types_public.h ****************************************/

/********** Begin file: c_list.h ************************************************/
/*line -strong(AJX,c_list_error_t,c_list_find_t,c_list_string_type_t) */
#ifndef C_LIST_H_INCLUDED
#define C_LIST_H_INCLUDED

#include <stdlib.h>
#include <stdint.h>

/** @file c_list.h
 * c_list is a library for maintaining lists used in-camera.  There is a
 * C++ wrapper for this library called cList.
 *
 * Lists contain any number of entries.  Each entry contains a numeric
 * value, string representation, and option user defined data.
 *
 * Lists also have a "current" entry.  That is, a entry in the list
 * that is the denoted as being the currently selected item.
 *
 * Lists can be converted to strings for transfer between two devices.
 * Normally, this is to send lists out from the camera to a external
 * device using RCP.
 * */

/*
 * Stringify format:  There are three different stringify formats
 * including: normal (C_LIST_STRING_TYPE_NORMAL), compressed
 * (C_LIST_STRING_TYPE_COMPRESSED), and min/max/step
 * (C_LIST_STRING_TYPE_MIN_MAX_STEP).
 *
 * C_LIST_STRING_TYPE_NORMAL:
 *     format: TYPE|CURRENT_INDEX|[NUM|STRING|]*
 *
 * C_LIST_STRING_TYPE_COMPRESSED:
 *     format: TYPE|CURRENT_INDEX|[NUM|COMPRESSED_STRING|]*{[UNCOMPRESSED_STRING:COMPRESSED_CHARACTER|]*}
 *
 *     Note: Compression is only used when the normal format generates a
 *     string too large to fit the 8K buffer.
 *
 *     This format replaces the STRING portion of the
 *     C_LIST_STRING_TYPE_NORMAL format with a COMPRESSED_STRING.  The
 *     COMPRESSED_STRING can contain both COMPRESSED_CHARACTERs and
 *     non-compressed portions of the original STRING. The mapping
 *     between UNCOMPRESSED_STRINGs and COMPRESSED_CHARACTERs is added
 *     at the end of the stringified list in a dictionary (denoted by
 *     curly braces).  To uncompress the stringified list use the
 *     dictionary to replace all COMPRESSED_CHARACTERs in each
 *     COMPRESSED_STRING with the corresponding UNCOMPRESSED_STRING.
 *
 * C_LIST_STRING_TYPE_MIN_MAX_STEP:
 *     format: TYPE|CURRENT_INDEX|MIN|MAX|STEP|DIVIDER|PRECISION|PREFIX|POSTFIX|
 *
 * TYPE: type of string (see c_list_string_type_t)
 * CURRENT_INDEX: zero based index denoting which entry in the list is
 *     the "current" entry; -1, if the list is empty.
 * NUM: integer portion of list entry
 * STRING: string portion of list entry
 * COMPRESSED_STRING: see above
 * UNCOMPRESSED_STRING: see above
 * COMPRESSED_CHARACTER: see above
 * MIN: minimum value for NUM (value for first entry in list)
 * MAX: maximum value for NUM
 * STEP: each entry in list is calculated as previous entry plus STEP
 * DIVIDER/PRECISION/PREFIX/POSTFIX: used to create string for entry
 *     based on NUM.  The format is: "PREFIX VALUE POSTFIX" where VALUE
 *     is NUM/DIVIDER shown to PRECISION decimal places.
 */

typedef int32_t c_list_num_t;
#define C_LIST_MAX_STRING_LEN 255
typedef void * (* c_list_malloc_t) (size_t);
typedef void (* c_list_free_t) (void *);

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum {
    C_LIST_SUCCESS,                    /**< No error */
    C_LIST_INDEX_ERROR,                /**< Index is out of range */
    C_LIST_FIND_ERROR,                 /**< Could not find item matching search criteria */
    C_LIST_LOAD_ERROR,                 /**< Error loading list from file */
    C_LIST_PARAM_ERROR,                /**< Invalid parameter */
    C_LIST_MEM_ERROR,                  /**< Out of memory */
    C_LIST_NO_DATA_ERROR,              /**< Empty List */
    C_LIST_BUFFER_FULL_ERROR           /**< String buffer full Error*/
} c_list_error_t;

typedef enum {
    C_LIST_FIND_EXACT,                 /**< Match search criteria exactly */
    C_LIST_FIND_CLOSEST,               /**< Find closest value */
    C_LIST_FIND_NEXT_SMALLER,          /**< Find next smaller match */
    C_LIST_FIND_NEXT_BIGGER            /**< Find next bigger match */
} c_list_find_t;

typedef enum {
    C_LIST_STRING_TYPE_NORMAL,
    C_LIST_STRING_TYPE_MIN_MAX_STEP,
    C_LIST_STRING_TYPE_COMPRESSED
} c_list_string_type_t;

/** INTERNAL USE ONLY */
typedef struct
{
    int valid;
    int min;
    int max;
    int step;
    int divider;
    int precision;
    char prefix[C_LIST_MAX_STRING_LEN];
    char postfix[C_LIST_MAX_STRING_LEN];
} c_list_step_options_t;

typedef union
{
    void * ptr;
    int32_t int32;
} user_defined_t;

/** Structure defining each entry in the list */
typedef struct c_list_entry_tag {
    c_list_num_t num;                   /**< Number */
    char str[C_LIST_MAX_STRING_LEN];    /**< String */
    user_defined_t user_defined;        /**< User Defined Data */
    struct c_list_entry_tag * next;     /**< INTERNAL USE ONLY */
    struct c_list_entry_tag * prev;     /**< INTERNAL USE ONLY */
} c_list_entry_t;

/** INTERNAL USE ONLY */
typedef struct {
    c_list_entry_t * head;
    c_list_entry_t * tail;
    c_list_entry_t * cur;
    c_list_step_options_t step_options;
    c_list_malloc_t malloc;
    c_list_free_t free;
} c_list_t;

/** @brief Create list.
 *
 * @param[in] c_list_malloc    allocator function to use for all
 * dynamic memory allocations (typically this will be malloc)
 * @param[in] c_list_free      de-allocator function to use for all
 * dynamic memory de-allocations (typically this will be free)
 *
 * @returns pointer to newly allocated list (must be deleted by
 * calling @ref c_list_delete) or NULL on error.
 * */
c_list_t * c_list_create(c_list_malloc_t c_list_malloc, c_list_free_t c_list_free);

/** @brief Delete list.
 *
 * @param[in] c_list    pointer of list to delete (returned by @ref c_list_create)
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_delete(c_list_t * c_list);

/** @brief Copy list.
 *
 * Will copy list @p src to @p dest.  Both @p src and @p must be valid
 * lists allocated by @ref c_list_create.  @note If the @a user_defined
 * field is a pointer to an external object it will not be deep copied.
 *
 * @param dest  destination list
 * @param src   source list
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_copy(c_list_t * dest, const c_list_t * src);

/** @brief Append item to list.
 *
 * @param[in] c_list    list to add item to
 * @param[in] num       integer value of item to add
 * @param[in] str       string value of item to add
 * @param[in] user_defined   user defined value of item to add
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_append(c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined);

/** @brief Insert item in list at specified location.
 *
 * @param[in] c_list    list to add item to
 * @param[in] idx       0-based index of where to add item
 * @param[in] num       integer value of item to add
 * @param[in] str       string value of item to add
 * @param[in] user_defined   user defined value of item to add
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_insert(c_list_t * c_list, size_t idx, c_list_num_t num, const char * str, user_defined_t user_defined);

/** @brief Insert item in list in sorted order.
 *
 * Inserts item in list in sorted order.
 *
 * @note The list must already be in sorted order
 *
 * @param[in] c_list    list to add item to
 * @param[in] num       integer value of item to add
 * @param[in] str       string value of item to add
 * @param[in] user_defined   user defined value of item to add
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_insert_in_sort_order(c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined);

/** @brief Insert item in list in sorted order (unique).
 *
 * Inserts item in list in sorted order.  If an item with the same
 * numeric value already exists in the list it will be replaced with
 * the values provided.
 *
 * @note The list must already be in sorted order
 *
 * @param[in] c_list    list to add item to
 * @param[in] num       integer value of item to add
 * @param[in] str       string value of item to add
 * @param[in] user_defined   user defined value of item to add
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_insert_in_sort_order_unique(c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined);

/** @brief Insert item in list in alphabetical order.
 *
 * @note The list must already be in alphabetical order
 *
 * @param[in] c_list    list to add item to
 * @param[in] num       integer value of item to add
 * @param[in] str       string value of item to add
 * @param[in] user_defined   user defined value of item to add
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_insert_in_alphabetical_order(c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined);

/** @brief Remove item from list.
 *
 * Remove item from list specified by the index @p idx
 *
 * @param[in] c_list    list object
 * @param[in] idx   index of item to remove
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_remove(c_list_t * c_list, size_t idx);

/** @brief Clear list.
 *
 * Clears all items from list
 *
 * @param[in] c_list    list object
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_clear(c_list_t * c_list);

/** @brief Length of list
 *
 * @param[in] c_list    list object
 *
 * @returns the number of items in the list.
 * */
size_t c_list_get_length(const c_list_t * c_list);

/** @brief Find first entry in the list
 *
 * Sets the current item index to the first item in the list and returns the
 * contents of the item.
 *
 * @param[in] c_list    list object
 * @param[out] c_list_entry pointer to list entry object that found
 * data will be copied to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_find_first(c_list_t * c_list, c_list_entry_t * c_list_entry);

/** @brief Find last entry in the list
 *
 * Sets the current item index to the last item in the list and returns the
 * contents of the item.
 *
 * @param[in] c_list    list object
 * @param[out] c_list_entry pointer to list entry object that found
 * data will be copied to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_find_last(c_list_t * c_list, c_list_entry_t * c_list_entry);

/** @brief Find next entry in the list
 *
 * Sets the current item index to the next item in the list (based on
 * the current item index) and returns the contents of the item.
 *
 * @param[in] c_list    list object
 * @param[out] c_list_entry pointer to list entry object that found
 * data will be copied to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_find_next(c_list_t * c_list, c_list_entry_t * c_list_entry);

/** @brief Find previous entry in the list
 *
 * Sets the current item index to the previous item in the list (based on
 * the current item index) and returns the contents of the item.
 *
 * @param[in] c_list    list object
 * @param[out] c_list_entry pointer to list entry object that found
 * data will be copied to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_find_prev(c_list_t * c_list, c_list_entry_t * c_list_entry);

/** @brief Get entry details by index.
 *
 * Get entry details for an entry by index
 *
 * @param[in] c_list            list object
 * @param[in] idx               index of item to get
 * @param[out] c_list_entry     pointer to list entry object to copy
 * data to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_get_entry(const c_list_t * c_list, size_t idx, c_list_entry_t * c_list_entry);

/** @brief Set entry details by index.
 *
 * Replace the given entry (specified by the index @p idx) with the
 * data contained in @p c_list_entry.
 *
 * @param[in] c_list        list_object
 * @param[in] idx           index of item to replace
 * @param[in] c_list_entry  pointer to entry object containing new data
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_set_entry(c_list_t * c_list, size_t idx, const c_list_entry_t * c_list_entry);

/** @brief Get current entry details.
 *
 * Get current entry details
 *
 * @param[in] c_list            list object
 * @param[out] c_list_entry     pointer to list entry object to copy
 * data to
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_get_current_entry(const c_list_t * c_list, c_list_entry_t * c_list_entry);

/** @brief Set details of current entry.
 *
 * Replace the current entry with the data contained in @p c_list_entry.
 *
 * @param[in] c_list        list object
 * @param[in] c_list_entry  pointer to entry object containing new data
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_set_current_entry(c_list_t * c_list, const c_list_entry_t * c_list_entry);

/** @brief Get index of current entry.
 *
 * @param[in] c_list    list object
 * @param[out] idx      index of current object
 *
 * @returns C_LIST_SUCCESS on success.*/
c_list_error_t c_list_get_index(const c_list_t * c_list, size_t * idx);

/** @brief Set current entry by index;
 *
 * @param[in] c_list    list object
 * @param[in] idx       index of new current object
 *
 * @returns C_LIST_SUCCESS on success.*/
c_list_error_t c_list_set_index(c_list_t * c_list, size_t idx);

/** @brief Find entry by number.
 *
 * Finds the entry in the list that matches the specified number @p num (using
 * the criteria set by @p find).  The entry, if found, is set as the
 * current entry.
 *
 * @param[in] c_list            list object
 * @param[in] num               number to find
 * @param[out] c_list_entry     pointer to entry object to copy data to
 * @param[in] find              search criteria
 *
 * @returns C_LIST_SUCCESS if a match is found.
 * */
c_list_error_t c_list_find_num(c_list_t * c_list, c_list_num_t num, c_list_entry_t * c_list_entry, c_list_find_t find);

/** @brief Find entry by string.
 *
 * Finds the entry in the list that matches the specified string @p
 * str. The entry, if found, is set as the current entry.
 *
 * @param[in] c_list            list object
 * @param[in] str               string to find
 * @param[out] c_list_entry     pointer to entry object to copy data to
 *
 * @returns C_LIST_SUCCESS if a match is found.
 * */
c_list_error_t c_list_find_str(c_list_t * c_list, const char * str, c_list_entry_t * c_list_entry);

/** @brief Find entry by partial string.
 *
 * Finds the entry in the list that matches the specified string @p
 * str up to the length @p len. The entry, if found, is set as the current entry.
 *
 * @param[in] c_list            list object
 * @param[in] str               string to find
 * @param[in] len               length of characters to compare
 * @param[out] c_list_entry     pointer to entry object to copy data to
 *
 * @returns C_LIST_SUCCESS if a match is found.
 * */
c_list_error_t c_list_find_strn(c_list_t * c_list, const char * str, size_t len, c_list_entry_t * c_list_entry);

/** @brief Create list using min, max, step.
 *
 * Create a list given a @p min value, @p max value and @p step size.
 * The string for each entry will be generated using the @p divider and
 * @p precision parameters.  For example, if @p divider is 1000 and @p
 * precision is 3, the value 1000 will be represented as "1.000".
 * Furthermore, each string will have the @p prefix and @p postfix
 * added to the string.
 *
 * @note: The list will be cleared of any existing data before being
 * filled with new data.
 *
 * @param[in] c_list        list object
 * @param[in] min           minimum value in list
 * @param[in] max           maximum value in list
 * @param[in] step          step size used to create values between @p
 * min and @p max
 * @param[in] divider       divider used to create string
 * @param[in] precision     precision (number of digits after decimal
 * point) used to create string
 * @param[in] postfix       string to the appended to end of string
 * @param[in] prefix        string to be prepended to beginning of
 * string
 *
 * @return C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_fill_generic(c_list_t * c_list, int min, int max, int step, int divider, int precision, const char * postfix, const char * prefix);

/** @brief Decode all decorated strings in list.
 *
 *  Decorated string contain special characters encoded using the HTML
 *  Entities syntax.  That is, \&special;.  This function will decode
 *  all the strings and replace the special characters with ASCII
 *  equivalents.  For example, \&red1over; will be replaced with "1/".
 *
 *  @param[in] c_list   list object
 *
 *  @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_decode(const c_list_t * c_list);

/** @brief Convert string to list.
 *
 * This function will import a list from a string previously created by
 * @ref c_list_export_to_string.
 *
 * @note All contents of the list will be cleared before importing form
 * the string.
 *
 * @param[in] c_list    list object
 * @param[in] str       string to import
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_import_from_string(c_list_t * c_list, const char * str);

/** @brief Convert list to a single string.
 *
 * This function will convert the list into a single string that can be
 * converted back into a list using @ref c_list_import_from_string.
 *
 * @note The user_defined data for each entry is not part of the created
 * string.
 *
 * @param[in] c_list    list_object
 * @param[out] str      buffer to hold output string
 * @param[in] size      size of @p str
 *
 * @returns C_LIST_SUCCESS on success.
 * */
c_list_error_t c_list_export_to_string(const c_list_t * c_list, char * str, size_t size);
c_list_error_t c_list_export_to_string_ext(const c_list_t * c_list, char * str, size_t size, int force_compression);

/** @brief Compare two lists.
 *
 * Two lists are considered equal if all their entries are identical
 * and they have the same "current" entry.
 *
 * @param[in] c_list_1  first list to compare
 * @param[in] c_list_2  second list to compare
 *
 * @return 1 if two lists are equal, 0 otherwise.
 * */
int c_list_compare(const c_list_t * c_list_1, const c_list_t * c_list_2);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: c_list.h **************************************************/

/********** Begin file: keydefinition.h *****************************************/
#ifndef KEYDEFINITION_H_INCLUDED
#define KEYDEFINITION_H_INCLUDED

/* Unique Key-Codes are defined as 24-bit numbers
 * Lower 8 Bit = Code
 * Middle 8 Bit = Flags
 * Upper 8 Bit = Source
 * */

/* Event sources */
#define BRAIN                       0
#define SIDE_HANDLE                 1
#define BOTTOM_HANDLE               2
#define SIDE_SSD                    3
#define REDMOTE                     4
#define LCD                         5
#define LENS                        6
#define LCD_PROMODULE               7
#define EVF                         8
#define EVF_PROMODULE               9
#define PRO_IO                      10
#define UI_SOFTKEY                  11
#define SIDE_MODULE                 12
#define FLAT_UI                     13
#define TOP_HANDLE                  14
#define WEAPON_SIDE_HANDLE          15
#define LCD3                        16
#define EVF3                        17
#define XLFIZ                       18  /* No longer supported... */
#define SIDE_UI_LEFT                19
#define SIDE_UI_RIGHT               20

/* Key flags */
#define KEY_DOWN                    1   /**< Key press down event (should always be followed eventually by a @ref KEY_UP event. */
#define KEY_UP                      2   /**< Key released */
#define CW                          4   /**< Clockwise */
#define CCW                         8   /**< Counter Clockwise */

/* Key ID's */
#define USER_KEY_A                  1
#define USER_KEY_B                  2
#define USER_KEY_C                  3
#define USER_KEY_D                  4
#define FUNCTION_KEY_1              5
#define FUNCTION_KEY_2              6
#define FUNCTION_KEY_3              7
#define FUNCTION_KEY_4              8
#define FUNCTION_KEY_5              9
#define FUNCTION_KEY_6              10
#define FUNCTION_KEY_7              11
#define FUNCTION_KEY_8              12
#define STILL_SELECT_KEY            13
#define MOVIE_SELECT_KEY            14
#define RECORD_HALF_KEY             15
#define RECORD_FULL_KEY             16
#define FRONT_ROTARY_1              26
#define FRONT_ROTARY_2              27
#define BACK_ROTARY_JOG             28
#define BACKLIGHT_KEY               29
#define MENU_KEY                    30
#define NORTH_KEY                   31
#define SOUTH_KEY                   32
#define EAST_KEY                    33
#define WEST_KEY                    34
#define CENTER_KEY                  35
#define LOCK_KEY                    40
#define UNLOCK_KEY                  41
#define ROCKER_PLUS                 42
#define ROCKER_MINUS                43
#define MODE_KEY                    44

/* Utility Macros */

/** Create keycode from @p source, @p flags, and @p id. */
#define MAKEKEYCODE(source, flags, id) ((((source) & 0xFF) << 16) | (((flags) & 0xFF) << 8) | ((id) & 0xFF))

/** Extract source from @p keycode. */
#define KEYCODE_SOURCE(keycode) (((keycode) & 0xFF0000) >> 16)

/** Extract flags from @p keycode. */
#define KEYCODE_FLAGS(keycode) (((keycode) & 0x00FF00) >> 8)

/** Extract id from @p keycode. */
#define KEYCODE_ID(keycode) ((keycode) & 0x0000FF)
#endif
/********** End file: keydefinition.h *******************************************/

/********** Begin file: rcp_api.h ***********************************************/
/*lint -strong(AJX,rcp_param_t,rcp_param_status_t,rcp_connection_state_t,rcp_mutex_t,rcp_log_t,rcp_notification_action_t,rcp_clip_list_status_t,rcp_error_t) */

/** @file rcp_api.h
 * RCP API Header
 **/

/** @mainpage Documentation
 *
 * @section API_OVERVIEW API Overview
 *
 * @subsection RCP_API_INFO RCP API Information
 * function                 | description
 * -------------------------|------------
 * @ref rcp_api_get_version | @copybrief rcp_api_get_version
 *
 * @subsection CONNECTION_MANAGEMENT Connection Management
 *
 * function                          | description
 * ----------------------------------|------------
 * @ref rcp_create_camera_connection | @copybrief rcp_create_camera_connection
 * @ref rcp_delete_camera_connection | @copybrief rcp_delete_camera_connection
 * @ref rcp_camera_connection_stats  | @copybrief rcp_camera_connection_stats
 *
 * @subsection CAMERA_DISCOVERY Camera Discovery
 * function                        | description
 * --------------------------------|------------
 * @ref rcp_discovery_start        | @copybrief rcp_discovery_start
 * @ref rcp_discovery_step         | @copybrief rcp_discovery_step
 * @ref rcp_discovery_get_list     | @copybrief rcp_discovery_get_list
 * @ref rcp_discovery_free_list    | @copybrief rcp_discovery_free_list
 * @ref rcp_discovery_process_data | @copybrief rcp_discovery_process_data
 * @ref rcp_discovery_end          | @copybrief rcp_discovery_end
 *
 * @subsection SET_GET_CAM_PARAMS Setting/Getting Camera Parameters
 * function                           | description
 * -----------------------------------|------------
 * @ref rcp_get                       | @copybrief rcp_get
 * @ref rcp_get_list                  | @copybrief rcp_get_list
 * @ref rcp_get_status                | @copybrief rcp_get_status
 * @ref rcp_get_default               | @copybrief rcp_get_default
 * @ref rcp_send                      | @copybrief rcp_send
 * @ref rcp_set_int                   | @copybrief rcp_set_int
 * @ref rcp_set_int_relative          | @copybrief rcp_set_int_relative
 * @ref rcp_set_uint                  | @copybrief rcp_set_uint
 * @ref rcp_set_uint_relative         | @copybrief rcp_set_uint_relative
 * @ref rcp_set_str                   | @copybrief rcp_set_str
 * @ref rcp_set_list                  | @copybrief rcp_set_list
 * @ref rcp_set_list_relative         | @copybrief rcp_set_list_relative
 * @ref rcp_get_periodic_is_supported | @copybrief rcp_get_periodic_is_supported
 * @ref rcp_get_periodic_on           | @copybrief rcp_get_periodic_on
 * @ref rcp_get_periodic_off          | @copybrief rcp_get_periodic_off
 *
 * @subsection NOTIFICATIONS Notification Interface
 * function                       | description
 * -------------------------------|------------
 * @ref rcp_notification_get      | @copybrief rcp_notification_get
 * @ref rcp_notification_timeout  | @copybrief rcp_notification_timeout
 * @ref rcp_notification_response | @copybrief rcp_notification_response
 *
 * @subsection GET_PARAM_PROP Getting Properties of RCP Parameters
 * function                               | description
 * ---------------------------------------|------------
 * @ref rcp_get_name                      | @copybrief rcp_get_name
 * @ref rcp_get_label                     | @copybrief rcp_get_label
 * @ref rcp_get_id                        | @copybrief rcp_get_id
 * @ref rcp_get_update_list_only_on_close | (DEPRECATED) @copybrief rcp_get_update_list_only_on_close
 * @ref rcp_get_is_supported              | @copybrief rcp_get_is_supported
 *
 * @subsection MENU_TREE Getting Menu Tree for Camera
 * function                                       | description
 * -----------------------------------------------|------------
 * @ref rcp_menu_is_supported                     | @copybrief rcp_menu_is_supported
 * @ref rcp_menu_get_children                     | @copybrief rcp_menu_get_children
 * @ref rcp_menu_node_status_is_supported         | @copybrief rcp_menu_node_status_is_supported
 * @ref rcp_menu_get_node_status                  | @copybrief rcp_menu_get_node_status
 * @ref rcp_menu_get_multi_action_list_leaf_flags | @copybrief rcp_menu_get_multi_action_list_leaf_flags
 *
 * @subsection FILE_TRANSFER File Transfer Functions
 * function                                       | description
 * -----------------------------------------------|------------
 * @ref rcp_rftp_is_supported                     | @copybrief rcp_rftp_is_supported
 * @ref rcp_rftp_tethered_is_supported            | @copybrief rcp_rftp_tethered_is_supported
 * @ref rcp_rftp_send_file                        | @copybrief rcp_rftp_send_file
 * @ref rcp_rftp_retrieve_file                    | @copybrief rcp_rftp_retrieve_file
 * @ref rcp_rftp_retrieve_file_tethered           | @copybrief rcp_rftp_retrieve_file_tethered
 * @ref rcp_rftp_abort_transfer                   | @copybrief rcp_rftp_abort_transfer
 * @ref rcp_rftp_delete_file                      | @copybrief rcp_rftp_delete_file
 * @ref rcp_rftp_directory_listing                | @copybrief rcp_rftp_directory_listing
 *
 * @subsection USER_MSG User Pass-Through Message Functions
 * function                          | description
 * ----------------------------------|------------
 * @ref rcp_user_is_supported        | @copybrief rcp_user_is_supported
 * @ref rcp_user_send_set            | @copybrief rcp_user_send_set
 * @ref rcp_user_send_get            | @copybrief rcp_user_send_get
 * @ref rcp_user_send_current        | @copybrief rcp_user_send_current
 *
 * @subsection USER_METADATA_MSG User Metadata Message Functions
 * function                             | description
 * -------------------------------------|------------
 * @ref rcp_user_metadata_is_supported  | @copybrief rcp_user_metadata_is_supported
 * @ref rcp_user_metadata_register      | @copybrief rcp_user_metadata_register
 * @ref rcp_user_metadata_unregister    | @copybrief rcp_user_metadata_unregister
 * @ref rcp_user_metadata_send          | @copybrief rcp_user_metadata_send
 *
 * @subsection KEYMAPPING_FUNCTIONS Key Mapping Functions
 *
 * function                                | description
 * ----------------------------------------|------------
 * @ref rcp_key_mapping_is_supported        | @copybrief rcp_key_mapping_is_supported
 * @ref rcp_key_mapping_get_action_list     | @copybrief rcp_key_mapping_get_action_list
 * @ref rcp_key_mapping_get_mapping         | @copybrief rcp_key_mapping_get_mapping
 * @ref rcp_key_mapping_set_mapping         | @copybrief rcp_key_mapping_set_mapping
 *
 * @subsection CLIENT_FUNCTIONS Client Provided Functions
 *
 * function              | description
 * ----------------------|------------
 * @ref rcp_malloc       | @copybrief rcp_malloc
 * @ref rcp_free         | @copybrief rcp_free
 * @ref rcp_mutex_lock   | @copybrief rcp_mutex_lock
 * @ref rcp_mutex_unlock | @copybrief rcp_mutex_unlock
 * @ref rcp_log          | @copybrief rcp_log
 * @ref rcp_rand         | @copybrief rcp_rand
 * @ref rcp_timestamp    | @copybrief rcp_timestamp
 *
 * @section BUILD_CONFIGURATION API Build Configuration
 *
 * The API build can be customized to fit the needs of your target
 * platform - for details see rcp_api_config.h
 *
 * @page CHANGELOG Changelog
 *
 * * @section VERSION_6_62_0 Version 6.62
 * - Added parameters:
 *   - @ref RCP_PARAM_CDL_ENABLE
 *   - @ref RCP_PARAM_LUT_FEED_1_ENABLE
 *
 * * @section VERSION_6_61_0 Version 6.61
 * - Added parameters:
 *   - @ref RCP_PARAM_VOLTAGE_THRESHOLD_DC_IN
 *   - @ref RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN
 *   - @ref RCP_PARAM_POWER_IN_TYPE_0 - @RCP_PARAM_POWER_IN_TYPE_LAST
 *   - @ref RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0 - @RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_LAST
 * - Deprecated parameters:
 *   - @ref RCP_PARAM_VOLTAGE_BELOW_THRESHOLD
 *
 * @section VERSION_6_60_0 Version 6.60
 * - Added parameters:
 *   - @ref RCP_PARAM_CENTER_GUIDE_MARKER_TYPE
 *   - @ref RCP_PARAM_SHUTDOWN_NOTIFICATION
 *   - @ref RCP_PARAM_PEAKING_LEVEL
 *   - @ref RCP_PARAM_VOLTAGE_THRESHOLD
 *   - @ref RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD
 *   - @ref RCP_PARAM_VOLTAGE_BELOW_THRESHOLD
 *
 * @section VERSION_6_51_2 Version 6.51.2
 * - Added parameters:
 *   - @ref RCP_PARAM_SENSOR_SENSITIVITY
 *
 * @section VERSION_6_51_0 Version 6.51.0
 * - Added parameters:
 *   - @ref RCP_PARAM_QT_DROPPED_FRAMES
 *   - @ref RCP_PARAM_MXF_DROPPED_FRAMES
 *   - @ref RCP_PARAM_R3D_DROPPED_FRAMES
 *
 * @section VERSION_6_50_24 Version 6.50.24
 * - Added is_paused field to rcp_cur_rftp_status_cb_data_t
 *
 * - Added parameters:
 *
 * @section VERSION_6_50_23 Version 6.50.23
 * - Added parameters:
 *   - @ref RCP_PARAM_MIN_RECORD_PROXY_BAKED_IN_SETTINGS
 *   - @ref RCP_PARAM_MAX_RECORD_PROXY_BAKED_IN_SETTINGS
 *   - @ref RCP_PARAM_POWER_CURRENT_SOURCE_INDEX
 *
 * @section VERSION_6_50_22 Version 6.50.22
 * - Added parameters:
 *   - @ref RCP_PARAM_MONITOR_LUT_LCD
 *   - @ref RCP_PARAM_MONITOR_LUT_EVF
 *   - @ref RCP_PARAM_MONITOR_LUT_HDMI
 *   - @ref RCP_PARAM_MONITOR_LUT_HDSDI
 *   - @ref RCP_PARAM_MONITOR_LUT_REAR_LCD
 *   - @ref RCP_PARAM_MONITOR_LUT_REAR_EVF
 *   - @ref RCP_PARAM_MONITOR_LUT_REAR_HDSDI1
 *   - @ref RCP_PARAM_MONITOR_LUT_REAR_HDSDI2
 *   - @ref RCP_PARAM_MONITOR_LUT_BRAIN_LCD3
 *   - @ref RCP_PARAM_MONITOR_LUT_BRAIN_EVF3
 *   - @ref RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS
 *
 * @section VERSION_6_50_20 Version 6.50.20
 * - bug fixes
 *
 * @section VERSION_6_50_16 Version 6.50.16
 * - Added Client ID feature: The API will now inform the camera with
 * the client application provided information: see client_name,
 * client_version, and client_user added to
 * rcp_camera_connection_info_t.  This information may be shown to the
 * camera operator.
 * - Added rcp_interface_enabled and rcp_interface_enabled_valid fields
 * to rcp_cam_info_t.
 * - Added RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE
 * to rcp_connection_state_t.  This is used to signify that RCP has
 * been disabled on the interface connected to (the user will need to
 * re-enable before a connection is allowed)
 * - Note: Periodic data (RCP_PARAM_HISTOGRAM, RCP_PARAM_AUDIO_VU_DATA,
 * RCP_PARAM_CAMERA_PITCH, and RCP_PARAM_CAMERA_ROLL) is no longer
 * enabled by default on the camera.  If you application requires this
 * data, you must enable it using:
 * - Added @ref rcp_get_periodic_is_supported, @ref
 * rcp_get_periodic_on, and @ref rcp_get_periodic_off.
 * - Added @ref rcp_get_default
 *
 * - Deprecated parameters:
 *   - @ref RCP_PARAM_SET_TIMECODE
 *   - @ref RCP_PARAM_PROXY_ENCODE_FRAMERATE (replaced with
 *   @ref RCP_PARAM_PRORES_ENCODE_FRAMERATE and
 *   @ref RCP_PARAM_MXF_ENCODE_FRAMERATE)
 *   - @ref RCP_PARAM_MONITOR_SPLIT_CURVE
 *   - @ref RCP_PARAM_MONITOR_CURVE_LCD
 *   - @ref RCP_PARAM_MONITOR_CURVE_HDMI
 *   - @ref RCP_PARAM_MONITOR_CURVE_HDSDI
 *   - @ref RCP_PARAM_MONITOR_CURVE_EVF
 *   - @ref RCP_PARAM_MONITOR_CURVE_REAR_LCD
 *   - @ref RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1
 *   - @ref RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2
 *   - @ref RCP_PARAM_MONITOR_CURVE_REAR_EVF
 *   - @ref RCP_PARAM_MONITOR_CURVE_LCD3
 *   - @ref RCP_PARAM_MONITOR_CURVE_EVF3
 *   - @ref RCP_PARAM_FLIP_MIRROR_FEED_0
 *   - @ref RCP_PARAM_FLIP_MIRROR_FEED_1
 *
 * - Added parameters:
 *   - @ref RCP_PARAM_CDL_SATURATION
 *   - @ref RCP_PARAM_EXPOSURE_ADJUST
 *   - @ref RCP_PARAM_CDL_OFFSET_RED
 *   - @ref RCP_PARAM_CDL_OFFSET_GREEN
 *   - @ref RCP_PARAM_CDL_OFFSET_BLUE
 *   - @ref RCP_PARAM_CDL_POWER_RED
 *   - @ref RCP_PARAM_CDL_POWER_GREEN
 *   - @ref RCP_PARAM_CDL_POWER_BLUE
 *   - @ref RCP_PARAM_CDL_SLOPE_RED
 *   - @ref RCP_PARAM_CDL_SLOPE_GREEN
 *   - @ref RCP_PARAM_CDL_SLOPE_BLUE
 *   - @ref RCP_PARAM_GIGABIT_ETHERNET_MAC_ADDRESS
 *   - @ref RCP_PARAM_WIFI_MAC_ADDRESS
 *   - @ref RCP_PARAM_PRORES_ENCODE_FRAMERATE
 *   - @ref RCP_PARAM_MXF_ENCODE_FRAMERATE
 *   - @ref RCP_PARAM_MONITOR_MODE_LCD3
 *   - @ref RCP_PARAM_MONITOR_OVERLAY_LCD3
 *   - @ref RCP_PARAM_MONITOR_FREQ_LCD3
 *   - @ref RCP_PARAM_MONITOR_CURVE_LCD3
 *   - @ref RCP_PARAM_MONITOR_TOOLS_LCD3
 *   - @ref RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3
 *   - @ref RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3
 *   - @ref RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3
 *   - @ref RCP_PARAM_MONITOR_DOCK_MENUS_LCD3
 *   - @ref RCP_PARAM_MONITOR_FEED_LCD3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3
 *   - @ref RCP_PARAM_MONITOR_MODE_EVF3
 *   - @ref RCP_PARAM_MONITOR_OVERLAY_EVF3
 *   - @ref RCP_PARAM_MONITOR_FREQ_EVF3
 *   - @ref RCP_PARAM_MONITOR_CURVE_EVF3
 *   - @ref RCP_PARAM_MONITOR_TOOLS_EVF3
 *   - @ref RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3
 *   - @ref RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3
 *   - @ref RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3
 *   - @ref RCP_PARAM_MONITOR_DOCK_MENUS_EVF3
 *   - @ref RCP_PARAM_MONITOR_FEED_EVF3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3
 *   - @ref RCP_PARAM_MONITOR_BRIGHTNESS_LCD3
 *   - @ref RCP_PARAM_MONITOR_BRIGHTNESS_EVF3
 *   - @ref RCP_PARAM_ND_INCREMENT_SIZE
 *   - @ref RCP_PARAM_ZEBRA_1_PATTERN
 *   - @ref RCP_PARAM_ZEBRA_2_PATTERN
 *   - @ref RCP_PARAM_ZEBRA_1_COLOR
 *   - @ref RCP_PARAM_ZEBRA_2_COLOR
 *   - @ref RCP_PARAM_START_USER_CAL_MANUAL_CURRENT_INT_TIME
 *   - @ref RCP_PARAM_START_USER_CAL_MANUAL_DEFAULT_INT_TIME
 *   - @ref RCP_PARAM_START_USER_CAL_AUTO
 *   - @ref RCP_PARAM_MONITOR_CONTROL_SCREEN
 *   - @ref RCP_PARAM_RCP_CLIENT_LIST
 *   - @ref RCP_PARAM_BWF_ENABLE
 *   - @ref RCP_PARAM_BWF_VALID
 *   - @ref RCP_PARAM_WSH_FOCUS_WHEEL
 *   - @ref RCP_PARAM_SIDE_MODULE_LOCK_KEYS
 *   - @ref RCP_PARAM_SIDE_MODULE_RECORD_KEY_LOCKABLE
 *   - @ref RCP_PARAM_SIDE_MODULE_NAV_KEYS_LOCKABLE
 *   - @ref RCP_PARAM_SHOW_KEY_ACTION_NOTIFICATIONS
 *   - @ref RCP_PARAM_POWER_IN_LIST
 *   - @ref RCP_PARAM_POWER_IN_PERCENT_0 - @ref RCP_PARAM_POWER_IN_PERCENT_LAST
 *   - @ref RCP_PARAM_POWER_IN_RUNTIME_0 - @ref RCP_PARAM_POWER_IN_RUNTIME_LAST
 *   - @ref RCP_PARAM_POWER_IN_VOLTAGE_0 - @ref RCP_PARAM_POWER_IN_VOLTAGE_LAST
 *   - @ref RCP_PARAM_POWER_IN_CURRENT_0 - @ref RCP_PARAM_POWER_IN_CURRENT_LAST
 *   - @ref RCP_PARAM_POWER_IN_PRESENT_0 - @ref RCP_PARAM_POWER_IN_PRESENT_LAST
 *   - @ref RCP_PARAM_POWER_OUT_LIST
 *   - @ref RCP_PARAM_POWER_OUT_ENABLE_0 - @ref RCP_PARAM_POWER_OUT_ENABLE_LAST
 *   - @ref RCP_PARAM_POWER_OUT_STATUS_0 - @ref RCP_PARAM_POWER_OUT_STATUS_LAST
 *   - @ref RCP_PARAM_POWER_OUT_RESET_0 - @ref RCP_PARAM_POWER_OUT_RESET_LAST
 *   - @ref RCP_PARAM_POWER_OUT_CURRENT_0 - @ref RCP_PARAM_POWER_OUT_CURRENT_LAST
 *   - @ref RCP_PARAM_MONITOR_LIST
 *   - @ref RCP_PARAM_SIDE_UI_NAME
 *   - @ref RCP_PARAM_SENSOR_WIDTH_PHY
 *   - @ref RCP_PARAM_SENSOR_HEIGHT_PHY
 *   - @ref RCP_PARAM_SENSOR_DIMENSIONS_PHY
 *   - @ref RCP_PARAM_FORMAT_WIDTH_PHY
 *   - @ref RCP_PARAM_FORMAT_HEIGHT_PHY
 *   - @ref RCP_PARAM_FORMAT_DIMENSIONS_PHY
 *   - @ref RCP_PARAM_FORMAT_WIDTH_PIXELS
 *   - @ref RCP_PARAM_FORMAT_HEIGHT_PIXELS
 *   - @ref RCP_PARAM_FORMAT_DIMENSIONS_PIXELS
 *   - @ref RCP_PARAM_RECORD_FORMAT_SPHERICAL
 *   - @ref RCP_PARAM_RECORD_FORMAT_ANA_1_3
 *   - @ref RCP_PARAM_RECORD_FORMAT_ANA_1_25
 *   - @ref RCP_PARAM_RECORD_FORMAT_ANA_2
 *   - @ref RCP_PARAM_RECORD_FORMAT_RESOLUTION
 *   - @ref RCP_PARAM_RECORD_FORMAT_ASPECT_RATIO
 *   - @ref RCP_PARAM_RECORD_FORMAT_ANAMORPHIC
 *   - @ref RCP_PARAM_RECORD_FORMAT_LOOKAROUND
 *   - @ref RCP_PARAM_SENSOR_NAME
 *   - @ref RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY
 *   - @ref RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY
 *   - @ref RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY
 *   - @ref RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS
 *   - @ref RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS
 *   - @ref RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS
 *   - @ref RCP_PARAM_AMBIENT_CHANNEL
 *   - @ref RCP_PARAM_KEY_MAPPING_ACTION_LIST
 *   - @ref RCP_PARAM_DIALOG_LIST
 *   - @ref RCP_PARAM_CAMERA_SCRIPT_LIST
 *   - @ref RCP_PARAM_COLOR_SCIENCE
 *   - @ref RCP_PARAM_IMAGE_PIPELINE_MODE
 *   - @ref RCP_PARAM_SUPPORT_CONTACT
 *   - @ref RCP_PARAM_CAMERA_CDL_LIST
 *   - @ref RCP_PARAM_CAMERA_CDL_APPLY
 *   - @ref RCP_PARAM_CAMERA_CDL_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_CDL_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_CDL_CREATE
 *   - @ref RCP_PARAM_CAMERA_CDL_DELETE
 *   - @ref RCP_PARAM_MEDIA_CDL_LIST
 *   - @ref RCP_PARAM_MEDIA_CDL_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_CDL_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_SLATE_CAMERA_COLOR
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_USER_LEFT
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_AUDIO_LEFT
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_MONITOR_LEFT
 *   - @ref RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT
 *   - @ref RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_USER_RIGHT
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_AUDIO_RIGHT
 *   - @ref RCP_PARAM_SIDE_UI_PAGE_MONITOR_RIGHT
 *   - @ref RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT
 *   - @ref RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT
 *   - @ref RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1
 *   - @ref RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2
 *   - @ref RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI
 *   - @ref RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI
 *   - @ref RCP_PARAM_RETURN_FEED
 *   - @ref RCP_PARAM_RETURN_FEED_STATE
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3
 *   - @ref RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3
 *   - @ref RCP_PARAM_OUTPUT_TRANSFORM
 *   - @ref RCP_PARAM_DISPLAY_PRESET_LCD
 *   - @ref RCP_PARAM_DISPLAY_PRESET_HDMI
 *   - @ref RCP_PARAM_DISPLAY_PRESET_HDSDI
 *   - @ref RCP_PARAM_DISPLAY_PRESET_EVF
 *   - @ref RCP_PARAM_DISPLAY_PRESET_REAR_LCD
 *   - @ref RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1
 *   - @ref RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2
 *   - @ref RCP_PARAM_DISPLAY_PRESET_REAR_EVF
 *   - @ref RCP_PARAM_DISPLAY_PRESET_LCD3
 *   - @ref RCP_PARAM_DISPLAY_PRESET_EVF3
 *   - @ref RCP_PARAM_OUTPUT_TONE_MAP
 *   - @ref RCP_PARAM_FLIP_MIRROR_FEED_0_1
 *   - @ref RCP_PARAM_MIN_FRAME_PROCESSING_MODE
 *   - @ref RCP_PARAM_MAX_FRAME_PROCESSING_MODE
 *   - @ref RCP_PARAM_MIN_FRAME_PROCESSING_FRAME_COUNT
 *   - @ref RCP_PARAM_MAX_FRAME_PROCESSING_FRAME_COUNT
 *   - @ref RCP_PARAM_ROLL_OFF
 *   - @ref RCP_PARAM_LOOKAROUND_AVAILABLE
 *   - @ref RCP_PARAM_LOG_VIEW_MODE
 *   - @ref RCP_PARAM_AUTO_FOCUS_PEAK
 *   - @ref RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE
 *   - @ref RCP_PARAM_ISO_CAL2_ENABLED
 *
 * - Added support for user metadata RCP messages
 *   - @ref rcp_user_metadata_is_supported
 *   - @ref rcp_user_metadata_register
 *   - @ref rcp_user_metadata_unregister
 *   - @ref rcp_user_metadata_send
 *   - Added new handle_user_metadata_cb callback
 *
 * - Added support for key mapping via RCP messages
 *   - @ref rcp_key_mapping_is_supported
 *   - @ref rcp_key_mapping_get_action_list
 *   - @ref rcp_key_mapping_get_mapping
 *   - @ref rcp_key_mapping_set_mapping
 *
 * - Added new menu tree node: RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF
 *
 * @section VERSION_6_42_5 Version 6.42.5
 * - Added support for compressed c_list
 *   (C_LIST_STRING_TYPE_COMPRESSED) types
 *
 * @section VERSION_6_42_4 Version 6.42.4
 * - Added parameters:
 *   - @ref RCP_PARAM_AUDIO_CH3_MODE_STATUS
 *   - @ref RCP_PARAM_AUDIO_CH4_MODE_STATUS
 *   - @ref RCP_PARAM_RECORD_PRE_FRAME_COUNT_AVAILABLE
 *   - @ref RCP_PARAM_RECORD_POST_FRAME_COUNT_AVAILABLE
 *   - @ref RCP_PARAM_RECORD_PRE_FRAME_COUNT_ACTUAL
 *   - @ref RCP_PARAM_RECORD_POST_FRAME_COUNT_ACTUAL
 *
 * @section VERSION_6_41_5 Version 6.41.5
 * - Added parameters:
 *   - @ref RCP_PARAM_WIFI_NETMASK
 *   - @ref RCP_PARAM_WIFI_GATEWAY
 *   - @ref RCP_PARAM_WIFI_DHCP_ENABLE
 *   - @ref RCP_PARAM_AUDIO_CH1_MODE_STATUS
 *   - @ref RCP_PARAM_AUDIO_CH2_MODE_STATUS
 *
 * @section VERSION_6_40_13 Version 6.40.13
 * - Added support for user RCP messages (for communicating with 3rd
 *   party modules attached to the camera)
 *   - @ref rcp_user_is_supported
 *   - @ref rcp_user_send_set
 *   - @ref rcp_user_send_get
 *   - @ref rcp_user_send_current
 * - Added @ref rcp_param_properties_t.has_display_str
 *
 * - Added parameters:
 *   - @ref RCP_PARAM_MEDIA_IS_PRESENT
 *   - @ref RCP_PARAM_LENS_IMAGE_STABILIZATION_ENABLED
 *   - @ref RCP_PARAM_LENS_CAPABILITIES
 *   - @ref RCP_PARAM_PLAYBACK_FILE_FORMAT
 *   - @ref RCP_PARAM_MONITOR_MODE_LCD3
 *   - @ref RCP_PARAM_MONITOR_OVERLAY_LCD3
 *   - @ref RCP_PARAM_MONITOR_FREQ_LCD3
 *   - @ref RCP_PARAM_MONITOR_CURVE_LCD3
 *   - @ref RCP_PARAM_MONITOR_TOOLS_LCD3
 *   - @ref RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3
 *   - @ref RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3
 *   - @ref RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3
 *   - @ref RCP_PARAM_MONITOR_DOCK_MENUS_LCD3
 *   - @ref RCP_PARAM_MONITOR_FEED_LCD3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3
 *   - @ref RCP_PARAM_MONITOR_MODE_EVF3
 *   - @ref RCP_PARAM_MONITOR_OVERLAY_EVF3
 *   - @ref RCP_PARAM_MONITOR_FREQ_EVF3
 *   - @ref RCP_PARAM_MONITOR_CURVE_EVF3
 *   - @ref RCP_PARAM_MONITOR_TOOLS_EVF3
 *   - @ref RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3
 *   - @ref RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3
 *   - @ref RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3
 *   - @ref RCP_PARAM_MONITOR_DOCK_MENUS_EVF3
 *   - @ref RCP_PARAM_MONITOR_FEED_EVF3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3
 *   - @ref RCP_PARAM_MONITOR_BRIGHTNESS_LCD3
 *   - @ref RCP_PARAM_MONITOR_BRIGHTNESS_EVF3
 *   - @ref RCP_PARAM_RECORD_VIDEO_MXF_CODEC
 *   - @ref RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC
 *   - @ref RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION
 *   - @ref RCP_PARAM_RECORD_MXF_STATE
 *   - @ref RCP_PARAM_RECORD_MXF_STATE_DETAILED
 *   - @ref RCP_PARAM_MXF_WIDTH
 *   - @ref RCP_PARAM_MXF_HEIGHT
 *   - @ref RCP_PARAM_MXF_DIMENSION
 *   - @ref RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID
 *   - @ref RCP_PARAM_PLAYBACK_FILE_FORMAT_TYPE
 *   - @ref RCP_PARAM_OLPF_THIRD_PARTY_NAME
 *   - @ref RCP_PARAM_OLPF_THIRD_PARTY_EMULATED_TYPE
 *   - @ref RCP_PARAM_LENS_META_NAME
 *   - @ref RCP_PARAM_LENS_META_SERIAL
 *   - @ref RCP_PARAM_LENS_META_OWNER
 *   - @ref RCP_PARAM_LENS_META_MANUFACTURER
 *   - @ref RCP_PARAM_LENS_META_FLEN_MIN
 *   - @ref RCP_PARAM_LENS_META_FLEN_MAX
 *   - @ref RCP_PARAM_RECORD_R3D_METADATA_CURVE
 *
 * @section VERSION_6_32_10 Version 6.32.10
 * - Fix potential bad read from memory when parsing histogram data
 * - Frame limit is no longer available for any camera while in network
 * mode.
 * - Disable various look controls based on RAW and ACES modes
 *
 * @section VERSION_6_32_7 Version 6.32.7
 * - Fixed typos/wording of comments
 * - Fixed labels
 * - Fixed typo (from RCP_API_ENABLE_CACHEING to RCP_API_ENABLE_CACHING)
 * - Fixed bug where 'is_hw_supported_valid' was not cleared when connecting to a camera
 * - Fixed @ref RCP_PARAM_HDR_FACTOR not updating on boot
 * - Fixed bug in handling hardware capabilities for older firmware
 *
 * @section VERSION_6_32_4 Version 6.32.4
 * - Added parameters:
 *   - @ref RCP_PARAM_SERIAL_2_PROTOCOL
 *   - @ref RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_REAR_AUX_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_REAR_AUX_RESET
 *   - @ref RCP_PARAM_POWER_OUT_REAR_AUX_CURRENT
 *   - @ref RCP_PARAM_POWER_OUT_TIMECODE_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_TIMECODE_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_TIMECODE_RESET
 *
 * @section VERSION_6_31_6 Version 6.31.6
 * - Added parameters:
 *   - @ref RCP_PARAM_ZEBRA_1_MODE
 *   - @ref RCP_PARAM_ZEBRA_1_STOPS_LOW
 *   - @ref RCP_PARAM_ZEBRA_1_STOPS_HIGH
 *   - @ref RCP_PARAM_ZEBRA_2_MODE
 *   - @ref RCP_PARAM_ZEBRA_2_STOPS_LOW
 *   - @ref RCP_PARAM_ZEBRA_2_STOPS_HIGH
 *
 * @section VERSION_6_30_16 Version 6.30.16
 * - Added file transfer API.  This allows the transfer of
 *   presets, overlays, LUTs, thumbnails, log files, etc. to and from
 *   the camera.
 *
 * - Added parameters:
 *   - @ref RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM
 *   - @ref RCP_PARAM_WIPE_CAMERA
 *   - @ref RCP_PARAM_PROXY_ENCODE_FRAMERATE
 *   - @ref RCP_PARAM_CAMERA_CAL_LIST
 *   - @ref RCP_PARAM_CAMERA_CAL_APPLY
 *   - @ref RCP_PARAM_CAMERA_CAL_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_CAL_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_CAL_DELETE
 *   - @ref RCP_PARAM_MEDIA_CAL_LIST
 *   - @ref RCP_PARAM_MEDIA_CAL_APPLY
 *   - @ref RCP_PARAM_MEDIA_CAL_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_CAL_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_PRORES_WIDTH
 *   - @ref RCP_PARAM_PRORES_HEIGHT
 *   - @ref RCP_PARAM_PRORES_DIMENSION
 *   - @ref RCP_PARAM_OPEN_GATE_MODE
 *   - @ref RCP_PARAM_OPEN_GATE_STATE
 *   - @ref RCP_PARAM_RECORD_REDCODE_RAW_STATE_DETAILED
 *   - @ref RCP_PARAM_RECORD_QUICKTIME_STATE_DETAILED
 *   - @ref RCP_PARAM_WIFI_SCAN_SELECT
 *
 * @section VERSION_6_21_8 Version 6.21.8
 * - Bug fixes
 *
 * @section VERSION_6_21_6 Version 6.21.6
 * - Added @ref extended_clipinfo_t.has_r3d and @ref extended_clipinfo_t.has_qt
 *
 * @section VERSION_6_21_5 Version 6.21.5
 * - Fixed string for RCP_PARAM_PLAYBACK_METADATA_ISO
 *
 * @section VERSION_6_21_4 Version 6.21.4
 * - Added support for REC. 709
 *
 * @section VERSION_6_21_3 Version 6.21.3
 * - RCP_PARAM_RECORD_LIMIT_ENABLE and RCP_PARAM_RECORD_LIMIT_FRAMES
 *   are now enabled when RCP_PARAM_PRIMARY_STORAGE == PRIMARY_STORAGE_NETWORK.
 * - Added more descriptive ProRes labels to RCP_PARAM_QUALITY
 *
 * @section VERSION_6_20_23 Version 6.20.23
 * - Added new required functions to be implemented by client code:
 *   - rcp_rand
 *   - rcp_timestamp
 * - Added @ref rcp_cur_str_edit_info_t.min_len and @ref rcp_cur_str_edit_info_t.is_password
 * - Added @ref rcp_menu_node_info_t.is_supported and @ref rcp_menu_node_info_t.is_supported_valid
 * - Added @ref rcp_cur_menu_node_status_cb_data_t.is_supported and @ref rcp_cur_menu_node_status_cb_data_t.is_supported_valid
 *
 * - Added utility function @ref rcp_menu_get_multi_action_list_leaf_flags
 * - Added functions:
 *   - @ref rcp_get_clip_list
 *
 * - Added parameters:
 *   - @ref RCP_PARAM_FOCUS_STATE_DETAILED
 *   - @ref RCP_PARAM_IRIS_STATE_DETAILED
 *   - @ref RCP_PARAM_ZOOM_STATE_DETAILED
 *   - @ref RCP_PARAM_RECORD_FILE_FORMAT
 *   - @ref RCP_PARAM_RECORD_VIDEO_CODEC
 *   - @ref RCP_PARAM_HARDWARE_CAPABILITIES
 *   - @ref RCP_PARAM_AUDIO_CH1_MUTE
 *   - @ref RCP_PARAM_AUDIO_CH2_MUTE
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_VOL1
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_PAN1
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_VOL2
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_PAN2
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_VOL3
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_PAN3
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_VOL4
 *   - @ref RCP_PARAM_AUDIO_MIX_CH12_PAN4
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_VOL1
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_PAN1
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_VOL2
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_PAN2
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_VOL3
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_PAN3
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_VOL4
 *   - @ref RCP_PARAM_AUDIO_MIX_CH34_PAN4
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_VOL1
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_PAN1
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_VOL2
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_PAN2
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_VOL3
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_PAN3
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_VOL4
 *   - @ref RCP_PARAM_AUDIO_MIX_MON_PAN4
 *   - @ref RCP_PARAM_MONITOR_LCD_EVF_2_HDMI_MUX
 *   - @ref RCP_PARAM_WIFI_MODE
 *   - @ref RCP_PARAM_WIFI_AD_HOC_ENCRYPTION
 *   - @ref RCP_PARAM_WIFI_AD_HOC_PASSPHRASE
 *   - @ref RCP_PARAM_WIFI_AD_HOC_SSID
 *   - @ref RCP_PARAM_WIFI_CHANNEL
 *   - @ref RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION
 *   - @ref RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE
 *   - @ref RCP_PARAM_WIFI_INFRASTRUCTURE_SSID
 *   - @ref RCP_PARAM_WIFI_SIGNAL
 *   - @ref RCP_PARAM_WIFI_CONNECT
 *   - @ref RCP_PARAM_WIFI_SCAN
 *   - @ref RCP_PARAM_WIFI_SCAN_RESULTS
 *   - @ref RCP_PARAM_WIFI_IP_ADDRESS
 *   - @ref RCP_PARAM_MODULE_CAPABILITIES
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET
 *   - @ref RCP_PARAM_POWER_OUT_PRO_IO_AUX_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET
 *   - @ref RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_BAT_AUX_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_BAT_AUX_CURRENT
 *   - @ref RCP_PARAM_POWER_OUT_BAT_AUX_RESET
 *   - @ref RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE
 *   - @ref RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS
 *   - @ref RCP_PARAM_POWER_OUT_JETPACK_USB_RESET
 *   - @ref RCP_PARAM_POWER_SAVE_STATE
 *   - @ref RCP_PARAM_QUALITY
 *   - @ref RCP_PARAM_CUSTOM_SENSOR_FRAME_RATE
 *   - @ref RCP_PARAM_MASTER_SENSOR_FRAME_RATE
 *   - @ref RCP_PARAM_CUSTOM_RECORD_FORMAT
 *   - @ref RCP_PARAM_MASTER_RECORD_FORMAT
 *   - @ref RCP_PARAM_CUSTOM_SHUTTER_ANGLE
 *   - @ref RCP_PARAM_MASTER_SHUTTER_ANGLE
 *   - @ref RCP_PARAM_CUSTOM_INTEGRATION_TIME
 *   - @ref RCP_PARAM_MASTER_INTEGRATION_TIME
 *   - @ref RCP_PARAM_CUSTOM_ISO
 *   - @ref RCP_PARAM_MASTER_ISO
 *   - @ref RCP_PARAM_CUSTOM_REDCODE
 *   - @ref RCP_PARAM_MASTER_REDCODE
 *   - @ref RCP_PARAM_CUSTOM_COLOR_TEMPERATURE
 *   - @ref RCP_PARAM_MASTER_COLOR_TEMPERATURE
 *   - @ref RCP_PARAM_USE_CUSTOM_FORMAT
 *   - @ref RCP_PARAM_USE_CUSTOM_FRAME_RATE
 *   - @ref RCP_PARAM_USE_CUSTOM_SHUTTER_ANGLE
 *   - @ref RCP_PARAM_USE_CUSTOM_INTEGRATION_TIME
 *   - @ref RCP_PARAM_USE_CUSTOM_ISO
 *   - @ref RCP_PARAM_USE_CUSTOM_REDCODE
 *   - @ref RCP_PARAM_USE_CUSTOM_COLOR_TEMPERATURE
 *   - @ref RCP_PARAM_MONITOR_FEED_LCD
 *   - @ref RCP_PARAM_MONITOR_FEED_HDMI
 *   - @ref RCP_PARAM_MONITOR_FEED_HDSDI
 *   - @ref RCP_PARAM_MONITOR_FEED_EVF
 *   - @ref RCP_PARAM_MONITOR_FEED_REAR_LCD
 *   - @ref RCP_PARAM_MONITOR_FEED_REAR_HDSDI1
 *   - @ref RCP_PARAM_MONITOR_FEED_REAR_HDSDI2
 *   - @ref RCP_PARAM_MONITOR_FEED_REAR_EVF
 *   - @ref RCP_PARAM_VIDEO_SOURCE
 *   - @ref RCP_PARAM_LUT_FEED_1
 *   - @ref RCP_PARAM_FLIP_MIRROR_FEED_0
 *   - @ref RCP_PARAM_FLIP_MIRROR_FEED_1
 *   - @ref RCP_PARAM_SSD_TALLY_LIGHT
 *   - @ref RCP_PARAM_OVERDRIVE_FRAME_RATE
 *   - @ref RCP_PARAM_PRE_RECORD
 *   - @ref RCP_PARAM_CALIBRATION_ENTRY
 *   - @ref RCP_PARAM_RECORD_VIDEO_CODEC_FEED
 *   - @ref RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION
 *   - @ref RCP_PARAM_RECORD_REDCODE_RAW_STATE
 *   - @ref RCP_PARAM_RECORD_QUICKTIME_STATE
 *   - @ref RCP_PARAM_SENSOR_SCAN_DIRECTION
 *
 * @section VERSION_6_10_28 Version 6.10.28
 *   - Minor bug fixes
 *   - Fix numerous parameter dependencies
 *
 * @section VERSION_6_10_25 Version 6.10.25
 * - Added status for menu nodes:
 *   - @ref rcp_menu_node_status_is_supported
 *   - @ref rcp_menu_get_node_status
 * - Added parameters:
 *   - @ref RCP_PARAM_CAMERA_LUT_LIST
 *   - @ref RCP_PARAM_CAMERA_LUT_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_LUT_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_LUT_DELETE
 *   - @ref RCP_PARAM_MEDIA_LUT_LIST
 *   - @ref RCP_PARAM_MEDIA_LUT_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_LUT_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_LUT_CH_0
 *   - @ref RCP_PARAM_LUT_CH_1
 *   - @ref RCP_PARAM_LUT_CH_2
 *   - @ref RCP_PARAM_LUT_CH_3
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF
 *   - @ref RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF
 *   - @ref RCP_PARAM_AUDIO_CH12_OUTPUT_NAME
 *   - @ref RCP_PARAM_AUDIO_CH34_OUTPUT_NAME
 *   - @ref RCP_PARAM_AUDIO_CH56_OUTPUT_NAME
 *   - @ref RCP_PARAM_AE_EXPOSURE_PRIORITY
 *   - @ref RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE
 *   - @ref RCP_PARAM_REMOTE_CONTROL_PANEL_ADDRESS
 *   - @ref RCP_PARAM_REMOTE_CONTROL_PANEL_STATUS
 *   - @ref RCP_PARAM_TETHERED_SERVER_ADDRESS
 *   - @ref RCP_PARAM_TETHERED_SERVER_STATE
 *   - @ref RCP_PARAM_OUTPUT_SHARPNESS
 *   - @ref RCP_PARAM_SLATE_SHOT
 *   - @ref RCP_PARAM_CALIBRATION_STATUS_TEMPERATURE
 *   - @ref RCP_PARAM_CALIBRATION_STATUS_EXPOSURE
 *   - @ref RCP_PARAM_WIFI_STATE
 *   - @ref RCP_PARAM_TIMECODE_LTC_OUT_ENABLE
 *   - @ref RCP_PARAM_FOCUS_STATE
 *   - @ref RCP_PARAM_IRIS_STATE
 *   - @ref RCP_PARAM_ZOOM_STATE
 *   - @ref RCP_PARAM_REDMOTE_STATE
 *   - @ref RCP_PARAM_CAMERA_CAPTURE_MODE
 *   - @ref RCP_PARAM_PRIMARY_STORAGE
 *   - @ref RCP_PARAM_USER_MATRIX_RR
 *   - @ref RCP_PARAM_USER_MATRIX_RG
 *   - @ref RCP_PARAM_USER_MATRIX_RB
 *   - @ref RCP_PARAM_USER_MATRIX_GR
 *   - @ref RCP_PARAM_USER_MATRIX_GG
 *   - @ref RCP_PARAM_USER_MATRIX_GB
 *   - @ref RCP_PARAM_USER_MATRIX_BR
 *   - @ref RCP_PARAM_USER_MATRIX_BG
 *   - @ref RCP_PARAM_USER_MATRIX_BB
 *   - @ref RCP_PARAM_FALSE_COLOR_MODE_STATE
 *   - @ref RCP_PARAM_RIG_STATE_DETAILED
 *   - @ref RCP_PARAM_GIGE_STATE_DETAILED
 *   - @ref RCP_PARAM_SYNC_STATE_DETAILED
 *   - @ref RCP_PARAM_GENLOCK_STATE_DETAILED
 *   - @ref RCP_PARAM_TIMECODE_STATE_DETAILED
 *   - @ref RCP_PARAM_WIFI_STATE_DETAILED
 *   - @ref RCP_PARAM_MEDIA_MODEL_NUMBER
 *   - @ref RCP_PARAM_MEDIA_ACTIVE_MEDIA
 *   - @ref RCP_PARAM_SLATE_AUTO_HEAD_FRAMES
 *   - @ref RCP_PARAM_SLATE_AUTO_TAIL_FRAMES
 *   - @ref RCP_PARAM_GIO_SCOPE_PRIMARY_COLORS
 *   - @ref RCP_PARAM_GIO_SCOPE_SECONDARY_COLORS
 *   - @ref RCP_PARAM_GIO_SCOPE_ZONES
 *   - @ref RCP_PARAM_UI_GESTURE_PINCH_MAGNIFY
 *   - @ref RCP_PARAM_UI_GESTURE_DOUBLE_TAP_RIGHT_REC
 *   - @ref RCP_PARAM_UI_GESTURE_DOUBLE_TAP_LEFT_AF
 *   - @ref RCP_PARAM_UI_LOCK_TOUCHSCREEN
 *   - @ref RCP_PARAM_UI_SMALL_DIALOGS_ON_9_INCH
 *   - @ref RCP_PARAM_PLAYBACK_CLIP_DATE
 *   - @ref RCP_PARAM_PLAYBACK_CLIP_TIME
 *   - @ref RCP_PARAM_PLAYBACK_CLIP_DATE_TIME
 *   - @ref RCP_PARAM_PLAYBACK_METADATA_FOCAL_LENGTH
 *   - @ref RCP_PARAM_PLAYBACK_METADATA_ISO
 *   - @ref RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE
 *   - @ref RCP_PARAM_PLAYBACK_METADATA_TINT
 *   - @ref RCP_PARAM_CAMERA_FIRMWARE_SVN_REVISION
 *   - @ref RCP_PARAM_CAMERA_RUNTIME
 *   - @ref RCP_PARAM_RED_CURVE_SHADOW_X
 *   - @ref RCP_PARAM_RED_CURVE_SHADOW_Y
 *   - @ref RCP_PARAM_RED_CURVE_DARK_X
 *   - @ref RCP_PARAM_RED_CURVE_DARK_Y
 *   - @ref RCP_PARAM_RED_CURVE_MIDTONE_X
 *   - @ref RCP_PARAM_RED_CURVE_MIDTONE_Y
 *   - @ref RCP_PARAM_RED_CURVE_LIGHT_X
 *   - @ref RCP_PARAM_RED_CURVE_LIGHT_Y
 *   - @ref RCP_PARAM_RED_CURVE_HIGHLIGHT_X
 *   - @ref RCP_PARAM_RED_CURVE_HIGHLIGHT_Y
 *   - @ref RCP_PARAM_GREEN_CURVE_SHADOW_X
 *   - @ref RCP_PARAM_GREEN_CURVE_SHADOW_Y
 *   - @ref RCP_PARAM_GREEN_CURVE_DARK_X
 *   - @ref RCP_PARAM_GREEN_CURVE_DARK_Y
 *   - @ref RCP_PARAM_GREEN_CURVE_MIDTONE_X
 *   - @ref RCP_PARAM_GREEN_CURVE_MIDTONE_Y
 *   - @ref RCP_PARAM_GREEN_CURVE_LIGHT_X
 *   - @ref RCP_PARAM_GREEN_CURVE_LIGHT_Y
 *   - @ref RCP_PARAM_GREEN_CURVE_HIGHLIGHT_X
 *   - @ref RCP_PARAM_GREEN_CURVE_HIGHLIGHT_Y
 *   - @ref RCP_PARAM_BLUE_CURVE_SHADOW_X
 *   - @ref RCP_PARAM_BLUE_CURVE_SHADOW_Y
 *   - @ref RCP_PARAM_BLUE_CURVE_DARK_X
 *   - @ref RCP_PARAM_BLUE_CURVE_DARK_Y
 *   - @ref RCP_PARAM_BLUE_CURVE_MIDTONE_X
 *   - @ref RCP_PARAM_BLUE_CURVE_MIDTONE_Y
 *   - @ref RCP_PARAM_BLUE_CURVE_LIGHT_X
 *   - @ref RCP_PARAM_BLUE_CURVE_LIGHT_Y
 *   - @ref RCP_PARAM_BLUE_CURVE_HIGHLIGHT_X
 *   - @ref RCP_PARAM_BLUE_CURVE_HIGHLIGHT_Y
 *   - @ref RCP_PARAM_LUMA_CURVE_SHADOW_X
 *   - @ref RCP_PARAM_LUMA_CURVE_SHADOW_Y
 *   - @ref RCP_PARAM_LUMA_CURVE_DARK_X
 *   - @ref RCP_PARAM_LUMA_CURVE_DARK_Y
 *   - @ref RCP_PARAM_LUMA_CURVE_MIDTONE_X
 *   - @ref RCP_PARAM_LUMA_CURVE_MIDTONE_Y
 *   - @ref RCP_PARAM_LUMA_CURVE_LIGHT_X
 *   - @ref RCP_PARAM_LUMA_CURVE_LIGHT_Y
 *   - @ref RCP_PARAM_LUMA_CURVE_HIGHLIGHT_X
 *   - @ref RCP_PARAM_LUMA_CURVE_HIGHLIGHT_Y
 *   - @ref RCP_PARAM_MEDIA_IS_ATTACHED
 *   - @ref RCP_PARAM_MEDIA_SERIAL_NUMBER
 *   - @ref RCP_PARAM_MEDIA_FIRMWARE_VERSION
 *   - @ref RCP_PARAM_MEDIA_SIZE
 *   - @ref RCP_PARAM_MEDIA_SIZE_AVIALABLE
 *   - @ref RCP_PARAM_OLPF_TYPE
 *   - @ref RCP_PARAM_MEDIA_DOWNLOAD_FIRMWARE
 *   - @ref RCP_PARAM_RESET_FACTORY_DEFAULTS
 *   - @ref RCP_PARAM_REDISCOVER_HARDWARE
 *   - @ref RCP_PARAM_RAMP_A_FPS
 *   - @ref RCP_PARAM_RAMP_A_DURATION
 *   - @ref RCP_PARAM_RAMP_B_FPS
 *   - @ref RCP_PARAM_RAMP_B_DURATION
 *   - @ref RCP_PARAM_RAMP_C_FPS
 *   - @ref RCP_PARAM_RAMP_C_DURATION
 *   - @ref RCP_PARAM_RAMP_D_FPS
 *   - @ref RCP_PARAM_RAMP_D_DURATION
 *   - @ref RCP_PARAM_RAMP_RESET_DURATION
 *   - @ref RCP_PARAM_CAMERA_PRESET_LIST
 *   - @ref RCP_PARAM_CAMERA_PRESET_APPLY
 *   - @ref RCP_PARAM_CAMERA_PRESET_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_PRESET_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_PRESET_UPDATE
 *   - @ref RCP_PARAM_CAMERA_PRESET_DELETE
 *   - @ref RCP_PARAM_MEDIA_PRESET_LIST
 *   - @ref RCP_PARAM_MEDIA_PRESET_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_PRESET_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_CAMERA_LOOK_LIST
 *   - @ref RCP_PARAM_CAMERA_LOOK_APPLY
 *   - @ref RCP_PARAM_CAMERA_LOOK_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_LOOK_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_LOOK_DELETE
 *   - @ref RCP_PARAM_MEDIA_LOOK_LIST
 *   - @ref RCP_PARAM_MEDIA_LOOK_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_LOOK_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_UPGRADE_CAMERA_FIRMWARE
 *   - @ref RCP_PARAM_UPGRADE_REDMOTE_FIRMWARE
 *   - @ref RCP_PARAM_AF_RACK_SPEED
 *   - @ref RCP_PARAM_AF_RACK_NUMBER_OF_POINTS
 *   - @ref RCP_PARAM_AF_RACK_TO_POINT
 *   - @ref RCP_PARAM_CAMERA_OVERLAY_LIST
 *   - @ref RCP_PARAM_CAMERA_OVERLAY_DELETE
 *   - @ref RCP_PARAM_CAMERA_OVERLAY_EXPORT_TO_MEDIA
 *   - @ref RCP_PARAM_CAMERA_OVERLAY_EXPORT_ALL_TO_MEDIA
 *   - @ref RCP_PARAM_MEDIA_OVERLAY_LIST
 *   - @ref RCP_PARAM_MEDIA_OVERLAY_IMPORT_TO_CAMERA
 *   - @ref RCP_PARAM_MEDIA_OVERLAY_IMPORT_ALL_TO_CAMERA
 *   - @ref RCP_PARAM_CURRENT_CALIBRATION_TEMPERATURE
 *   - @ref RCP_PARAM_CURRENT_CALIBRATION_INTEGRATION_TIME
 *   - @ref RCP_PARAM_REDMOTE_WIRELESS_ENABLE
 *   - @ref RCP_PARAM_REDMOTE_WIRELESS_CHANNEL
 *   - @ref RCP_PARAM_REDMOTE_DISCOVERED_LIST
 *   - @ref RCP_PARAM_REDMOTE_PAIRED_LIST
 *   - @ref RCP_PARAM_REDMOTE_SCAN
 *   - @ref RCP_PARAM_REDMOTE_PAIR
 *   - @ref RCP_PARAM_REDMOTE_UNPAIR
 *   - @ref RCP_PARAM_REDMOTE_CAMERA_MAC
 *   - @ref RCP_PARAM_REDMOTE_ATTACHED_MAC
 *   - @ref RCP_PARAM_AUTO_PRESET_STARTUP
 *   - @ref RCP_PARAM_AUTO_PRESET_MOTION
 *   - @ref RCP_PARAM_AUTO_PRESET_MOTION_AUTO_UPDATE
 *   - @ref RCP_PARAM_AUTO_PRESET_STILLS
 *   - @ref RCP_PARAM_AUTO_PRESET_STILLS_AUTO_UPDATE
 *   - @ref RCP_PARAM_AUTO_PRESET_PLAYBACK
 *   - @ref RCP_PARAM_AUTO_PRESET_PLAYBACK_AUTO_UPDATE
 *   - @ref RCP_PARAM_TETHERING_SUPPORTED
 *   - @ref RCP_PARAM_TETHERING_SUPPORTED_ON_THIS_INTERFACE
 *   - @ref RCP_PARAM_TETHERED_SERVER_SPACE_TOTAL
 *   - @ref RCP_PARAM_TETHERED_SERVER_SPACE_REMAINING
 *   - @ref RCP_PARAM_TETHERED_SERVER_REEL_NO
 *   - @ref RCP_PARAM_TETHERED_SERVER_CLIP_NO
 *   - @ref RCP_PARAM_GENLOCK_OFFSET_HDSDI
 *   - @ref RCP_PARAM_GENLOCK_OFFSET_REDCAST
 *   - @ref RCP_PARAM_AF_RACK_POINT_SELECT
 *   - @ref RCP_PARAM_AF_WINDOW_POS_X
 *   - @ref RCP_PARAM_AF_WINDOW_POS_Y
 *   - @ref RCP_PARAM_AF_WINDOW_POS_MOVE_COMPLETE
 * - Added @ref RECORD_STATE_ENCODING
 * - Added dependencies between audio CH1/2 source CH3/4 source
 * - Added dependencies between audio CH1/2/3/4 source and its mode
 * - Added dependency between RCP_PARAM_FOCUS_CONTROL and RCP_PARAM_AF_MODE
 * - Added dependency between RCP_PARAM_CALIBRATION_STATUS and RCP_PARAM_CALIBRATION_STATUS_TEMPERATURE
 * - Added dependency between RCP_PARAM_CALIBRATION_STATUS and RCP_PARAM_CALIBRATION_STATUS_EXPOSURE
 * - Added dependency between RCP_PARAM_PROJECT_FRAME_RATE and RCP_PARAM_AUDIO_VU_DATA
 * - Added dependency between RCP_PARAM_RECORD_MODE and RCP_PARAM_AUDIO_VU_DATA
 * - Added dependency between RCP_PARAM_VARISPEED_MODE and RCP_PARAM_AUDIO_VU_DATA
 * - Added dependency between RCP_PARAM_AUDIO_CH12_STATE and RCP_PARAM_AUDIO_VU_DATA
 * - Added dependency between RCP_PARAM_AUDIO_CH34_STATE and RCP_PARAM_AUDIO_VU_DATA
 *
 * - Added more audio information to @ref rcp_cur_audio_vu_cb_data_t
 * - Modified _rcp_process_audio_vu_packet to enable dependencies with other parameters
 *
 * - Added abbreviated display strings for parameters:
 *   - @ref RCP_PARAM_HDR_MODE
 *   - @ref RCP_PARAM_TIMECODE_STATE
 *   - @ref RCP_PARAM_MAGNIFY_STATE
 *   - @ref RCP_PARAM_FALSE_COLOR_MODE
 *   - @ref RCP_PARAM_GIGE_STATE
 *   - @ref RCP_PARAM_RIG_STATE
 *   - @ref RCP_PARAM_SYNC_STATE
 *   - @ref RCP_PARAM_GENLOCK_STATE
 *
 * - Added functions to set a parameter's value with a relative offset
 *  from current value (or index in list):
 *   - @ref rcp_set_int_relative
 *   - @ref rcp_set_uint_relative
 *   - @ref rcp_set_list_relative
 *
 * - Added the following flags:
 *   - @ref rcp_param_properties_t.has_set_int_relative
 *   - @ref rcp_param_properties_t.has_set_uint_relative
 *   - @ref rcp_param_properties_t.has_set_list_relative
 *
 * - The following parameters are considered deprecated (and may be
 *  removed in future released):
 *   - @ref RCP_PARAM_LIST_SELECT_ISO (use @ref rcp_set_list_relative with
 *    @ref RCP_PARAM_ISO instead)
 *   - @ref  RCP_PARAM_LIST_SELECT_SHUTTER (use @ref rcp_set_list_relative with
 *    @ref RCP_PARAM_EXPOSURE_DISPLAY instead)
 *
 * - Added new error @ref RCP_ERROR_INTERNAL, see @ref rcp_error_t
 *
 * @section VERSION_6_0_45 Version 6.0.45
 * - Modified RCP_PARAM_FALSE_COLOR_MODE so that update_list_only_on_close flag is now false
 * - Fixed status of timecode settings so they are disabled during record
 * - Fixed bug that would invalidate a cached list if it was empty
 *
 * @section VERSION_6_0_36 Version 6.0.36
 *
 * - Added dependencies between audio CH1/2 source CH3/4 source
 * - Added dependencies between audio CH1/2/3/4 source and its mode
 * - Fixed histogram label when ACES Proxy is enabled.
 * - Fixed status of @ref RCP_PARAM_RECORD_HDR_MODE and @ref
 * RCP_PARAM_HDR_FACTOR so they are disabled while in record.
 * - Fixed name of RCP_PARAM_RTC_DATE_TIME
 *
 * @section VERSION_6_0_29 Version 6.0.29
 *
 * Version 6.0.x of the API is a major update to the API.  It provides
 * many more parameters that can be controlled as well as major new
 * features such as parameter status, notification support, and menu
 * tree support.
 *
 * Parameter status should be used to disable controls dynamically
 * based on other camera settings.  The application does not need to
 * know the logic of when a parameter should be disabled as the API
 * will push the status to the application when appropriate.
 *
 * Notifications can now be displayed on the application and provide
 * feedback to the camera.  Note: only a subset of all notifications
 * that are generated by the camera are pushed to external controllers.
 *
 * Menu tree support allows a generic way for the application to show
 * the menu tree of the connected camera.  It works by providing a list
 * of children under a specified node (starting at a ROOT node).  Each
 * entry in the list provides the information required to show the
 * final "leaf" node such as the parameter ID and leaf type (list, text entry,
 * etc).
 *
 * All Changes:
 * - Refactored source code into multiple source files
 * - Added rcp_api_config.h to allow customization of API
 * - Added over 230 new parameters (see @ref rcp_param_t for details)
 * - Added support for Notifications
 *   - @ref rcp_notification_get
 *   - @ref rcp_notification_timeout
 *   - @ref rcp_notification_response
 * - Added support for Menu Tree
 *   - @ref rcp_menu_is_supported
 *   - @ref rcp_menu_get_children
 * - Added connection statistics (see @ref rcp_camera_connection_stats)
 * - Added ability to get the status of any parameter (see @ref
 * rcp_get_status and @ref rcp_cur_status_cb_data_t)
 * - Added ability to set list on allowed parameters (see @ref rcp_set_list)
 * - Added parameter properties (returned from @ref
 * rcp_get_is_supported)
 * - Added edit info to current data callbacks.  This provides
 * information required to allow the user to manually enter values for
 * parameters (like min value, max value, divider, etc.)
 * - Added the following fields to the current list callback:
 *   - send_int
 *   - send_uint
 *   - send_str
 *   - update_list_only_on_close
 * - Added @ref rcp_cam_info_t.rcp_interface
 * - Moved @ref rcp_discovery_cam_info_list_t.ip_address field from @ref rcp_cam_info_t
 * - Renamed rcp_cam_info_list_t to @ref rcp_discovery_cam_info_list_t
 * - Added new error code @ref RCP_ERROR_NOT_SUPPORTED
 * - Added new parameter status color @ref RCP_PARAM_DISPLAY_STATUS_WARNING2
 * - Added new callbacks per connection:
 *   - cur_status_cb: changes to status of a parameter (see @ref  rcp_cur_status_cb_t)
 *   - notification_cb: notifications from camera (see @ref rcp_notification_cb_t)
 *   - cur_audio_vu_cb: data to display audio VU meters (see @ref rcp_cur_audio_vu_cb_t)
 *   - cur_menu_cb: data to display menu tree (see @ref rcp_cur_menu_cb_t)
 * - Deprecated @ref rcp_get_update_list_only_on_close
 *
 * Changes that break backwards compatibility with 5.1.x:
 * - UDP discovery process:
 *   - the client must provide the IP address to the API in a new
 *   argument of @ref rcp_discovery_process_data
 *   - the struct rcp_cam_info_list_t has been renamed to @ref rcp_discovery_cam_info_list_t
 *   - the ip_address field of @ref rcp_cam_info_t has been moved to @ref rcp_discovery_cam_info_list_t
 * - New callbacks required in @ref rcp_camera_connection_info_t (set
 * to NULL if they won't be used)
 * - @ref rcp_get_is_supported has a new argument that returns the
 * properties of the provided parameter (pass in NULL if these
 * properties are not required).
 *
 * @section VERSION_5_1_5 Version 5.1.5
 * - Added parameters:
 *   - @ref RCP_PARAM_HAND_CONTROLLER_FOCUS_POS
 *   - @ref RCP_PARAM_HAND_CONTROLLER_IRIS_POS
 *   - @ref RCP_PARAM_HAND_CONTROLLER_ZOOM_POS
 *   - @ref RCP_PARAM_HAND_CONTROLLER_REINIT
 *
 * @section VERSION_5_0_8 Version 5.0.8
 * - Initial Release
 */

#ifndef RCP_API_H
#define RCP_API_H

#include <stdlib.h>
/* #include "types/rcp_types_public.h" */
/* #include "clist/c_list.h" */
/* #include "keys/keydefinition.h" */

#ifdef __cplusplus
extern "C"
{
#endif

#define RCP_DISCOVERY_STEP_SLEEP_MS 300
#define RCP_DISCOVERY_STEP_LOOP_COUNT 5

typedef struct rcp_camera_connection_t rcp_camera_connection_t;

typedef enum
{
    RCP_PARAM_HISTOGRAM,                              /**< DSHIST: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_VU_DATA,                          /**< AUDIOVU: added in Parameter Set Version 6.0 */
    RCP_PARAM_CAMERA_PITCH,                           /**< MPITCH: added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_ROLL,                            /**< MROLL: added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_VAL,                              /**< PWRBATL: for display use @ref RCP_PARAM_POWER_DISPLAY_VAL instead, added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_TIME_REMAINING,                   /**< BATTRTM: added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_SPEED_TOP,                          /**< FANPCTT: added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_SPEED_FRONT,                        /**< FANPCTF: added in Parameter Set Version 5.0 */
    RCP_PARAM_CORE_TEMP,                              /**< CURRTEMP: added in Parameter Set Version 5.0 */
    RCP_PARAM_SENSOR_TEMP,                            /**< CURSENST: added in Parameter Set Version 5.0 */
    RCP_PARAM_TIMECODE,                               /**< POSTTC: added in Parameter Set Version 5.0 */
    RCP_PARAM_ISO,                                    /**< ISO: added in Parameter Set Version 5.0 */
    RCP_PARAM_REDCODE,                                /**< REDCODE: added in Parameter Set Version 5.0 */
    RCP_PARAM_SHUTDOWN,                               /**< SHUTDOWN: added in Parameter Set Version 5.0 */
    RCP_PARAM_MM_ISO_PULL,                            /**< MMMISOND: see @ref motion_mount_iso_pull_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_ND_VAL,                                 /**< MMNDV: added in Parameter Set Version 5.0 */
    RCP_PARAM_ND_DISPLAY_VAL,                         /**< Composite of: @ref RCP_PARAM_ND_VAL, @ref RCP_PARAM_MM_MODE, and @ref RCP_PARAM_MM_ND_MODE, added in Parameter Set Version 5.0 */
    RCP_PARAM_SENSOR_FRAME_RATE,                      /**< SENSFPS: added in Parameter Set Version 5.0 */
    RCP_PARAM_PROJECT_FRAME_RATE,                     /**< PROJFPS: added in Parameter Set Version 5.0 */
    RCP_PARAM_APERTURE,                               /**< APRTR: added in Parameter Set Version 5.0 */
    RCP_PARAM_EXPOSURE_INTEGRATION_TIME,              /**< SHTIME: added in Parameter Set Version 5.0 */
    RCP_PARAM_COLOR_TEMPERATURE,                      /**< COLTMP: added in Parameter Set Version 5.0 */
    RCP_PARAM_RCP_VERSION,                            /**< RCPVER: added in Parameter Set Version 5.0 */
    RCP_PARAM_RCP_PARAMETER_SET_VERSION,              /**< RCPPSVER: added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_FORMAT,                          /**< FORMAT2: added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_FORMAT_NAME,                     /**< FORMATST: added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_STATE_BASE,                      /**< RECORD: see @ref set_record_state_t and @ref record_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_STATE,                           /**< Composite of: @ref RCP_PARAM_RECORD_STATE_BASE, @ref RCP_PARAM_RECORD_MODE, and @ref RCP_PARAM_TETHERED_SERVER_STATE, added in Parameter Set Version 5.0 */
    RCP_PARAM_SATURATION,                             /**< SATURAT: added in Parameter Set Version 5.0 */
    RCP_PARAM_CDL_ENABLE,                             /**< CDLEN: added in Parameter Set Version 6.62 */
    RCP_PARAM_CDL_SATURATION,                         /**< CSATURAT: added in Parameter Set Version 6.50 */
    RCP_PARAM_CONTRAST,                               /**< CONTRST: added in Parameter Set Version 5.0 */
    RCP_PARAM_BRIGHTNESS,                             /**< BRIGHT: added in Parameter Set Version 5.0 */
    RCP_PARAM_EXPOSURE_COMPENSATION,                  /**< EXPCOMP: added in Parameter Set Version 5.0 */
    RCP_PARAM_RED_GAIN,                               /**< REDG: added in Parameter Set Version 5.0 */
    RCP_PARAM_GREEN_GAIN,                             /**< GREENG: added in Parameter Set Version 5.0 */
    RCP_PARAM_BLUE_GAIN,                              /**< BLUEG: added in Parameter Set Version 5.0 */
    RCP_PARAM_FLUT,                                   /**< FLUT: added in Parameter Set Version 5.0 */
    RCP_PARAM_EXPOSURE_ADJUST,                        /**< FLUT: added in Parameter Set Version 5.0 */
    RCP_PARAM_SHADOW,                                 /**< SHADOW: added in Parameter Set Version 5.0 */
    RCP_PARAM_FOCUS_DIST,                             /**< Composite of: 'FOCUS', @ref RCP_PARAM_FOCUS_DIST_NEAR, @ref RCP_PARAM_FOCUS_DIST_FAR, and @ref RCP_PARAM_FOCUS_DIST_DISPLAY_MODE, added in Parameter Set Version 5.0 */
    RCP_PARAM_FOCUS_DIST_NEAR,                        /**< FOCUSN: added in Parameter Set Version 5.0 */
    RCP_PARAM_FOCUS_DIST_FAR,                         /**< FOCUSF: added in Parameter Set Version 5.0 */
    RCP_PARAM_FOCUS_DIST_DISPLAY_MODE,                /**< LENSFDMD: see @ref focus_distance_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_FRAME_PROCESSING_MODE,                  /**< FRPRMODE: see @ref frame_processing_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_FRAME_PROCESSING_NUM,                   /**< FRPRNUM: added in Parameter Set Version 5.0 */
    RCP_PARAM_EXPOSURE_ANGLE,                         /**< SHANGLE: added in Parameter Set Version 5.0 */
    RCP_PARAM_AF_MODE,                                /**< AFMODE: see @ref af_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_MIN_REDCODE,                            /**< MINRC: added in Parameter Set Version 5.0 */
    RCP_PARAM_MAX_REDCODE,                            /**< MAXRC: added in Parameter Set Version 5.0 */
    RCP_PARAM_MIN_EXPOSURE_INTEGRATION_TIME,          /**< MINSHT: added in Parameter Set Version 5.0 */
    RCP_PARAM_MAX_EXPOSURE_INTEGRATION_TIME,          /**< MAXSHT: added in Parameter Set Version 5.0 */
    RCP_PARAM_MIN_EXPOSURE_ANGLE,                     /**< MINSHA: added in Parameter Set Version 5.0 */
    RCP_PARAM_MAX_EXPOSURE_ANGLE,                     /**< MAXSHA: added in Parameter Set Version 5.0 */
    RCP_PARAM_CLIP_NAME,                              /**< CLIPNAME: added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_ID,                              /**< CAMID: added in Parameter Set Version 5.0 */
    RCP_PARAM_GAMMA_SPACE,                            /**< GSPACE: see @ref gammaspace_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_COLOR_SPACE,                            /**< CSPACE: see @ref colorspace_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RAW_MODE,                               /**< RAWMODE: see @ref raw_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_HDR_MODE,                        /**< HDRMODE: see @ref hdr_mode_t,  added in Parameter Set Version 5.0 */
    RCP_PARAM_HDR_MONITOR_TRACK,                      /**< HDRXMONX: see @ref hdr_track_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_HDR_FACTOR,                             /**< HDRFACT: added in Parameter Set Version 5.0 */
    RCP_PARAM_FALSE_COLOR_MODE,                       /**< FALSEC: see @ref false_color_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_FALSE_COLOR_MODE_STATE,                 /**< FALSEC: see @ref false_color_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_TINT,                                   /**< TINT: added in Parameter Set Version 5.0 */
    RCP_PARAM_MAGNIFY_STATE,                          /**< MAGNIFY: see @ref magnify_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RIG_STATE,                              /**< RIGSTATE: see @ref metadata_status_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RIG_STATE_DETAILED,                     /**< RIGSTATE: see @ref metadata_status_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_GIGE_STATE,                             /**< NWSTAT: see @ref gige_status_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_GIGE_STATE_DETAILED,                    /**< NWSTAT: see @ref gige_status_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_SYNC_STATE,                             /**< SYNC: see @ref sync_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_SYNC_STATE_DETAILED,                    /**< SYNC: see @ref sync_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_GENLOCK_STATE,                          /**< GENLOC: see @ref genlock_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_GENLOCK_STATE_DETAILED,                 /**< GENLOC: see @ref genlock_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_TIMECODE_STATE,                         /**< TCJAM: see @ref tc_sync_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_TIMECODE_STATE_DETAILED,                /**< TCJAM: see @ref tc_sync_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_MODE,                               /**< FSMODE: added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_REC_SPEED,                          /**< RECFS: added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_PREVIEW_SPEED,                      /**< PREVFS: added in Parameter Set Version 5.0 */
    RCP_PARAM_FAN_DELAY,                              /**< FPRDELAY: added in Parameter Set Version 5.0 */
    RCP_PARAM_AF_ZONE,                                /**< AFZONE: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH1_GAIN,                         /**< CH1GAIN: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH2_GAIN,                         /**< CH2GAIN: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH3_GAIN,                         /**< CH3GAIN: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH4_GAIN,                         /**< CH4GAIN: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH1_VOL,                          /**< CH1VOL: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH2_VOL,                          /**< CH2VOL: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH3_VOL,                          /**< CH3VOL: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH4_VOL,                          /**< CH4VOL: added in Parameter Set Version 5.0 */
    RCP_PARAM_R3D_DROPPED_FRAMES,                     /**< DRPFRMS: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_LCD,                       /**< LCDM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_HDMI,                      /**< HDMIM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_HDSDI,                     /**< HDSDIM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_EVF,                       /**< EVFM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_REAR_LCD,                  /**< PLCDM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               /**< PHDSDI1M: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               /**< PHDSDI2M: added in Parameter Set Version 5.0 */
    RCP_PARAM_MONITOR_MODE_REAR_EVF,                  /**< REVFM: added in Parameter Set Version 5.0 */
    RCP_PARAM_MM_MODE,                                /**< MMMODE: see @ref motion_mount_shutter_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_STATE,                         /**< PLAYBACK: see @ref set_playback_state_t and @ref playback_state_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RECORD_MODE,                            /**< RECMODE: see @ref record_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_LABEL,                            /**< PLABEL: added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_VAL,                              /**< MEDIAPCT: for display use @ref RCP_PARAM_MEDIA_DISPLAY_VAL instead, added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_LABEL,                            /**< MLABEL: for display use @ref RCP_PARAM_MEDIA_DISPLAY_LABEL instead, added in Parameter Set Version 5.0 */
    RCP_PARAM_RED_CLIP,                               /**< RCLIP: added in Parameter Set Version 5.0 */
    RCP_PARAM_GREEN_CLIP,                             /**< GCLIP: added in Parameter Set Version 5.0 */
    RCP_PARAM_BLUE_CLIP,                              /**< BCLIP: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH12_STATE,                       /**< CH12ST: added in Parameter Set Version 5.0 */
    RCP_PARAM_AUDIO_CH34_STATE,                       /**< CH34ST: added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_DISPLAY_MODE,                     /**< BATTMODE: see @ref battery_display_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_TIME_REMAINING,                   /**< MEDIAMIN: added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_DISPLAY_MODE,                     /**< MEDIAMOD: see @ref media_display_t added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,                /**< PBHDRTRC: added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_DISPLAY_VAL,                      /**< Composite of: @ref RCP_PARAM_MEDIA_VAL, @ref RCP_PARAM_MEDIA_TIME_REMAINING, @ref RCP_PARAM_MEDIA_DISPLAY_MODE, @ref RCP_PARAM_RECORD_MODE, and @ref RCP_PARAM_PRIMARY_STORAGE added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_DISPLAY_VAL,                      /**< Composite of: @ref RCP_PARAM_POWER_VAL, @ref RCP_PARAM_POWER_TIME_REMAINING, and @ref RCP_PARAM_POWER_DISPLAY_MODE, added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_DISPLAY_LABEL,                    /**< Composite of: @ref RCP_PARAM_RECORD_MODE, @ref RCP_PARAM_MEDIA_LABEL, and @ref RCP_PARAM_PRIMARY_STORAGE, added in Parameter Set Version 5.0 */
    RCP_PARAM_HDR_MODE,                               /**< Composite of: @ref RCP_PARAM_RECORD_HDR_MODE, @ref RCP_PARAM_PLAYBACK_STATE, and @ref RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS, added in Parameter Set Version 5.0 */
    RCP_PARAM_HDR_MODE_DETAILED,                      /**< Composite of: @ref RCP_PARAM_RECORD_HDR_MODE, @ref RCP_PARAM_PLAYBACK_STATE, and @ref RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS, added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_FIRMWARE_VERSION,                /**< CAMFWVER: added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_TYPE,                            /**< CAMNAME: added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_PIN,                             /**< CAMSER: added in Parameter Set Version 5.0 */
    RCP_PARAM_KEYCODE,                                /**< KEYCODE: see @ref MAKEKEYCODE, added in Parameter Set Version 5.0 */
    RCP_PARAM_LIST_SELECT_ISO,                        /**< SELISO: see @ref list_select_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_LIST_SELECT_SHUTTER,                    /**< SELSH: see @ref list_select_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_CAMERA_OPERATOR,                  /**< CAMERAOP: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_LOCATION,                         /**< CAMLOC: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_SCENE,                            /**< CAMSCENE: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_TAKE,                             /**< CAMTAKE: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_UNIT,                             /**< CAMUNIT: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_DIRECTOR,                         /**< DIRECTOR: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_DOP,                              /**< DOPNAME: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_PRODUCTION,                       /**< PRODUCTN: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_COPYRIGHT,                        /**< PROJINFO: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_CAMERA_ID,                        /**< CAMMEID: added in Parameter Set Version 5.0 */
    RCP_PARAM_SLATE_CAMERA_POS,                       /**< CAMPOS: see @ref cam_pos_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_1_ENABLE,                         /**< ZEBRA1: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_1_MODE,                           /**< ZEBRA1M: added in Parameter Set Version 6.31 */
    RCP_PARAM_ZEBRA_1_IRE_LOW,                        /**< ZEBRA1LO: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_1_IRE_HIGH,                       /**< ZEBRA1HI: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_1_STOPS_LOW,                      /**< ZEBRA1LS: added in Parameter Set Version 6.31 */
    RCP_PARAM_ZEBRA_1_STOPS_HIGH,                     /**< ZEBRA1HS: added in Parameter Set Version 6.31 */
    RCP_PARAM_ZEBRA_2_ENABLE,                         /**< ZEBRA2: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_2_MODE,                           /**< ZEBRA2M: added in Parameter Set Version 6.31 */
    RCP_PARAM_ZEBRA_2_IRE_LOW,                        /**< ZEBRA2LO: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_2_IRE_HIGH,                       /**< ZEBRA2HI: added in Parameter Set Version 5.0 */
    RCP_PARAM_ZEBRA_2_STOPS_LOW,                      /**< ZEBRA2LS: added in Parameter Set Version 6.31 */
    RCP_PARAM_ZEBRA_2_STOPS_HIGH,                     /**< ZEBRA2HS: added in Parameter Set Version 6.31 */
    RCP_PARAM_FOCAL_LENGTH,                           /**< FLENGTH: added in Parameter Set Version 5.0 */
    RCP_PARAM_APERTURE_CONTROL,                       /**< APERCTRL: added in Parameter Set Version 5.0 */
    RCP_PARAM_FOCUS_CONTROL,                          /**< FOCSCTRL: added in Parameter Set Version 5.0 */
    RCP_PARAM_SET_TIMECODE,                           /**< TCSET: added in Parameter Set Version 5.0 */
    RCP_PARAM_VARISPEED_MODE,                         /**< VRISPDMD: added in Parameter Set Version 5.0 */
    RCP_PARAM_POWER_SOURCE,                           /**< PWRSRC: see @ref power_source_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_TEST_PATTERN,                           /**< TPATTERN: see @ref monitor_test_pattern_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_MIN_SENSOR_FRAME_RATE,                  /**< MINFPS: added in Parameter Set Version 5.0 */
    RCP_PARAM_MAX_SENSOR_FRAME_RATE,                  /**< MAXFPS: added in Parameter Set Version 5.0 */
    RCP_PARAM_SHUTTER_DISPLAY_MODE,                   /**< SHDISP: see @ref shutter_display_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_SHUTTER_MODE,                           /**< SHMODE: see @ref shutter_mode_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_RED_CURVE,                              /**< RCURVE: added in Parameter Set Version 5.0 */
    RCP_PARAM_GREEN_CURVE,                            /**< GCURVE: added in Parameter Set Version 5.0 */
    RCP_PARAM_BLUE_CURVE,                             /**< BCURVE: added in Parameter Set Version 5.0 */
    RCP_PARAM_LUMA_CURVE,                             /**< LCURVE: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_CLIP_LENGTH,                   /**< CLIPLEN: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_CLIP_LOAD,                     /**< CLIPLOAD: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_CLIP_LOAD_REL,                 /**< CLPNUM: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_CLIP_DIR,                      /**< CLPDIR: see @ref player_direction_t, added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_IN_POINT,                      /**< CLPINPT: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_OUT_POINT,                     /**< CLPOUTPT: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_LOOP,                          /**< LOOP: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_PLAY,                          /**< PLAY: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_PAUSE,                         /**< PAUSE: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_PLAY_PAUSE,                    /**< PLAYPAUS: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_POS,                           /**< PLAYPOS: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_POS_REL,                       /**< PLAYRPOS: added in Parameter Set Version 5.0 */
    RCP_PARAM_PLAYBACK_SPEED,                         /**< PLAYSPD: added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_CLIP_COUNT,                       /**< MEDACLPC: added in Parameter Set Version 5.0 */
    RCP_PARAM_MEDIA_CLIP_EXT_INFO,                    /**< MEDAGCII: added in Parameter Set Version 5.0 */
    RCP_PARAM_KEYACTION,                              /**< KEYACT: added in Parameter Set Version 5.0 */
    RCP_PARAM_FRAME_TAG,                              /**< TAGGED: added in Parameter Set Version 5.0 */
    RCP_PARAM_CAMERA_INFO,                            /**< CAMINFO: added in Parameter Set Version 5.0 */
    RCP_PARAM_HAND_CONTROLLER_FOCUS_POS,              /**< HCFOCUS: added in Parameter Set Version 5.1 */
    RCP_PARAM_HAND_CONTROLLER_IRIS_POS,               /**< HCIRIS: added in Parameter Set Version 5.1 */
    RCP_PARAM_HAND_CONTROLLER_ZOOM_POS,               /**< HCZOOM: added in Parameter Set Version 5.1 */
    RCP_PARAM_HAND_CONTROLLER_REINIT,                 /**< HCREINIT: added in Parameter Set Version 5.1 */
    RCP_PARAM_EXPOSURE_DISPLAY,                       /**< Composite of: @ref RCP_PARAM_SHUTTER_DISPLAY_MODE, @ref RCP_PARAM_EXPOSURE_INTEGRATION_TIME, @ref RCP_PARAM_EXPOSURE_ANGLE, added in Parameter Set Version 5.0 */
    RCP_PARAM_MM_SHUTTER_COLOR,                       /**< MMSHCOLR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MM_INTEGRATION_TIME,                    /**< MMSHTIME: added in Parameter Set Version 6.0 */
    RCP_PARAM_MM_SHUTTER_ANGLE,                       /**< MMSHANGL: added in Parameter Set Version 6.0 */
    RCP_PARAM_GROUP_ID,                               /**< GROUPID: added in Parameter Set Version 6.0 */
    RCP_PARAM_CORE_TEMP_WARNING_1,                    /**< TWARN1: added in Parameter Set Version 6.0 */
    RCP_PARAM_CORE_TEMP_WARNING_2,                    /**< TWARN2: added in Parameter Set Version 6.0 */
    RCP_PARAM_CORE_TEMP_WARNING_3,                    /**< TWARN3: added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_MODE,                                /**< AEMODE: see @ref ae_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_EV_SHIFT,                            /**< AEEVSHFT: added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_METERING_MODE,                       /**< AEMETERM: see @ref ae_metering_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_SPEED,                               /**< AESPEED: see @ref ae_speed_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_SELECTION,                           /**< AESELECT: see @ref ae_selection_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AE_LOCK_APERTURE,                       /**< AELOCKAP: added in Parameter Set Version 6.0, deprecated - use RCP_PARAM_AE_EXPOSURE_PRIORITY instead */
    RCP_PARAM_AE_LOCK_EXPOSURE,                       /**< AELOCKEX: added in Parameter Set Version 6.0, deprecated - use RCP_PARAM_AE_EXPOSURE_PRIORITY instead */
    RCP_PARAM_CALIBRATION_STATUS,                     /**< CALSTAT: see @ref cal_status_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_CALIBRATION_STATUS_TEMPERATURE,         /**< Component of: @ref RCP_PARAM_CALIBRATION_STATUS, just the temperature portion, added in Parameter Set Version 6.0 */
    RCP_PARAM_CALIBRATION_STATUS_EXPOSURE,            /**< Component of: @ref RCP_PARAM_CALIBRATION_STATUS, just the exposure portion, added in Parameter Set Version 6.0 */
    RCP_PARAM_FAN_TARGET_TEMPERATURE,                 /**< FANTRGTT: added in Parameter Set Version 6.0 */
    RCP_PARAM_COLOR_TEMPERATURE_PRESET,               /**< COLTMPP: added in Parameter Set Version 6.0 */
    RCP_PARAM_SHOW_HORIZON_LINE,                      /**< HORIZON: added in Parameter Set Version 6.0 */
    RCP_PARAM_TEST_PATTERN_TONE,                      /**< TPATTONE: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_LCD,                    /**< BLCDOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_HDMI,                   /**< BHDMIOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_HDSDI,                  /**< BHDSDIOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_EVF,                    /**< BEVFOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_REAR_LCD,               /**< PLCDOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1,            /**< PHDS1OV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2,            /**< PHDS2OV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_OVERLAY_REAR_EVF,               /**< REVFOV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_RESOLUTION_HDMI,                /**< HDMIR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_RESOLUTION_HDSDI,               /**< HDSDIR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1,         /**< PHDSDI1R: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2,         /**< PHDSDI2R: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_LCD,                       /**< LCDF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_HDMI,                      /**< HDMIF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_HDSDI,                     /**< HDSDIF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_EVF,                       /**< EVFF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_REAR_LCD,                  /**< PLCDF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1,               /**< PHDSDI1F: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2,               /**< PHDSDI2F: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FREQ_REAR_EVF,                  /**< REVFF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_LCD,                      /**< BLCDTL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_HDMI,                     /**< BHDMITL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_HDSDI,                    /**< BHDSDITL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_EVF,                      /**< BEVFTL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_REAR_LCD,                 /**< PLCDTL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1,              /**< PSDI1TL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2,              /**< PSDI2TL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_TOOLS_REAR_EVF,                 /**< REVFTL: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD,             /**< BLCDFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI,            /**< BHDMIFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI,           /**< BHDSDIFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF,             /**< BEVFFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD,        /**< PLCDFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1,     /**< PSDI1FM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2,     /**< PSDI2FM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF,        /**< REVFFM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_LCD,                 /**< BLCDVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI,                /**< BHDMIVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI,               /**< BHDSDIVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_EVF,                 /**< BEVFVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD,            /**< PLCDVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1,         /**< PSDI1VF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2,         /**< PSDI2VF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF,            /**< REVFVF: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD,             /**< BLCDFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI,            /**< BHDMIFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI,           /**< BHDSDIFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF,             /**< BEVFFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD,        /**< PLCDFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1,     /**< PSDI1FO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2,     /**< PSDI2FO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF,        /**< REVFFO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_LCD,                 /**< BLCDDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_HDMI,                /**< BHDMIDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI,               /**< BHDSDIDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_EVF,                 /**< BEVFDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD,            /**< PLCDDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1,         /**< PSDI1DM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2,         /**< PSDI2DM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF,            /**< REVFDM: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_BRIGHTNESS_LCD,                 /**< BLCDBR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_BRIGHTNESS_EVF,                 /**< BEVFBR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_BRIGHTNESS_REAR_LCD,            /**< PLCDBR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_BRIGHTNESS_REAR_EVF,            /**< REVFBR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_BRIGHTNESS_SIDE_UI,             /**< FUIBR: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_ENABLE_HDSDI,                   /**< BHDSDIEN: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             /**< PHDS1EN: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             /**< PHDS2EN: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_VU_METER_SOURCE,                  /**< VUSRC: see @ref vu_meter_source_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_HISTOGRAM_TYPE,                         /**< HISTTYPE: see @ref histogram_type_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_APERTURE_LIST_MODE,                     /**< LDISPM: see @ref aperture_list_t added, in Parameter Set Version 6.0 */
    RCP_PARAM_MM_ND_MODE,                             /**< MMNDMODE: see @ref motion_mount_display_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_SHOW_RACK_DISTANCES,                    /**< SHRCKDST: see @ref focus_rack_show_distance_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_POWER_SAVE_LEVEL_1,                     /**< PSLEVEL1: added in Parameter Set Version 6.0 */
    RCP_PARAM_POWER_SAVE_LEVEL_2,                     /**< PSLEVEL2: added in Parameter Set Version 6.0 */
    RCP_PARAM_POWER_SAVE_LEVEL_3,                     /**< PSLEVEL3: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_MODE,                       /**< F0MODE: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_USER_AR_NUM,                /**< F0NUM: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_SCALE,                      /**< F0SCL: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_X_OFFSET,                   /**< F0OFFSX: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_Y_OFFSET,                   /**< F0OFFSY: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_ABS_X_OFFSET,               /**< F0ABSXOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_ABS_Y_OFFSET,               /**< F0ABSYOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_ABS_W,                      /**< F0ABSW: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_ABS_H,                      /**< F0ABSH: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_LINE_STYLE,                 /**< F0LNST: see @ref guide_line_style_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_COLOR,                      /**< F0COLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_FRAME_GUIDE_OPACITY,                    /**< F0OPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_MODE,                      /**< F1MODE: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_USER_AR_NUM,               /**< F1NUM: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_SCALE,                     /**< F1SCL: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_X_OFFSET,                  /**< F1OFFSX: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_Y_OFFSET,                  /**< F1OFFSY: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_ABS_X_OFFSET,              /**< F1ABSXOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_ABS_Y_OFFSET,              /**< F1ABSYOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_ABS_W,                     /**< F1ABSW: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_ABS_H,                     /**< F1ABSH: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_LINE_STYLE,                /**< F1LNST: see @ref guide_line_style_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_COLOR,                     /**< F1COLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_OPACITY,                   /**< F1OPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACTION_GUIDE_RELATIVE,                  /**< F1RELF0: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_MODE,                       /**< F2MODE: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_USER_AR_NUM,                /**< F2NUM: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_SCALE,                      /**< F2SCL: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_X_OFFSET,                   /**< F2OFFSX: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_Y_OFFSET,                   /**< F2OFFSY: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_ABS_X_OFFSET,               /**< F2ABSXOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_ABS_Y_OFFSET,               /**< F2ABSYOF: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_ABS_W,                      /**< F2ABSW: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_ABS_H,                      /**< F2ABSH: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_LINE_STYLE,                 /**< F2LNST: see @ref guide_line_style_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_COLOR,                      /**< F2COLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_OPACITY,                    /**< F2OPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_TITLE_GUIDE_RELATIVE,                   /**< F2RELF0: added in Parameter Set Version 6.0 */
    RCP_PARAM_CENTER_GUIDE_GUIDE,                     /**< CGGUIDE: added in Parameter Set Version 6.0 */
    RCP_PARAM_CENTER_GUIDE_MARKER_TYPE,               /**< CGMARK: added in Parameter Set Version 6.60 */
    RCP_PARAM_CENTER_GUIDE_COLOR,                     /**< CGCOLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_CENTER_GUIDE_OPACITY,                   /**< CGOPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_GRID_GUIDE_GUIDE,                       /**< GGGUIDE: added in Parameter Set Version 6.0 */
    RCP_PARAM_GRID_GUIDE_COLOR,                       /**< GGCOLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_GRID_GUIDE_OPACITY,                     /**< GGOPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_SHADING_GUIDE,                          /**< SHGUIDE: added in Parameter Set Version 6.0 */
    RCP_PARAM_SHADING_COLOR,                          /**< SHCOLOR: added in Parameter Set Version 6.0 */
    RCP_PARAM_SHADING_OPACITY,                        /**< SHOPAC: added in Parameter Set Version 6.0 */
    RCP_PARAM_ACES_PROXY,                             /**< ACES:  added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_SPLIT_CURVE,                    /**< IMGSPCRV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_LCD,                      /**< LCDCV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_HDMI,                     /**< HDMICV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_HDSDI,                    /**< HDSDICV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_EVF,                      /**< EVFCV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_REAR_LCD,                 /**< PLCDCV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1,              /**< PHDSD1CV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2,              /**< PHDSD2CV: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_CURVE_REAR_EVF,                 /**< REVFCV: added in Parameter Set Version 6.0 */
    RCP_PARAM_TIMECODE_DISPLAY_MODE,                  /**< TCDMODE: see @ref tc_display_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_TIMECODE_SOURCE,                        /**< TCSOURCE: see @ref tc_source_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_SAVE_LOG,                               /**< SAVELOG: added in Parameter Set Version 6.0 */
    RCP_PARAM_AF_SIZE,                                /**< AFSIZE: added in Parameter Set Version 6.0 */
    RCP_PARAM_AF_ENHANCED_ENABLE,                     /**< AFENHNCD: added in Parameter Set Version 6.0 */
    RCP_PARAM_AF_ENHANCED_MONITOR,                    /**< AFENHMON: added in Parameter Set Version 6.0 */
    RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE,              /**< AFENCONS: added in Parameter Set Version 6.0 */
    RCP_PARAM_BEEP_ENABLE,                            /**< BEEPEN: added in Parameter Set Version 6.0 */
    RCP_PARAM_BEEP_RECORD_START,                      /**< BEEPREC: added in Parameter Set Version 6.0 */
    RCP_PARAM_BEEP_RECORD_STOP,                       /**< BEEPSTOP: added in Parameter Set Version 6.0 */
    RCP_PARAM_BEEP_TAG_STILL_FRAME,                   /**< BEEPTAGS: added in Parameter Set Version 6.0 */
    RCP_PARAM_EVF_TALLY_LIGHT,                        /**< EVFTALLY: added in Parameter Set Version 6.0 */
    RCP_PARAM_PRE_RECORD_DURATION,                    /**< PRERECDR: added in Parameter Set Version 6.0 */
    RCP_PARAM_PRE_RECORD_ALWAYS_TRIGGER,              /**< PRERECON: added in Parameter Set Version 6.0 */
    RCP_PARAM_LGG_LIFT_RED,                           /**< RLIFT: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_OFFSET_RED,                         /**< ROFFSET: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_LIFT_GREEN,                         /**< GLIFT: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_OFFSET_GREEN,                       /**< GOFFSET: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_LIFT_BLUE,                          /**< BLIFT: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_OFFSET_BLUE,                        /**< BOFFSET: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAMMA_RED,                          /**< RGAMMA: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_POWER_RED,                          /**< RPOWER: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAMMA_GREEN,                        /**< GGAMMA: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_POWER_GREEN,                        /**< GPOWER: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAMMA_BLUE,                         /**< BGAMMA: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_POWER_BLUE,                         /**< BPOWER: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAIN_RED,                           /**< RGAIN: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_SLOPE_RED,                          /**< RSLOPE: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAIN_GREEN,                         /**< GGAIN: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_SLOPE_GREEN,                        /**< GSLOPE: added in Parameter Set Version 6.50 */
    RCP_PARAM_LGG_GAIN_BLUE,                          /**< BGAIN: added in Parameter Set Version 6.0 */
    RCP_PARAM_CDL_SLOPE_BLUE,                         /**< BSLOPE: added in Parameter Set Version 6.50 */
    RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS,            /**< GEIPADDR: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_NETMASK,               /**< GENETMSK: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_GATEWAY,               /**< GEGWADDR: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE,           /**< GEDHCP: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_C2C_ENABLE,            /**< GEC2C: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_EXT_ENABLE,            /**< GEEXT: added in Parameter Set Version 6.0 */
    RCP_PARAM_GIGABIT_ETHERNET_MAC_ADDRESS,           /**< GEMAC: added in Parameter Set Version 6.50 */
    RCP_PARAM_SERIAL_PROTOCOL,                        /**< SERPROTO: added in Parameter Set Version 6.0 */
    RCP_PARAM_SERIAL_2_PROTOCOL,                      /**< SERPROT2: added in Parameter Set Version 6.32 */
    RCP_PARAM_AUDIO_CH12_SOURCE,                      /**< CH12SRC: see @ref audio_channel_source_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH34_SOURCE,                      /**< CH34SRC: see @ref audio_channel_source_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH12_LINK_GAIN,                   /**< CH12ILNK: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH34_LINK_GAIN,                   /**< CH34ILNK: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH12_LINK_VOL,                    /**< CH12OLNK: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH34_LINK_VOL,                    /**< CH34OLNK: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_NAME,                         /**< CH1NAME: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_MODE,                         /**< CH1MODE: see @ref audio_channel_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_48V_POWER,                    /**< CH1_48V: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_48V_PRESENT,                  /**< CH1_48VP: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_LIMITER,                      /**< CH1LIMIT: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH1_LIMITER_PRESENT,              /**< CH1LIMPR: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_NAME,                         /**< CH2NAME: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_MODE,                         /**< CH2MODE: see @ref audio_channel_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_48V_POWER,                    /**< CH2_48V: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_48V_PRESENT,                  /**< CH2_48VP: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_LIMITER,                      /**< CH2LIMIT: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH2_LIMITER_PRESENT,              /**< CH2LIMPR: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_NAME,                         /**< CH3NAME: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_MODE,                         /**< CH3MODE: see @ref audio_channel_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_48V_POWER,                    /**< CH3_48V: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_48V_PRESENT,                  /**< CH3_48VP: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_LIMITER,                      /**< CH3LIMIT: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH3_LIMITER_PRESENT,              /**< CH3LIMPR: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_NAME,                         /**< CH4NAME: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_MODE,                         /**< CH4MODE: see @ref audio_channel_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_48V_POWER,                    /**< CH4_48V: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_48V_PRESENT,                  /**< CH4_48VP: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_LIMITER,                      /**< CH4LIMIT: added in Parameter Set Version 6.0 */
    RCP_PARAM_AUDIO_CH4_LIMITER_PRESENT,              /**< CH4LIMPR: added in Parameter Set Version 6.0 */
    RCP_PARAM_CLIP_NAME_STATUS,                       /**< CLIPNMST: added in Parameter Set Version 6.0 */
    RCP_PARAM_SENSOR_SYNC_MODE,                       /**< SHSYNC: see @ref sync_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_GPI_FUNCTION,                           /**< GPIN: see @ref gpi_function_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_GPO_FUNCTION,                           /**< GPOUT: see @ref gpo_function_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_GENLOCK_SOURCE,                         /**< GENSRC: see @ref genlock_source_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_AWB_MODE,                               /**< AWBMODE: see @ref awb_mode_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_LIMIT_ENABLE,                    /**< RECLIMEN: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_LIMIT_FRAMES,                    /**< RECLIMFR: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_TIMELAPSE_FRAMES,                /**< RECTLFR: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_TIMELAPSE_INTERVAL,              /**< RECTLINT: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_PRE_FRAME_COUNT,                 /**< RECPRE: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_POST_FRAME_COUNT,                /**< RECPOST: added in Parameter Set Version 6.0 */
    RCP_PARAM_RECORD_PRE_FRAME_COUNT_AVAILABLE,       /**< RECPREA: added in Parameter Set Version 6.42 */
    RCP_PARAM_RECORD_POST_FRAME_COUNT_AVAILABLE,      /**< RECPOSTA: added in Parameter Set Version 6.42 */
    RCP_PARAM_RECORD_PRE_FRAME_COUNT_ACTUAL,          /**< RECPREB: added in Parameter Set Version 6.42 */
    RCP_PARAM_RECORD_POST_FRAME_COUNT_ACTUAL,         /**< RECPOSTB: added in Parameter Set Version 6.42 */
    RCP_PARAM_RTC_DATE_TIME,                          /**< DATETIME: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_PRIORITY_LIST,                  /**< MONPRTY: added in Parameter Set Version 6.0 */
    RCP_PARAM_TARGET,                                 /**< TARGET: see @ref rcp_target_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_TARGET_ID,                              /**< TARGETID: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_EJECT,                            /**< EJECT: see @ref media_loc_t, added in Parameter Set Version 6.0 */
    RCP_PARAM_TIMEZONE,                               /**< TIMEZONE: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_FORMAT_REEL_NO,                   /**< FMTREELN: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_FORMAT_CAMERA_ID,                 /**< FMTCAMID: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_FORMAT_CAMERA_POS,                /**< FMTCAMPO: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_FORMAT_EDGE_TC_START,             /**< FMTETCS: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_FORMAT,                           /**< FMTMEDIA: added in Parameter Set Version 6.0 */
    RCP_PARAM_MEDIA_SECURE_FORMAT,                    /**< SFMTMEDI: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD,      /**< BLCDFMSP: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD, /**< RLCDFMSP: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_LCD,                /**< BLCDFM2: added in Parameter Set Version 6.0 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD,           /**< RLCDFM2: added in Parameter Set Version 6.0 */
    RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE,            /**< CNA1ENA: added in Parameter Set Version 6.1 */
    RCP_PARAM_REMOTE_CONTROL_PANEL_ADDRESS,           /**< CNA1ADDR: added in Parameter Set Version 6.1 */
    RCP_PARAM_REMOTE_CONTROL_PANEL_STATUS,            /**< CNA1STA: added in Parameter Set Version 6.1 */
    RCP_PARAM_TETHERED_SERVER_ADDRESS,                /**< TSRVAD: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERED_SERVER_STATE,                  /**< TSRVSTAT: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_OUTPUT_SHARPNESS,                       /**< FRSHARP: added in Parameter Set Version 6.1 */
    RCP_PARAM_SLATE_SHOT,                             /**< CAMSHOT: added in Parameter Set Version 6.1 */
    RCP_PARAM_WIFI_STATE,                             /**< WLANSTAT: see @ref wl_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_WIFI_STATE_DETAILED,                    /**< WLANSTAT: see @ref wl_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_FOCUS_STATE,                            /**< MTMST0: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_FOCUS_STATE_DETAILED,                   /**< MTMST0: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_IRIS_STATE,                             /**< MTMST1: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_IRIS_STATE_DETAILED,                    /**< MTMST1: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_ZOOM_STATE,                             /**< MTMST2: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_ZOOM_STATE_DETAILED,                    /**< MTMST2: see @ref mc_motor_status_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_TIMECODE_LTC_OUT_ENABLE,                /**< TCLTCOUT: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_STATE,                          /**< RMSTATE: see @ref redmote_connected_state_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_CAPTURE_MODE,                    /**< CAMMODE: see @ref camera_capture_mode_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_PRIMARY_STORAGE,                        /**< PRISTOR: see @ref primary_storage_t, added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_RR,                         /**< CMATRR: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_RG,                         /**< CMATRG: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_RB,                         /**< CMATRB: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_GR,                         /**< CMATGR: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_GG,                         /**< CMATGG: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_GB,                         /**< CMATGB: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_BR,                         /**< CMATBR: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_BG,                         /**< CMATBG: added in Parameter Set Version 6.1 */
    RCP_PARAM_USER_MATRIX_BB,                         /**< CMATBB: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_MODEL_NUMBER,                     /**< MEDIANUM: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_ACTIVE_MEDIA,                     /**< MEDIA: added in Parameter Set Version 6.1 */
    RCP_PARAM_SLATE_AUTO_HEAD_FRAMES,                 /**< SLHEAD: added in Parameter Set Version 6.1 */
    RCP_PARAM_SLATE_AUTO_TAIL_FRAMES,                 /**< SLTAIL: added in Parameter Set Version 6.1 */
    RCP_PARAM_GIO_SCOPE_PRIMARY_COLORS,               /**< GIOCPRI: added in Parameter Set Version 6.1 */
    RCP_PARAM_GIO_SCOPE_SECONDARY_COLORS,             /**< GIOCSEC: added in Parameter Set Version 6.1 */
    RCP_PARAM_GIO_SCOPE_ZONES,                        /**< GIOZONE: added in Parameter Set Version 6.1 */
    RCP_PARAM_UI_GESTURE_PINCH_MAGNIFY,               /**< GESTPNCH: added in Parameter Set Version 6.1 */
    RCP_PARAM_UI_GESTURE_DOUBLE_TAP_RIGHT_REC,        /**< GESTDTR: added in Parameter Set Version 6.1 */
    RCP_PARAM_UI_GESTURE_DOUBLE_TAP_LEFT_AF,          /**< GESTDTL: added in Parameter Set Version 6.1 */
    RCP_PARAM_UI_LOCK_TOUCHSCREEN,                    /**< UILOCK: added in Parameter Set Version 6.1 */
    RCP_PARAM_UI_SMALL_DIALOGS_ON_9_INCH,             /**< SMDLG9IN: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_CLIP_DATE,                     /**< PBCLSTDT: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_CLIP_TIME,                     /**< PBCLSTTM: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_CLIP_DATE_TIME,                /**< Composite of @ref RCP_PARAM_PLAYBACK_CLIP_DATE and @ref RCP_PARAM_PLAYBACK_CLIP_TIME, added in Paramter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_METADATA_FOCAL_LENGTH,         /**< PBZOOM: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_METADATA_ISO,                  /**< PBISO: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE,    /**< PBCOLTMP: added in Parameter Set Version 6.1 */
    RCP_PARAM_PLAYBACK_METADATA_TINT,                 /**< PBTINT: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_FIRMWARE_SVN_REVISION,           /**< CAMVCREV: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_RUNTIME,                         /**< RUNTIME: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_SHADOW_X,                     /**< RCURVESX: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_SHADOW_Y,                     /**< RCURVESY: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_DARK_X,                       /**< RCURVEDX: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_DARK_Y,                       /**< RCURVEDY: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_MIDTONE_X,                    /**< RCURVEMX: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_MIDTONE_Y,                    /**< RCURVEMY: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_LIGHT_X,                      /**< RCURVELX: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_LIGHT_Y,                      /**< RCURVELY: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_HIGHLIGHT_X,                  /**< RCURVEHX: added in Parameter Set Version 6.1 */
    RCP_PARAM_RED_CURVE_HIGHLIGHT_Y,                  /**< RCURVEHY: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_SHADOW_X,                   /**< GCURVESX: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_SHADOW_Y,                   /**< GCURVESY: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_DARK_X,                     /**< GCURVEDX: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_DARK_Y,                     /**< GCURVEDY: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_MIDTONE_X,                  /**< GCURVEMX: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_MIDTONE_Y,                  /**< GCURVEMY: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_LIGHT_X,                    /**< GCURVELX: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_LIGHT_Y,                    /**< GCURVELY: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_HIGHLIGHT_X,                /**< GCURVEHX: added in Parameter Set Version 6.1 */
    RCP_PARAM_GREEN_CURVE_HIGHLIGHT_Y,                /**< GCURVEHY: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_SHADOW_X,                    /**< BCURVESX: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_SHADOW_Y,                    /**< BCURVESY: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_DARK_X,                      /**< BCURVEDX: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_DARK_Y,                      /**< BCURVEDY: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_MIDTONE_X,                   /**< BCURVEMX: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_MIDTONE_Y,                   /**< BCURVEMY: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_LIGHT_X,                     /**< BCURVELX: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_LIGHT_Y,                     /**< BCURVELY: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_HIGHLIGHT_X,                 /**< BCURVEHX: added in Parameter Set Version 6.1 */
    RCP_PARAM_BLUE_CURVE_HIGHLIGHT_Y,                 /**< BCURVEHY: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_SHADOW_X,                    /**< LCURVESX: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_SHADOW_Y,                    /**< LCURVESY: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_DARK_X,                      /**< LCURVEDX: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_DARK_Y,                      /**< LCURVEDY: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_MIDTONE_X,                   /**< LCURVEMX: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_MIDTONE_Y,                   /**< LCURVEMY: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_LIGHT_X,                     /**< LCURVELX: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_LIGHT_Y,                     /**< LCURVELY: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_HIGHLIGHT_X,                 /**< LCURVEHX: added in Parameter Set Version 6.1 */
    RCP_PARAM_LUMA_CURVE_HIGHLIGHT_Y,                 /**< LCURVEHY: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_IS_ATTACHED,                      /**< MEDATCHD: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_IS_PRESENT,                       /**< MEDPRSNT: added in Parameter Set Version 6.40 */
    RCP_PARAM_MEDIA_SERIAL_NUMBER,                    /**< MEDASRNU: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_FIRMWARE_VERSION,                 /**< MEDIAVER: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_SIZE,                             /**< MEDIASZ: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_SIZE_AVIALABLE,                   /**< MEDIASZA: added in Parameter Set Version 6.1 */
    RCP_PARAM_OLPF_TYPE,                              /**< OLPF: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_DOWNLOAD_FIRMWARE,                /**< MEDIAUPG: added in Parameter Set Version 6.1 */
    RCP_PARAM_RESET_FACTORY_DEFAULTS,                 /**< RESETDEF: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDISCOVER_HARDWARE,                    /**< RESETHW: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_A_FPS,                             /**< RAMPAFPS: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_A_DURATION,                        /**< RAMPADUR: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_B_FPS,                             /**< RAMPBFPS: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_B_DURATION,                        /**< RAMPBDUR: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_C_FPS,                             /**< RAMPCFPS: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_C_DURATION,                        /**< RAMPCDUR: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_D_FPS,                             /**< RAMPDFPS: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_D_DURATION,                        /**< RAMPDDUR: added in Parameter Set Version 6.1 */
    RCP_PARAM_RAMP_RESET_DURATION,                    /**< RAMPRDUR: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_LIST,                     /**< CPRE: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_APPLY,                    /**< CPREAPLY: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_EXPORT_TO_MEDIA,          /**< CPREE2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_EXPORT_ALL_TO_MEDIA,      /**< CPREEA2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_UPDATE,                   /**< CPREUP: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_PRESET_DELETE,                   /**< CPREDEL: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_PRESET_LIST,                      /**< MPRE: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_PRESET_IMPORT_TO_CAMERA,          /**< MPREI2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_PRESET_IMPORT_ALL_TO_CAMERA,      /**< MPREIA2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LOOK_LIST,                       /**< CLOK: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LOOK_APPLY,                      /**< CLOKAPLY: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LOOK_EXPORT_TO_MEDIA,            /**< CLOKE2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LOOK_EXPORT_ALL_TO_MEDIA,        /**< CLOKEA2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LOOK_DELETE,                     /**< CLOKDEL: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_LOOK_LIST,                        /**< MLOK: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_LOOK_IMPORT_TO_CAMERA,            /**< MLOKI2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_LOOK_IMPORT_ALL_TO_CAMERA,        /**< MLOKIA2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_UPGRADE_CAMERA_FIRMWARE,                /**< CAMUPG: added in Parameter Set Version 6.1 */
    RCP_PARAM_UPGRADE_REDMOTE_FIRMWARE,               /**< RMUPG: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_RACK_SPEED,                          /**< AFRCKSPD: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_RACK_NUMBER_OF_POINTS,               /**< AFRCKNPT: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_RACK_TO_POINT,                       /**< AFRCKTO: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_OVERLAY_LIST,                    /**< COVR: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_OVERLAY_DELETE,                  /**< COVRDEL: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_OVERLAY_EXPORT_TO_MEDIA,         /**< COVRE2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_OVERLAY_EXPORT_ALL_TO_MEDIA,     /**< COVREA2M: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_OVERLAY_LIST,                     /**< MOVR: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_OVERLAY_IMPORT_TO_CAMERA,         /**< MOVRI2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_MEDIA_OVERLAY_IMPORT_ALL_TO_CAMERA,     /**< MOVRIA2C: added in Parameter Set Version 6.1 */
    RCP_PARAM_CURRENT_CALIBRATION_TEMPERATURE,        /**< CALTEMP: added in Parameter Set Version 6.1 */
    RCP_PARAM_CURRENT_CALIBRATION_INTEGRATION_TIME,   /**< CALINT: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_WIRELESS_ENABLE,                /**< RMEN: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_WIRELESS_CHANNEL,               /**< RMCH: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_DISCOVERED_LIST,                /**< RMDMAC: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_PAIRED_LIST,                    /**< RMPMAC: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_SCAN,                           /**< RMSCAN: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_PAIR,                           /**< RMPAIR: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_UNPAIR,                         /**< RMUNPAIR: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_CAMERA_MAC,                     /**< RMCAMMAC: added in Parameter Set Version 6.1 */
    RCP_PARAM_REDMOTE_ATTACHED_MAC,                   /**< RMMAC: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_STARTUP,                    /**< APSTART: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_MOTION,                     /**< APMOTION: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_MOTION_AUTO_UPDATE,         /**< APAUMOTN: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_STILLS,                     /**< APSTILLS: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_STILLS_AUTO_UPDATE,         /**< APAUSTIL: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_PLAYBACK,                   /**< APPLAY: added in Parameter Set Version 6.1 */
    RCP_PARAM_AUTO_PRESET_PLAYBACK_AUTO_UPDATE,       /**< APAUPLAY: added in Parameter Set Version 6.1 */
    RCP_PARAM_TETHERING_SUPPORTED,                    /**< TETHERS: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERING_SUPPORTED_ON_THIS_INTERFACE,  /**< TETHERSI: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERED_SERVER_SPACE_TOTAL,            /**< TSRVSPT: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERED_SERVER_SPACE_REMAINING,        /**< TSRVSPR: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERED_SERVER_REEL_NO,                /**< TSRVRN: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_TETHERED_SERVER_CLIP_NO,                /**< TSRVCN: added in Parameter Set Version 6.1 (Intended for internal RED use only) */
    RCP_PARAM_PL_POWER,                               /**< PLPOWER: added in Parameter Set Version 6.1 */
    RCP_PARAM_PL_DETECT,                              /**< PLDETECT: added in Parameter Set Version 6.1 */
    RCP_PARAM_GENLOCK_OFFSET_HDSDI,                   /**< BHDSGLO: added in Parameter Set Version 6.1 */
    RCP_PARAM_GENLOCK_OFFSET_REDCAST,                 /**< TURRGLO: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_RACK_POINT_SELECT,                   /**< AFRCKSEL: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_WINDOW_POS_X,                        /**< AFWPOSX: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_WINDOW_POS_Y,                        /**< AFWPOSY: added in Parameter Set Version 6.1 */
    RCP_PARAM_AF_WINDOW_POS_MOVE_COMPLETE,            /**< AFWPOSC: added in Parameter Set Version 6.1 */
    RCP_PARAM_CAMERA_LUT_LIST,                        /**< CLUT: added in Parameter Set Version 6.10 */
    RCP_PARAM_CAMERA_LUT_EXPORT_TO_MEDIA,             /**< CLUTE2M: added in Parameter Set Version 6.10 */
    RCP_PARAM_CAMERA_LUT_EXPORT_ALL_TO_MEDIA,         /**< CLUTEA2M: added in Parameter Set Version 6.10 */
    RCP_PARAM_CAMERA_LUT_DELETE,                      /**< CLUTDEL: added in Parameter Set Version 6.10 */
    RCP_PARAM_MEDIA_LUT_LIST,                         /**< MLUT: added in Parameter Set Version 6.10 */
    RCP_PARAM_MEDIA_LUT_IMPORT_TO_CAMERA,             /**< MLUTI2C: added in Parameter Set Version 6.10 */
    RCP_PARAM_MEDIA_LUT_IMPORT_ALL_TO_CAMERA,         /**< MLUTIA2C: added in Parameter Set Version 6.10 */
    RCP_PARAM_LUT_CH_0,                               /**< CLUTCH0: added in Parameter Set Version 6.10 */
    RCP_PARAM_LUT_CH_1,                               /**< CLUTCH1: added in Parameter Set Version 6.10 */
    RCP_PARAM_LUT_CH_2,                               /**< CLUTCH2: added in Parameter Set Version 6.10 */
    RCP_PARAM_LUT_CH_3,                               /**< CLUTCH3: added in Parameter Set Version 6.10 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF, /**< BEVFFMSP: added in Parameter Set Version 6.10 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF, /**< REVFFMSP: added in Parameter Set Version 6.10 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF,          /**< BEVFFM2: added in Parameter Set Version 6.10 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF,           /**< REVFFM2: added in Parameter Set Version 6.10 */
    RCP_PARAM_AUDIO_CH12_OUTPUT_NAME,                 /**< CH12ONME: added in Parameter Set Version 6.10 */
    RCP_PARAM_AUDIO_CH34_OUTPUT_NAME,                 /**< CH34ONME: added in Parameter Set Version 6.10 */
    RCP_PARAM_AUDIO_CH56_OUTPUT_NAME,                 /**< CH56ONME: added in Parameter Set Version 6.10 */
    RCP_PARAM_AE_EXPOSURE_PRIORITY,                   /**< AEEXPRI: added in Parameter Set Version 6.10 */
    RCP_PARAM_RECORD_FILE_FORMAT,                     /**< FILEFMT: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_VIDEO_CODEC,                     /**< VCODEC: added in Parameter Set Version 6.20 */
    RCP_PARAM_MIN_RECORD_VIDEO_CODEC,                 /**< Composite of @ref RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION */
    RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION,          /**< VCODECR: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_VIDEO_MXF_CODEC,                 /**< VMCODEC: added in Parameter Set Version 6.40 */
    RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC,             /**< Composite of @ref RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION */
    RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION,      /**< VMCODECR: added in Parameter Set Version 6.40 */
    RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID,        /**< MXFCMPID: added in Parameter Set Version 6.40 */
    RCP_PARAM_HARDWARE_CAPABILITIES,                  /**< HWCAP: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_CH1_MUTE,                         /**< CH1MUTE: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_CH2_MUTE,                         /**< CH2MUTE: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_VOL1,                    /**< MIX12VL1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_PAN1,                    /**< MIX12PN1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_VOL2,                    /**< MIX12VL2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_PAN2,                    /**< MIX12PN2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_VOL3,                    /**< MIX12VL3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_PAN3,                    /**< MIX12PN3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_VOL4,                    /**< MIX12VL4: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH12_PAN4,                    /**< MIX12PN4: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_VOL1,                    /**< MIX12VL1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_PAN1,                    /**< MIX12PN1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_VOL2,                    /**< MIX12VL2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_PAN2,                    /**< MIX12PN2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_VOL3,                    /**< MIX12VL3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_PAN3,                    /**< MIX12PN3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_VOL4,                    /**< MIX12VL4: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_CH34_PAN4,                    /**< MIX12PN4: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_VOL1,                     /**< MIXHDVL1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_PAN1,                     /**< MIXHDPN1: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_VOL2,                     /**< MIXHDVL2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_PAN2,                     /**< MIXHDPN2: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_VOL3,                     /**< MIXHDVL3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_PAN3,                     /**< MIXHDPN3: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_VOL4,                     /**< MIXHDVL4: added in Parameter Set Version 6.20 */
    RCP_PARAM_AUDIO_MIX_MON_PAN4,                     /**< MIXHDPN4: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_LCD_EVF_2_HDMI_MUX,             /**< HDMIMUX: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_MODE,                              /**< WLANMODE: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_AD_HOC_ENCRYPTION,                 /**< WLANAHEN: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_AD_HOC_PASSPHRASE,                 /**< WLANAHPW: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_AD_HOC_SSID,                       /**< WLANAHID: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_CHANNEL,                           /**< WLANCHAN: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION,         /**< WLANAPEN: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE,         /**< WLANAPPW: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_INFRASTRUCTURE_SSID,               /**< WLANAPID: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_SIGNAL,                            /**< WLANSIG: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_CONNECT,                           /**< WLANCONN: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_SCAN,                              /**< WLANSCAN: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_SCAN_RESULTS,                      /**< WLANSCRL: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_SCAN_SELECT,                       /**< WLANSCS: added in Parameter Set Version 6.30 */
    RCP_PARAM_WIFI_IP_ADDRESS,                        /**< WLANIP: added in Parameter Set Version 6.20 */
    RCP_PARAM_WIFI_NETMASK,                           /**< WLANNETM: added in Parameter Set Version 6.41 */
    RCP_PARAM_WIFI_GATEWAY,                           /**< WLANGATE: added in Parameter Set Version 6.41 */
    RCP_PARAM_WIFI_DHCP_ENABLE,                       /**< WLANDHCP: added in Parameter Set Version 6.41 */
    RCP_PARAM_WIFI_MAC_ADDRESS,                       /**< WLANMAC: added in Parameter Set Version 6.50 */
    RCP_PARAM_MODULE_CAPABILITIES,                    /**< MODCAP: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE,           /**< POPIOGE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS,           /**< POPIOGS: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET,            /**< POPIOGR: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE,            /**< POPIOPE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS,            /**< POPIOPS: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET,             /**< POPIOPR: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PRO_IO_AUX_ENABLE,            /**< POPIOAE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE,          /**< POPOPE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS,          /**< POPOPS: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET,           /**< POPOPR: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE,               /**< POBAE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_BAT_AUX_STATUS,               /**< POBAS: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_BAT_AUX_CURRENT,              /**< POBAC: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_BAT_AUX_RESET,                /**< POBAR: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE,           /**< POJPUE: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS,           /**< POJPUS: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_JETPACK_USB_RESET,            /**< POJPUR: added in Parameter Set Version 6.20 */
    RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE,              /**< PORXAE: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_REAR_AUX_STATUS,              /**< PORXAS: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_REAR_AUX_RESET,               /**< PORXAR: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_REAR_AUX_CURRENT,             /**< PORXAC: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_TIMECODE_ENABLE,              /**< PORXTCE: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_TIMECODE_STATUS,              /**< PORXTCS: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_OUT_TIMECODE_RESET,               /**< PORXTCR: added in Parameter Set Version 6.32 */
    RCP_PARAM_POWER_SAVE_STATE,                       /**< PWRSAVE: see @ref power_save_state_t, added in Parameter Set Version 6.20 */
    RCP_PARAM_QUALITY,                                /**< Composite of @ref RCP_PARAM_REDCODE, @ref RCP_PARAM_RECORD_FILE_FORMAT, @ref RCP_PARAM_RECORD_VIDEO_CODEC, and @ref RCP_PARAM_RECORD_VIDEO_MXF_CODEC, added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_SENSOR_FRAME_RATE,               /**< CUSTMFPS: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_SENSOR_FRAME_RATE,               /**< MASTRFPS: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_RECORD_FORMAT,                   /**< CUSTMFMT: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_RECORD_FORMAT,                   /**< MASTRFMT: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_SHUTTER_ANGLE,                   /**< CUSTMPHS: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_SHUTTER_ANGLE,                   /**< MASTRPHS: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_INTEGRATION_TIME,                /**< CUSTMINT: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_INTEGRATION_TIME,                /**< MASTRINT: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_ISO,                             /**< CUSTMISO: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_ISO,                             /**< MASTRISO: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_REDCODE,                         /**< CUSTMRC: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_REDCODE,                         /**< MASTRRC: added in Parameter Set Version 6.20 */
    RCP_PARAM_CUSTOM_COLOR_TEMPERATURE,               /**< CUSTMAWB: added in Parameter Set Version 6.20 */
    RCP_PARAM_MASTER_COLOR_TEMPERATURE,               /**< MASTRAWB: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_FORMAT,                      /**< USECFL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_FRAME_RATE,                  /**< USECFRL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_SHUTTER_ANGLE,               /**< USECPHSL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_INTEGRATION_TIME,            /**< USECINTL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_ISO,                         /**< USECISOL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_REDCODE,                     /**< USECRCL: added in Parameter Set Version 6.20 */
    RCP_PARAM_USE_CUSTOM_COLOR_TEMPERATURE,           /**< USECWBL: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_LCD,                       /**< LCDG: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_HDMI,                      /**< HDMIG: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_HDSDI,                     /**< HDSDIG: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_EVF,                       /**< EVFG: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_REAR_LCD,                  /**< PLCDG: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_REAR_HDSDI1,               /**< PHDSDI1G: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_REAR_HDSDI2,               /**< PHDSDI2G: added in Parameter Set Version 6.20 */
    RCP_PARAM_MONITOR_FEED_REAR_EVF,                  /**< REVFG: added in Parameter Set Version 6.20 */
    RCP_PARAM_VIDEO_SOURCE,                           /**< VIDEOSRC: added in Parameter Set Version 6.20 */
    RCP_PARAM_LUT_FEED_1_ENABLE,                      /**< CLUTF1EN: added in Parameter Set Version 6.62 */
    RCP_PARAM_LUT_FEED_1,                             /**< CLUTF1: added in Parameter Set Version 6.20 */
    RCP_PARAM_FLIP_MIRROR_FEED_0,                     /**< ROTF0: added in Parameter Set Version 6.20 */
    RCP_PARAM_FLIP_MIRROR_FEED_1,                     /**< ROTF1: added in Parameter Set Version 6.20 */
    RCP_PARAM_FLIP_MIRROR_FEED_0_1,                   /**< ROTF01: added in Parameter Set Version 6.50 */
    RCP_PARAM_SSD_TALLY_LIGHT,                        /**< SSDTALLY: added in Parameter Set Version 6.20 */
    RCP_PARAM_OVERDRIVE_FRAME_RATE,                   /**< PORECFPS: added in Parameter Set Version 6.20 */
    RCP_PARAM_PRE_RECORD,                             /**< PREREC: added in Parameter Set Version 6.20 */
    RCP_PARAM_CALIBRATION_ENTRY,                      /**< CALENTRY: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_VIDEO_CODEC_FEED,                /**< VCODECG: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_REDCODE_RAW_STATE,               /**< R3DST: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_REDCODE_RAW_STATE_DETAILED,      /**< R3DSTD: added in Parameter Set Version 6.30 */
    RCP_PARAM_RECORD_QUICKTIME_STATE,                 /**< QTST: added in Parameter Set Version 6.20 */
    RCP_PARAM_RECORD_QUICKTIME_STATE_DETAILED,        /**< QTSTD: added in Parameter Set Version 6.30 */
    RCP_PARAM_RECORD_MXF_STATE,                       /**< MXFST: added in Parameter Set Version 6.40 */
    RCP_PARAM_RECORD_MXF_STATE_DETAILED,              /**< MXFSTD: added in Parameter Set Version 6.40 */
    RCP_PARAM_SENSOR_SCAN_DIRECTION,                  /**< SSCANDIR: added in Parameter Set Version 6.20 */
    RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM,               /**< FMTFSYS: added in Parameter Set Version 6.30 */
    RCP_PARAM_WIPE_CAMERA,                            /**< RESETUSR: added in Parameter Set Version 6.30 */
    RCP_PARAM_PROXY_ENCODE_FRAMERATE,                 /**< PROXYFPS: added in Parameter Set Version 6.30 */
    RCP_PARAM_PRORES_ENCODE_FRAMERATE,                /**< PROXYFPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_MXF_ENCODE_FRAMERATE,                   /**< PROXYFPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CAL_LIST,                        /**< CCAL: added in Parameter Set Version 6.30 */
    RCP_PARAM_CAMERA_CAL_APPLY,                       /**< CCALAPLY: added in Parameter Set Version 6.30 */
    RCP_PARAM_CAMERA_CAL_EXPORT_TO_MEDIA,             /**< CCALE2M: added in Parameter Set Version 6.30 */
    RCP_PARAM_CAMERA_CAL_EXPORT_ALL_TO_MEDIA,         /**< CCALEA2M: added in Parameter Set Version 6.30 */
    RCP_PARAM_CAMERA_CAL_DELETE,                      /**< CCALDEL: added in Parameter Set Version 6.30 */
    RCP_PARAM_MEDIA_CAL_LIST,                         /**< MCAL: added in Parameter Set Version 6.30 */
    RCP_PARAM_MEDIA_CAL_APPLY,                        /**< MCALAPLY: added in Parameter Set Version 6.30 */
    RCP_PARAM_MEDIA_CAL_IMPORT_TO_CAMERA,             /**< MCALI2C: added in Parameter Set Version 6.30 */
    RCP_PARAM_MEDIA_CAL_IMPORT_ALL_TO_CAMERA,         /**< MCALIA2C: added in Parameter Set Version 6.30 */
    RCP_PARAM_PRORES_WIDTH,                           /**< PRORESW: added in Parameter Set Version 6.30 */
    RCP_PARAM_PRORES_HEIGHT,                          /**< PRORESH: added in Parameter Set Version 6.30 */
    RCP_PARAM_PRORES_DIMENSION,                       /**< Composite of @ref RCP_PARAM_PRORES_WIDTH, @ref RCP_PARAM_PRORES_HEIGHT added in Parameter Set Version 6.30 */
    RCP_PARAM_MXF_WIDTH,                              /**< MXFW: added in Parameter Set Version 6.40 */
    RCP_PARAM_MXF_HEIGHT,                             /**< MXFH: added in Parameter Set Version 6.40 */
    RCP_PARAM_MXF_DIMENSION,                          /**< Composite of @ref RCP_PARAM_MXF_WIDTH, @ref RCP_PARAM_MXF_HEIGHT added in Parameter Set Version 4.30 */
    RCP_PARAM_OPEN_GATE_MODE,                         /**< OGTMODE: added in Parameter Set Version 6.30 */
    RCP_PARAM_OPEN_GATE_STATE,                        /**< OGTSTATE: added in Parameter Set Version 6.30 */
    RCP_PARAM_LENS_IMAGE_STABILIZATION_ENABLED,       /**< LENSISEN: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_CAPABILITIES,                      /**< LENSCAP: added in Parameter Set Version 6.40 */
    RCP_PARAM_PLAYBACK_FILE_FORMAT,                   /**< PLAYFMT: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_MODE_LCD3,                      /**< LCD3M: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_OVERLAY_LCD3,                   /**< LCD3OV: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FREQ_LCD3,                      /**< LCD3F: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_CURVE_LCD3,                     /**< LCD3CV: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_TOOLS_LCD3,                     /**< LCD3TL: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3,            /**< LCD3FM: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3,                /**< LCD3VF: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3,               /**< LCD3FM2: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3,            /**< LCD3FO: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_DOCK_MENUS_LCD3,                /**< LCD3DM: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FEED_LCD3,                      /**< LCD3G: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3,     /**< LCD3FMSP: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_MODE_EVF3,                      /**< EVF3M: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_OVERLAY_EVF3,                   /**< EVF3OV: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FREQ_EVF3,                      /**< EVF3F: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_CURVE_EVF3,                     /**< EVF3CV: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_TOOLS_EVF3,                     /**< EVF3TL: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3,            /**< EVF3FM: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3,                /**< EVF3VF: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3,               /**< EVF3FM2: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3,            /**< EVF3FO: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_DOCK_MENUS_EVF3,                /**< EVF3DM: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FEED_EVF3,                      /**< EVF3G: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3,     /**< EVF3FMSP: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_BRIGHTNESS_LCD3,                /**< LCD3BR: added in Parameter Set Version 6.40 */
    RCP_PARAM_MONITOR_BRIGHTNESS_EVF3,                /**< EVF3BR: added in Parameter Set Version 6.40 */
    RCP_PARAM_PLAYBACK_FILE_FORMAT_TYPE,              /**< PLAYTYPE: added in Parameter Set Version 6.40 */
    RCP_PARAM_OLPF_THIRD_PARTY_NAME,                  /**< OLPFTPNM: added in Parameter Set Version 6.40 */
    RCP_PARAM_OLPF_THIRD_PARTY_EMULATED_TYPE,         /**< OLPFTPEM: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_NAME,                         /**< LNMTNAME: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_SERIAL,                       /**< LNMTSERL: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_OWNER,                        /**< LNMTOWNR: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_MANUFACTURER,                 /**< LNMTMANU: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_FLEN_MIN,                     /**< LNMTFLMN: added in Parameter Set Version 6.40 */
    RCP_PARAM_LENS_META_FLEN_MAX,                     /**< LNMTFLMX: added in Parameter Set Version 6.40 */
    RCP_PARAM_RECORD_R3D_METADATA_CURVE,              /**< METACV: added in Parameter Set Version 6.40 */
    RCP_PARAM_ND_INCREMENT_SIZE,                      /**< MMNDINSZ: added in Parameter Set Version 6.50 */
    RCP_PARAM_ZEBRA_1_PATTERN,                        /**< ZEB1PAT: added in Parameter Set Version 6.50 */
    RCP_PARAM_ZEBRA_2_PATTERN,                        /**< ZEB2PAT: added in Parameter Set Version 6.50 */
    RCP_PARAM_ZEBRA_1_COLOR,                          /**< ZEB1CLR: added in Parameter Set Version 6.50 */
    RCP_PARAM_ZEBRA_2_COLOR,                          /**< ZEB2CLR: added in Parameter Set Version 6.50 */
    RCP_PARAM_AUDIO_CH1_MODE_STATUS,                  /**< AINSR1ST: added in Parameter Set Version 6.41 */
    RCP_PARAM_AUDIO_CH2_MODE_STATUS,                  /**< AINSR2ST: added in Parameter Set Version 6.41 */
    RCP_PARAM_AUDIO_CH3_MODE_STATUS,                  /**< AINSR3ST: added in Parameter Set Version 6.42 */
    RCP_PARAM_AUDIO_CH4_MODE_STATUS,                  /**< AINSR4ST: added in Parameter Set Version 6.42 */
    RCP_PARAM_START_USER_CAL_MANUAL_CURRENT_INT_TIME, /**< CALMANC: added in Parameter Set Version 6.50 */
    RCP_PARAM_START_USER_CAL_MANUAL_DEFAULT_INT_TIME, /**< CALMAND: added in Parameter Set Version 6.50 */
    RCP_PARAM_START_USER_CAL_AUTO,                    /**< CALAUTO: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_CONTROL_SCREEN,                 /**< CTRLSCRN: added in Parameter Set Version 6.50 */
    RCP_PARAM_RCP_CLIENT_LIST,                        /**< RCPCLL: added in Parameter Set Version 6.50 */
    RCP_PARAM_BWF_ENABLE,                             /**< BWFENABL: added in Parameter Set Version 6.50 */
    RCP_PARAM_BWF_VALID,                              /**< BWFVALID: added in Parameter Set Version 6.50 */
    RCP_PARAM_WSH_FOCUS_WHEEL,                        /**< WSHFOCUS: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_MODULE_LOCK_KEYS,                  /**< SMLCKKEY: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_MODULE_RECORD_KEY_LOCKABLE,        /**< SMLCKREC: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_MODULE_NAV_KEYS_LOCKABLE,          /**< SMLCKNAV: added in Parameter Set Version 6.50 */
    RCP_PARAM_SHOW_KEY_ACTION_NOTIFICATIONS,          /**< KEYACNOT: added in Parameter Set Version 6.50 */

    /* Indexed Power In Messages
     * Note: if adding more placeholders make sure to update the *_LAST
     * pointers. Also, the dependency table entries for these
     * parameters are auto generated)
     * */
    RCP_PARAM_POWER_IN_LIST,                          /**< PWILIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_0,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_1,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_2,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_3,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_4,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_5,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_6,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_7,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_8,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_9,                     /**< PWIBTLVL: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PERCENT_LAST = RCP_PARAM_POWER_IN_PERCENT_9,
    RCP_PARAM_POWER_IN_RUNTIME_0,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_1,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_2,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_3,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_4,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_5,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_6,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_7,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_8,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_9,                     /**< PWIBTRT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_RUNTIME_LAST = RCP_PARAM_POWER_IN_RUNTIME_9,
    RCP_PARAM_POWER_IN_VOLTAGE_0,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_1,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_2,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_3,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_4,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_5,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_6,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_7,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_8,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_9,                     /**< PWIVOLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_VOLTAGE_LAST = RCP_PARAM_POWER_IN_VOLTAGE_9,
    RCP_PARAM_POWER_IN_CURRENT_0,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_1,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_2,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_3,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_4,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_5,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_6,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_7,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_8,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_9,                     /**< PWIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_CURRENT_LAST = RCP_PARAM_POWER_IN_CURRENT_9,
    RCP_PARAM_POWER_IN_PRESENT_0,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_1,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_2,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_3,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_4,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_5,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_6,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_7,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_8,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_9,                     /**< PWIPRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_IN_PRESENT_LAST = RCP_PARAM_POWER_IN_PRESENT_9,
    RCP_PARAM_POWER_IN_TYPE_0,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_1,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_2,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_3,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_4,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_5,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_6,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_7,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_8,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_9,                        /**< PWITYPE: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_TYPE_LAST = RCP_PARAM_POWER_IN_TYPE_9,
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_1,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_2,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_3,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_4,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_5,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_6,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_7,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_8,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_9,     /**< PWIVBT: added in Parameter Set Version 6.61 */
    RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_LAST = RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_9,


    /* Indexed Power Out Messages
     * Note: if adding more placeholders make sure to update the *_LAST
     * pointers. Also, the dependency table entries for these
     * parameters are auto generated)
     * */
    RCP_PARAM_POWER_OUT_LIST,                         /**< PWOLIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_0,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_1,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_2,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_3,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_4,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_5,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_6,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_7,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_8,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_9,                     /**< PWOIEN: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_ENABLE_LAST = RCP_PARAM_POWER_OUT_ENABLE_9,
    RCP_PARAM_POWER_OUT_STATUS_0,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_1,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_2,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_3,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_4,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_5,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_6,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_7,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_8,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_9,                     /**< PWOIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_STATUS_LAST = RCP_PARAM_POWER_OUT_STATUS_9,
    RCP_PARAM_POWER_OUT_RESET_0,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_1,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_2,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_3,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_4,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_5,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_6,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_7,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_8,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_9,                      /**< PWOIRST: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_RESET_LAST = RCP_PARAM_POWER_OUT_RESET_9,
    RCP_PARAM_POWER_OUT_CURRENT_0,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_1,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_2,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_3,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_4,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_5,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_6,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_7,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_8,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_9,                    /**< PWOIAMPS: added in Parameter Set Version 6.50 */
    RCP_PARAM_POWER_OUT_CURRENT_LAST = RCP_PARAM_POWER_OUT_CURRENT_9,

    RCP_PARAM_MONITOR_LIST,                           /**< MONLIST: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_NAME,                           /**< SUNAME: added in Parameter Set Version 6.50 */
    RCP_PARAM_SENSOR_WIDTH_PHY,                       /**< PHYSENSW: added in Parameter Set Version 6.50 */
    RCP_PARAM_SENSOR_HEIGHT_PHY,                      /**< PHYSENSH: added in Parameter Set Version 6.50 */
    RCP_PARAM_SENSOR_DIMENSIONS_PHY,                  /**< Composite of @ref RCP_PARAM_SENSOR_WIDTH_PHY and @ref RCP_PARAM_SENSOR_HEIGHT_PHY, added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_WIDTH_PHY,                       /**< Composite of @ref RCP_PARAM_SENSOR_WIDTH_PHY and @ref RCP_PARAM_FORMAT_WIDTH_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_HEIGHT_PHY,                      /**< Composite of @ref RCP_PARAM_SENSOR_HEIGHT_PHY and @ref RCP_PARAM_FORMAT_HEIGHT_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_DIMENSIONS_PHY,                  /**< Composite of @ref RCP_PARAM_FORMAT_WIDTH_PHY and @ref RCP_PARAM_FORMAT_HEIGHT_PHY, added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_WIDTH_PIXELS,                    /**< PXFMTW: added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_HEIGHT_PIXELS,                   /**< PXFMTH: added in Parameter Set Version 6.50 */
    RCP_PARAM_FORMAT_DIMENSIONS_PIXELS,               /**< Composite of @ref RCP_PARAM_FORMAT_WIDTH_PIXELS and @ref RCP_PARAM_FORMAT_HEIGHT_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_SPHERICAL,                /**< FRMTSPH: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_ANA_1_3,                  /**< FRMTA13: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_ANA_1_25,                 /**< FRMTA125: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_ANA_2,                    /**< FRMTA12: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_RESOLUTION,               /**< FRMTRES: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_ASPECT_RATIO,             /**< FRMTAR: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_ANAMORPHIC,               /**< FRMTANA: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_FORMAT_LOOKAROUND,               /**< FRMTLA: added in Parameter Set Version 6.50 */
    RCP_PARAM_SENSOR_NAME,                            /**< SENSNAME: added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY,                /**< Composite of @ref RCP_PARAM_SENSOR_WIDTH_PHY and @ref RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY,               /**< Composite of @ref RCP_PARAM_SENSOR_HEIGHT_PHY and @ref RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY,           /**< Composite of @ref RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY and @ref RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY, added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS,             /**< PXSFMTW: added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS,            /**< PXSFMTH: added in Parameter Set Version 6.50 */
    RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS,        /**< Composite of @ref RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS and @ref RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS, added in Parameter Set Version 6.50 */
    RCP_PARAM_AMBIENT_CHANNEL,                        /**< AMBNTCH: added in Parameter Set Version 6.50 */
    RCP_PARAM_KEY_MAPPING_ACTION_LIST,                /**< ACTION: added in Parameter Set Version 6.50 */
    RCP_PARAM_DIALOG_LIST,                            /**< DIALOGS: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_SCRIPT_LIST,                     /**< CSCR: added in Parameter Set Version 6.50 */
    RCP_PARAM_COLOR_SCIENCE,                          /**< COLORSCI: added in Parameter Set Version 6.50 */
    RCP_PARAM_IMAGE_PIPELINE_MODE,                    /**< IMGPIPEM: added in Parameter Set Version 6.50 */
    RCP_PARAM_SUPPORT_CONTACT,                        /**< SUPPORT: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_LIST,                        /**< CCDL: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_APPLY,                       /**< CCDLAPLY: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_EXPORT_TO_MEDIA,             /**< CCDLE2M: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_EXPORT_ALL_TO_MEDIA,         /**< CCDLEA2M: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_CREATE,                      /**< CCDLCREA: added in Parameter Set Version 6.50 */
    RCP_PARAM_CAMERA_CDL_DELETE,                      /**< CCDLDEL: added in Parameter Set Version 6.50 */
    RCP_PARAM_MEDIA_CDL_LIST,                         /**< MCDL: added in Parameter Set Version 6.50 */
    RCP_PARAM_MEDIA_CDL_IMPORT_TO_CAMERA,             /**< MCDLI2C: added in Parameter Set Version 6.50 */
    RCP_PARAM_MEDIA_CDL_IMPORT_ALL_TO_CAMERA,         /**< MCDLIA2C: added in Parameter Set Version 6.50 */
    RCP_PARAM_SLATE_CAMERA_COLOR,                     /**< CAMCOLOR: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_USER_LEFT,                 /**< SUILPUSR: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_AUDIO_LEFT,                /**< SUILPAUD: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_MONITOR_LEFT,              /**< SUILPMON: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT,                 /**< SUILAH: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT,         /**< SUILAHTO: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_USER_RIGHT,                /**< SUIRPUSR: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_AUDIO_RIGHT,               /**< SUIRPAUD: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_PAGE_MONITOR_RIGHT,             /**< SUIRPMON: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT,                /**< SUIRAH: added in Parameter Set Version 6.50 */
    RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT,        /**< SUIRAHTO: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1,              /**< UHDSDI1M: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2,              /**< UHDSDI2M: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI,               /**< UHDSDIF: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI,             /**< DPUHD: added in Parameter Set Version 6.50 */
    RCP_PARAM_RETURN_FEED,                            /**< RTRNFEED: added in Parameter Set Version 6.50 */
    RCP_PARAM_RETURN_FEED_STATE,                      /**< RTRNFST: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD,          /**< BLCDRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI,         /**< BHDMIRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI,        /**< BHDSDIRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF,          /**< BEVFRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD,     /**< PLCDRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1,  /**< PSDI1RF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2,  /**< PSDI2RF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF,     /**< REVFRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3,         /**< LCD3RF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3,         /**< EVF3RF: added in Parameter Set Version 6.50 */
    RCP_PARAM_OUTPUT_TRANSFORM,                       /**< OUTPUTTR: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_LCD,                     /**< DPLCD: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_HDMI,                    /**< DPHDMI: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_HDSDI,                   /**< DPHDSDI: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_EVF,                     /**< DPEVF: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_REAR_LCD,                /**< DPRLCD: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1,             /**< DPPHDSD1: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2,             /**< DPPHDSD2: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_REAR_EVF,                /**< DPREVF: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_LCD3,                    /**< DPLCD3: added in Parameter Set Version 6.50 */
    RCP_PARAM_DISPLAY_PRESET_EVF3,                    /**< DPEVF3: added in Parameter Set Version 6.50 */
    RCP_PARAM_OUTPUT_TONE_MAP,                        /**< DEVCON: added in Parameter Set Version 6.50 */
    RCP_PARAM_MIN_FRAME_PROCESSING_MODE,              /**< MINFRPRM: added in Parameter Set Version 6.50 */
    RCP_PARAM_MAX_FRAME_PROCESSING_MODE,              /**< MAXFRPRM: added in Parameter Set Version 6.50 */
    RCP_PARAM_MIN_FRAME_PROCESSING_FRAME_COUNT,       /**< MINFRPRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_MAX_FRAME_PROCESSING_FRAME_COUNT,       /**< MAXFRPRF: added in Parameter Set Version 6.50 */
    RCP_PARAM_ROLL_OFF,                               /**< ROLLOFF: added in Parameter Set Version 6.50 */
    RCP_PARAM_LOOKAROUND_AVAILABLE,                   /**< FRMTLAST: added in Parameter Set Version 6.50 */
    RCP_PARAM_LOG_VIEW_MODE,                          /**< LOGVWMDE: see @ref log_view_mode_t, added in Parameter Set Version 6.50 */
    RCP_PARAM_AUTO_FOCUS_PEAK,                        /**< AUTOPEAK: added in Parameter Set Version 6.50 */
    RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE,       /**< TCDFMODE: see @ref tc_drop_frame_display_t, added in Parameter Set Version 6.50 */
    RCP_PARAM_ISO_CAL2_ENABLED,                       /**< ISOCAL2: added in Parameter Set Version 6.50 */
    RCP_PARAM_SHUTDOWN_NOTIFICATION,                  /**< SHUTDWNC: added in Parameter Set Version 6.60 */
    RCP_PARAM_MONITOR_LUT_LCD,                        /**< BLCDLUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_EVF,                        /**< BEVFLUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_HDMI,                       /**< BHDMILUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_HDSDI,                      /**< BSDILUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_REAR_LCD,                   /**< RLCDLUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_REAR_EVF,                   /**< REVFLUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_REAR_HDSDI1,                /**< RSDI1FLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_REAR_HDSDI2,                /**< RSDI2FLT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_BRAIN_LCD3,                 /**< LCD3LUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_MONITOR_LUT_BRAIN_EVF3,                 /**< EVF3LUT: added in Parameter Set Version 6.50 */
    RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS,         /**< VCBAKED: added in Parameter Set Version 6.50 */
    RCP_PARAM_MIN_RECORD_PROXY_BAKED_IN_SETTINGS,     /**< VCBAKMIN: added in Parameter Set Version 6.50 */
    RCP_PARAM_MAX_RECORD_PROXY_BAKED_IN_SETTINGS,     /**< VCBAKMAX: added in Parameter Set Version 6.50 */
    RCP_PARAM_SENSOR_SENSITIVITY,                     /**< SENSTVTY: added in Parameter Set Version 6.50 */     
    RCP_PARAM_QT_DROPPED_FRAMES,                      /**< QTDRPFRM: added in Parameter Set Version 6.51 */
    RCP_PARAM_MXF_DROPPED_FRAMES,                     /**< MXFDRPFM: added in Parameter Set Version 6.51 */
    RCP_PARAM_DROPPED_FRAMES,                         /**< Composite of @ref RCP_PARAM_R3D_DROPPED_FRAMES, @ref RCP_PARAM_QT_DROPPED_FRAMES and @ref RCP_PARAM_MXF_DROPPED_FRAMES, added in Parameter Set Version 6.51 */
    RCP_PARAM_PEAKING_LEVEL,                          /**< PEAKLVL: added in Parameter Set Version 6.60  */     
    RCP_PARAM_VOLTAGE_THRESHOLD,                      /**< VOLTHSH: added in Parameter Set Version 6.60 */
    RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD,               /**< EVOLTHSH: added in Parameter Set Version 6.60 */
    RCP_PARAM_VOLTAGE_BELOW_THRESHOLD,                /**< VLTBLWTH: added in Parameter Set Version 6.60 */
    RCP_PARAM_POWER_CURRENT_SOURCE_INDEX,             /**< PWISRCI: added in Parameter Set Version 6.50 */
    RCP_PARAM_VOLTAGE_THRESHOLD_DC_IN,                /**< VOLTHSDC: added in Parameter Set Version 6.61 */
    RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN,         /**< EVOLTHDC: added in Parameter Set Version 6.61 */

    RCP_PARAM_COUNT
} rcp_param_t;

typedef struct
{
    unsigned int major : 16;
    unsigned int minor : 16;
} rcp_version_t;

typedef struct
{
    rcp_version_t first;
    rcp_version_t last;
} rcp_version_range_t;

typedef struct
{
    const char * name;                  /**< Name of parameter */
    const char * label;                 /**< Label for parameter */
    int has_get;                        /**< If true, calls to @ref rcp_get are valid for this parameter */
    int has_get_list;                   /**< If true, calls to @ref rcp_get_list are valid for this parameter */
    int has_get_status;                 /**< If true, calls to @ref rcp_get_status are valid for this parameter */
    int has_get_periodic;               /**< If true, calls to @ref rcp_get_periodic_on/@ref rcp_get_periodic_off are valid for this parameter */
    int has_send;                       /**< If true, calls to @ref rcp_send are valid for this parameter */
    int has_set_int;                    /**< If true, calls to @ref rcp_set_int are valid for this parameter */
    int has_set_int_relative;           /**< If true, calls to @ref rcp_set_int_relative are valid for this parameter */
    int has_set_uint;                   /**< If true, calls to @ref rcp_set_uint are valid for this parameter */
    int has_set_uint_relative;          /**< If true, calls to @ref rcp_set_uint_relative are valid for this parameter */
    int has_set_str;                    /**< If true, calls to @ref rcp_set_str are valid for this parameter */
    int has_set_list;                   /**< If true, calls to @ref rcp_set_list are valid for this parameter */
    int has_set_list_relative;          /**< If true, calls to @ref rcp_set_list_relative are valid for this parameter */
    int has_display_str;                /**< If true, there is a display string available for this parameter */
    int has_edit_info;                  /**< If true, edit info exists for this parameter.  see @ref rcp_cur_int_edit_info_t, @ref rcp_cur_uint_edit_info_t, @ref rcp_cur_str_edit_info_t  */
    int update_list_only_on_close;      /**< If true, only set data once list is closed and not as the user scrolls through the list (this parameter takes a long time to apply the setting) */
} rcp_param_properties_t;

typedef enum
{
    RCP_PARAM_DISPLAY_STATUS_NORMAL,     /**< The parameter should be displayed in its default color (typically white). */

    RCP_PARAM_DISPLAY_STATUS_GOOD,       /**< The parameter should be displayed in a good color (typically green). */
    RCP_PARAM_DISPLAY_STATUS_WARNING,    /**< The parameter should be displayed in a warning color (typically yellow). */
    RCP_PARAM_DISPLAY_STATUS_WARNING2,   /**< The parameter should be displayed in a serious warning color (typically orange). */
    RCP_PARAM_DISPLAY_STATUS_ERROR,      /**< The parameter should be displayed in an error color (typically red). */
    RCP_PARAM_DISPLAY_STATUS_DISABLED,   /**< The parameter should be displayed in a disabled color (typically dark gray). */

    RCP_PARAM_DISPLAY_STATUS_RECORDING,  /**< The parameter should be displayed in a recording color (typically red). */
    RCP_PARAM_DISPLAY_STATUS_FINALIZING  /**< The parameter should be displayed in a finalizing color (typically yellow). */
} rcp_param_status_t;

typedef enum
{
    RCP_CONNECTION_STATE_INIT,                                      /**< The connection to the camera is being initialized. */
    RCP_CONNECTION_STATE_GET_REQUIRED_PARAMS,                       /**< Initialization is complete, but the API needs more information before allowing the application to continue.  */
    RCP_CONNECTION_STATE_CONNECTED,                                 /**< The connection has been established and communication is ready to continue. */
    RCP_CONNECTION_STATE_ERROR_RCP_VERSION_MISMATCH,                /**< There was an error establishing a connection due to RCP version mismatch. An updates RCP API is likely required. */
    RCP_CONNECTION_STATE_ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH,  /**< There was an error establishing a connection due to RCP parameter set version mismatch. An updates RCP API is likely required. */
    RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE,                 /**< RCP Communication is not allowed on this interface.  If once connected, connection should be closed. */
    RCP_CONNECTION_STATE_COMMUNICATION_ERROR,                       /**< There was a communication error with the camera. */
    RCP_CONNECTION_STATE_COUNT
} rcp_connection_state_t;

typedef struct
{
    size_t tx_packets;
    size_t tx_bytes;
    size_t rx_packets;
    size_t rx_bytes;
} rcp_camera_connection_stats_t;

typedef enum
{
    RCP_MUTEX_CONNECTION,
    RCP_MUTEX_DISCOVERY,
    RCP_MUTEX_COUNT
} rcp_mutex_t;

typedef enum
{
    RCP_LOG_ERROR,
    RCP_LOG_WARNING,
    RCP_LOG_INFO,
    RCP_LOG_DEBUG
} rcp_log_t;

typedef struct
{
    rcp_version_range_t version_range;      /**< For internal use */
    int32_t min;                            /**< Minimum allowed value */
    int32_t max;                            /**< Maximum allowed value */
    int32_t divider;                        /**< Divide the current value by @ref divider to get floating point representation */
    int32_t digits;                         /**< The number of digits show/allow in the floating point result */
    int32_t step;                           /**< Minimum step size (for non-divided value) */
    const char * prefix;                    /**< Text to be shown in-line before the user entered value */
    const char * prefix_decoded;            /**< Text to be shown in-line before the user entered value (decoded) */
    const char * suffix;                    /**< Text to be shown in-line after the user entered value */
    const char * suffix_decoded;            /**< Text to be shown in-line after the user entered value (decoded) */
} rcp_cur_int_edit_info_t;

/** This structure is passed into the current integer callback. */
typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    int32_t cur_val;                        /**< Current value of parameter. */
    int cur_val_valid;                      /**< If true, @ref cur_val contains valid data. */
    int32_t target_val;                     /**< Target value of parameter. */
    int target_val_valid;                   /**< If true, @ref target_val contains valid data. */
    const char * display_str;               /**< Current value formatted into a string to be displayed (contains special markups chars). */
    const char * display_str_decoded;       /**< Decoded version of @ref display_str. That is, all special markup chars have been replaced. */
    const char * display_str_abbr;          /**< Current value formatted into an abbreviated string to be displayed (contains special markups chars). */
    const char * display_str_abbr_decoded;  /**< Decoded version of @ref display_str_abbr. That is, all special markup chars have been replaced. */
    rcp_param_status_t display_str_status;  /**< Status associated with @ref display_str. That is, the color to display the string. */
    int display_str_valid;                  /**< If true, @ref display_str, @ref display_str_decoded, and @ref display_str_status contain valid data. */
    int display_str_in_list;                /**< If true, the display string needs to be retrieved from the list rather than the members in this struct. */
    rcp_cur_int_edit_info_t edit_info;      /**< Contains information required for manually editing the value */
    int edit_info_valid;                    /**< If true, the parameter can be editing using the properties described in @ref edit_info  */
} rcp_cur_int_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    int32_t default_val;                    /**< Default value of parameter. */
    int default_val_valid;                  /**< If true, @ref default_val contains valid data. */
} rcp_cur_default_int_cb_data_t;

typedef struct
{
    rcp_version_range_t version_range;      /**< For internal use */
    uint32_t min;                           /**< Minimum allowed value */
    uint32_t max;                           /**< Maximum allowed value */
    uint32_t divider;                       /**< Divide the current value by @ref divider to get floating point representation */
    uint32_t digits;                        /**< The number of digits show/allow in the floating point result */
    uint32_t step;                          /**< Minimum step size (for non-divided value) */
    const char * prefix;                    /**< Text to be shown in-line before the user entered value */
    const char * prefix_decoded;            /**< Text to be shown in-line before the user entered value (decoded) */
    const char * suffix;                    /**< Text to be shown in-line after the user entered value */
    const char * suffix_decoded;            /**< Text to be shown in-line after the user entered value (decoded) */
} rcp_cur_uint_edit_info_t;

/** This structure is passed into the current unsigned integer callback. */
typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    uint32_t cur_val;                       /**< Current value of parameter. */
    int cur_val_valid;                      /**< If true, @ref cur_val contains valid data. */
    uint32_t target_val;                    /**< Target value of parameter. */
    int target_val_valid;                   /**< If true, @ref target_val contains valid data. */
    const char * display_str;               /**< Current value formatted into a string to be displayed (contains special markups chars). */
    const char * display_str_decoded;       /**< Decoded version of @ref display_str. That is, all special markup chars have been replaced. */
    const char * display_str_abbr;          /**< Current value formatted into an abbreviated string to be displayed (contains special markups chars). */
    const char * display_str_abbr_decoded;  /**< Decoded version of @ref display_str_abbr. That is, all special markup chars have been replaced. */
    rcp_param_status_t display_str_status;  /**< Status associated with @ref display_str. That is, the color to display the string. */
    int display_str_valid;                  /**< If true, @ref display_str, @ref display_str_decoded, and @ref display_str_status contain valid data. */
    int display_str_in_list;                /**< If true, the display string needs to be retrieved from the list rather than the members in this struct. */
    rcp_cur_uint_edit_info_t edit_info;     /**< Contains information required for manually editing the value */
    int edit_info_valid;                    /**< If true, the parameter can be editing using the properties described in @ref edit_info  */
} rcp_cur_uint_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    uint32_t default_val;                   /**< Default value of parameter. */
    int default_val_valid;                  /**< If true, @ref default_val contains valid data. */
} rcp_cur_default_uint_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    const char * list_string;               /**< Raw string representation of list (needs to be converted to a cList or equivalent). */
    int list_string_valid;                  /**< If true, @ref list_string contains valid data. */
    int display_str_in_list;                /**< If true, the display string needs to be retrieved from this list rather than current message. */
    int32_t min_val;                        /**< Minimum value in list that is currently available on camera. Values outside this range can still be selected by the user as a target. Should be shown in an alternate color. */
    int min_val_valid;                      /**< If true, @ref min_val contains valid data. */
    int32_t max_val;                        /**< Maximum value in list that is currently available on camera. Values outside this range can still be selected by the user as a target. Should be shown in an alternate color. */
    int max_val_valid;                      /**< If true, @ref max_val contains valid data. */
    int send_int;                           /**< If true, send back integer value in set command. */
    int send_uint;                          /**< If true, send back unsigned integer value in set command. */
    int send_str;                           /**< If true, send back string value in set command. */
    int update_list_only_on_close;          /**< If true, only set data once list is closed and not as the user scrolls through the list (this parameter takes a long time to apply the setting) */
} rcp_cur_list_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    uint32_t red[128];                      /**< red data (4 bits per column - 128 columns)*/
    uint32_t green[128];                    /**< green data (4 bits per column - 128 columns)*/
    uint32_t blue[128];                     /**< blue data (4 bits per column - 128 columns)*/
    uint32_t luma[128];                     /**< luma data (4 bits per column - 128 columns)*/
    int32_t bottom_clip;                    /**< percent (0-100) of bottom clip bar (or goalpost) that should be filled in. */
    int32_t top_clip;                       /**< percent (0-100) of top clip bar (or goalpost) that should be filled in. */
    const char * display_str;               /**< Label that should be shown super-imposed on histogram. */
    const char * display_str_decoded;       /**< Decoded version of @ref display_str. That is, all special markup chars have been replaced. */
    const char * display_str_abbr;          /**< Abbreviated label that should be shown super-imposed on histogram. Use this version if @ref display_str is too long. */
    const char * display_str_abbr_decoded;  /**< Decoded version of @ref display_str_abbr. That is, all special markup chars have been replaced. */
} rcp_cur_hist_cb_data_t;

typedef struct
{
    rcp_version_range_t version_range;      /**< For internal use */
    size_t min_len;                         /**< Minimum number of characters allowed in string */
    size_t max_len;                         /**< Maximum number of characters allowed in string */
    int is_password;                        /**< If true, show this field as a password */
    const char * allowed_characters;        /**< If NULL, no characters limitations, else contains list of allowed characters  */
    const char * prefix;                    /**< Text to be shown in-line before the user entered value */
    const char * prefix_decoded;            /**< Text to be shown in-line before the user entered value (decoded) */
    const char * suffix;                    /**< Text to be shown in-line after the user entered value */
    const char * suffix_decoded;            /**< Text to be shown in-line after the user entered value (decoded) */
} rcp_cur_str_edit_info_t;

typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    const char * display_str;               /**< Current value formatted into a string to be displayed (contains special markups chars). */
    const char * display_str_decoded;       /**< Decoded version of @ref display_str. That is, all special markup chars have been replaced. */
    const char * display_str_abbr;          /**< Current value formatted into an abbreviated string to be displayed (contains special markups chars). */
    const char * display_str_abbr_decoded;  /**< Decoded version of @ref display_str_abbr. That is, all special markup chars have been replaced. */
    rcp_param_status_t display_str_status;  /**< Status associated with @ref display_str. That is, the color to display the string. */
    rcp_cur_str_edit_info_t edit_info;      /**< Contains information required for manually editing the value */
    int edit_info_valid;                    /**< If true, the parameter can be editing using the properties described in @ref edit_info  */
} rcp_cur_str_cb_data_t;

typedef struct
{
    char id[9];                         /**< Camera ID (setup in communication dialog on camera) */
    char pin[12];                       /**< Unique PIN of camera. */
    char type[50];                      /**< Type of camera (e.g. "EPIC-X") */
    char version[50];                   /**< Version of camera (e.g. "5.1.38") */
    rcp_interface_t rcp_interface;      /**< RCP Interface type to camera */
    int rcp_interface_enabled;          /**< If true, RCP is enabled on this interface */
    int rcp_interface_enabled_valid;    /**< If true, the value in @ref rcp_interface_enabled is valid */
} rcp_cam_info_t;

typedef struct
{
    rcp_camera_connection_t * con;        /**< Camera connection. */
    rcp_connection_state_t state;         /**< Current state of camera connection. */
    int32_t parameter_set_version_major;  /**< Camera RCP parameter set version (major) */
    int32_t parameter_set_version_minor;  /**< Camera RCP parameter set version (minor) */
    int parameter_set_newer;              /**< Camera RCP parameter set version is newer than APIs; upgrade API. */
    int parameter_set_version_valid;      /**< If true, the values in @ref parameter_set_version_major, @ref parameter_set_version_minor, and @ref parameter_set_newer */
    const rcp_cam_info_t * cam_info;      /**< Pointer to camera info structure of camera connected to */
} rcp_state_data_t;

typedef struct rcp_discovery_cam_info_list
{
    rcp_cam_info_t info;
    char ip_address[16];                /**< IP Address of camera (e.g. "192.168.0.2") */
    struct rcp_discovery_cam_info_list * next;
} rcp_discovery_cam_info_list_t;

typedef struct rcp_clip_info_list
{
    extended_clipinfo_t info;
    struct rcp_clip_info_list * next;
} rcp_clip_info_list_t;

typedef struct
{
    char * id;                          /**< Unique ID of notification.  Used in calls back into API.  */
    char * title;                       /**< Title of notification.  */
    char * message;                     /**< Message of notification.  '|' represents a new line. */
    notification_progress_t progress_type; /**< Type of progress bar to show */
    uint8_t progress_percent;           /**< Percentage to show on progress bar (only applicable for progress_type == NOTIFICATION_PROGRESS_NORMAL) */
    char * response_list;               /**< List of responses available to the user (should be shown as list of buttons) (needs to be converted to a cList or equivalent) */
    int32_t timeout;                    /**< Number of seconds for notification to auto-timeout (or 0 if no timeout) */
    int32_t type;                       /**< Internal use only */
} rcp_notification_t;

typedef enum
{
    NOTIFICATION_ACTION_OPEN,           /**< Open (or Show) the Notification  */
    NOTIFICATION_ACTION_UPDATE,         /**< Update the already open notification with the supplied information  */
    NOTIFICATION_ACTION_CLOSE           /**< Close the currently open notification */
} rcp_notification_action_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    rcp_notification_action_t action;           /**< Notification action  */
    const rcp_notification_t * notification;    /**< Notification details  */
} rcp_notification_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    int32_t input_db[4];                        /**< dB of audio input channels */
    int32_t output_db[6];                       /**< dB of audio output channels */
    int is_db_data_valid;                       /**< If true, @ref input_db and @ref output_db contain valid data. */
    int show_audio_vu_meters;                   /**< If true, Audio VU meters should be shown. */
    const char * input_label[4];                /**< Labels to use for input channels */
    const char * output_label[6];               /**< Labels to use for output channels */
    vu_meter_source_t vu_meter_source;          /**< Current display mode for vu meter (same as RCP_PARAM_AUDIO_VU_METER_SOURCE) */
    const char * no_audio_vu_info[2];           /**< If show_audio_vu_meters is false, these lines should be displayed instead of the VU meter. */
    int input_state[4];                         /**< If true, audio channel is enabled. */
    int bwf_valid;                              /**< If true, a broadcast wave file will be created during recording. */
} rcp_cur_audio_vu_cb_data_t;

typedef enum
{
    CLIP_LIST_LOADING,                  /**< API is loading current clip list */
    CLIP_LIST_DONE,                     /**< clip list is valid */
    CLIP_LIST_BLOCKED                   /**< clip list is unavailable at the moment; camera is busy (i.e. recording) */
} rcp_clip_list_status_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    rcp_clip_info_list_t * clip_list;           /**< linked list of clips */
    rcp_clip_list_status_t clip_list_status;    /**< status of @ref clip_list */
} rcp_cur_clip_list_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;      /**< Camera connection. */
    rcp_param_t id;                     /**< ID of parameter being updated. */
    tag_info_t tag_info;                /**< info on tag */
} rcp_cur_tag_info_cb_data_t;

typedef int rcp_menu_node_id_t;
#define RCP_MENU_NODE_ID_NULL ((rcp_menu_node_id_t) -1)
#define RCP_MENU_NODE_ID_ROOT ((rcp_menu_node_id_t) 0)

typedef struct
{
    /* common for all node types: */
    rcp_menu_node_type_t type;          /**< Type of node. */
    rcp_menu_node_filter_t filter;      /**< Filter for which camera modes this node is available. */
    rcp_menu_node_id_t id;              /**< ID of this node. */
    rcp_menu_node_id_t parent_id;       /**< ID of parent node.  */
    char * title;                       /**< Title of menu node. */
    int is_enabled;                     /**< If true, the node is enabled. */
    int is_enabled_valid;               /**< If true, @ref is_enabled contains valid data. */
    int is_supported;                   /**< If true, the node is supported by the camera hardware. */
    int is_supported_valid;             /**< If true, @ref is_supported contains valid data. */

    /* the following are only valid for leaf nodes: */
    rcp_param_t param_id;               /**< Parameter ID of node  */
    c_list_t * arg_c_list;              /**< Optional argument list */

    /* the following are only valid for RCP_MENU_NODE_TYPE_ACTION_LEAF
     * leaf nodes. */
    int has_payload;                    /**< Optional action has payload */
    int payload;                        /**< Optional action payload */

    /* the following are only valid for RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF */
    int key_code;

    /* the following are only valid for RCP_MENU_NODE_TYPE_NUMBER_LEAF
     * and RCP_MENU_NODE_TYPE_LIST_LEAF leaf nodes. */
    int send_int;                       /**< If true, send back integer value in set command. */
    int send_uint;                      /**< If true, send back unsigned integer value in set command. */
    int send_str;                       /**< If true, send back string value in set command. */
} rcp_menu_node_info_t;

typedef struct rcp_menu_node_list
{
    rcp_menu_node_info_t * info;
    struct rcp_menu_node_list * next;
} rcp_menu_node_list_t;

typedef struct
{
    rcp_camera_connection_t * con;        /**< Camera connection. */
    rcp_menu_node_id_t id;                /**< ID of current node. */
    rcp_menu_node_list_t * children_list; /**< List of all children of node ID. */
    rcp_menu_node_list_t * ancestor_list; /**< List of all ancestors of node ID.  The first entry is the current node, the next is its parent, etc. */
} rcp_cur_menu_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;        /**< Camera connection. */
    rcp_menu_node_id_t id;                /**< ID of current node. */
    int is_enabled;                       /**< If true, the node is enabled. */
    int is_enabled_valid;                 /**< If true, @ref is_enabled contains valid data. */
    int is_supported;                     /**< If true, the node is supported by the camera hardware. */
    int is_supported_valid;               /**< If true, @ref is_supported contains valid data. */
} rcp_cur_menu_node_status_cb_data_t;

/** This structure is passed into the current status callback. */
typedef struct
{
    rcp_camera_connection_t * con;          /**< Camera connection. */
    rcp_param_t id;                         /**< ID of parameter being updated. */
    int is_enabled;                         /**< If true, parameter @ref id should be enabled in any user displays. */
    int is_enabled_valid;                   /**< If true, @ref is_enabled contains valid data. */
    int is_supported;                       /**< If true, parameter @ref id is supported by the camera hardware. */
    int is_supported_valid;                 /**< If true, @ref is_supported contains valid data. */
} rcp_cur_status_cb_data_t;

typedef struct
{
    uint8_t data[16];
    char str[25];
} rcp_uuid_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    rcp_uuid_t uuid;
    rftp_error_t error;                         /**< Error status. */
    rftp_type_t rftp_type;                      /**< Type of operation (store, retrieve, abort, delete, list). */
    uint8_t * data;                             /**< Pointer to data being sent/retrieved. */
    int64_t data_size;                          /**< Size of @ref data. */
    int is_compressed;                          /**< If true, @ref data contains compressed data. */
    int32_t percent_complete;                   /**< Transfer completion percentage. */
    const char * directory_list_string;         /**< Raw string representation of the directory listing for a specific directory (needs to be converted to a cList or equivalent). */
    const char * md5sum;                        /**< MD5 hex string of file being retrieved from the camera. Only applicable on tethered retrieve transfers. */
    int is_paused;                              /**< If true, data flow is paused for this transfer. */
} rcp_cur_rftp_status_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    const char * id;                            /**< User ID. */
    const char * value;                         /**< User Value (NULL if none). */
} rcp_handle_user_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    const char * id;                            /**< User ID. */
    int is_registered;                          /**< If true, the ID specified is registered with the camera. */
    uint32_t max_len;                           /**< Amount of space reserved for this ID.  Note: this may be smaller than the amount requested. */
} rcp_handle_user_metadata_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    const c_list_t * action_c_list;             /**< List of mappable actions. */
} rcp_cur_action_list_cb_data_t;

typedef struct
{
    rcp_camera_connection_t * con;              /**< Camera connection. */
    const c_list_t * action_c_list;             /**< List of mappable actions. */
    int key_code;                               /**< Key code */
    key_action_t key_action;                    /**< Action assigned to key_code */
    const char * key_action_param;              /**< Parameter portion of key_action (only applicable for certain key_actions, e.g.: KEY_ACTION_APPLY_PRESET */
} rcp_cur_key_mapping_cb_data_t;

/** Error codes for RCP_API functions. It is good practice to always
 * check the error codes for every call into the RCP API. For future
 * compatibility it is safer to check that the return value is !=
 * RCP_SUCCESS rather than checking for specific errors. The specific
 * error can be used for debugging or informational purposes. */
typedef enum
{
    RCP_SUCCESS,                                    /**< Success. */
    RCP_ERROR_BAD_PARAM,                            /**< One of the parameters passed in to the function was bad. */
    RCP_ERROR_NO_GET,                               /**< An RCP GET command was attempted for a parameter without a GET command. */
    RCP_ERROR_NO_GET_LIST,                          /**< An RCP GET_LIST command was attempted for a parameter without a GET_LIST command.*/
    RCP_ERROR_NO_GET_PERIODIC,                      /**< An RCP GET_PERIODIC command was attempted for a parameter without a GET_PERIODIC command.*/
    RCP_ERROR_NO_GET_DEFAULT,                       /**< An RCP GET DEFAULT command was attempted for a parameter without a GET DEFAULT command. */
    RCP_ERROR_NO_SET,                               /**< An RCP SET command was attempted for a parameter without a SET command. */
    RCP_ERROR_SET_WRONG_TYPE,                       /**< An RCP SET command was attempted for a parameter with the incorrect payload type. */
    RCP_ERROR_SEND_DATA_TO_CAM_FAILED,              /**< To be returned by send_data_to_camera_cb callback if there was an error sending data out to the camera. */
    RCP_ERROR_TETHERED_RFTP_TRANSFER_IN_PROGRESS,   /**< To be returned by _rcp_rftp_retr if a tethered file retrieval was requested while one was already in progress. */
    RCP_ERROR_NOT_SUPPORTED,                        /**< This feature is not supported by the connected camera. */
    RCP_ERROR_INTERNAL                              /**< An internal RCP API error occurred. */
} rcp_error_t;

typedef rcp_error_t (* rcp_send_data_to_camera_cb_t) (const char * data, size_t len, void * user_data);
typedef void (* rcp_cur_int_cb_t) (const rcp_cur_int_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_uint_cb_t) (const rcp_cur_uint_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_list_cb_t) (const rcp_cur_list_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_hist_cb_t) (const rcp_cur_hist_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_str_cb_t) (const rcp_cur_str_cb_data_t * data, void * user_data);
typedef void (* rcp_clip_list_cb_t) (const rcp_cur_clip_list_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_tag_cb_t) (const rcp_cur_tag_info_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_status_cb_t) (const rcp_cur_status_cb_data_t * data, void * user_data);
typedef void (* rcp_notification_cb_t) (const rcp_notification_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_audio_vu_cb_t) (const rcp_cur_audio_vu_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_menu_cb_t) (const rcp_cur_menu_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_menu_node_status_cb_t) (const rcp_cur_menu_node_status_cb_data_t * data, void * user_data);
typedef void (* rcp_state_cb_t) (const rcp_state_data_t * data, void * user_data);
typedef void (* rcp_broadcast_data_to_cameras_cb_t) (const char * data, size_t len, void * user_data);
typedef void (* rcp_rftp_status_cb_t) (const rcp_cur_rftp_status_cb_data_t * data, void * user_data);
typedef void (* rcp_handle_user_cb_t) (const rcp_handle_user_cb_data_t * data, void * user_data);
typedef void (* rcp_handle_user_metadata_cb_t) (const rcp_handle_user_metadata_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_default_int_cb_t) (const rcp_cur_default_int_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_default_uint_cb_t) (const rcp_cur_default_uint_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_action_list_cb_t) (const rcp_cur_action_list_cb_data_t * data, void * user_data);
typedef void (* rcp_cur_key_mapping_cb_t) (const rcp_cur_key_mapping_cb_data_t * data, void * user_data);

typedef struct
{
    const char * client_name;                               /**< Name of application (to be shown to user in camera) e.g.: "Test Application"  */
    const char * client_version;                            /**< Version of application (to be shown to user in camera) e.g.: "1.2.3"  */
    const char * client_user;                               /**< Application specific user data (to be shown to user in camera). can be used to show user logged in, device type, etc. */

    rcp_send_data_to_camera_cb_t send_data_to_camera_cb;    /**< Callback for sending data to camera. */
    void * send_data_to_camera_cb_user_data;                /**< User data to be sent back with call to @ref send_data_to_camera_cb. */

    rcp_cur_int_cb_t cur_int_cb;                            /**< Callback for CURRENT messages with integer payload. */
    void * cur_int_cb_user_data;                            /**< User data to be sent back with call to @ref cur_int_cb. */

    rcp_cur_uint_cb_t cur_uint_cb;                          /**< Callback for CURRENT messages with unsigned integer payload. */
    void * cur_uint_cb_user_data;                           /**< User data to be sent back with call to @ref cur_uint_cb. */

    rcp_cur_list_cb_t cur_list_cb;                          /**< Callback for CURRENT_LIST messages with list payload. */
    void * cur_list_cb_user_data;                           /**< User data to be sent back with call to @ref cur_list_cb. */

    rcp_cur_hist_cb_t cur_hist_cb;                          /**< Callback for CURRENT messages with histogram payload. */
    void * cur_hist_cb_user_data;                           /**< User data to be sent back with call to @ref cur_hist_cb. */

    rcp_cur_str_cb_t cur_str_cb;                            /**< Callback for CURRENT messages with string payload. */
    void * cur_str_cb_user_data;                            /**< User data to be sent back with call to @ref cur_str_cb. */

    rcp_clip_list_cb_t clip_list_cb;                        /**< Callback for updates to media list. */
    void * clip_list_cb_user_data;                          /**< User data to be send back with call to @ref clip_list_cb. */

    rcp_cur_tag_cb_t cur_tag_cb;                            /**< Callback for CURRENT messages with tag info payload. */
    void * cur_tag_cb_user_data;                            /**< User data to be sent back with call to @ref cur_tag_cb. */

    rcp_cur_status_cb_t cur_status_cb;                      /**< Callback for status changes to a parameter. */
    void * cur_status_cb_user_data;                         /**< User data to be sent back with call to @ref cur_status_cb. */

    rcp_notification_cb_t notification_cb;                  /**< Callback for notifications. */
    void * notification_cb_user_data;                       /**< User data to be sent back with call to @ref notification_cb. */

    rcp_cur_audio_vu_cb_t cur_audio_vu_cb;                  /**< Callback for CURRENT message with audio vu payload. */
    void * cur_audio_vu_cb_user_data;                       /**< User data to be sent back with call to @ref cur_audio_vu_cb. */

    rcp_cur_menu_cb_t cur_menu_cb;                          /**< Callback for menu tree. */
    void * cur_menu_cb_user_data;                           /**< User data to be sent back with call to @ref cur_menu_cb. */

    rcp_cur_menu_node_status_cb_t cur_menu_node_status_cb;  /**< Callback for menu tree node status. */
    void * cur_menu_node_status_cb_user_data;               /**< User data to be sent back with call to @ref cur_menu_node_status_cb. */

    rcp_rftp_status_cb_t rftp_status_cb;                    /**< Callback for rftp status. */
    void * rftp_status_cb_user_data;                        /**< User data to be sent back with call to @ref rftp_status_cb. */

    rcp_handle_user_cb_t handle_user_set_cb;                /**< Callback for handling SET USER messages. */
    void * handle_user_set_cb_user_data;                    /**< User data to be sent back with call to @ref handle_user_set_cb. */

    rcp_handle_user_cb_t handle_user_get_cb;                /**< Callback for handling GET USER messages. */
    void * handle_user_get_cb_user_data;                    /**< User data to be sent back with call to @ref handle_user_get_cb. */

    rcp_handle_user_cb_t handle_user_current_cb;            /**< Callback for handling CURRENT USER messages. */
    void * handle_user_current_cb_user_data;                /**< User data to be sent back with call to @ref handle_user_current_cb. */

    rcp_handle_user_metadata_cb_t handle_user_metadata_cb;  /**< Callback for handling USER METADATA registration ack/nak */
    void * handle_user_metadata_cb_user_data;               /**< User data to be sent back with call to @ref handle_user_metadata_cb. */

    rcp_cur_default_int_cb_t cur_default_int_cb;            /**< Callback for handling CURRENT DEFAULT messages with integer payload. */
    void * cur_default_int_cb_user_data;                    /**< User data to be sent back with call to @ref cur_default_int_cb. */

    rcp_cur_default_uint_cb_t cur_default_uint_cb;          /**< Callback for handling CURRENT DEFAULT messages with unsigned integer payload. */
    void * cur_default_uint_cb_user_data;                   /**< User data to be sent back with call to @ref cur_default_uint_cb. */

    rcp_cur_action_list_cb_t cur_action_list_cb;            /**< Callback for key mapping action list. */
    void * cur_action_list_cb_user_data;                    /**< User data to be sent back with call to @ref cur_action_list_cb. */

    rcp_cur_key_mapping_cb_t cur_key_mapping_cb;            /**< Callback for current key mapping. */
    void * cur_key_mapping_cb_user_data;                    /**< User data to be send back with call to @ref cur_key_mapping_cb. */

    rcp_state_cb_t state_cb;                                /**< Callback for changes in connection state. */
    void * state_cb_user_data;                              /**< User data to be sent back with call to @ref state_cb. */
} rcp_camera_connection_info_t;

const char * c_list_strings_to_compress_1[] =
{
	"&redformatk; ",
	"&redformatk;",
	"&redkelvin;",
	"&redana125;",
	"&redana165;",
	"&red1over;",
	"&redana13;",
	"&redana15;",
	"&redana18;",
	"&redcheck;",
	"&redfover;",
	"&redana2;",
	"&redsub2;",
	"&redfps;",
	"&rediso;",
	"&redsec;",
	"&redae;",
	"&redav;",
	"&redll;",
	"&trade;",
	"&copy;",
	"&amp;",
	"&deg;",
	"&reg;",
	"2%:1",
	"3%:2",
	"6%:5",
	"4%:1",
	"8%:1",
	"5%:4",
	"4%:3",
	"5.5",
	"4.5",
	"3.5",
	"2.5",
	"HD",
	"WS"
};


/** @brief Get version of RCP API
 *
 * @returns version of RCP API (in string form, e.g. "1.2.3")
 * */
const char * rcp_api_get_version(void);

/** @brief Process incoming camera data.
 *
 * Must be called from the client code with any data received by an
 * open camera connection.
 *
 * @param[in] con   the camera connection
 * @param[in] data  data received (from TCP port, serial port, etc)
 * @param[in] len   number of bytes pointed to by data
 * */
void rcp_process_data(rcp_camera_connection_t * con, const char * data, size_t len);

/** @brief Get name of RCP parameter.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @returns the name of the RCP parameter identified by id.
 * */
const char * rcp_get_name(const rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Get label for RCP parameter.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @returns the label of the RCP parameter identified by id.
 * */
const char * rcp_get_label(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Get ID for RCP parameter by name
 *
 * @param[in] con   the camera connection
 * @param[in] name  name of the RCP parameter
 * @returns the id of the RCP parameter identified by name, or
 * RCP_PARAM_COUNT if the name is not found.
 * */
rcp_param_t rcp_get_id(const rcp_camera_connection_t * con, const char * name);

/** @brief Get update_list_only_on_close property of RCP parameter.
 *
 * @deprecated use the update_list_only_on_close flag in the cur_list
 * callback or update_list_only_on_close flag in @ref
 * rcp_param_properties_t (@ref rcp_get_is_supported) instead.
 *
 * Most RCP parameters should live update as their values are selected
 * in the list presented to the user. However, there are a few
 * parameters that take a significant amount of time to take effect -
 * in these cases the new value should only be sent to the camera after
 * the value has been selected and the list has been dismissed.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @retval 0    this RCP parameter should be updated as the list is modified.
 * @retval 1    this RCP parameter should only be updated after the list is closed.
 * */
int rcp_get_update_list_only_on_close(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Check if parameter is supported by connected camera.
 *
 * Check if the given parameter is supported by the connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if a parameter is available.  This should be used to
 * conditionally show newer commands to the user when connecting to
 * older camera builds.
 *
 * @param[in] con           the camera connection
 * @param[in] id            the RCP parameter
 * @param[out] properties   properties of the parameter (pass in NULL
 * if not required)
 *
 * @retval 0    this RCP parameter is not supported by the connected camera.
 * @retval 1    this RCP parameter is supported by the connected camera.
 * */
int rcp_get_is_supported(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_properties_t * properties);

/** @brief Request RCP parameter data from the camera.
 *
 * This will send an RCP GET message to the camera for the given RCP
 * parameter.  Note: if the data is cacheable and cached a message may
 * not be sent to the camera, instead the cached data will be sent
 * directly to the application via the appropriate current callback
 * function.
 *
 * The data requested with this call will be returned in one of the
 * callbacks: cur_int_cb, cur_uint_cbm cur_str_cb, etc.
 *
 * A simple transaction is shown below:
 *
 * @msc
 *  cam,app,api;
 *  |||;
 *  app=>api [label="rcp_get()", url="@ref rcp_get"];
 *  --- [label="if data is not cached"];
 *  api=>>app [label="send_data_to_camera_cb()"];
 *  app->cam [label="RCP G:PARAM:"];
 *  ...;
 *  cam->app [label="RCP C:PARAM:"];
 *  app=>api [label="rcp_process_data()", url="@ref rcp_process_data"];
 *  --- [label="endif"];
 *  api=>>app [label="cur_<type>_cb"];
 * @endmsc
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Request RCP parameter list from the camera.
 *
 * This will send an RCP GET_LIST message to the camera for the given RCP
 * parameter.
 *
 * The list requested with this call will be returned in the
 * callback: cur_list_cb.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_list(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Request RCP parameter status from the camera.
 *
 * The status requested with this call will be returned in the
 * callback: cur_status_cb.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_status(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Request RCP parameter default value from the camera.
 *
 * The default value requested with this call will be returned in one of the callbacks:
 * cur_default_int_cb, cur_default_uint_cb
 *
 * @note Not all parameters will have a default value.
 *
 * @note Cameras running firmware with an RCP Parameter Set version
 * less than 6.50 will not support default values for any parameter.
 *
 * If called with a parameter that does not have a default value the
 * function will either return with RCP_ERROR_NO_GET_DEFAULT, or the
 * callback will be called with default_val_valid set to 0.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_default(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Request RCP parameter status from the camera.
 *
 * The clip list requested with this call will be returned in the
 * callback: cur_clip_list_cb.
 *
 * @param[in] con   the camera connection
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_clip_list(rcp_camera_connection_t * con);

/** @brief Send RCP parameter to camera
 *
 * This is used to send a parameter to the camera that does not take
 * any arguments.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_send(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Set integer value for RCP parameter.
 *
 * This is used to set a value on the camera. This value usually comes
 * from a list provided by the camera or an enum found in
 * rcp_types_public.h rather than directly given by the user or
 * hard-coded in the client application.
 *
 * @note Do not assume the set will be honored by the camera. Always
 * rely on CURRENT messages from the camera to display data to the
 * user. For example, to toggle record on the camera you can call @code
 * rcp_set_int(con, RCP_PARAM_RECORD_STATE, SET_RECORD_STATE_TOGGLE);
 * @endcode
 * However, record should not be indicated on the client application
 * until an incoming CURRENT for RCP_PARAM_RECORD_STATE with the value
 * of RECORD_STATE_RECORDING has been received.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @param[in] val   value to set
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val);

/** @brief Set integer value for RCP parameter given an offset.
 *
 * Similar to @ref rcp_set_int except instead of providing the absolute
 * parameter value, an offset to the current value is used to calculate
 * the new value.
 *
 * @param[in] con       the camera connection
 * @param[in] id        the RCP parameter
 * @param[in] offset    offset to the current value
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_int_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);

/** @brief Set unsigned integer value for RCP parameter.
 *
 * This is used to set a value on the camera. This value usually comes
 * from a list provided by the camera or an enum found in
 * rcp_types_public.h rather than directly given by the user or
 * hard-coded in the client application.
 *
 * @note Do not assume the set will be honored by the camera. Always
 * rely on CURRENT messages from the camera to display data to the
 * user.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @param[in] val   value to set
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_uint(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val);

/** @brief Set unsigned integer value for RCP parameter given an offset.
 *
 * Similar to @ref rcp_set_uint except instead of providing the absolute
 * parameter value, an offset to the current value is used to calculate
 * the new value.
 *
 * @param[in] con       the camera connection
 * @param[in] id        the RCP parameter
 * @param[in] offset    offset to the current value
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_uint_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);

/** @brief Set string value for RCP parameter.
 *
 * This is used to set a value on the camera.
 *
 * @note Do not assume the set will be honored by the camera. Always
 * rely on CURRENT messages from the camera to display data to the
 * user.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @param[in] val   value to set
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_str(rcp_camera_connection_t * con, rcp_param_t id, const char * val);

/** @brief Set list value for RCP parameter.
 *
 * This is used to set a list value on the camera.
 *
 * @note Do not assume the set will be honored by the camera. Always
 * rely on CURRENT messages from the camera to display data to the
 * user.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 * @param[in] val   stringified c_list to set
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_list(rcp_camera_connection_t * con, rcp_param_t id, const char * val);

/** @brief Set list (by value) with relative offset.
 *
 * This is not like @ref rcp_set_list which changes the entire list,
 * instead this is like calling @ref rcp_set_int, @ref rcp_set_uint, or
 * @ref rcp_set_str on a parameter based on the relative entry in its
 * list.
 *
 * For example, to set the ISO to the next (higher value) in the list
 * call:
 * @code
 * rcp_set_list_relative(con, RCP_PARAM_ISO, 1);
 * @endcode
 * to set the ISO to the previous (lower value) in the list call:
 * @code
 * rcp_set_list_relative(con, RCP_PARAM_ISO, -1);
 * @endcode
 *
 * @param[in] con       the camera connection
 * @param[in] id        the RCP parameter
 * @param[in] offset    offset to the current index of the list
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_set_list_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);

/** @brief Check if the get_periodic feature is supported by connected camera.
 *
 * Check if the get_periodic feature is supported by the connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.  This should be used to conditionally
 * before calling rcp_get_periodic_on/off
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    get_periodic is not supported by the connected camera.
 * @retval 1    get_periodic is supported by the connected camera.
 * */
int rcp_get_periodic_is_supported(rcp_camera_connection_t * con);

/** @brief Enable periodic RCP parameter data from the camera.
 *
 * This will send an RCP GET_PERIODIC message to the camera for the
 * given RCP parameter, with a value of 1 to enable the periodic data
 * to be sent.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_periodic_on(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Disable periodic RCP parameter data from the camera.
 *
 * This will send an RCP GET_PERIODIC message to the camera for the
 * given RCP parameter, with a value of 0 to disable the periodic data
 * to be sent.
 *
 * @param[in] con   the camera connection
 * @param[in] id    the RCP parameter
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_get_periodic_off(rcp_camera_connection_t * con, rcp_param_t id);

/** @brief Get current notification.
 *
 * This function will cause the notification callback to be re-called with
 * the current notification to be displayed (if there is one).
 *
 * Note: this function doesn't usually need to be called.  Only call
 * it, if for some reason, your application ignores notification
 * callbacks until some specific time during execution.  Once your
 * application is ready to handle the notification callbacks, call this
 * function one time.
 *
 * @param[in] con   the camera connection
 *
 * @return RCP_SUCCESS on success. */
rcp_error_t rcp_notification_get(rcp_camera_connection_t * con);

/** @brief Current notification has timed out.
 *
 * This function should be called to notify the API that the timeout
 * associated with the current notification has expired and that the
 * notification should be closed.
 *
 * Note: this can also be called if the user dismisses a timeout based
 * notification by tapping on it (or other application specific
 * appropriate action)
 *
 * Note: the client code should wait until the API issues a CLOSE
 * action on the current notification before actually closing it
 *
 * @param[in] con   the camera connection
 * @param[in] id    the notification ID
 *
 * @return RCP_SUCCESS on success. */
rcp_error_t rcp_notification_timeout(rcp_camera_connection_t * con, const char * id);

/** @brief Send response for current notification.
 *
 * This function should be called when a user responds to a
 * notification by selecting one of the response options.
 *
 * @param[in] con        the camera connection
 * @param[in] id         the notification ID
 * @param[in] response   value of response selected
 *
 * @return RCP_SUCCESS on success. */
rcp_error_t rcp_notification_response(rcp_camera_connection_t * con, const char * id, int32_t response);

/** @brief Check if menu tree is supported by connected camera.
 *
 * Check if the menu tree is supported by the connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.  This should be used to conditionally
 * allow the user to pull up a menu tree.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    The menu tree is not supported by the connected camera.
 * @retval 1    The menu tree is supported by the connected camera.
 * */
int rcp_menu_is_supported(const rcp_camera_connection_t * con);

/** @brief Request menu tree children for given parent node.
 *
 * After requesting the children of a node, the response will be sent
 * back in the cur_menu_cb callback.  The payload includes a
 * linked-list of children and ancestors.
 *
 * Note: the root node ID is RCP_MENU_NODE_ID_ROOT.
 *
 * @param[in] con       the camera connection
 * @param[in] id        id of the parent node
 *
 * @return RCP_SUCCESS on success
 * */
rcp_error_t rcp_menu_get_children(rcp_camera_connection_t * con, rcp_menu_node_id_t id);

/** @brief Check if menu node status is supported by connected camera.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    Menu node status is not supported by the connected camera.
 * @retval 1    Menu node status is supported by the connected camera.
 * */
int rcp_menu_node_status_is_supported(const rcp_camera_connection_t * con);

/** @brief Request menu tree status for given node.
 *
 * @param[in] con       the camera connection
 * @param[in] id        id of the node
 *
 * @return RCP_SUCCESS on success
 * */
rcp_error_t rcp_menu_get_node_status(rcp_camera_connection_t * con, rcp_menu_node_id_t id);

/** @brief Convert user-defined int32 value in arg_c_list for multi
 * action list leaf into flags.
 *
 * @param[in] con       the camera connection
 * @param[in] data data from user_defined.int32 field of clist
 *
 * @return flags as a bitfield
 *  */
uint32_t rcp_menu_get_multi_action_list_leaf_flags(const rcp_camera_connection_t * con, int32_t data);

/** @brief Create camera connection to the RCP API.
 *
 * Before this function is called a physical connection must already
 * be established with a camera. For example, this can be a TCP socket
 * or Serial port connection.
 *
 * The RCP API will attempt to establish a connection to the camera and
 * verify the version to ensure proper communication can be made
 * using this version of the RCP API. Once this has been completed the
 * connection state will change to @ref RCP_CONNECTION_STATE_CONNECTED.
 *
 * No calls to @ref rcp_get, @ref rcp_get_list, @ref rcp_set_int, @ref
 * rcp_set_uint, or @ref rcp_set_str should be made
 * until the RCP_CONNECTION_STATE_CONNECTED state has been reached.
 *
 * It is up to the client code to terminate the connection (by calling
 * @ref rcp_delete_camera_connection) if the
 * RCP_CONNECTION_STATE_CONNECTED state has not been reached after an
 * appropriate timeout or one of the error states has been reached.
 *
 * @param[in] info  structure containing all the required callback
 * information.
 *
 * @returns pointer to camera connection or NULL if there was an error.
 * */
rcp_camera_connection_t * rcp_create_camera_connection(const rcp_camera_connection_info_t * info);

/** @brief Close and cleanup camera connection.
 *
 * This function should be called when a connection with a camera has
 * been lost or the user wants to disconnect from the camera. It will
 * free up any allocated memory.
 *
 * @param[in] con   camera connection to terminate.
 * */
void rcp_delete_camera_connection(rcp_camera_connection_t * con);

/** @brief Get stats regarding camera connection
 *
 * Get stats about connection, such as number of packets/bytes sent and
 * received.
 *
 * @param[in] con       camera connection
 * @param[out] stats    stats for given connection
 *
 * @return RCP_SUCCESS on success */
rcp_error_t rcp_camera_connection_stats(const rcp_camera_connection_t * con, rcp_camera_connection_stats_t * stats);

/** @brief Start camera discovery process.
 *
 * This function is used to start the camera discovery processes. For
 * GigE or wireless networks, this process is performed via broadcast
 * UDP packets on port 1112.
 *
 * @msc
 *  camA,camB,camC,app,api;
 *  |||;
 *  app=>api [label="rcp_discovery_start()", url="@ref rcp_discovery_start"];
 *  app box app [label="start RCP_DISCOVERY_STEP_SLEEP_MS delay"];
 *  api=>>app [label="cb()"];
 *  app->camA [label="broadcast UDP"], app->camB, app->camC;
 *  camA->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  camB->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  camC->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  ...;
 *  app box app [label="end RCP_DISCOVERY_STEP_SLEEP_MS delay"];
 *  --- [label="begin loop RCP_DISCOVERY_STEP_LOOP_COUNT times"];
 *  app=>api [label="rcp_discovery_step()", url="@ref rcp_discovery_step"];
 *  app box app [label="start RCP_DISCOVERY_STEP_SLEEP_MS delay"];
 *  api=>>app [label="cb()"];
 *  app->camA [label="broadcast UDP"], app->camB, app->camC;
 *  camA->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  camB->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  camC->app [label="udp packet"];
 *  app=>api [label="rcp_discovery_process_data", url = "@ref rcp_discovery_process_data"];
 *  ...;
 *  app box app [label="end RCP_DISCOVERY_STEP_SLEEP_MS delay"];
 *  --- [label="end loop RCP_DISCOVERY_STEP_LOOP_COUNT times"];
 *  app=>api [label="rcp_discovery_get_list()", url="@ref rcp_discovery_get_list"];
 *  app=>app [label="copy list"];
 *  app=>api [label="rcp_discovery_free_list()", url="@ref rcp_discovery_free_list"];
 *  app=>api [label="rcp_discovery_end()", url="@ref rcp_discovery_end"];
 * @endmsc
 *
 *
 * After this call is made @ref rcp_discovery_step must be called @ref
 * RCP_DISCOVERY_STEP_LOOP_COUNT times, with a delay of @ref
 * RCP_DISCOVERY_STEP_SLEEP_MS after the call to @ref
 * rcp_discovery_start and after each call to @ref rcp_discovery_step.
 * The list of cameras discovered can be retrieved with a call to @ref
 * rcp_discovery_get_list. Once the data in the camera list has been
 * copied, a call to @ref rcp_discovery_free_list should be made to
 * free the memory. Finally, a call to @ref rcp_discovery_end should be
 * made to clear all memory used internally by the discovery process.
 *
 * During the discovery process all incoming data must be fed into the
 * RCP API using @ref rcp_discovery_process_data.  It is recommended to
 * have a helper thread listening for incoming UDP packets on port 1112
 * and relaying all data via this call.
 *
 * @param[in] cb    callback used for broadcasting data to all cameras.
 * WHen this callback is called, the data should be sent as a broadcast
 * UDP packet out port 1112.
 * @param[in] cb_user_data  additional user data passed into the
 * callback.  If not required, use NULL.
 * */
void rcp_discovery_start(rcp_broadcast_data_to_cameras_cb_t cb, void * cb_user_data);

/** @brief Continue camera discovery process.
 *
 * @note See the description of @ref rcp_discovery_start for details on the
 * camera discovery process. */
void rcp_discovery_step(void);

/** @brief Get list of discovered cameras.
 *
 * @note See the description of @ref rcp_discovery_start for details on the
 * camera discovery process.
 *
 * @returns linked list of cameras discovered. To free memory
 * associated with this list a call to @ref rcp_discovery_free_list
 * must be made after its contents are no longer required.
 * rcp_discovery_clear_list is made.*/
rcp_discovery_cam_info_list_t * rcp_discovery_get_list(void);

/** @brief Clears list of discovered cameras.
 *
 * Clears list by freeing all memory associated with link list. Do not
 * try to reference the list pointer after this function has been
 * called.
 *
 * @note See the description of @ref rcp_discovery_start for details on the
 * camera discovery process.
 *
 * @param[in] list  list to free
 * */
void rcp_discovery_free_list(rcp_discovery_cam_info_list_t * list);

/** @brief Process incoming discovery camera data.
 *
 * Must be called from the client code with any data received on the
 * camera discovery channel (UDP port 1112).
 *
 * @param[in] data      data from UDP packet
 * @param[in] len       length of data in UDP packet
 * @param[in] from_ipv4 Source IPv4 address of UDP packet
 * (NULL-terminates string in dotted-decimal notation. e.g.:
 * "192.168.0.1")
 *
 * @note See the description of @ref rcp_discovery_start for details on the
 * camera discovery process.
 * */
void rcp_discovery_process_data(const char * data, size_t len, const char * from_ipv4);

/** @brief End the camera discovery process.
 *
 * Clears all memory allocated internally for the camera discovery
 * process.
 *
 * @note See the description of @ref rcp_discovery_start for details on the
 * camera discovery process.
 * */
void rcp_discovery_end(void);

/** @brief Check if rftp operations are supported by connected camera.
 *
 * Check if the rftp operations are supported by the connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    The rftp operations are not supported by the connected camera.
 * @retval 1    The rftp operations are supported by the connected camera.
 * */
int rcp_rftp_is_supported(const rcp_camera_connection_t * con);

/** @brief Check if rftp tethered file retrieval is supported by connected camera.
 *
 * Check if rftp tethered file retrieval is supported by the connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    The rftp tethered file retrieval is not supported by the connected camera.
 * @retval 1    The rftp tethered file retrieval is supported by the connected camera.
 * */
int rcp_rftp_tethered_is_supported(const rcp_camera_connection_t * con);

/** @brief Send file to camera
 *
 * Sends a file to the camera.  This can be a preset file, overlay
 * file, upgrade image, etc.
 *
 *
 * @param[in] con                   the camera connection
 * @param[in] path                  destination path of the file on the camera
 * @param[in] data                  data of the file to be sent
 * @param[in] uncompressed_len      uncompressed length of @p data
 * @param[in] compressed_len        compressed length of @p data
 * @param[in] file_is_compressed    if true, @p data contains compressed data
 * @param[out] uuid                 UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_send_file(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, rcp_uuid_t * uuid);

/** @brief Send file to camera
 *
 * Sends a file to the camera.  This can be a preset file, overlay
 * file, upgrade image, etc.
 *
 *
 * @param[in] con                   the camera connection
 * @param[in] path                  destination path of the file on the camera
 * @param[in] data                  data of the file to be sent
 * @param[in] uncompressed_len      uncompressed length of @p data
 * @param[in] compressed_len        compressed length of @p data
 * @param[in] file_is_compressed    if true, @p data contains compressed data
 * @param[in] fragment_size         number of base64-encoded bytes of data sent per fragment
 * @param[out] uuid                 UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_send_file_v2(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, int fragment_size, rcp_uuid_t * uuid);

/** @brief Retrieve file from camera
 *
 * Retrieves a file from the camera.  This can be a preset file, overlay
 * file, look file, etc.
 *
 *
 * @param[in] con                   the camera connection
 * @param[in] path                  destination path of the file on the camera
 * @param[in] max_file_size         maximum acceptable file size
 * @param[in] compression_allowed   if true, the file data can be compressed
 * @param[out] uuid                 UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_retrieve_file(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, rcp_uuid_t * uuid);

/** @brief Retrieve file from camera using the RED streaming protocol (for internal RED use only)
 *
 * Retrieves a file from the camera.  This can be a preset file, overlay
 * file, look file, etc.
 *
 * @note Only one tethered transfer is allowed at a time.  This call
 * will fail if a previous tethered transfer is still in progress.
 *
 * @param[in] con                   the camera connection
 * @param[in] path                  destination path of the file on the camera
 * @param[in] max_file_size         maximum acceptable file size
 * @param[in] compression_allowed   if true, the file data can be compressed
 * @param[out] uuid                 UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_retrieve_file_tethered(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, rcp_uuid_t * uuid);

/** @brief Abort store or retrieve file transfer
 *
 * Halts a file transfer, whether a file is being sent to the camera or
 * being retrieved from the camera.
 *
 * @param[in] con              the camera connection
 * @param[in] uuid             UUID object of transfer to abort
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_abort_transfer(rcp_camera_connection_t * con, rcp_uuid_t * uuid);

/** @brief Delete file from camera
 *
 * Deletes a file from the camera.  This can be a preset file, overlay
 * file, upgrade image, etc.
 *
 * @param[in] con               the camera connection
 * @param[in] path              destination path of the file on the camera
 * @param[out] uuid             UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_delete_file(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid);

/** @brief Get virtual directory listing from camera
 *
 * Gets a directory listing for a virtual path from the camera.
 *
 * @param[in] con       the camera connection
 * @param[in] path      virtual path on the camera
 * @param[out] uuid     UUID object to use in subsequent api calls
 *
 * @returns RCP_SUCCESS if successful.
 * */
rcp_error_t rcp_rftp_directory_listing(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid);

/** @brief Check if user pass through messages are supported by connected camera.
 *
 * Check if user pass through messages are supported by connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    The user pass through messages are not supported by the connected camera.
 * @retval 1    The user pass through messages are supported by the connected camera.
 * */
int rcp_user_is_supported(const rcp_camera_connection_t * con);

/** @brief Send "Set USER" RCP Message.
 *
 * The USER RCP message allows for USER messages to be sent to all
 * attached devices/peripherals of the camera.  The camera does not
 * interpret the USER messages, it simply forwards them out every other
 * port.  It is intended to be used by third parties for controlling
 * third party modules/software.  The USER message contains a string id
 * and string value.  There are three variants of the USER message:
 * SET, GET, and CURRENT.
 *
 * @note It is important to choose a unique id so that it does not
 * collide with other third party applications.  One possible solution
 * would be to use reverse domain name notation.  e.g.:
 * "com.red.dsmc.iso"
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 * @param[in] val       the value to send (NULL if no value required)
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_send_set(rcp_camera_connection_t * con, const char * id, const char * val);

/** @brief Send "Get USER" RCP Message.
 *
 * The USER RCP message allows for USER messages to be sent to all
 * attached devices/peripherals of the camera.  The camera does not
 * interpret the USER messages, it simply forwards them out every other
 * port.  It is intended to be used by third parties for controlling
 * third party modules/software.  The USER message contains a string id
 * and string value.  There are three variants of the USER message:
 * SET, GET, and CURRENT.
 *
 * @note It is important to choose a unique id so that it does not
 * collide with other third party applications.  One possible solution
 * would be to use reverse domain name notation.  e.g.:
 * "com.red.dsmc.iso"
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 * @param[in] val       the value to send (NULL if no value required)
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_send_get(rcp_camera_connection_t * con, const char * id, const char * val);

/** @brief Send "Current USER" RCP Message.
 *
 * The USER RCP message allows for USER messages to be sent to all
 * attached devices/peripherals of the camera.  The camera does not
 * interpret the USER messages, it simply forwards them out every other
 * port.  It is intended to be used by third parties for controlling
 * third party modules/software.  The USER message contains a string id
 * and string value.  There are three variants of the USER message:
 * SET, GET, and CURRENT.
 *
 * @note It is important to choose a unique id so that it does not
 * collide with other third party applications.  One possible solution
 * would be to use reverse domain name notation.  e.g.:
 * "com.red.dsmc.iso"
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 * @param[in] val       the value to send (NULL if no value required)
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_send_current(rcp_camera_connection_t * con, const char * id, const char * val);

/** @brief Check if user metadata messages are supported by connected camera.
 *
 * Check if user metadata messages are supported by connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    The user pass through messages are not supported by the connected camera.
 * @retval 1    The user pass through messages are supported by the connected camera.
 * */
int rcp_user_metadata_is_supported(const rcp_camera_connection_t * con);

/** @brief Register user metadata id with camera.
 *
 * Before sending user metadata to the camera, the id must first be
 * registered.  You will receive confirmation of the registration.
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 * @param[in] max_len   max length of data associated with id
 *
 * @note It is important to choose a unique id so that it does not
 * collide with other third party applications.  One possible solution
 * would be to use reverse domain name notation.  e.g.:
 * "com.red.dsmc.iso"
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_metadata_register(rcp_camera_connection_t * con, const char * id, uint32_t max_len);

/** @brief Unregister user metadata id with camera.
 *
 * Unregistering a user id will remove the item from the current set of
 * user metadata as well as free up space for other third party
 * metadata.
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_metadata_unregister(rcp_camera_connection_t * con, const char * id);

/** @brief Send user metadata to camera.
 *
 * Send updated user metadata.  Before user metadata can be sent it
 * must first be registered with the camera.
 *
 * @param[in] con       the camera connection
 * @param[in] id        the user assigned ID
 * @param[in] val       the value of the user metadata item (should be human-readable)
 *
 * @returns RCP_SUCCESS on success.
 * */
rcp_error_t rcp_user_metadata_send(rcp_camera_connection_t * con, const char * id, const char * val);

/** @brief Check if key mapping is supported by connected camera.
 * Check if key mapping is supported via RCP by connected camera.
 * This function uses the camera's RCP Parameter Set Version to
 * determine if is is available.
 *
 * @param[in] con   the camera connection
 *
 * @retval 0    Key mapping is not supported by the connected camera.
 * @retval 1    Key mapping is supported by the connected camera.
 * */
int rcp_key_mapping_is_supported(const rcp_camera_connection_t * con);

/** @brief Request list of mappable actions from the camera.
 *
 * The list will be returned in the callback: cur_action_list_cb
 *
 * @param[in] con   the camera connection
 *
 * @return RCP_SUCCESS on success.
 * */
rcp_error_t rcp_key_mapping_get_action_list(rcp_camera_connection_t * con);

/** @brief Request current key-mapping for given keycode.
 *
 * The current mapping (and list) will be return in the callback:
 * cur_key_mapping_cb
 *
 * @param[in] con       the camera connection
 * @param[in] keycode   the key code requested (see @ref MAKEKEYCODE
 * macro)
 *
 * @return RCP_SUCCESS on success.
 * */
rcp_error_t rcp_key_mapping_get_mapping(rcp_camera_connection_t * con, int keycode);

/** @brief Set key-mapping for given keycode.
 *
 * Set the key mapping for keycode to action and param.
 *
 * @param[in] con       the camera connection
 * @param[in] keycode   key code to map
 * @param[in] action    action to map key code to (use num portion of list
 * action_c_list in cur_key_mapping_cb)
 * @param[in] param     parameter for action to map to key code (use
 * str portion of list action_c_list in cur_key_mapping_cb)
 *
 * @return RCP_SUCCESS on success.
 * */
rcp_error_t rcp_key_mapping_set_mapping(rcp_camera_connection_t * con, int keycode, key_action_t action, const char * param);

/** @brief Wrapper for memory allocations required by RCP API.
 *
 * This function must be implemented by the client code. In most
 * cases this can simply be implemented as such:
 * @code
 * void * rcp_malloc(size_t NBYTES)
 * {
 *     return malloc(NBYTES);
 * }
 * @endcode
 * */
void * rcp_malloc(size_t NBYTES);

/** @brief Wrapper for freeing memory allocations required by RCP API.
 *
 * This function must be implemented by the client code. In most
 * cases this can simply be implemented as such:
 * @code
 * void rcp_free(void * APTR)
 * {
 *     free(APTR);
 * }
 * @endcode
 * */
void rcp_free(void * APTR);

/** @brief Wrapper for mutex lock required by the RCP API.
 *
 * This function must be implemented by the client code. The client
 * must provide @ref RCP_MUTEX_COUNT mutexes for the RCP API.
 *
 * The mutex provided must be recursive.  That is, it must allow the
 * same thread to lock the mutex more than once without creating a
 * deadlock.
 *
 * @param[in] id    id of the mutex to lock
 * */
void rcp_mutex_lock(rcp_mutex_t id);

/** @brief Wrapper for mutex unlock required by the RCP API.
 *
 * This function must be implemented by the client code. The client
 * must provide @ref RCP_MUTEX_COUNT mutexes for the RCP API.
 *
 * @param[in] id    id of the mutex to unlock
 * */
void rcp_mutex_unlock(rcp_mutex_t id);

/** @brief Wrapper for logging messages from the RCP API.
 *
 * This function must be implemented by the client code.  It is up to
 * the client code on what to do with this log data.
 *
 * @param[in] severity  severity of log message
 * @param[in] con       camera connection associated with message (or
 * NULL if none or unknown)
 * @param[in] msg       message contents
 * */
void rcp_log(rcp_log_t severity, const rcp_camera_connection_t * con, const char * msg);

/** @brief Wrapper for getting pseudo-random integer required by the
 * RCP API.
 *
 * This function must be implemented by the client code.
 *
 * The client code is responsible for seeding the pseudo-random
 * generator.
 *
 * One possible implementation could be:
 * @code
 * int rcp_rand(void)
 * {
 *     static int seed = 1;
 *     if (seed)
 *     {
 *         srand(time(NULL));
 *         seed = 0;
 *     }
 *     return rand();
 * }
 * @endcode
 * */
int rcp_rand(void);

/** @brief Wrapper for getting system time stamp in milliseconds.
 *
 * This function must be implemented by the client code.  It is a
 * running time in milliseconds.  The starting point of the timer is
 * irrelevant.
 * */
uint32_t rcp_timestamp(void);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: rcp_api.h *************************************************/

/********** Begin file: rcp_api_config.h ****************************************/
#ifndef RCP_API_CONFIG_H
#define RCP_API_CONFIG_H

/** @file rcp_api_config.h
 *
 * The RCP API can be customized with the options below to reduce the
 * overall footprint.  That is, both code size and memory usage can be
 * reduced by disabling certain portions of the API or changing the
 * size of internally used buffers.
 *
 * Note: The default settings enable everything and have properly sized
 * buffers.  Furthermore, the API has primarily been tested with the
 * default settings.  Take care when changing any of the settings
 * below.
 * */

/** If disabled, there will be no support for parameter labels. @ref
 * rcp_get_label will always return NULL. */
#define RCP_API_ENABLE_LABELS

/** If disabled, there will be no support for converting parameter ids
 * (@ref rcp_param_t) to strings, or vice versa.  @ref rcp_get_name
 * will always return NULL and @ref rcp_get_id will always return
 * RCP_PARAM_COUNT */
#ifndef RCP_API_ENABLE_STR_TO_ENUM
#define RCP_API_ENABLE_STR_TO_ENUM
#endif

/** If disabled, memory usage will be reduced by not caching the value
 * of every parameter in the API itself.  Note: this will increase the
 * amount of traffic between the application and camera. */
#define RCP_API_ENABLE_CACHING

/** If disabled, notifications from the camera will not be supported.
 * @ref rcp_notification_get, @ref rcp_notification_timeout, and
 * @ref rcp_notification_response will all do nothing and return
 * successful. */
#define RCP_API_ENABLE_NOTIFICATIONS

/** If disabled, the clip list from the camera will not be accessible
 * through the API.*/
#define RCP_API_ENABLE_CLIP_LIST

/** If disabled, no log messages from the API will be generated. */
#define RCP_API_ENABLE_LOGGING

/** If disabled, camera discovery will be disabled. @ref
 * rcp_discovery_get_list will always return NULL and all other
 * rcp_discovery_* calls will do nothing. */
#define RCP_API_ENABLE_DISCOVERY

/** If disabled, menu navigation will be disabled. */
#define RCP_API_ENABLE_MENU

/** If disabled, stats collection will be disabled. */
#define RCP_API_ENABLE_STATS

/** If disabled, relative sets will be disabled. */
#define RCP_API_ENABLE_RELATIVE

/** If disabled, file transfers will be disabled. */
#define RCP_API_ENABLE_FILE_TRANSFER

/** Maximum size of any display string generated by the API */
#define RCP_API_DISPLAY_STR_SIZE                100

/** Maximum size of any line sent to a logger function */
#define RCP_API_LOG_LINE_SIZE                   1024

/** Size of internal buffer used to parse incoming RCP packets.  Note:
 * if this is reduced in size, not all packets are guaranteed to be
 * handled correctly. */
#define RCP_API_PARSER_BUFFER_SIZE              RCP2_MAX_PACKET_LENGTH

/** Maximum size of any outgoing RCP packet. */
#define RCP_API_OUTGOING_PACKET_BUFFER_SIZE     RCP2_MAX_PACKET_LENGTH

#define RCP_API_SOURCE_NAME "API"

#define RCP_EXPECTED_RETRY_COUNT    25

#define RCP_FILE_TRANSFER_MAX_FRAGMENT_SIZE 3072 /* must be multiple of 4 */

/* Minimum RCP Parameter Set Version supported */
#define RCP_PARAMETER_SET_MIN_VERSION_MAJOR 5
#define RCP_PARAMETER_SET_MIN_VERSION_MINOR 0

/* Current RCP Parameter Set Version supported */
#define RCP_PARAMETER_SET_VERSION_MAJOR 6
#define RCP_PARAMETER_SET_VERSION_MINOR 62

/* Some platforms, like windows phone, reportedly don't support a plain
 * C compiler.  For better cross platform support we need to cast the
 * result of malloc.  Casting the result of malloc in plain C is not
 * only not necessary, but can mask an error if the required header is
 * not included. */
#ifdef __cplusplus
#define RCP_MALLOC(type, size) (type) rcp_malloc(size)
#else
#define RCP_MALLOC(type, size) rcp_malloc(size)
#endif

#ifndef RCP_API_PRIVATE
#define RCP_API_PRIVATE
#endif

#endif
/********** End file: rcp_api_config.h ******************************************/

/********** Begin file: rcp_parser2.h *******************************************/
#ifndef RCP_PARSER_2_H_
#define RCP_PARSER_2_H_

#include <stdlib.h>

/*
 *  RCP Message Format:
 *  #@[targetID]$[sourceID]:cmd:param:value[:value...]:*cksum<cr>
 *
 */

/* Options */
#define RCP2_CHECK_BUFFER_OVERFLOW

#define RCP2_VERSION   2

/* Field Length */
#define RCP2_MAX_ID_LENGTH 8        /* Maximum length of a source or target ID */
#define RCP2_MAX_CMD_LENGTH 1       /* Maximum length of a command */
#define RCP2_MAX_PARAM_LENGTH 8     /* Maximum length of the parameter name */
#define RCP2_MAX_VALUE_LENGTH (8 * 1024)  /* Maximum length of all concatenated values (including separators between values, but not trailing separator) */
#define RCP2_MAX_HEADER_LENGTH (1 + 1 + RCP2_MAX_ID_LENGTH + 1 + RCP2_MAX_ID_LENGTH + 1) /* Maximum length of header (up to, but not including separator after source id) */
#define RCP2_MAX_PACKET_LENGTH (RCP2_MAX_HEADER_LENGTH + 1 + RCP2_MAX_CMD_LENGTH + 1 + RCP2_MAX_VALUE_LENGTH + 1 + 1 + 2 + 1)

#define RCP2_MAX_ARG_COUNT 30

/* Symbol offsets */
#define RCP2_MSG_START_SYMBOL '#'
#define RCP2_MSG_TARGET_SYMBOL '@'
#define RCP2_MSG_SOURCE_SYMBOL '$'
#define RCP2_MSG_SEPARATOR_SYMBOL ':'
#define RCP2_MSG_CKSUM_SYMBOL '*'
#define RCP2_MSG_END1_SYMBOL  '\n'
#define RCP2_MSG_END2_SYMBOL  '\r'
#define RCP2_MSG_ESCAPE_SYMBOL '\\'

/* RCP Errors */
#define RCP2_PARSER_OK                  0
#define RCP2_PARSER_NO_HEADER           -1
#define RCP2_PARSER_NO_CHECKSUM         -2
#define RCP2_PARSER_CHECKSUM_MISSMATCH  -3
#define RCP2_PARSER_WRONG_ID            -4
#define RCP2_PARSER_NO_PARAMETER        -5
#define RCP2_PARSER_NO_VALUE            -6
#define RCP2_PARSER_BUFFER_FULL         -7
#define RCP2_PARSER_BUFFER_END          -8
#define RCP2_PARSER_NO_COMMAND          -9
#define RCP2_PARSER_INCOMPLETE_PACKET   -10
#define RCP2_PARSER_TOO_MANY_ARGS       -11
#define RCP2_PARSER_MALFORMED           -12
#define RCP2_PARSER_FIELD_TOO_LARGE     -13
#define RCP2_PARSER_FIELD_NO_BYTES      -14

/* RCP Commands */
#define RCP2_CMD_SET                'S'     /* Set command */
#define RCP2_CMD_GET                'G'     /* Get command */
#define RCP2_CMD_CURRENT            'C'     /* Current command */
#define RCP2_CMD_SET_LIST           'T'     /* Set List command */
#define RCP2_CMD_GET_LIST           'H'     /* Get List command */
#define RCP2_CMD_CURRENT_LIST       'D'     /* Current List command */
#define RCP2_CMD_SET_RELATIVE       'U'     /* Set Relative command */
#define RCP2_CMD_SET_LIST_RELATIVE  'V'     /* Set List Relative command */
#define RCP2_CMD_GET_PERIODIC       'I'     /* Get Periodic command - used to turn periodic updates on/off */
#define RCP2_CMD_GET_DEFAULT        'J'     /* Get default command */
#define RCP2_CMD_CURRENT_DEFAULT    'E'     /* Current default command */
#define RCP2_CMD_FAIL               'F'     /* Fail */

typedef struct
{
    char * pSourceID;            /* Pointer to Sender ID */
    char * pTargetID;            /* Pointer to Target ID or NULL for a broadcast */
    char * pBufferPos;           /* Position of Buffer */
    char * pParserPos;           /* Current Parser position in Buffer */
    int bufferLength;            /* Maximum buffer length */
} tRCP;

/* for get_packet */
typedef struct
{
    char * pCmd;
    char * pTarget;
    char * pSource;
    char * pParam;

    char * pArg;
    char * pExtra;
} tRCPParsedPacket;

typedef struct
{
    unsigned int len;
    char * buf;                         /* must be provided by caller */
    unsigned int buf_len;               /* must be provided by caller */
    int escaped;
    int in_packet;

    tRCPParsedPacket parsed;
    int is_binary;
    int skip_bytes;
} tRCPPacketState;

/* for get_and_parse_packet */
typedef struct
{
    char * pCmd;
    char * pTarget;
    char * pSource;
    char * pParam;

    char * argv[RCP2_MAX_ARG_COUNT];
    char * pChecksum;
    int argc;
} tRCPParsedPacket2;

/* for get_and_parse_packet */
typedef enum
{
    RCP2_STATE_IDLE,
    RCP2_STATE_START,
    RCP2_STATE_TARGET,
    RCP2_STATE_SOURCE,
    RCP2_STATE_CMD,
    RCP2_STATE_PARAM,
    RCP2_STATE_ARG,
    RCP2_STATE_BIN_LEN,
    RCP2_STATE_BIN_DATA,
    RCP2_STATE_BIN_DONE,
    RCP2_STATE_CHKSUM,
    RCP2_STATE_END
} tRCPState;

typedef struct
{
    char * buf;                         /* must be provided by caller */
    unsigned int buf_len;               /* must be provided by caller */
    int initialized;                    /* must be zero on first call */

    unsigned int len;
    int is_escaped;
    int is_binary;

    unsigned char checksum;
    int last_error;

    int skip_bytes;

    tRCPParsedPacket2 parsed;

    tRCPState cur_state;
} tRCPParsedPacketState;

#ifdef __cplusplus
extern "C"
{
#endif

/* Receive Functions
 * ----------------- */

/* Set initial values for Parsing (We need to initialize the parser so we can run
 * the checksum validation.
 */
int RCP_prepareForParsing(tRCP * pRcpData, char * pBuffer, int bufferLength);

/* Validate checksum: calculates the checksum for a message and compares it to the message
 * checksum if one is present. Returns 0 on success or an error.
 * Checksum check needs to be run before we parse the data as that modifies the buffer.
 */
int RCP_validateChecksum(const tRCP * pRcpData);

/* Validate binary checksum: calculates the binary checksum for a message and compares it to the message
 * checksum if one is present. Returns 0 on success or an error.
 * Checksum check needs to be run before we parse the data as that modifies the buffer.
 */
int RCP_validateChecksumBinary(const tRCP * pRcpData);

/* Parses the header and fills in the RCP structure. This structure needs to be kept and
 * Passed on to the next functions.
 */
int RCP_parseHeader(tRCP * pRcpData, const char * pDeviceID, char * pCmd);

/* Get the next token. Returns a string or NULL if it was the last one
 * Notice that we do not distinguish between parameters and values, it is
 * up to the caller to determine what he expects next
 */
char * RCP_getNextToken(tRCP * pRcpData);

/* Send Functions
 * -------------- */

/* Build a header in the buffer provided based on the data provided.
 * The Data will be filled in to the RCP structure which needs to be passed on to the next functions
 */
int RCP_buildHeader(tRCP * pRcpData, char * pBuffer, int bufferLength, const char * pSourceID, const char * pTargetID, char Cmd);

/* Add a token to the message. Escape characters will be automatically added. */
int RCP_addToken(tRCP * pRcpData, const char * pToken);

/* Add the optional checksum */
int RCP_addChecksum(tRCP * pRcpData);

/* Finalize message and add a checksum to the message if addChecksum is true.
 * Returns the final size of the message
 */
int RCP_finalizeMessage(tRCP * pRcpData);

/* Convenient Wrapper Functions
 * ---------------------------- */

/* Create a Param/Value Pair Message */
int RCP_buildMessage(char * pBuffer, int maxSize, const char * pSource, const char * pTarget, char cmd, const char * pParam, const char * pValue, char addChecksum);

/* Parse a Param/Value Pair Message */
int RCP_parseMessage(char * pBuffer, int bufferSize, const char * myDeviceId, char * * senderID, char * pCmd, char * * pParam, char * * pValue);

/* Helper Routines
 * --------------- */

/* designed to be used with RCP_get_and_parse_packet_non_destructive.
 * Behaves like strcmp but handles RCP escaping and non-NULL
 * terminatation (strings can be
 * RCP2_MSG_SEPARATOR_SYMBOL/RCP2_MSG_SOURCE_SYMBOL terminated. */
int RCP_strcmp(const char * s1, const char * s2);

/* designed to be used with RCP_get_and_parse_packet_non_destructive.
 * Behaves like strlcpy but handles RCP escaping and non-NULL
 * terminatation for src (strings can be
 * RCP2_MSG_SEPARATOR_SYMBOL/RCP2_MSG_SOURCE_SYMBOL terminated. */
size_t RCP_strlcpy(char *dst, const char *src, size_t siz);

/* call this function with each char received.   It will return a
 * pointer to RCP packet that has been detected in the stream (and its
 * length) or NULL if no complete packet has been received yet.
 * Note that packetState should be memset to all 0s before the first call
 * and state members buf and buf_len should be set to valid values
 */
const char * RCP_get_packet(tRCPPacketState * packetState, char nextChar, int * numBytes);

/* call this function with each char received.  It will return
 * RCP2_PARSER_OK when a packet has been detected and parsed.  The
 * parsed data can be found in the packetState structure.  Before the
 * first call the state members buf, buf_len, and initialized should be set.
 */
int RCP_get_and_parse_packet(tRCPParsedPacketState * packetState, char nextChar);

/* same as RCP_get_and_parse_packet, but the original stream sent into
 * the parse is left intact.  That is, when RCP2_PARSER_OK is returned,
 * packetState->buf / packetState->len can be used to inspect the
 * actual packet received.  Note: the pointers in packetState->parsed,
 * such as cCmd, pTarget, pSource, pParam, argv, etc. will not be NULL
 * terminated, they will be RCP2_MSG_SEPARATOR_SYMBOL terminated.
 */
int RCP_get_and_parse_packet_non_destructive(tRCPParsedPacketState * packetState, char nextChar);

/* Get the RCP Version */
int RCP_getVersion(void);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: rcp_parser2.h *********************************************/

/********** Begin file: rcp_api_clip_list.h *************************************/
#ifndef RCP_API_CLIP_LIST_H
#define RCP_API_CLIP_LIST_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#ifdef RCP_API_ENABLE_CLIP_LIST

/* #include "rcp_parser/rcp_parser2.h" */

typedef enum
{
    CLIP_LIST_STATE_DISABLED,           /**< clip list feature is disabled (the user didn't provide a callback) */
    CLIP_LIST_STATE_GET_RECORD_STATE,   /**< waiting for camera record state before getting list  */
    CLIP_LIST_STATE_RECORDING,          /**< camera is recording; we need to wait to get list */
    CLIP_LIST_STATE_INIT_LIST,          /**< start getting list */
    CLIP_LIST_STATE_GET_LIST,           /**< in the process of gettings list */
    CLIP_LIST_STATE_HAVE_LIST           /**< we have the complete list */
} rcp_clip_list_state_t;

RCP_API_PRIVATE void _rcp_clip_list_clear(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_handle_media_clip_count(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_handle_media_clip_ext_info(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_handle_media_label(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_clip_list_handle_record_state_changed(rcp_camera_connection_t * con);

#endif

#endif
/********** End file: rcp_api_clip_list.h ***************************************/

/********** Begin file: rcp_api_menu.h ******************************************/
#ifndef RCP_API_MENU_H
#define RCP_API_MENU_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

struct rcp_menu_sibling_node_list;

/* defines parent/children relationships */
typedef struct rcp_menu_parent_node_list
{
    struct rcp_menu_sibling_node_list * parent;     /* parent node */
    struct rcp_menu_sibling_node_list * children;   /* first child */
    struct rcp_menu_parent_node_list * next;        /* next entry in the parent/children list  */
} rcp_menu_parent_node_list_t;

typedef struct rcp_menu_sibling_node_list
{
    rcp_menu_parent_node_list_t * parent;           /* parent's parent/children entry */
    rcp_menu_node_info_t * info;                    /* data for this entry */
    struct rcp_menu_sibling_node_list * next;       /* next entry in the sibling list */
} rcp_menu_sibling_node_list_t;

RCP_API_PRIVATE void _rcp_menu_init(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_menu_clear(const rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_menu_handle_node_list(rcp_camera_connection_t * con, const char * node_list_string);
RCP_API_PRIVATE void _rcp_menu_handle_node_status(rcp_camera_connection_t * con, rcp_menu_node_id_t node_id, int is_enable, int is_supported);
RCP_API_PRIVATE void _rcp_menu_handle_playback_state_changed(rcp_camera_connection_t * con);

#endif
/********** End file: rcp_api_menu.h ********************************************/

/********** Begin file: rcp_api_notifications.h *********************************/
#ifndef RCP_API_NOTIFICATIONS_H
#define RCP_API_NOTIFICATIONS_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#ifdef RCP_API_ENABLE_NOTIFICATIONS

/* #include "rcp_parser/rcp_parser2.h" */

typedef struct rcp_notification_list
{
    rcp_notification_t * info;
    struct rcp_notification_list * next;
    struct rcp_notification_list * prev;
} rcp_notification_list_t;

RCP_API_PRIVATE rcp_error_t _rcp_notification_get(rcp_camera_connection_t * con);
RCP_API_PRIVATE rcp_error_t _rcp_notification_timeout(rcp_camera_connection_t * con, const char * id);
RCP_API_PRIVATE rcp_error_t _rcp_notification_response(rcp_camera_connection_t * con, const char * id, int32_t response);
RCP_API_PRIVATE void _rcp_notification_remove(rcp_camera_connection_t * con, rcp_notification_list_t * entry);
RCP_API_PRIVATE void _rcp_process_packet_notification(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);

#endif

#endif
/********** End file: rcp_api_notifications.h ***********************************/

/********** Begin file: rcp_api_parameters.h ************************************/
#ifndef RCP_API_PARAM_DEF_H
#define RCP_API_PARAM_DEF_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

/* macros to make the parameter definition table a bit more manageable/readable */
#define V(major, minor) {major, minor}
#define VER_NONE() V(0, 0)
#define VER_MIN(major, minor) VER_RANGE(V(major, minor), VER_NONE())
#define VER_MAX(major, minor) VER_RANGE(VER_NONE(), V(major, minor))
#define VER_RANGE(min, max) {min, max}
#define VER_RANGE_NONE() VER_RANGE(VER_NONE(), VER_NONE())

#define RCP_SGC(m) m, m, m, NULL
#define RCP_SC(m) m, NULL, m, NULL
#define RCP_S(m) m, NULL, NULL, NULL
#define RCP_GC(m) NULL, m, m, NULL
#define RCP_GC2(m, n) NULL, m, n, NULL
#define RCP_C(m) NULL, NULL, m, NULL
#define RCP_IC(m) NULL, NULL, m, m
#define RCP_NONE() NULL, NULL, NULL, NULL

#define RCP_REL(m, version_range) m, version_range
#define RCP_REL_NONE() NULL, VER_RANGE_NONE()

#define RCP_LIST_REL(m, version_range) m, version_range
#define RCP_LIST_REL_NONE() NULL, VER_RANGE_NONE()

#define RCP_TGT_SGC(m, version_range) m, m, m, version_range
#define RCP_TGT_NONE() NULL, NULL, NULL, VER_RANGE_NONE()

#define RCP_LIST_SGC(m) m, m, m
#define RCP_LIST_GC(m) NULL, m, m
#define RCP_LIST_S(m) m, NULL, NULL
#define RCP_LIST_NONE() NULL, NULL, NULL

#define RCP_MIN(m) m
#define RCP_MIN_NONE() RCP_PARAM_COUNT

#define RCP_MAX(m) m
#define RCP_MAX_NONE() RCP_PARAM_COUNT

#ifdef RCP_API_ENABLE_STR_TO_ENUM
#define PARAM_NOR(s) s, 0, 0, RCP_PARAM_COUNT, 0, #s
#define PARAM_IDX(s, i, l, m) s ## _ ## i, 1, i, l, m, #s "_" #i
#else
#define PARAM_NOR(s) s, 0, 0, RCP_PARAM_COUNT, 0, NULL
#define PARAM_IDX(s, i, l, m) s ## _ ## i, 1, i, l, m, NULL
#endif

#ifdef RCP_API_ENABLE_LABELS
#define LABEL(l) l, NULL
#define LABEL_FP(fp) NULL, fp
#else
#define LABEL(l) NULL, NULL
#define LABEL_FP(fp) NULL, NULL
#endif

#define CACHE_NONE     0, 0, 0
#define CACHE_VAL      1, 1, 0
#define CACHE_LIST     0, 0, 1
#define CACHE_VAL_LIST 1, 1, 1

#define UPDATE_LIST_ON_CHANGE 0
#define UPDATE_LIST_ON_CLOSE  1

#define ENABLED_IN_REC(x) x
#define ENABLED_IN_PAT(x) x
#define ENABLED_IN_MAG(x) x
#define ENABLED_IN_RAWPB(x) x
#define ENABLED_IN_BAKEDPB(x) x
#define ENABLED_IN_RAW(x) x
#define ENABLED_IN_ACES(x) x
#define ENABLED_IN_PREVIEW(x) x

#define ALWAYS_ENABLED                      ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define ALWAYS_DISABLED                     ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(0), ENABLED_IN_PREVIEW(0)

#define DISABLED_IN_MAG                     ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT                     ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_BAKEDPB             ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_MAG                 ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_PB                  ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC                     ENABLED_IN_REC(0), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_MAG                 ENABLED_IN_REC(0), ENABLED_IN_PAT(1), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PAT                 ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PAT_MAG             ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PAT_MAG_PB          ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PAT_PB              ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PB                  ENABLED_IN_REC(0), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_BAKEDPB             ENABLED_IN_REC(0), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PB                      ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_RAW                     ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(0), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_ACES                    ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(0), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_ACES_RAW                ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(0), ENABLED_IN_ACES(0), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_BAKEDPB_RAW         ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_BAKEDPB_ACES_RAW    ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(0), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_PB_ACES_RAW         ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(0), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_REC_PAT_MAG_PB_RAW      ENABLED_IN_REC(0), ENABLED_IN_PAT(0), ENABLED_IN_MAG(0), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PAT_PB_RAW              ENABLED_IN_REC(1), ENABLED_IN_PAT(0), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(0), ENABLED_IN_BAKEDPB(0), ENABLED_IN_RAW(0), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(1)
#define DISABLED_IN_PREVIEW                 ENABLED_IN_REC(1), ENABLED_IN_PAT(1), ENABLED_IN_MAG(1), ENABLED_IN_RAWPB(1), ENABLED_IN_BAKEDPB(1), ENABLED_IN_RAW(1), ENABLED_IN_ACES(1), ENABLED_IN_PREVIEW(0)

#define HW_CAP(cap)     HW_CAP_ ## cap
#define HW_CAP__        HW_CAP_COUNT

#define COLOR_SCIENCE(cs)   COLOR_SCIENCE_ ## cs
#define COLOR_SCIENCE__     COLOR_SCIENCE_COUNT

#define EDIT_INFO(e)        (void *) &e, NULL
#define EDIT_INFO_FP(fp)    NULL, fp
#define EDIT_INFO_NONE()    NULL, NULL

typedef void (* rcp_create_string_fp_t)(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
typedef void (* rcp_create_int_fp_t)(rcp_camera_connection_t * con, rcp_param_t id);
typedef void (* rcp_create_list_fp_t)(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_t id_incoming);
typedef void (* rcp_set_int_fp_t)(rcp_camera_connection_t * con, rcp_param_t id, int32_t val);
typedef void (* rcp_create_status_fp_t)(rcp_camera_connection_t * con, rcp_param_t id);
typedef void (* rcp_create_edit_info_fp_t)(rcp_camera_connection_t * con, rcp_param_t id);
typedef void (* rcp_create_label_fp_t)(rcp_camera_connection_t * con, rcp_param_t id);

typedef enum
{
    RCP_TYPE_NULL,
    RCP_TYPE_INT,
    RCP_TYPE_UINT,
    RCP_TYPE_HIST,
    RCP_TYPE_STR,
    RCP_TYPE_EXT_CLIP_INFO,
    RCP_TYPE_TAG,
    RCP_TYPE_CAM_INFO,
    RCP_TYPE_AUDIOVU,
    RCP_TYPE_HW_CAP
} rcp_type_t;

typedef struct
{
    rcp_param_t id;
    unsigned int is_indexed : 1;
    unsigned int index : 7;
    rcp_param_t index_list_id;
    uint32_t index_list_mask;
    const char * enum_name;                                     /* name of enum (for reverse look up) */
    rcp_version_range_t rcp_param_version_range;                /* RCP parameter set version range for parameter itself */
    rcp_version_range_t set_version_range;                      /* RCP parameter set version range to support set_msg */
    const char * label;                                         /* text label associated with parameter */
    rcp_create_label_fp_t create_label_fp;                      /* Function pointer to create label for parameter */
    rcp_type_t set_type;                                        /* type of SET message */
    rcp_type_t current_type;                                    /* type of CURRENT message */
    unsigned int val_cacheable : 1;                             /* TRUE if the API can cache the value */
    unsigned int target_val_cacheable : 1;                      /* TRUE if the API can cache the target value */
    unsigned int list_cacheable : 1;                            /* TRUE if the API can cache the list (if the list is dynamic - either the user can edit it or it changes based on other camera settings - set to FALSE) */
    const char * set_msg;                                       /* RCP SET message */
    const char * get_msg;                                       /* RCP GET message */
    const char * cur_msg;                                       /* RCP CURRENT message */
    const char * get_periodic_msg;                              /* RCP GET_PERIODIC message */
    const char * set_relative_msg;                              /* RCP SET_RELATIVE message */
    rcp_version_range_t set_relative_version_range;             /* RCP parameter set version range to support set_relative_msg  */
    const char * set_list_relative_msg;                         /* RCP SET_LIST_RELATIVE message */
    rcp_version_range_t set_list_relative_version_range;        /* RCP parameter set version range to support set_list_relative_msg  */
    const char * set_target_msg;                                /* RCP SET message for associated TARGET value - if a parameter as a SET target message it will be used instead of the SET message for the parameter */
    const char * get_target_msg;                                /* RCP GET message for associated TARGET value */
    const char * cur_target_msg;                                /* RCP CURRENT message for associated TARGET value */
    rcp_version_range_t target_version_range;                   /* RCP parameter set version range to support *_target_msg  */
    const char * set_list_msg;                                  /* RCP SET_LIST message */
    const char * get_list_msg;                                  /* RCP GET_LIST message */
    const char * cur_list_msg;                                  /* RCP CURRENT_LIST message */
    rcp_param_t min_param;                                      /* Associated parameter that defines the minimum attainable value (to color code valid targets in lists) */
    rcp_param_t max_param;                                      /* Associated parameter that defines the maximum attainable value (to color code valid targets in lists) */
    rcp_create_string_fp_t create_string_fp;                    /* Function pointer to create display string for parameter */
    rcp_create_int_fp_t create_int_fp;                          /* Function pointer to create integer value for parameter (this is normally only used for composite variables) */
    rcp_create_list_fp_t create_list_fp;                        /* Function pointer to create list for parameter (this is normally only used for composite variables) */
    rcp_set_int_fp_t set_int_fp;                                /* Function pointer to create integer value for SET message for parameter (this is normally only used for composite variables) */
    rcp_create_status_fp_t create_status_fp;                    /* Function pointer to create current status for parameter  */
    void * default_edit_info;                                   /* Pointer to appropriate edit info structure */
    rcp_create_edit_info_fp_t create_edit_info_fp;              /* Function pointer to create edit info structure */
    unsigned int update_list_only_on_close : 1;                 /* TRUE if the SET message associated with the list should only be sent when the list is closed */

    /* the following could technically be done using create_status_fp,
     * but since these are common scenarios it is easier having these
     * set of flags. */
    unsigned int enabled_in_record : 1;             /* TRUE if the parameter is enabled while the camera is recording  */
    unsigned int enabled_in_test_pattern : 1;       /* TRUE if the parameter is enabled while the camera is showing a test pattern */
    unsigned int enabled_in_magnify : 1;            /* TRUE if the parameter is enabled while the camera is in magnify mode */
    unsigned int enabled_in_raw_playback : 1;       /* TRUE if the parameter is enabled while the camera is in playback with a RAW clip loaded */
    unsigned int enabled_in_baked_playback : 1;     /* TRUE if the parameter is enabled while the camera is in playback with a non RAW clip loaded */
    unsigned int enabled_in_raw : 1;                /* TRUE if the parameter is enabled while the camera is RAW view mode */
    unsigned int enabled_in_aces : 1;               /* TRUE if the parameter is enabled while the camera is ACES mode */
    unsigned int enabled_in_preview : 1;            /* TRUE if the parameter is enabled while the camera is in preview mode (that is, not playback) */

    color_science_t color_science;                  /* color science this parameter belongs to (COLOR_SCIENCE_COUNT if not applicable) */
    hw_cap_t hw_cap;                                /* Required HW Capabilities for this parameter */
} rcp_param_def_t;

/** Stores current state of a parameter; including cached values and
 * status bits. */
typedef struct
{
    union
    {
        int32_t int_val;
        uint32_t uint_val;
        char * str_val;
    } val;

    union
    {
        int32_t int_val;
        uint32_t uint_val;
    } target_val;

    union
    {
        int32_t int_val;
        uint32_t uint_val;
    } default_val;

    char * list_val;
    int32_t list_current_val;

#ifdef RCP_API_ENABLE_RELATIVE
    int32_t pending_relative_offset_value;
    union
    {
        int32_t int_val;
        uint32_t uint_val;
    } pending_expected_relative_value;
    int32_t expected_retry_count;

    int32_t pending_relative_list_offset_value;

#endif

    void * edit_info;
    char * generated_label;

    unsigned int is_enabled : 1;
    unsigned int is_enabled_valid : 1;
    unsigned int is_hw_supported : 1;
    unsigned int is_hw_supported_valid : 1;
    unsigned int is_color_science_supported : 1;
    unsigned int is_color_science_supported_valid : 1;
    unsigned int val_valid : 1;
    unsigned int target_val_valid : 1;
    unsigned int list_val_valid : 1;
    unsigned int list_current_val_valid : 1;
    unsigned int default_val_valid : 1;
    unsigned int get_pending : 1;
    unsigned int get_target_pending : 1;
    unsigned int get_list_pending : 1;
} rcp_param_state_t;

extern const rcp_param_def_t _rcp_param_def[RCP_PARAM_COUNT];

RCP_API_PRIVATE void _rcp_get_dependencies(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_create_list(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_get(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_get_status(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_parameters_handle_record_state_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_test_pattern_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_magnify_state_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_playback_state_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_playback_file_format_state_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_raw_mode_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_video_source_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_parameters_handle_color_science_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE int _rcp_check_parameter_dependencies(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE int _rcp_get_indexed_parameter_info(rcp_camera_connection_t * con, rcp_param_t list_param, int idx, c_list_entry_t * e);
RCP_API_PRIVATE void _rcp_clear_cache_val(rcp_camera_connection_t * con, rcp_param_t param);
RCP_API_PRIVATE void _rcp_clear_cache_list(rcp_camera_connection_t * con, rcp_param_t param);


#endif
/********** End file: rcp_api_parameters.h **************************************/

/********** Begin file: rcp_api_rftp.h ******************************************/
#ifndef RCP_API_RFTP_H
#define RCP_API_RFTP_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

typedef enum
{
    RCP_RFTP_STATE_IDLE,
    RCP_RFTP_STATE_STOR_INIT_WAIT_FOR_ACK,
    RCP_RFTP_STATE_STOR_SEND_DATA_WAIT_FOR_ACK,
    RCP_RFTP_STATE_RETR_INIT_WAIT_FOR_ACK,
    RCP_RFTP_STATE_RETR_ACK_WAIT_FOR_DATA
} rcp_rftp_state_t;

typedef struct rcp_rftp_transfer
{
    rftp_type_t rftp_type;

    /* store and retrieve properties */
    rcp_rftp_state_t rftp_state;
    rcp_uuid_t rftp_uuid;
    int64_t rftp_data_size;
    uint8_t * rftp_data;
    uint8_t * rftp_data_cur;
    int rftp_data_is_compressed;
    int rftp_last_percent_sent;
    uint32_t rftp_start_timestamp;
    int is_paused;

    /* store properties */
    int64_t rftp_last_ack;
    int64_t rftp_cur_fragment;
    int64_t rftp_max_fragment_size;
    int64_t rftp_num_fragments;

    /* retrieve properties */
    int64_t rftp_bytes_read;
    int64_t rftp_max_file_size; /* if 0, any file size is ok */
    int rftp_is_tethered;
    int rftp_tethering_is_complete;
    char rftp_md5sum[33];

    struct rcp_rftp_transfer * next;
} rcp_rftp_transfer_t;

RCP_API_PRIVATE void _rcp_rftp_handle_store(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_retrieve(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_list(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_data(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_abort(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_delete(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_handle_pause(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_rftp_free_all_data(rcp_camera_connection_t * con);

#endif
/********** End file: rcp_api_rftp.h ********************************************/

/********** Begin file: rcp_api_camera_connection.h *****************************/
#ifndef RCP_API_CAMERA_CONNECTION_H
#define RCP_API_CAMERA_CONNECTION_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_api_clip_list.h" */
/* #include "rcp_api_menu.h" */
/* #include "rcp_api_notifications.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_rftp.h" */
/* #include "rcp_parser/rcp_parser2.h" */

/** Stores current state and configuration of camera connection. */
struct rcp_camera_connection_t
{
    rcp_connection_state_t state;

    /* callbacks to client code (and user data to send back) */
    rcp_send_data_to_camera_cb_t send_data_to_camera_cb;
    void * send_data_to_camera_cb_user_data;

    rcp_cur_int_cb_t cur_int_cb;
    void * cur_int_cb_user_data;

    rcp_cur_uint_cb_t cur_uint_cb;
    void * cur_uint_cb_user_data;

    rcp_cur_list_cb_t cur_list_cb;
    void * cur_list_cb_user_data;

    rcp_cur_hist_cb_t cur_hist_cb;
    void * cur_hist_cb_user_data;

    rcp_cur_str_cb_t cur_str_cb;
    void * cur_str_cb_user_data;

    rcp_clip_list_cb_t clip_list_cb;
    void * clip_list_cb_user_data;

    rcp_cur_tag_cb_t cur_tag_cb;
    void * cur_tag_cb_user_data;

    rcp_cur_status_cb_t cur_status_cb;
    void * cur_status_cb_user_data;

    rcp_notification_cb_t notification_cb;
    void * notification_cb_user_data;

    rcp_cur_audio_vu_cb_t cur_audio_vu_cb;
    void * cur_audio_vu_cb_user_data;

    rcp_cur_menu_cb_t cur_menu_cb;
    void * cur_menu_cb_user_data;

    rcp_cur_menu_node_status_cb_t cur_menu_node_status_cb;
    void * cur_menu_node_status_cb_user_data;

    rcp_rftp_status_cb_t rftp_status_cb;
    void * rftp_status_cb_user_data;

    rcp_handle_user_cb_t handle_user_set_cb;
    void * handle_user_set_cb_user_data;

    rcp_handle_user_cb_t handle_user_get_cb;
    void * handle_user_get_cb_user_data;

    rcp_handle_user_cb_t handle_user_current_cb;
    void * handle_user_current_cb_user_data;

    rcp_handle_user_metadata_cb_t handle_user_metadata_cb;
    void * handle_user_metadata_cb_user_data;

    rcp_cur_default_int_cb_t cur_default_int_cb;
    void * cur_default_int_cb_user_data;

    rcp_cur_default_uint_cb_t cur_default_uint_cb;
    void * cur_default_uint_cb_user_data;

    rcp_cur_action_list_cb_t cur_action_list_cb;
    void * cur_action_list_cb_user_data;

    rcp_cur_key_mapping_cb_t cur_key_mapping_cb;
    void * cur_key_mapping_cb_user_data;

    rcp_state_cb_t state_cb;
    void * state_cb_user_data;

    rcp_param_state_t param_state[RCP_PARAM_COUNT];
    tRCPParsedPacketState parser_state;
    char parser_buffer[RCP_API_PARSER_BUFFER_SIZE];
#ifdef RCP_API_ENABLE_CLIP_LIST
    rcp_clip_list_state_t clip_list_state;
    int32_t clip_list_cur;
    int32_t clip_list_count;
    rcp_clip_info_list_t * clip_list;
    rcp_clip_info_list_t * clip_list_tail;
    char last_media_label[20];
#endif
    record_state_t last_record_state;
    monitor_test_pattern_t last_test_pattern;
    magnify_mode_t last_magnify_state;
    playback_state_t last_playback_state;
    file_format_type_t last_playback_file_format_type;
    raw_mode_t last_raw_mode;
    video_source_t last_video_source;
    output_transform_t last_output_transform;
    color_science_t last_color_science;
    int32_t rcp_version;
    uint16_t parameter_set_version_major;
    uint16_t parameter_set_version_minor;
    unsigned int parameter_set_newer : 1;
    unsigned int parameter_set_version_valid : 1;
    unsigned int rcp_version_valid : 1;
    unsigned int cam_info_valid : 1;
    rcp_error_t deferred_error;
    rcp_cam_info_t cam_info;
#ifdef RCP_API_ENABLE_NOTIFICATIONS
    rcp_notification_list_t * notification_list;
#endif

#ifdef RCP_API_ENABLE_MENU
    rcp_menu_parent_node_list_t * menu_parent_node_list;
    rcp_menu_parent_node_list_t * menu_last_sent_parent;
#endif

#ifdef RCP_API_ENABLE_STATS
    rcp_camera_connection_stats_t stats;
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
    rcp_rftp_transfer_t * rftp_transfer;
#endif

    uint32_t hw_cap_data[(HW_CAP_COUNT + 31) / 32];
    rcp_uuid_t uuid;
    char * client_name;
    char * client_version;
    char * client_user;

    c_list_t * key_mapping_action_list;
    char key_action_apply_look_prefix[RCP_API_DISPLAY_STR_SIZE];
    char key_action_apply_preset_prefix[RCP_API_DISPLAY_STR_SIZE];
    char key_action_show_dialog_prefix[RCP_API_DISPLAY_STR_SIZE];
    char key_action_run_script_prefix[RCP_API_DISPLAY_STR_SIZE];
    size_t key_mapping_key_code_queue_length;
    int * key_mapping_key_code_queue;
};

typedef enum
{
    RCP_FEATURE_MENU,
    RCP_FEATURE_MENU_NODE_STATUS,
    RCP_FEATURE_MENU_NODE_STATUS_IN_NODE_INFO,
    RCP_FEATURE_RFTP,
    RCP_FEATURE_RFTP_TETHERED,
    RCP_FEATURE_USER_PASS_THROUGH,
    RCP_FEATURE_USER_METADATA,
    RCP_FEATURE_CLIENT_ID,
    RCP_FEATURE_GET_PERIODIC,
    RCP_FEATURE_GET_DEFAULT,
    RCP_FEATURE_KEY_MAPPING,
    RCP_FEATURE_DYNAMIC_MONITOR_LABELS,
    RCP_FEATURE_MIN_CODEC_FROM_CAMERA,
    RCP_FEATURE_INDEXED_POWER_IN,
    RCP_FEATURE_COUNT
} rcp_feature_t;

RCP_API_PRIVATE void _rcp_connection_send_packet(rcp_camera_connection_t * con, const char * buf, size_t len);
RCP_API_PRIVATE int _rcp_version_in_range(const rcp_camera_connection_t * con, const rcp_version_range_t * range);
RCP_API_PRIVATE int _rcp_version_in_range_ext(const rcp_camera_connection_t * con, uint16_t min_major, uint16_t min_minor, uint16_t max_major, uint16_t max_minor);
RCP_API_PRIVATE int _rcp_version_less_or_equal_to(const rcp_camera_connection_t * con, uint16_t max_major, uint16_t max_minor);
RCP_API_PRIVATE int _rcp_version_greater_or_equal_to(const rcp_camera_connection_t * con, uint16_t min_major, uint16_t min_minor);
RCP_API_PRIVATE int _rcp_has_feature(const rcp_camera_connection_t * con, rcp_feature_t feature);

#endif
/********** End file: rcp_api_camera_connection.h *******************************/

/********** Begin file: rcp_api_audio_vu.h **************************************/
#ifndef RCP_API_AUDIO_VU_H
#define RCP_API_AUDIO_VU_H

/* #include "rcp_api.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

RCP_API_PRIVATE void _rcp_process_audio_vu_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);

#endif
/********** End file: rcp_api_audio_vu.h ****************************************/

/********** Begin file: rcp_api_get.h *******************************************/
#ifndef RCP_API_GET_H
#define RCP_API_GET_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_get(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_create_get_message(rcp_camera_connection_t * con, char cmd, const char * msg);
RCP_API_PRIVATE void _rcp_create_get_with_int_arg_message(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t arg);

#endif
/********** End file: rcp_api_get.h *********************************************/

/********** Begin file: decorated_string.h **************************************/
#ifndef DECORATED_STRING_H
#define DECORATED_STRING_H

/* #include "types/rcp_types_public.h" */
#include <stdlib.h>

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
    DECORATED_STRING_LEN_NORMAL,
    DECORATED_STRING_LEN_ABBREVIATED,
    DECORATED_STRING_LEN_COUNT
} decorated_string_len_t;

typedef enum
{
    DECORATED_STRING_COLOR_OK,
    DECORATED_STRING_COLOR_WARNING,
    DECORATED_STRING_COLOR_ERROR,
    DECORATED_STRING_COLOR_DISABLED
} decorated_string_color_t;

void decorated_string_decode(const char * src, char * dest, size_t dest_len);
void decorated_string_decode1(const char * src, char * dest, size_t dest_len);
void decorated_string_decode2(const char * src, char * dest, size_t dest_len, int32_t builtin);
void decorated_string_1_to_2(const char * src, char * dest, size_t dest_len);

void decorated_string_create(char * dest, size_t dest_size, int32_t num, int32_t divider, int32_t digits, const char * prefix, const char * postfix);

void decorated_string_abbreviate(char * str);

void decorated_string_create_fps_label(char * dest, size_t dest_size, decorated_string_len_t len, int32_t fps);
void decorated_string_create_int_time_label(char * dest, size_t dest_size, decorated_string_len_t len, int32_t show_angle, int32_t int_time, int32_t int_time_angle, frame_processing_t frame_processing, int32_t frame_divider, int32_t ae_control);
void decorated_string_create_red_gamma(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_red_color(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_main_output_preset(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_display_preset(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_output_transform(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_iso(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value, int32_t iso_pull, int32_t nd_val, int32_t sensor_gain_supported, int32_t sensor_gain_mode);
void decorated_string_create_redcode(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_file_format(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_aperture(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value, int32_t ae_control);
void decorated_string_create_power(char * dest, size_t dest_size, decorated_string_len_t len, battery_display_mode_t display_mode, int32_t power_level, int32_t runtime);
void decorated_string_create_power2(char * dest, size_t dest_size, decorated_string_len_t len, battery_display_mode_t display_mode, int32_t voltage, int32_t runtime, int32_t percent);
void decorated_string_create_power_voltage(char * dest, size_t dest_size, decorated_string_len_t len, int32_t voltage);
void decorated_string_create_power_percent(char * dest, size_t dest_size, decorated_string_len_t len, int32_t percent);
void decorated_string_create_power_runtime(char * dest, size_t dest_size, decorated_string_len_t len, int32_t runtime);
void decorated_string_create_focus_dist(char * dest, size_t dest_size, decorated_string_len_t len, focus_distance_mode_t display_mode, int32_t near_dist, int32_t far_dist);
void decorated_string_create_focal_length(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value);
void decorated_string_create_media(char * dest, size_t dest_size, decorated_string_len_t len, decorated_string_color_t * color, record_mode_t record_mode, media_display_t display_mode, int32_t media_level, int32_t runtime);
void decorated_string_create_color_temperature(char * dest, size_t dest_size, decorated_string_len_t len, int32_t color_temp);
void decorated_string_create_temperature(char * dest, size_t dest_size, decorated_string_len_t len, int32_t temp);
void decorated_string_create_fan_speed(char * dest, size_t dest_size, decorated_string_len_t len, int32_t fan_speed);
void decorated_string_create_gyro_angle(char * dest, size_t dest_size, decorated_string_len_t len, int32_t angle);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: decorated_string.h ****************************************/

/********** Begin file: stringl.h ***********************************************/
#ifndef STRINGL_H
#define STRINGL_H

#include <stdlib.h>
#if defined(HAVE_STRLCAT) || defined(HAVE_STRLCPY)
#include <string.h>
#endif

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef HAVE_STRLCAT
size_t strlcat(char *dst, const char *src, size_t siz);
#endif

#ifndef HAVE_STRLCPY
size_t strlcpy(char *dst, const char *src, size_t siz);
#endif

size_t strlncpy(char * dst, const char * src, size_t dst_size, size_t src_bytes_to_copy);

#ifdef __cplusplus
}
#endif

#endif

/********** End file: stringl.h *************************************************/

/********** Begin file: rcp_api_error.h *****************************************/
/* If a communication error occurs we need to notify the client
 * code by changing the connection state to:
 * RCP_CONNECTION_STATE_COMMUNICATION_ERROR. The client code should
 * respond by closing down its communication channel and then calling
 * rcp_delete_camera_connection.
 *
 * In order to ensure the API is in a state where the camera connection
 * can be deleted it is often useful to deffer the error reporting
 * until a later point in time.  Any error set by calling
 * _rcp_set_deferred_error will be sent to the client code when
 * _rcp_handle_deferred_error is called.  This way, errors can be set
 * anywhere in the API code and handled in a known "safe" location.
 * */

#ifndef RCP_API_ERROR_H
#define RCP_API_ERROR_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE void _rcp_handle_deferred_error(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_set_deferred_error(rcp_camera_connection_t * con, rcp_error_t error);

#endif
/********** End file: rcp_api_error.h *******************************************/

/********** Begin file: rcp_api_log.h *******************************************/
#ifndef RCP_API_LOG_H
#define RCP_API_LOG_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#ifdef RCP_API_ENABLE_LOGGING

#ifdef _MSC_VER
#define __func__ __FUNCTION__
#if (_MSC_VER < 1900)
#define snprintf _snprintf
#endif
#define strtoull(a, b, c) _strtoui64(a, b, c)
#endif

#ifdef __ghs__
#define __func__ __PRETTY_FUNCTION__
#endif

#define _rcp_log_error(C, ...) _rcp_log(__FILE__, __func__, __LINE__, RCP_LOG_ERROR, C, __VA_ARGS__)
#define _rcp_log_warning(C, ...) _rcp_log(__FILE__, __func__, __LINE__, RCP_LOG_WARNING, C, __VA_ARGS__)
#define _rcp_log_info(C, ...) _rcp_log(__FILE__, __func__, __LINE__, RCP_LOG_INFO, C, __VA_ARGS__)
#define _rcp_log_debug(C, ...) _rcp_log(__FILE__, __func__, __LINE__, RCP_LOG_DEBUG, C, __VA_ARGS__)
RCP_API_PRIVATE void _rcp_log(const char * file, const char * func, int line, rcp_log_t severity, const rcp_camera_connection_t * con, const char * fmt, ...);

#else

#define _rcp_log_error(C, ...)
#define _rcp_log_warning(C, ...)
#define _rcp_log_info(C, ...)
#define _rcp_log_debug(C, ...)

#endif

#endif
/********** End file: rcp_api_log.h *********************************************/

/********** Begin file: rcp_api_state.h *****************************************/
#ifndef RCP_API_STATE_H
#define RCP_API_STATE_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE void _rcp_set_state(rcp_camera_connection_t * con, rcp_connection_state_t new_state);

RCP_API_PRIVATE void _rcp_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data);
RCP_API_PRIVATE void _rcp_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data);
RCP_API_PRIVATE void _rcp_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info);
RCP_API_PRIVATE void _rcp_cur_tag_cb(rcp_camera_connection_t * con, const rcp_cur_tag_info_cb_data_t * data);
RCP_API_PRIVATE void _rcp_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data);

#endif
/********** End file: rcp_api_state.h *******************************************/

/********** Begin file: rcp_api_utils.h *****************************************/
#ifndef RCP_API_UTILS_H
#define RCP_API_UTILS_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#define RCP_STR_LEN_FOR_INT32   12       /* allow for -2147483648 - 2147483647 plus NULL */
#define RCP_STR_LEN_FOR_UINT32  11       /* allow for 0 - 4294967295 plus NULL */
#define RCP_STR_LEN_FOR_INT64   21       /* allow for -9223372036854775807 - 9223372036854775807 plus NULL */

RCP_API_PRIVATE char * _rcp_strdup(const char * src);

#endif
/********** End file: rcp_api_utils.h *******************************************/

/********** Begin file: rcp_api_uuid.h ******************************************/
#ifndef RCP_API_UUID
#define RCP_API_UUID

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE int _rcp_create_uuid(rcp_uuid_t * uuid);

#endif
/********** End file: rcp_api_uuid.h ********************************************/

/********** Begin file: rcp_api_client_id.h *************************************/
#ifndef RCP_API_SEND_CLIENT_ID
#define RCP_API_SEND_CLIENT_ID

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

RCP_API_PRIVATE rcp_error_t _rcp_send_client_id(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_client_id_ping(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);

#endif
/********** End file: rcp_api_client_id.h ***************************************/

/********** Begin file: rcp_api_packet.h ****************************************/
#ifndef RCP_API_PACKET
#define RCP_API_PACKET

/* #include "rcp_api.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_create_and_send_packet(rcp_camera_connection_t * con, char cmd, const char * param, size_t count, ...);

#endif
/********** End file: rcp_api_packet.h ******************************************/

/********** Begin file: rcp_api_set_str.h ***************************************/
#ifndef RCP_API_SET_STR_H
#define RCP_API_SET_STR_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_set_str(rcp_camera_connection_t * con, rcp_param_t id, const char * val);
RCP_API_PRIVATE void _rcp_create_set_str_message(rcp_camera_connection_t * con, char cmd, const char * msg, const char * val);

#endif
/********** End file: rcp_api_set_str.h *****************************************/

/********** Begin file: rcp_parameter_types_public.h ****************************/
/* This file is generated automatically - do not modify directly */
#ifndef RCP_PARAMETER_TYPES_PUBLIC_HEADER
#define RCP_PARAMETER_TYPES_PUBLIC_HEADER

#define RCP_AEEVSHFT_MSG_INT "AEEVSHFT"
#define RCP_AEEVSHFT_MSG_LIST_PTR "AEEVSHFT"
#define RCP_AEEVSHFT_MSG_LIST_REL "AEEVSHFT"
#define RCP_AEEXPRI_MSG_INT "AEEXPRI"
#define RCP_AEEXPRI_MSG_LIST_PTR "AEEXPRI"
#define RCP_AELOCKAP_MSG_INT "AELOCKAP"
#define RCP_AELOCKEX_MSG_INT "AELOCKEX"
#define RCP_AEMETERM_MSG_INT "AEMETERM"
#define RCP_AEMETERM_MSG_LIST_PTR "AEMETERM"
#define RCP_AEMODE_MSG_INT "AEMODE"
#define RCP_AEMODE_MSG_LIST_PTR "AEMODE"
#define RCP_AESELECT_MSG_INT "AESELECT"
#define RCP_AESELECT_MSG_LIST_PTR "AESELECT"
#define RCP_AESPEED_MSG_INT "AESPEED"
#define RCP_AESPEED_MSG_LIST_PTR "AESPEED"
#define RCP_AFENCONS_MSG_INT "AFENCONS"
#define RCP_AFENCONS_MSG_LIST_PTR "AFENCONS"
#define RCP_AFENHMON_MSG_INT "AFENHMON"
#define RCP_AFENHMON_MSG_LIST_PTR "AFENHMON"
#define RCP_AFENHNCD_MSG_INT "AFENHNCD"
#define RCP_AFMODE_MSG_INT "AFMODE"
#define RCP_AFMODE_MSG_LIST_PTR "AFMODE"
#define RCP_AFRCKSEL_MSG_INT "AFRCKSEL"
#define RCP_AFRCKSEL_MSG_REL "AFRCKSEL"
#define RCP_AFSIZE_MSG_INT "AFSIZE"
#define RCP_AFSIZE_MSG_LIST_PTR "AFSIZE"
#define RCP_AFWPOSC "AFWPOSC"
#define RCP_AFWPOSX_MSG_INT "AFWPOSX"
#define RCP_AFWPOSX_MSG_REL "AFWPOSX"
#define RCP_AFWPOSY_MSG_INT "AFWPOSY"
#define RCP_AFWPOSY_MSG_REL "AFWPOSY"
#define RCP_AFZONE_MSG_INT "AFZONE"
#define RCP_AFZONE_MSG_LIST_PTR "AFZONE"
#define RCP_AWBMODE_MSG_INT "AWBMODE"
#define RCP_HCFOCUS_MSG_UINT "HCFOCUS"
#define RCP_HCFOCUS_MSG_REL "HCFOCUS"
#define RCP_HCIRIS_MSG_UINT "HCIRIS"
#define RCP_HCIRIS_MSG_REL "HCIRIS"
#define RCP_HCREINIT_MSG_UINT "HCREINIT"
#define RCP_HCZOOM_MSG_UINT "HCZOOM"
#define RCP_HCZOOM_MSG_REL "HCZOOM"
#define RCP_AINSR1ST_MSG_STR_PTR "AINSR1ST"
#define RCP_AINSR2ST_MSG_STR_PTR "AINSR2ST"
#define RCP_AINSR3ST_MSG_STR_PTR "AINSR3ST"
#define RCP_AINSR4ST_MSG_STR_PTR "AINSR4ST"
#define RCP_BWFENABL_MSG_INT "BWFENABL"
#define RCP_BWFVALID_MSG_INT "BWFVALID"
#define RCP_CH12ILNK_MSG_INT "CH12ILNK"
#define RCP_CH12OLNK_MSG_INT "CH12OLNK"
#define RCP_CH12ONME_MSG_STR_PTR "CH12ONME"
#define RCP_CH12SRC_MSG_INT "CH12SRC"
#define RCP_CH12SRC_MSG_LIST_PTR "CH12SRC"
#define RCP_CH12ST_MSG_INT "CH12ST"
#define RCP_CH1GAIN_MSG_INT "CH1GAIN"
#define RCP_CH1GAIN_MSG_LIST_PTR "CH1GAIN"
#define RCP_CH1GAIN_MSG_REL "CH1GAIN"
#define RCP_CH1LIMIT_MSG_INT "CH1LIMIT"
#define RCP_CH1LIMPR_MSG_INT "CH1LIMPR"
#define RCP_CH1MODE_MSG_INT "CH1MODE"
#define RCP_CH1MODE_MSG_LIST_PTR "CH1MODE"
#define RCP_CH1MUTE_MSG_INT "CH1MUTE"
#define RCP_CH1NAME_MSG_STR_PTR "CH1NAME"
#define RCP_CH1VOL_MSG_INT "CH1VOL"
#define RCP_CH1VOL_MSG_LIST_PTR "CH1VOL"
#define RCP_CH1_48V_MSG_INT "CH1_48V"
#define RCP_CH1_48VP_MSG_INT "CH1_48VP"
#define RCP_CH2GAIN_MSG_INT "CH2GAIN"
#define RCP_CH2GAIN_MSG_LIST_PTR "CH2GAIN"
#define RCP_CH2GAIN_MSG_REL "CH2GAIN"
#define RCP_CH2LIMIT_MSG_INT "CH2LIMIT"
#define RCP_CH2LIMPR_MSG_INT "CH2LIMPR"
#define RCP_CH2MODE_MSG_INT "CH2MODE"
#define RCP_CH2MODE_MSG_LIST_PTR "CH2MODE"
#define RCP_CH2MUTE_MSG_INT "CH2MUTE"
#define RCP_CH2NAME_MSG_STR_PTR "CH2NAME"
#define RCP_CH2VOL_MSG_INT "CH2VOL"
#define RCP_CH2VOL_MSG_LIST_PTR "CH2VOL"
#define RCP_CH2_48V_MSG_INT "CH2_48V"
#define RCP_CH2_48VP_MSG_INT "CH2_48VP"
#define RCP_CH34ILNK_MSG_INT "CH34ILNK"
#define RCP_CH34OLNK_MSG_INT "CH34OLNK"
#define RCP_CH34ONME_MSG_STR_PTR "CH34ONME"
#define RCP_CH34SRC_MSG_INT "CH34SRC"
#define RCP_CH34SRC_MSG_LIST_PTR "CH34SRC"
#define RCP_CH34ST_MSG_INT "CH34ST"
#define RCP_CH3GAIN_MSG_INT "CH3GAIN"
#define RCP_CH3GAIN_MSG_LIST_PTR "CH3GAIN"
#define RCP_CH3GAIN_MSG_REL "CH3GAIN"
#define RCP_CH3LIMIT_MSG_INT "CH3LIMIT"
#define RCP_CH3LIMPR_MSG_INT "CH3LIMPR"
#define RCP_CH3MODE_MSG_INT "CH3MODE"
#define RCP_CH3MODE_MSG_LIST_PTR "CH3MODE"
#define RCP_CH3NAME_MSG_STR_PTR "CH3NAME"
#define RCP_CH3VOL_MSG_INT "CH3VOL"
#define RCP_CH3VOL_MSG_LIST_PTR "CH3VOL"
#define RCP_CH3_48V_MSG_INT "CH3_48V"
#define RCP_CH3_48VP_MSG_INT "CH3_48VP"
#define RCP_CH4GAIN_MSG_INT "CH4GAIN"
#define RCP_CH4GAIN_MSG_LIST_PTR "CH4GAIN"
#define RCP_CH4GAIN_MSG_REL "CH4GAIN"
#define RCP_CH4LIMIT_MSG_INT "CH4LIMIT"
#define RCP_CH4LIMPR_MSG_INT "CH4LIMPR"
#define RCP_CH4MODE_MSG_INT "CH4MODE"
#define RCP_CH4MODE_MSG_LIST_PTR "CH4MODE"
#define RCP_CH4NAME_MSG_STR_PTR "CH4NAME"
#define RCP_CH4VOL_MSG_INT "CH4VOL"
#define RCP_CH4VOL_MSG_LIST_PTR "CH4VOL"
#define RCP_CH4_48V_MSG_INT "CH4_48V"
#define RCP_CH4_48VP_MSG_INT "CH4_48VP"
#define RCP_CH56ONME_MSG_STR_PTR "CH56ONME"
#define RCP_MIX12PN1_MSG_INT "MIX12PN1"
#define RCP_MIX12PN1_MSG_LIST_PTR "MIX12PN1"
#define RCP_MIX12PN2_MSG_INT "MIX12PN2"
#define RCP_MIX12PN2_MSG_LIST_PTR "MIX12PN2"
#define RCP_MIX12PN3_MSG_INT "MIX12PN3"
#define RCP_MIX12PN3_MSG_LIST_PTR "MIX12PN3"
#define RCP_MIX12PN4_MSG_INT "MIX12PN4"
#define RCP_MIX12PN4_MSG_LIST_PTR "MIX12PN4"
#define RCP_MIX12VL1_MSG_INT "MIX12VL1"
#define RCP_MIX12VL1_MSG_LIST_PTR "MIX12VL1"
#define RCP_MIX12VL2_MSG_INT "MIX12VL2"
#define RCP_MIX12VL2_MSG_LIST_PTR "MIX12VL2"
#define RCP_MIX12VL3_MSG_INT "MIX12VL3"
#define RCP_MIX12VL3_MSG_LIST_PTR "MIX12VL3"
#define RCP_MIX12VL4_MSG_INT "MIX12VL4"
#define RCP_MIX12VL4_MSG_LIST_PTR "MIX12VL4"
#define RCP_MIX34PN1_MSG_INT "MIX34PN1"
#define RCP_MIX34PN1_MSG_LIST_PTR "MIX34PN1"
#define RCP_MIX34PN2_MSG_INT "MIX34PN2"
#define RCP_MIX34PN2_MSG_LIST_PTR "MIX34PN2"
#define RCP_MIX34PN3_MSG_INT "MIX34PN3"
#define RCP_MIX34PN3_MSG_LIST_PTR "MIX34PN3"
#define RCP_MIX34PN4_MSG_INT "MIX34PN4"
#define RCP_MIX34PN4_MSG_LIST_PTR "MIX34PN4"
#define RCP_MIX34VL1_MSG_INT "MIX34VL1"
#define RCP_MIX34VL1_MSG_LIST_PTR "MIX34VL1"
#define RCP_MIX34VL2_MSG_INT "MIX34VL2"
#define RCP_MIX34VL2_MSG_LIST_PTR "MIX34VL2"
#define RCP_MIX34VL3_MSG_INT "MIX34VL3"
#define RCP_MIX34VL3_MSG_LIST_PTR "MIX34VL3"
#define RCP_MIX34VL4_MSG_INT "MIX34VL4"
#define RCP_MIX34VL4_MSG_LIST_PTR "MIX34VL4"
#define RCP_MIXHDPN1_MSG_INT "MIXHDPN1"
#define RCP_MIXHDPN1_MSG_LIST_PTR "MIXHDPN1"
#define RCP_MIXHDPN2_MSG_INT "MIXHDPN2"
#define RCP_MIXHDPN2_MSG_LIST_PTR "MIXHDPN2"
#define RCP_MIXHDPN3_MSG_INT "MIXHDPN3"
#define RCP_MIXHDPN3_MSG_LIST_PTR "MIXHDPN3"
#define RCP_MIXHDPN4_MSG_INT "MIXHDPN4"
#define RCP_MIXHDPN4_MSG_LIST_PTR "MIXHDPN4"
#define RCP_MIXHDVL1_MSG_INT "MIXHDVL1"
#define RCP_MIXHDVL1_MSG_LIST_PTR "MIXHDVL1"
#define RCP_MIXHDVL2_MSG_INT "MIXHDVL2"
#define RCP_MIXHDVL2_MSG_LIST_PTR "MIXHDVL2"
#define RCP_MIXHDVL3_MSG_INT "MIXHDVL3"
#define RCP_MIXHDVL3_MSG_LIST_PTR "MIXHDVL3"
#define RCP_MIXHDVL4_MSG_INT "MIXHDVL4"
#define RCP_MIXHDVL4_MSG_LIST_PTR "MIXHDVL4"
#define RCP_VUSRC_MSG_INT "VUSRC"
#define RCP_VUSRC_MSG_LIST_PTR "VUSRC"
#define RCP_HDRFACT_MSG_INT "HDRFACT"
#define RCP_HDRFACT_MSG_LIST_PTR "HDRFACT"
#define RCP_HDRMODE_MSG_INT "HDRMODE"
#define RCP_HDRMODE_MSG_LIST_PTR "HDRMODE"
#define RCP_OGTMODE_MSG_INT "OGTMODE"
#define RCP_OGTMODE_MSG_LIST_PTR "OGTMODE"
#define RCP_OGTSTATE_MSG_INT "OGTSTATE"
#define RCP_SHANGLE_MSG_INT "SHANGLE"
#define RCP_SHANGLE_MSG_LIST_PTR "SHANGLE"
#define RCP_SHANGLET_MSG_INT "SHANGLET"
#define RCP_SHDISP_MSG_INT "SHDISP"
#define RCP_SHDISP_MSG_LIST_PTR "SHDISP"
#define RCP_SHMODE_MSG_INT "SHMODE"
#define RCP_SHMODE_MSG_LIST_PTR "SHMODE"
#define RCP_SHTIME_MSG_INT "SHTIME"
#define RCP_SHTIME_MSG_LIST_PTR "SHTIME"
#define RCP_SHTIME_MSG_LIST_REL "SHTIME"
#define RCP_SHTIMET_MSG_INT "SHTIMET"
#define RCP_BCURVE_MSG_STR_PTR "BCURVE"
#define RCP_BCURVEDX_MSG_INT "BCURVEDX"
#define RCP_BCURVEDX_MSG_REL "BCURVEDX"
#define RCP_BCURVEDY_MSG_INT "BCURVEDY"
#define RCP_BCURVEDY_MSG_REL "BCURVEDY"
#define RCP_BCURVEHX_MSG_INT "BCURVEHX"
#define RCP_BCURVEHX_MSG_REL "BCURVEHX"
#define RCP_BCURVEHY_MSG_INT "BCURVEHY"
#define RCP_BCURVEHY_MSG_REL "BCURVEHY"
#define RCP_BCURVELX_MSG_INT "BCURVELX"
#define RCP_BCURVELX_MSG_REL "BCURVELX"
#define RCP_BCURVELY_MSG_INT "BCURVELY"
#define RCP_BCURVELY_MSG_REL "BCURVELY"
#define RCP_BCURVEMX_MSG_INT "BCURVEMX"
#define RCP_BCURVEMX_MSG_REL "BCURVEMX"
#define RCP_BCURVEMY_MSG_INT "BCURVEMY"
#define RCP_BCURVEMY_MSG_REL "BCURVEMY"
#define RCP_BCURVESX_MSG_INT "BCURVESX"
#define RCP_BCURVESX_MSG_REL "BCURVESX"
#define RCP_BCURVESY_MSG_INT "BCURVESY"
#define RCP_BCURVESY_MSG_REL "BCURVESY"
#define RCP_BGAIN_MSG_INT "BGAIN"
#define RCP_BGAIN_MSG_LIST_PTR "BGAIN"
#define RCP_BGAIN_MSG_REL "BGAIN"
#define RCP_BGAMMA_MSG_INT "BGAMMA"
#define RCP_BGAMMA_MSG_LIST_PTR "BGAMMA"
#define RCP_BGAMMA_MSG_REL "BGAMMA"
#define RCP_BLIFT_MSG_INT "BLIFT"
#define RCP_BLIFT_MSG_LIST_PTR "BLIFT"
#define RCP_BLIFT_MSG_REL "BLIFT"
#define RCP_BLUEG_MSG_INT "BLUEG"
#define RCP_BLUEG_MSG_LIST_PTR "BLUEG"
#define RCP_BLUEG_MSG_REL "BLUEG"
#define RCP_BOFFSET_MSG_INT "BOFFSET"
#define RCP_BOFFSET_MSG_LIST_PTR "BOFFSET"
#define RCP_BOFFSET_MSG_REL "BOFFSET"
#define RCP_BPOWER_MSG_INT "BPOWER"
#define RCP_BPOWER_MSG_LIST_PTR "BPOWER"
#define RCP_BPOWER_MSG_REL "BPOWER"
#define RCP_BRIGHT_MSG_INT "BRIGHT"
#define RCP_BRIGHT_MSG_LIST_PTR "BRIGHT"
#define RCP_BSLOPE_MSG_INT "BSLOPE"
#define RCP_BSLOPE_MSG_LIST_PTR "BSLOPE"
#define RCP_BSLOPE_MSG_REL "BSLOPE"
#define RCP_CDLEN_MSG_INT "CDLEN"
#define RCP_CMATBB_MSG_INT "CMATBB"
#define RCP_CMATBB_MSG_REL "CMATBB"
#define RCP_CMATBG_MSG_INT "CMATBG"
#define RCP_CMATBG_MSG_REL "CMATBG"
#define RCP_CMATBR_MSG_INT "CMATBR"
#define RCP_CMATBR_MSG_REL "CMATBR"
#define RCP_CMATGB_MSG_INT "CMATGB"
#define RCP_CMATGB_MSG_REL "CMATGB"
#define RCP_CMATGG_MSG_INT "CMATGG"
#define RCP_CMATGG_MSG_REL "CMATGG"
#define RCP_CMATGR_MSG_INT "CMATGR"
#define RCP_CMATGR_MSG_REL "CMATGR"
#define RCP_CMATRB_MSG_INT "CMATRB"
#define RCP_CMATRB_MSG_REL "CMATRB"
#define RCP_CMATRG_MSG_INT "CMATRG"
#define RCP_CMATRG_MSG_REL "CMATRG"
#define RCP_CMATRR_MSG_INT "CMATRR"
#define RCP_CMATRR_MSG_REL "CMATRR"
#define RCP_COLTMP_MSG_INT "COLTMP"
#define RCP_COLTMP_MSG_LIST_PTR "COLTMP"
#define RCP_COLTMP_MSG_REL "COLTMP"
#define RCP_COLTMP_MSG_LIST_REL "COLTMP"
#define RCP_COLTMPP_MSG_INT "COLTMPP"
#define RCP_COLTMPP_MSG_LIST_PTR "COLTMPP"
#define RCP_CONTRST_MSG_INT "CONTRST"
#define RCP_CONTRST_MSG_LIST_PTR "CONTRST"
#define RCP_CSATURAT_MSG_INT "CSATURAT"
#define RCP_CSATURAT_MSG_LIST_PTR "CSATURAT"
#define RCP_CSATURAT_MSG_REL "CSATURAT"
#define RCP_CSPACE_MSG_INT "CSPACE"
#define RCP_CSPACE_MSG_LIST_PTR "CSPACE"
#define RCP_DEVCON_MSG_INT "DEVCON"
#define RCP_DEVCON_MSG_LIST_PTR "DEVCON"
#define RCP_EXPCOMP_MSG_INT "EXPCOMP"
#define RCP_EXPCOMP_MSG_LIST_PTR "EXPCOMP"
#define RCP_FLUT_MSG_INT "FLUT"
#define RCP_FLUT_MSG_LIST_PTR "FLUT"
#define RCP_FLUT_MSG_REL "FLUT"
#define RCP_FRSHARP_MSG_INT "FRSHARP"
#define RCP_FRSHARP_MSG_LIST_PTR "FRSHARP"
#define RCP_GCURVE_MSG_STR_PTR "GCURVE"
#define RCP_GCURVEDX_MSG_INT "GCURVEDX"
#define RCP_GCURVEDX_MSG_REL "GCURVEDX"
#define RCP_GCURVEDY_MSG_INT "GCURVEDY"
#define RCP_GCURVEDY_MSG_REL "GCURVEDY"
#define RCP_GCURVEHX_MSG_INT "GCURVEHX"
#define RCP_GCURVEHX_MSG_REL "GCURVEHX"
#define RCP_GCURVEHY_MSG_INT "GCURVEHY"
#define RCP_GCURVEHY_MSG_REL "GCURVEHY"
#define RCP_GCURVELX_MSG_INT "GCURVELX"
#define RCP_GCURVELX_MSG_REL "GCURVELX"
#define RCP_GCURVELY_MSG_INT "GCURVELY"
#define RCP_GCURVELY_MSG_REL "GCURVELY"
#define RCP_GCURVEMX_MSG_INT "GCURVEMX"
#define RCP_GCURVEMX_MSG_REL "GCURVEMX"
#define RCP_GCURVEMY_MSG_INT "GCURVEMY"
#define RCP_GCURVEMY_MSG_REL "GCURVEMY"
#define RCP_GCURVESX_MSG_INT "GCURVESX"
#define RCP_GCURVESX_MSG_REL "GCURVESX"
#define RCP_GCURVESY_MSG_INT "GCURVESY"
#define RCP_GCURVESY_MSG_REL "GCURVESY"
#define RCP_GGAIN_MSG_INT "GGAIN"
#define RCP_GGAIN_MSG_LIST_PTR "GGAIN"
#define RCP_GGAIN_MSG_REL "GGAIN"
#define RCP_GGAMMA_MSG_INT "GGAMMA"
#define RCP_GGAMMA_MSG_LIST_PTR "GGAMMA"
#define RCP_GGAMMA_MSG_REL "GGAMMA"
#define RCP_GLIFT_MSG_INT "GLIFT"
#define RCP_GLIFT_MSG_LIST_PTR "GLIFT"
#define RCP_GLIFT_MSG_REL "GLIFT"
#define RCP_GOFFSET_MSG_INT "GOFFSET"
#define RCP_GOFFSET_MSG_LIST_PTR "GOFFSET"
#define RCP_GOFFSET_MSG_REL "GOFFSET"
#define RCP_GPOWER_MSG_INT "GPOWER"
#define RCP_GPOWER_MSG_LIST_PTR "GPOWER"
#define RCP_GPOWER_MSG_REL "GPOWER"
#define RCP_GREENG_MSG_INT "GREENG"
#define RCP_GREENG_MSG_LIST_PTR "GREENG"
#define RCP_GREENG_MSG_REL "GREENG"
#define RCP_GSLOPE_MSG_INT "GSLOPE"
#define RCP_GSLOPE_MSG_LIST_PTR "GSLOPE"
#define RCP_GSLOPE_MSG_REL "GSLOPE"
#define RCP_GSPACE_MSG_INT "GSPACE"
#define RCP_GSPACE_MSG_LIST_PTR "GSPACE"
#define RCP_HDMIMUX_MSG_INT "HDMIMUX"
#define RCP_HDMIMUX_MSG_LIST_PTR "HDMIMUX"
#define RCP_HDRXMONX_MSG_INT "HDRXMONX"
#define RCP_HDRXMONX_MSG_LIST_PTR "HDRXMONX"
#define RCP_ISO_MSG_INT "ISO"
#define RCP_ISO_MSG_LIST_PTR "ISO"
#define RCP_ISO_MSG_LIST_REL "ISO"
#define RCP_ISOCAL2_MSG_INT "ISOCAL2"
#define RCP_LCURVE_MSG_STR_PTR "LCURVE"
#define RCP_LCURVEDX_MSG_INT "LCURVEDX"
#define RCP_LCURVEDX_MSG_REL "LCURVEDX"
#define RCP_LCURVEDY_MSG_INT "LCURVEDY"
#define RCP_LCURVEDY_MSG_REL "LCURVEDY"
#define RCP_LCURVEHX_MSG_INT "LCURVEHX"
#define RCP_LCURVEHX_MSG_REL "LCURVEHX"
#define RCP_LCURVEHY_MSG_INT "LCURVEHY"
#define RCP_LCURVEHY_MSG_REL "LCURVEHY"
#define RCP_LCURVELX_MSG_INT "LCURVELX"
#define RCP_LCURVELX_MSG_REL "LCURVELX"
#define RCP_LCURVELY_MSG_INT "LCURVELY"
#define RCP_LCURVELY_MSG_REL "LCURVELY"
#define RCP_LCURVEMX_MSG_INT "LCURVEMX"
#define RCP_LCURVEMX_MSG_REL "LCURVEMX"
#define RCP_LCURVEMY_MSG_INT "LCURVEMY"
#define RCP_LCURVEMY_MSG_REL "LCURVEMY"
#define RCP_LCURVESX_MSG_INT "LCURVESX"
#define RCP_LCURVESX_MSG_REL "LCURVESX"
#define RCP_LCURVESY_MSG_INT "LCURVESY"
#define RCP_LCURVESY_MSG_REL "LCURVESY"
#define RCP_LOGVWMDE_MSG_INT "LOGVWMDE"
#define RCP_RAWMODE_MSG_INT "RAWMODE"
#define RCP_RCURVE_MSG_STR_PTR "RCURVE"
#define RCP_RCURVEDX_MSG_INT "RCURVEDX"
#define RCP_RCURVEDX_MSG_REL "RCURVEDX"
#define RCP_RCURVEDY_MSG_INT "RCURVEDY"
#define RCP_RCURVEDY_MSG_REL "RCURVEDY"
#define RCP_RCURVEHX_MSG_INT "RCURVEHX"
#define RCP_RCURVEHX_MSG_REL "RCURVEHX"
#define RCP_RCURVEHY_MSG_INT "RCURVEHY"
#define RCP_RCURVEHY_MSG_REL "RCURVEHY"
#define RCP_RCURVELX_MSG_INT "RCURVELX"
#define RCP_RCURVELX_MSG_REL "RCURVELX"
#define RCP_RCURVELY_MSG_INT "RCURVELY"
#define RCP_RCURVELY_MSG_REL "RCURVELY"
#define RCP_RCURVEMX_MSG_INT "RCURVEMX"
#define RCP_RCURVEMX_MSG_REL "RCURVEMX"
#define RCP_RCURVEMY_MSG_INT "RCURVEMY"
#define RCP_RCURVEMY_MSG_REL "RCURVEMY"
#define RCP_RCURVESX_MSG_INT "RCURVESX"
#define RCP_RCURVESX_MSG_REL "RCURVESX"
#define RCP_RCURVESY_MSG_INT "RCURVESY"
#define RCP_RCURVESY_MSG_REL "RCURVESY"
#define RCP_REDG_MSG_INT "REDG"
#define RCP_REDG_MSG_LIST_PTR "REDG"
#define RCP_REDG_MSG_REL "REDG"
#define RCP_RGAIN_MSG_INT "RGAIN"
#define RCP_RGAIN_MSG_LIST_PTR "RGAIN"
#define RCP_RGAIN_MSG_REL "RGAIN"
#define RCP_RGAMMA_MSG_INT "RGAMMA"
#define RCP_RGAMMA_MSG_LIST_PTR "RGAMMA"
#define RCP_RGAMMA_MSG_REL "RGAMMA"
#define RCP_RLIFT_MSG_INT "RLIFT"
#define RCP_RLIFT_MSG_LIST_PTR "RLIFT"
#define RCP_RLIFT_MSG_REL "RLIFT"
#define RCP_ROFFSET_MSG_INT "ROFFSET"
#define RCP_ROFFSET_MSG_LIST_PTR "ROFFSET"
#define RCP_ROFFSET_MSG_REL "ROFFSET"
#define RCP_ROLLOFF_MSG_INT "ROLLOFF"
#define RCP_ROLLOFF_MSG_LIST_PTR "ROLLOFF"
#define RCP_RPOWER_MSG_INT "RPOWER"
#define RCP_RPOWER_MSG_LIST_PTR "RPOWER"
#define RCP_RPOWER_MSG_REL "RPOWER"
#define RCP_RSLOPE_MSG_INT "RSLOPE"
#define RCP_RSLOPE_MSG_LIST_PTR "RSLOPE"
#define RCP_RSLOPE_MSG_REL "RSLOPE"
#define RCP_SATURAT_MSG_INT "SATURAT"
#define RCP_SATURAT_MSG_LIST_PTR "SATURAT"
#define RCP_SATURAT_MSG_REL "SATURAT"
#define RCP_SHADOW_MSG_INT "SHADOW"
#define RCP_SHADOW_MSG_LIST_PTR "SHADOW"
#define RCP_SHADOW_MSG_REL "SHADOW"
#define RCP_TINT_MSG_INT "TINT"
#define RCP_TINT_MSG_LIST_PTR "TINT"
#define RCP_TINT_MSG_REL "TINT"
#define RCP_KEYACT_MSG_STR_PTR "KEYACT"
#define RCP_KEYCODE_MSG_INT "KEYCODE"
#define RCP_SELISO_MSG_INT "SELISO"
#define RCP_SELSH_MSG_INT "SELSH"
#define RCP_APERCTRL_MSG_INT "APERCTRL"
#define RCP_APRTR_MSG_INT "APRTR"
#define RCP_APRTR_MSG_LIST_PTR "APRTR"
#define RCP_APRTR_MSG_LIST_REL "APRTR"
#define RCP_APRTRFIN_MSG_INT "APRTRFIN"
#define RCP_APRTRT_MSG_INT "APRTRT"
#define RCP_AUTOPEAK_MSG_INT "AUTOPEAK"
#define RCP_AUTOPEAK_MSG_LIST_PTR "AUTOPEAK"
#define RCP_FLENGTH_MSG_INT "FLENGTH"
#define RCP_FLENGTH_MSG_LIST_PTR "FLENGTH"
#define RCP_FOCSCTRL_MSG_INT "FOCSCTRL"
#define RCP_FOCUS_MSG_INT "FOCUS"
#define RCP_FOCUS_MSG_LIST_PTR "FOCUS"
#define RCP_FOCUS_MSG_LIST_REL "FOCUS"
#define RCP_FOCUSF_MSG_INT "FOCUSF"
#define RCP_FOCUSN_MSG_INT "FOCUSN"
#define RCP_LDISPM_MSG_INT "LDISPM"
#define RCP_LDISPM_MSG_LIST_PTR "LDISPM"
#define RCP_LENSCAP_MSG_LIST_PTR "LENSCAP"
#define RCP_LENSFDMD_MSG_INT "LENSFDMD"
#define RCP_LENSFDMD_MSG_LIST_PTR "LENSFDMD"
#define RCP_LENSISEN_MSG_INT "LENSISEN"
#define RCP_LNMTFLMN_MSG_INT "LNMTFLMN"
#define RCP_LNMTFLMX_MSG_INT "LNMTFLMX"
#define RCP_LNMTMANU_MSG_STR_PTR "LNMTMANU"
#define RCP_LNMTNAME_MSG_STR_PTR "LNMTNAME"
#define RCP_LNMTOWNR_MSG_STR_PTR "LNMTOWNR"
#define RCP_LNMTSERL_MSG_STR_PTR "LNMTSERL"
#define RCP_MMMISOND_MSG_INT "MMMISOND"
#define RCP_MMMISOND_MSG_LIST_PTR "MMMISOND"
#define RCP_MMMODE_MSG_UINT "MMMODE"
#define RCP_MMMODE_MSG_LIST_PTR "MMMODE"
#define RCP_MMNDINSZ_MSG_INT "MMNDINSZ"
#define RCP_MMNDINSZ_MSG_LIST_PTR "MMNDINSZ"
#define RCP_MMNDMODE_MSG_INT "MMNDMODE"
#define RCP_MMNDMODE_MSG_LIST_PTR "MMNDMODE"
#define RCP_MMNDV_MSG_INT "MMNDV"
#define RCP_MMNDV_MSG_LIST_PTR "MMNDV"
#define RCP_MMNDV_MSG_LIST_REL "MMNDV"
#define RCP_PLDETECT_MSG_INT "PLDETECT"
#define RCP_PLPOWER_MSG_INT "PLPOWER"
#define RCP_SHRCKDST_MSG_INT "SHRCKDST"
#define RCP_SHRCKDST_MSG_LIST_PTR "SHRCKDST"
#define RCP_USRMDREG_MSG_USER_METADATA_REGISTER "USRMDREG"
#define RCP_USRMDSET_MSG_USER_METADATA_SEND "USRMDSET"
#define RCP_USRMDUNR_MSG_USER_METADATA_UNREGISTER "USRMDUNR"
#define RCP_BEVFBR_MSG_INT "BEVFBR"
#define RCP_BEVFBR_MSG_LIST_PTR "BEVFBR"
#define RCP_BEVFDM_MSG_INT "BEVFDM"
#define RCP_BEVFFM_MSG_INT "BEVFFM"
#define RCP_BEVFFO_MSG_INT "BEVFFO"
#define RCP_BEVFLUT_MSG_STR_PTR "BEVFLUT"
#define RCP_BEVFOV_MSG_STR_PTR "BEVFOV"
#define RCP_BEVFOV_MSG_LIST_PTR "BEVFOV"
#define RCP_BEVFRF_MSG_INT "BEVFRF"
#define RCP_BEVFTL_MSG_INT "BEVFTL"
#define RCP_BHDMIDM_MSG_INT "BHDMIDM"
#define RCP_BHDMIFM_MSG_INT "BHDMIFM"
#define RCP_BHDMIFO_MSG_INT "BHDMIFO"
#define RCP_BHDMILUT_MSG_STR_PTR "BHDMILUT"
#define RCP_BHDMIOV_MSG_STR_PTR "BHDMIOV"
#define RCP_BHDMIOV_MSG_LIST_PTR "BHDMIOV"
#define RCP_BHDMIRF_MSG_INT "BHDMIRF"
#define RCP_BHDMITL_MSG_INT "BHDMITL"
#define RCP_BHDSDIDM_MSG_INT "BHDSDIDM"
#define RCP_BHDSDIEN_MSG_INT "BHDSDIEN"
#define RCP_BHDSDIFM_MSG_INT "BHDSDIFM"
#define RCP_BHDSDIFO_MSG_INT "BHDSDIFO"
#define RCP_BHDSDIOV_MSG_STR_PTR "BHDSDIOV"
#define RCP_BHDSDIOV_MSG_LIST_PTR "BHDSDIOV"
#define RCP_BHDSDIRF_MSG_INT "BHDSDIRF"
#define RCP_BHDSDITL_MSG_INT "BHDSDITL"
#define RCP_BLCDBR_MSG_INT "BLCDBR"
#define RCP_BLCDBR_MSG_LIST_PTR "BLCDBR"
#define RCP_BLCDDM_MSG_INT "BLCDDM"
#define RCP_BLCDFM_MSG_INT "BLCDFM"
#define RCP_BLCDFM2_MSG_INT "BLCDFM2"
#define RCP_BLCDFMSP_MSG_INT "BLCDFMSP"
#define RCP_BLCDFO_MSG_INT "BLCDFO"
#define RCP_BLCDLUT_MSG_STR_PTR "BLCDLUT"
#define RCP_BLCDOV_MSG_STR_PTR "BLCDOV"
#define RCP_BLCDOV_MSG_LIST_PTR "BLCDOV"
#define RCP_BLCDRF_MSG_INT "BLCDRF"
#define RCP_BLCDTL_MSG_INT "BLCDTL"
#define RCP_BSDILUT_MSG_STR_PTR "BSDILUT"
#define RCP_DPEVF_MSG_INT "DPEVF"
#define RCP_DPEVF_MSG_LIST_PTR "DPEVF"
#define RCP_DPEVF3_MSG_INT "DPEVF3"
#define RCP_DPEVF3_MSG_LIST_PTR "DPEVF3"
#define RCP_DPHDMI_MSG_INT "DPHDMI"
#define RCP_DPHDMI_MSG_LIST_PTR "DPHDMI"
#define RCP_DPHDSDI_MSG_INT "DPHDSDI"
#define RCP_DPHDSDI_MSG_LIST_PTR "DPHDSDI"
#define RCP_DPLCD_MSG_INT "DPLCD"
#define RCP_DPLCD_MSG_LIST_PTR "DPLCD"
#define RCP_DPLCD3_MSG_INT "DPLCD3"
#define RCP_DPLCD3_MSG_LIST_PTR "DPLCD3"
#define RCP_DPPHDSD1_MSG_INT "DPPHDSD1"
#define RCP_DPPHDSD1_MSG_LIST_PTR "DPPHDSD1"
#define RCP_DPPHDSD2_MSG_INT "DPPHDSD2"
#define RCP_DPPHDSD2_MSG_LIST_PTR "DPPHDSD2"
#define RCP_DPREVF_MSG_INT "DPREVF"
#define RCP_DPREVF_MSG_LIST_PTR "DPREVF"
#define RCP_DPRLCD_MSG_INT "DPRLCD"
#define RCP_DPRLCD_MSG_LIST_PTR "DPRLCD"
#define RCP_DPUHD_MSG_INT "DPUHD"
#define RCP_DPUHD_MSG_LIST_PTR "DPUHD"
#define RCP_EVF3BR_MSG_INT "EVF3BR"
#define RCP_EVF3BR_MSG_LIST_PTR "EVF3BR"
#define RCP_EVF3DM_MSG_INT "EVF3DM"
#define RCP_EVF3F_MSG_INT "EVF3F"
#define RCP_EVF3F_MSG_LIST_PTR "EVF3F"
#define RCP_EVF3FM_MSG_INT "EVF3FM"
#define RCP_EVF3FO_MSG_INT "EVF3FO"
#define RCP_EVF3G_MSG_INT "EVF3G"
#define RCP_EVF3G_MSG_LIST_PTR "EVF3G"
#define RCP_EVF3LUT_MSG_STR_PTR "EVF3LUT"
#define RCP_EVF3M_MSG_INT "EVF3M"
#define RCP_EVF3M_MSG_LIST_PTR "EVF3M"
#define RCP_EVF3OV_MSG_STR_PTR "EVF3OV"
#define RCP_EVF3OV_MSG_LIST_PTR "EVF3OV"
#define RCP_EVF3RF_MSG_INT "EVF3RF"
#define RCP_EVF3TL_MSG_INT "EVF3TL"
#define RCP_EVFF_MSG_INT "EVFF"
#define RCP_EVFF_MSG_LIST_PTR "EVFF"
#define RCP_EVFG_MSG_INT "EVFG"
#define RCP_EVFG_MSG_LIST_PTR "EVFG"
#define RCP_EVFM_MSG_INT "EVFM"
#define RCP_EVFM_MSG_LIST_PTR "EVFM"
#define RCP_FUIBR_MSG_INT "FUIBR"
#define RCP_FUIBR_MSG_LIST_PTR "FUIBR"
#define RCP_HDMIF_MSG_INT "HDMIF"
#define RCP_HDMIF_MSG_LIST_PTR "HDMIF"
#define RCP_HDMIG_MSG_INT "HDMIG"
#define RCP_HDMIG_MSG_LIST_PTR "HDMIG"
#define RCP_HDMIM_MSG_INT "HDMIM"
#define RCP_HDMIM_MSG_LIST_PTR "HDMIM"
#define RCP_HDMIR_MSG_INT "HDMIR"
#define RCP_HDMIR_MSG_LIST_PTR "HDMIR"
#define RCP_HDSDIF_MSG_INT "HDSDIF"
#define RCP_HDSDIF_MSG_LIST_PTR "HDSDIF"
#define RCP_HDSDIG_MSG_INT "HDSDIG"
#define RCP_HDSDIG_MSG_LIST_PTR "HDSDIG"
#define RCP_HDSDIM_MSG_INT "HDSDIM"
#define RCP_HDSDIM_MSG_LIST_PTR "HDSDIM"
#define RCP_HDSDIR_MSG_INT "HDSDIR"
#define RCP_HDSDIR_MSG_LIST_PTR "HDSDIR"
#define RCP_IMGSPCRV_MSG_INT "IMGSPCRV"
#define RCP_LCD3BR_MSG_INT "LCD3BR"
#define RCP_LCD3BR_MSG_LIST_PTR "LCD3BR"
#define RCP_LCD3DM_MSG_INT "LCD3DM"
#define RCP_LCD3F_MSG_INT "LCD3F"
#define RCP_LCD3F_MSG_LIST_PTR "LCD3F"
#define RCP_LCD3FM_MSG_INT "LCD3FM"
#define RCP_LCD3FO_MSG_INT "LCD3FO"
#define RCP_LCD3G_MSG_INT "LCD3G"
#define RCP_LCD3G_MSG_LIST_PTR "LCD3G"
#define RCP_LCD3LUT_MSG_STR_PTR "LCD3LUT"
#define RCP_LCD3M_MSG_INT "LCD3M"
#define RCP_LCD3M_MSG_LIST_PTR "LCD3M"
#define RCP_LCD3OV_MSG_STR_PTR "LCD3OV"
#define RCP_LCD3OV_MSG_LIST_PTR "LCD3OV"
#define RCP_LCD3RF_MSG_INT "LCD3RF"
#define RCP_LCD3TL_MSG_INT "LCD3TL"
#define RCP_LCDF_MSG_INT "LCDF"
#define RCP_LCDF_MSG_LIST_PTR "LCDF"
#define RCP_LCDG_MSG_INT "LCDG"
#define RCP_LCDG_MSG_LIST_PTR "LCDG"
#define RCP_LCDM_MSG_INT "LCDM"
#define RCP_LCDM_MSG_LIST_PTR "LCDM"
#define RCP_MAGNIFY_MSG_INT "MAGNIFY"
#define RCP_MAGNIFY_MSG_LIST_PTR "MAGNIFY"
#define RCP_MONPRTY_MSG_LIST_PTR "MONPRTY"
#define RCP_OUTPUTTR_MSG_INT "OUTPUTTR"
#define RCP_OUTPUTTR_MSG_LIST_PTR "OUTPUTTR"
#define RCP_PHDS1EN_MSG_INT "PHDS1EN"
#define RCP_PHDS1OV_MSG_STR_PTR "PHDS1OV"
#define RCP_PHDS1OV_MSG_LIST_PTR "PHDS1OV"
#define RCP_PHDS2EN_MSG_INT "PHDS2EN"
#define RCP_PHDS2OV_MSG_STR_PTR "PHDS2OV"
#define RCP_PHDS2OV_MSG_LIST_PTR "PHDS2OV"
#define RCP_PHDSDI1F_MSG_INT "PHDSDI1F"
#define RCP_PHDSDI1F_MSG_LIST_PTR "PHDSDI1F"
#define RCP_PHDSDI1G_MSG_INT "PHDSDI1G"
#define RCP_PHDSDI1G_MSG_LIST_PTR "PHDSDI1G"
#define RCP_PHDSDI1M_MSG_INT "PHDSDI1M"
#define RCP_PHDSDI1M_MSG_LIST_PTR "PHDSDI1M"
#define RCP_PHDSDI1R_MSG_INT "PHDSDI1R"
#define RCP_PHDSDI1R_MSG_LIST_PTR "PHDSDI1R"
#define RCP_PHDSDI2F_MSG_INT "PHDSDI2F"
#define RCP_PHDSDI2F_MSG_LIST_PTR "PHDSDI2F"
#define RCP_PHDSDI2G_MSG_INT "PHDSDI2G"
#define RCP_PHDSDI2G_MSG_LIST_PTR "PHDSDI2G"
#define RCP_PHDSDI2M_MSG_INT "PHDSDI2M"
#define RCP_PHDSDI2M_MSG_LIST_PTR "PHDSDI2M"
#define RCP_PHDSDI2R_MSG_INT "PHDSDI2R"
#define RCP_PHDSDI2R_MSG_LIST_PTR "PHDSDI2R"
#define RCP_PLCDBR_MSG_INT "PLCDBR"
#define RCP_PLCDBR_MSG_LIST_PTR "PLCDBR"
#define RCP_PLCDDM_MSG_INT "PLCDDM"
#define RCP_PLCDF_MSG_INT "PLCDF"
#define RCP_PLCDF_MSG_LIST_PTR "PLCDF"
#define RCP_PLCDFM_MSG_INT "PLCDFM"
#define RCP_PLCDFO_MSG_INT "PLCDFO"
#define RCP_PLCDG_MSG_INT "PLCDG"
#define RCP_PLCDG_MSG_LIST_PTR "PLCDG"
#define RCP_PLCDM_MSG_INT "PLCDM"
#define RCP_PLCDM_MSG_LIST_PTR "PLCDM"
#define RCP_PLCDOV_MSG_STR_PTR "PLCDOV"
#define RCP_PLCDOV_MSG_LIST_PTR "PLCDOV"
#define RCP_PLCDRF_MSG_INT "PLCDRF"
#define RCP_PLCDTL_MSG_INT "PLCDTL"
#define RCP_PSDI1DM_MSG_INT "PSDI1DM"
#define RCP_PSDI1FM_MSG_INT "PSDI1FM"
#define RCP_PSDI1FO_MSG_INT "PSDI1FO"
#define RCP_PSDI1RF_MSG_INT "PSDI1RF"
#define RCP_PSDI1TL_MSG_INT "PSDI1TL"
#define RCP_PSDI2DM_MSG_INT "PSDI2DM"
#define RCP_PSDI2FM_MSG_INT "PSDI2FM"
#define RCP_PSDI2FO_MSG_INT "PSDI2FO"
#define RCP_PSDI2RF_MSG_INT "PSDI2RF"
#define RCP_PSDI2TL_MSG_INT "PSDI2TL"
#define RCP_REVFBR_MSG_INT "REVFBR"
#define RCP_REVFBR_MSG_LIST_PTR "REVFBR"
#define RCP_REVFDM_MSG_INT "REVFDM"
#define RCP_REVFF_MSG_INT "REVFF"
#define RCP_REVFF_MSG_LIST_PTR "REVFF"
#define RCP_REVFFM_MSG_INT "REVFFM"
#define RCP_REVFFO_MSG_INT "REVFFO"
#define RCP_REVFG_MSG_INT "REVFG"
#define RCP_REVFG_MSG_LIST_PTR "REVFG"
#define RCP_REVFLUT_MSG_STR_PTR "REVFLUT"
#define RCP_REVFM_MSG_INT "REVFM"
#define RCP_REVFM_MSG_LIST_PTR "REVFM"
#define RCP_REVFOV_MSG_STR_PTR "REVFOV"
#define RCP_REVFOV_MSG_LIST_PTR "REVFOV"
#define RCP_REVFRF_MSG_INT "REVFRF"
#define RCP_REVFTL_MSG_INT "REVFTL"
#define RCP_RLCDFM2_MSG_INT "RLCDFM2"
#define RCP_RLCDFMSP_MSG_INT "RLCDFMSP"
#define RCP_RLCDLUT_MSG_STR_PTR "RLCDLUT"
#define RCP_ROTF0_MSG_INT "ROTF0"
#define RCP_ROTF01_MSG_INT "ROTF01"
#define RCP_ROTF1_MSG_INT "ROTF1"
#define RCP_RSDI1FLT_MSG_STR_PTR "RSDI1FLT"
#define RCP_RSDI2FLT_MSG_STR_PTR "RSDI2FLT"
#define RCP_RTRNFEED_MSG_INT "RTRNFEED"
#define RCP_RTRNFST_MSG_INT "RTRNFST"
#define RCP_SSCANDIR_MSG_INT "SSCANDIR"
#define RCP_UHDSDI1M_MSG_INT "UHDSDI1M"
#define RCP_UHDSDI1M_MSG_LIST_PTR "UHDSDI1M"
#define RCP_UHDSDI2M_MSG_INT "UHDSDI2M"
#define RCP_UHDSDI2M_MSG_LIST_PTR "UHDSDI2M"
#define RCP_UHDSDIF_MSG_INT "UHDSDIF"
#define RCP_UHDSDIF_MSG_LIST_PTR "UHDSDIF"
#define RCP_VCODECG_MSG_INT "VCODECG"
#define RCP_VCODECG_MSG_LIST_PTR "VCODECG"
#define RCP_CGCOLOR_MSG_INT "CGCOLOR"
#define RCP_CGCOLOR_MSG_LIST_PTR "CGCOLOR"
#define RCP_CGGUIDE_MSG_INT "CGGUIDE"
#define RCP_CGGUIDE_MSG_LIST_PTR "CGGUIDE"
#define RCP_CGMARK_MSG_INT "CGMARK"
#define RCP_CGMARK_MSG_LIST_PTR "CGMARK"
#define RCP_CGOPAC_MSG_INT "CGOPAC"
#define RCP_CGOPAC_MSG_LIST_PTR "CGOPAC"
#define RCP_F0ABSH_MSG_INT "F0ABSH"
#define RCP_F0ABSW_MSG_INT "F0ABSW"
#define RCP_F0ABSXOF_MSG_INT "F0ABSXOF"
#define RCP_F0ABSYOF_MSG_INT "F0ABSYOF"
#define RCP_F0COLOR_MSG_INT "F0COLOR"
#define RCP_F0COLOR_MSG_LIST_PTR "F0COLOR"
#define RCP_F0LNST_MSG_INT "F0LNST"
#define RCP_F0LNST_MSG_LIST_PTR "F0LNST"
#define RCP_F0MODE_MSG_INT "F0MODE"
#define RCP_F0MODE_MSG_LIST_PTR "F0MODE"
#define RCP_F0NUM_MSG_INT "F0NUM"
#define RCP_F0OFFSX_MSG_INT "F0OFFSX"
#define RCP_F0OFFSX_MSG_LIST_PTR "F0OFFSX"
#define RCP_F0OFFSY_MSG_INT "F0OFFSY"
#define RCP_F0OFFSY_MSG_LIST_PTR "F0OFFSY"
#define RCP_F0OPAC_MSG_INT "F0OPAC"
#define RCP_F0OPAC_MSG_LIST_PTR "F0OPAC"
#define RCP_F0SCL_MSG_INT "F0SCL"
#define RCP_F0SCL_MSG_LIST_PTR "F0SCL"
#define RCP_F1ABSH_MSG_INT "F1ABSH"
#define RCP_F1ABSW_MSG_INT "F1ABSW"
#define RCP_F1ABSXOF_MSG_INT "F1ABSXOF"
#define RCP_F1ABSYOF_MSG_INT "F1ABSYOF"
#define RCP_F1COLOR_MSG_INT "F1COLOR"
#define RCP_F1COLOR_MSG_LIST_PTR "F1COLOR"
#define RCP_F1LNST_MSG_INT "F1LNST"
#define RCP_F1LNST_MSG_LIST_PTR "F1LNST"
#define RCP_F1MODE_MSG_INT "F1MODE"
#define RCP_F1MODE_MSG_LIST_PTR "F1MODE"
#define RCP_F1NUM_MSG_INT "F1NUM"
#define RCP_F1OFFSX_MSG_INT "F1OFFSX"
#define RCP_F1OFFSX_MSG_LIST_PTR "F1OFFSX"
#define RCP_F1OFFSY_MSG_INT "F1OFFSY"
#define RCP_F1OFFSY_MSG_LIST_PTR "F1OFFSY"
#define RCP_F1OPAC_MSG_INT "F1OPAC"
#define RCP_F1OPAC_MSG_LIST_PTR "F1OPAC"
#define RCP_F1RELF0_MSG_INT "F1RELF0"
#define RCP_F1SCL_MSG_INT "F1SCL"
#define RCP_F1SCL_MSG_LIST_PTR "F1SCL"
#define RCP_F2ABSH_MSG_INT "F2ABSH"
#define RCP_F2ABSW_MSG_INT "F2ABSW"
#define RCP_F2ABSXOF_MSG_INT "F2ABSXOF"
#define RCP_F2ABSYOF_MSG_INT "F2ABSYOF"
#define RCP_F2COLOR_MSG_INT "F2COLOR"
#define RCP_F2COLOR_MSG_LIST_PTR "F2COLOR"
#define RCP_F2LNST_MSG_INT "F2LNST"
#define RCP_F2LNST_MSG_LIST_PTR "F2LNST"
#define RCP_F2MODE_MSG_INT "F2MODE"
#define RCP_F2MODE_MSG_LIST_PTR "F2MODE"
#define RCP_F2NUM_MSG_INT "F2NUM"
#define RCP_F2OFFSX_MSG_INT "F2OFFSX"
#define RCP_F2OFFSX_MSG_LIST_PTR "F2OFFSX"
#define RCP_F2OFFSY_MSG_INT "F2OFFSY"
#define RCP_F2OFFSY_MSG_LIST_PTR "F2OFFSY"
#define RCP_F2OPAC_MSG_INT "F2OPAC"
#define RCP_F2OPAC_MSG_LIST_PTR "F2OPAC"
#define RCP_F2RELF0_MSG_INT "F2RELF0"
#define RCP_F2SCL_MSG_INT "F2SCL"
#define RCP_F2SCL_MSG_LIST_PTR "F2SCL"
#define RCP_FALSEC_MSG_INT "FALSEC"
#define RCP_FALSEC_MSG_LIST_PTR "FALSEC"
#define RCP_GGCOLOR_MSG_INT "GGCOLOR"
#define RCP_GGCOLOR_MSG_LIST_PTR "GGCOLOR"
#define RCP_GGGUIDE_MSG_INT "GGGUIDE"
#define RCP_GGGUIDE_MSG_LIST_PTR "GGGUIDE"
#define RCP_GGOPAC_MSG_INT "GGOPAC"
#define RCP_GGOPAC_MSG_LIST_PTR "GGOPAC"
#define RCP_GIOCPRI_MSG_LIST_PTR "GIOCPRI"
#define RCP_GIOCSEC_MSG_LIST_PTR "GIOCSEC"
#define RCP_GIOZONE_MSG_LIST_PTR "GIOZONE"
#define RCP_HORIZON_MSG_INT "HORIZON"
#define RCP_PEAKLVL_MSG_UINT "PEAKLVL"
#define RCP_PEAKLVL_MSG_LIST_PTR "PEAKLVL"
#define RCP_SHCOLOR_MSG_INT "SHCOLOR"
#define RCP_SHCOLOR_MSG_LIST_PTR "SHCOLOR"
#define RCP_SHGUIDE_MSG_INT "SHGUIDE"
#define RCP_SHGUIDE_MSG_LIST_PTR "SHGUIDE"
#define RCP_SHOPAC_MSG_INT "SHOPAC"
#define RCP_SHOPAC_MSG_LIST_PTR "SHOPAC"
#define RCP_TCDFMODE_MSG_INT "TCDFMODE"
#define RCP_TCDFMODE_MSG_LIST_PTR "TCDFMODE"
#define RCP_TCDMODE_MSG_INT "TCDMODE"
#define RCP_TCDMODE_MSG_LIST_PTR "TCDMODE"
#define RCP_ZEB1CLR_MSG_INT "ZEB1CLR"
#define RCP_ZEB1CLR_MSG_LIST_PTR "ZEB1CLR"
#define RCP_ZEB1PAT_MSG_INT "ZEB1PAT"
#define RCP_ZEB1PAT_MSG_LIST_PTR "ZEB1PAT"
#define RCP_ZEB2CLR_MSG_INT "ZEB2CLR"
#define RCP_ZEB2CLR_MSG_LIST_PTR "ZEB2CLR"
#define RCP_ZEB2PAT_MSG_INT "ZEB2PAT"
#define RCP_ZEB2PAT_MSG_LIST_PTR "ZEB2PAT"
#define RCP_ZEBRA1_MSG_INT "ZEBRA1"
#define RCP_ZEBRA1HI_MSG_INT "ZEBRA1HI"
#define RCP_ZEBRA1HI_MSG_LIST_PTR "ZEBRA1HI"
#define RCP_ZEBRA1HS_MSG_INT "ZEBRA1HS"
#define RCP_ZEBRA1HS_MSG_LIST_PTR "ZEBRA1HS"
#define RCP_ZEBRA1LO_MSG_INT "ZEBRA1LO"
#define RCP_ZEBRA1LO_MSG_LIST_PTR "ZEBRA1LO"
#define RCP_ZEBRA1LS_MSG_INT "ZEBRA1LS"
#define RCP_ZEBRA1LS_MSG_LIST_PTR "ZEBRA1LS"
#define RCP_ZEBRA1M_MSG_INT "ZEBRA1M"
#define RCP_ZEBRA1M_MSG_LIST_PTR "ZEBRA1M"
#define RCP_ZEBRA2_MSG_INT "ZEBRA2"
#define RCP_ZEBRA2HI_MSG_INT "ZEBRA2HI"
#define RCP_ZEBRA2HI_MSG_LIST_PTR "ZEBRA2HI"
#define RCP_ZEBRA2HS_MSG_INT "ZEBRA2HS"
#define RCP_ZEBRA2HS_MSG_LIST_PTR "ZEBRA2HS"
#define RCP_ZEBRA2LO_MSG_INT "ZEBRA2LO"
#define RCP_ZEBRA2LO_MSG_LIST_PTR "ZEBRA2LO"
#define RCP_ZEBRA2LS_MSG_INT "ZEBRA2LS"
#define RCP_ZEBRA2LS_MSG_LIST_PTR "ZEBRA2LS"
#define RCP_ZEBRA2M_MSG_INT "ZEBRA2M"
#define RCP_ZEBRA2M_MSG_LIST_PTR "ZEBRA2M"
#define RCP_CLIPLEN_MSG_INT "CLIPLEN"
#define RCP_CLIPLOAD_MSG_INT "CLIPLOAD"
#define RCP_CLPDIR_MSG_INT "CLPDIR"
#define RCP_CLPINPT_MSG_INT "CLPINPT"
#define RCP_CLPNUM_MSG_INT "CLPNUM"
#define RCP_CLPOUTPT_MSG_INT "CLPOUTPT"
#define RCP_LOOP_MSG_INT "LOOP"
#define RCP_PAUSE_MSG_INT "PAUSE"
#define RCP_PBCLSTDT_MSG_STR_PTR "PBCLSTDT"
#define RCP_PBCLSTTM_MSG_STR_PTR "PBCLSTTM"
#define RCP_PBCOLTMP_MSG_INT "PBCOLTMP"
#define RCP_PBHDRTRC_MSG_INT "PBHDRTRC"
#define RCP_PBISO_MSG_INT "PBISO"
#define RCP_PBTINT_MSG_INT "PBTINT"
#define RCP_PBZOOM_MSG_INT "PBZOOM"
#define RCP_PLAY_MSG_INT "PLAY"
#define RCP_PLAYFMT_MSG_INT "PLAYFMT"
#define RCP_PLAYFMT_MSG_LIST_PTR "PLAYFMT"
#define RCP_PLAYFMTT_MSG_INT "PLAYFMTT"
#define RCP_PLAYPAUS_MSG_INT "PLAYPAUS"
#define RCP_PLAYPOS_MSG_INT "PLAYPOS"
#define RCP_PLAYRPOS_MSG_INT "PLAYRPOS"
#define RCP_PLAYSPD_MSG_INT "PLAYSPD"
#define RCP_PLAYTYPE_MSG_INT "PLAYTYPE"
#define RCP_AMBNTCH_MSG_INT "AMBNTCH"
#define RCP_AMBNTCH_MSG_LIST_PTR "AMBNTCH"
#define RCP_CAMCOLOR_MSG_INT "CAMCOLOR"
#define RCP_CAMCOLOR_MSG_LIST_PTR "CAMCOLOR"
#define RCP_CAMERAOP_MSG_STR_PTR "CAMERAOP"
#define RCP_CAMLOC_MSG_STR_PTR "CAMLOC"
#define RCP_CAMMEID_MSG_INT "CAMMEID"
#define RCP_CAMMEID_MSG_LIST_PTR "CAMMEID"
#define RCP_CAMPOS_MSG_INT "CAMPOS"
#define RCP_CAMPOS_MSG_LIST_PTR "CAMPOS"
#define RCP_CAMSCENE_MSG_STR_PTR "CAMSCENE"
#define RCP_CAMSHOT_MSG_STR_PTR "CAMSHOT"
#define RCP_CAMTAKE_MSG_INT "CAMTAKE"
#define RCP_CAMUNIT_MSG_STR_PTR "CAMUNIT"
#define RCP_CUSTMAWB_MSG_LIST_PTR "CUSTMAWB"
#define RCP_CUSTMFMT_MSG_LIST_PTR "CUSTMFMT"
#define RCP_CUSTMFPS_MSG_LIST_PTR "CUSTMFPS"
#define RCP_CUSTMINT_MSG_LIST_PTR "CUSTMINT"
#define RCP_CUSTMISO_MSG_LIST_PTR "CUSTMISO"
#define RCP_CUSTMPHS_MSG_LIST_PTR "CUSTMPHS"
#define RCP_CUSTMRC_MSG_LIST_PTR "CUSTMRC"
#define RCP_DIRECTOR_MSG_STR_PTR "DIRECTOR"
#define RCP_DOPNAME_MSG_STR_PTR "DOPNAME"
#define RCP_FILEFMT_MSG_INT "FILEFMT"
#define RCP_FILEFMT_MSG_LIST_PTR "FILEFMT"
#define RCP_FORMAT2_MSG_INT "FORMAT2"
#define RCP_FORMAT2_MSG_LIST_PTR "FORMAT2"
#define RCP_FORMATST_MSG_STR_PTR "FORMATST"
#define RCP_FRMTA125_MSG_LIST_PTR "FRMTA125"
#define RCP_FRMTA13_MSG_LIST_PTR "FRMTA13"
#define RCP_FRMTA18_MSG_LIST_PTR "FRMTA18"
#define RCP_FRMTA2_MSG_LIST_PTR "FRMTA2"
#define RCP_FRMTANA_MSG_INT "FRMTANA"
#define RCP_FRMTANA_MSG_LIST_PTR "FRMTANA"
#define RCP_FRMTAR_MSG_INT "FRMTAR"
#define RCP_FRMTAR_MSG_LIST_PTR "FRMTAR"
#define RCP_FRMTLA_MSG_INT "FRMTLA"
#define RCP_FRMTLAST_MSG_INT "FRMTLAST"
#define RCP_FRMTRES_MSG_INT "FRMTRES"
#define RCP_FRMTRES_MSG_LIST_PTR "FRMTRES"
#define RCP_FRMTSPH_MSG_LIST_PTR "FRMTSPH"
#define RCP_FRPRMODE_MSG_INT "FRPRMODE"
#define RCP_FRPRMODE_MSG_LIST_PTR "FRPRMODE"
#define RCP_FRPRMODE_MSG_LIST_REL "FRPRMODE"
#define RCP_FRPRMODT_MSG_INT "FRPRMODT"
#define RCP_FRPRNUM_MSG_INT "FRPRNUM"
#define RCP_FRPRNUM_MSG_LIST_PTR "FRPRNUM"
#define RCP_FRPRNUM_MSG_LIST_REL "FRPRNUM"
#define RCP_FRPRNUMT_MSG_INT "FRPRNUMT"
#define RCP_GENLOC_MSG_INT "GENLOC"
#define RCP_GENSRC_MSG_INT "GENSRC"
#define RCP_GENSRC_MSG_LIST_PTR "GENSRC"
#define RCP_MASTRAWB_MSG_LIST_PTR "MASTRAWB"
#define RCP_MASTRFMT_MSG_LIST_PTR "MASTRFMT"
#define RCP_MASTRFPS_MSG_LIST_PTR "MASTRFPS"
#define RCP_MASTRINT_MSG_LIST_PTR "MASTRINT"
#define RCP_MASTRISO_MSG_LIST_PTR "MASTRISO"
#define RCP_MASTRPHS_MSG_LIST_PTR "MASTRPHS"
#define RCP_MASTRRC_MSG_LIST_PTR "MASTRRC"
#define RCP_MAXFPS_MSG_INT "MAXFPS"
#define RCP_MAXFRPRF_MSG_INT "MAXFRPRF"
#define RCP_MAXFRPRM_MSG_INT "MAXFRPRM"
#define RCP_MAXRC_MSG_INT "MAXRC"
#define RCP_MAXSHA_MSG_INT "MAXSHA"
#define RCP_MAXSHT_MSG_INT "MAXSHT"
#define RCP_METACV_MSG_INT "METACV"
#define RCP_METACV_MSG_LIST_PTR "METACV"
#define RCP_MINFPS_MSG_INT "MINFPS"
#define RCP_MINFRPRF_MSG_INT "MINFRPRF"
#define RCP_MINFRPRM_MSG_INT "MINFRPRM"
#define RCP_MINRC_MSG_INT "MINRC"
#define RCP_MINSHA_MSG_INT "MINSHA"
#define RCP_MINSHT_MSG_INT "MINSHT"
#define RCP_MIVCODEC_MSG_INT "MIVCODEC"
#define RCP_MVMCODEC_MSG_INT "MVMCODEC"
#define RCP_MXFCMPID_MSG_INT "MXFCMPID"
#define RCP_MXFH_MSG_INT "MXFH"
#define RCP_MXFW_MSG_INT "MXFW"
#define RCP_PORECFPS_MSG_UINT "PORECFPS"
#define RCP_PRERECDR_MSG_UINT "PRERECDR"
#define RCP_PRERECDR_MSG_LIST_PTR "PRERECDR"
#define RCP_PRERECON_MSG_INT "PRERECON"
#define RCP_PRISTOR_MSG_INT "PRISTOR"
#define RCP_PRISTOR_MSG_LIST_PTR "PRISTOR"
#define RCP_PRODUCTN_MSG_STR_PTR "PRODUCTN"
#define RCP_PROJFPS_MSG_INT "PROJFPS"
#define RCP_PROJFPS_MSG_LIST_PTR "PROJFPS"
#define RCP_PROJINFO_MSG_STR_PTR "PROJINFO"
#define RCP_PRORESH_MSG_INT "PRORESH"
#define RCP_PRORESW_MSG_INT "PRORESW"
#define RCP_PROXYFPS_MSG_INT "PROXYFPS"
#define RCP_PXFMTH_MSG_INT "PXFMTH"
#define RCP_PXFMTW_MSG_INT "PXFMTW"
#define RCP_PXSFMTH_MSG_INT "PXSFMTH"
#define RCP_PXSFMTW_MSG_INT "PXSFMTW"
#define RCP_RAMPADUR_MSG_INT "RAMPADUR"
#define RCP_RAMPAFPS_MSG_INT "RAMPAFPS"
#define RCP_RAMPBDUR_MSG_INT "RAMPBDUR"
#define RCP_RAMPBFPS_MSG_INT "RAMPBFPS"
#define RCP_RAMPCDUR_MSG_INT "RAMPCDUR"
#define RCP_RAMPCFPS_MSG_INT "RAMPCFPS"
#define RCP_RAMPDDUR_MSG_INT "RAMPDDUR"
#define RCP_RAMPDFPS_MSG_INT "RAMPDFPS"
#define RCP_RAMPRDUR_MSG_INT "RAMPRDUR"
#define RCP_RCTARGET_MSG_INT "RCTARGET"
#define RCP_RECLIMEN_MSG_INT "RECLIMEN"
#define RCP_RECLIMFR_MSG_UINT "RECLIMFR"
#define RCP_RECMODE_MSG_INT "RECMODE"
#define RCP_RECMODE_MSG_LIST_PTR "RECMODE"
#define RCP_RECPOST_MSG_UINT "RECPOST"
#define RCP_RECPOSTA_MSG_UINT "RECPOSTA"
#define RCP_RECPOSTB_MSG_UINT "RECPOSTB"
#define RCP_RECPRE_MSG_UINT "RECPRE"
#define RCP_RECPREA_MSG_UINT "RECPREA"
#define RCP_RECPREB_MSG_UINT "RECPREB"
#define RCP_RECTLFR_MSG_UINT "RECTLFR"
#define RCP_RECTLINT_MSG_UINT "RECTLINT"
#define RCP_REDCODE_MSG_INT "REDCODE"
#define RCP_REDCODE_MSG_LIST_PTR "REDCODE"
#define RCP_REDCODE_MSG_LIST_REL "REDCODE"
#define RCP_SENSFPS_MSG_INT "SENSFPS"
#define RCP_SENSFPS_MSG_LIST_PTR "SENSFPS"
#define RCP_SHSYNC_MSG_INT "SHSYNC"
#define RCP_SHSYNC_MSG_LIST_PTR "SHSYNC"
#define RCP_SLHEAD_MSG_INT "SLHEAD"
#define RCP_SLTAIL_MSG_INT "SLTAIL"
#define RCP_SYNC_MSG_INT "SYNC"
#define RCP_TCLTCOUT_MSG_INT "TCLTCOUT"
#define RCP_TSRVAD_MSG_STR_PTR "TSRVAD"
#define RCP_USECFL_MSG_INT "USECFL"
#define RCP_USECFRL_MSG_INT "USECFRL"
#define RCP_USECINTL_MSG_INT "USECINTL"
#define RCP_USECISOL_MSG_INT "USECISOL"
#define RCP_USECPHSL_MSG_INT "USECPHSL"
#define RCP_USECRCL_MSG_INT "USECRCL"
#define RCP_USECWBL_MSG_INT "USECWBL"
#define RCP_VCBAKED_MSG_INT "VCBAKED"
#define RCP_VCBAKED_MSG_LIST_PTR "VCBAKED"
#define RCP_VCBAKEDT_MSG_INT "VCBAKEDT"
#define RCP_VCBAKMAX_MSG_INT "VCBAKMAX"
#define RCP_VCBAKMIN_MSG_INT "VCBAKMIN"
#define RCP_VCODEC_MSG_INT "VCODEC"
#define RCP_VCODEC_MSG_LIST_PTR "VCODEC"
#define RCP_VCODECR_MSG_INT "VCODECR"
#define RCP_VCODECR_MSG_LIST_PTR "VCODECR"
#define RCP_VCODECRT_MSG_INT "VCODECRT"
#define RCP_VCODECT_MSG_INT "VCODECT"
#define RCP_VMCODCRT_MSG_INT "VMCODCRT"
#define RCP_VMCODEC_MSG_INT "VMCODEC"
#define RCP_VMCODEC_MSG_LIST_PTR "VMCODEC"
#define RCP_VMCODECR_MSG_INT "VMCODECR"
#define RCP_VMCODECR_MSG_LIST_PTR "VMCODECR"
#define RCP_VMCODECT_MSG_INT "VMCODECT"
#define RCP_VRISPDMD_MSG_INT "VRISPDMD"
#define RCP_DAHDMI_MSG_INT "DAHDMI"
#define RCP_REDINFO_MSG_STR_PTR "REDINFO"
#define RCP_SUILAH_MSG_INT "SUILAH"
#define RCP_SUILAH_MSG_LIST_PTR "SUILAH"
#define RCP_SUILAHTO_MSG_INT "SUILAHTO"
#define RCP_SUILAHTO_MSG_LIST_PTR "SUILAHTO"
#define RCP_SUILPAUD_MSG_INT "SUILPAUD"
#define RCP_SUILPAUD_MSG_LIST_PTR "SUILPAUD"
#define RCP_SUILPMON_MSG_INT "SUILPMON"
#define RCP_SUILPMON_MSG_LIST_PTR "SUILPMON"
#define RCP_SUILPUSR_MSG_INT "SUILPUSR"
#define RCP_SUILPUSR_MSG_LIST_PTR "SUILPUSR"
#define RCP_SUIRAH_MSG_INT "SUIRAH"
#define RCP_SUIRAH_MSG_LIST_PTR "SUIRAH"
#define RCP_SUIRAHTO_MSG_INT "SUIRAHTO"
#define RCP_SUIRAHTO_MSG_LIST_PTR "SUIRAHTO"
#define RCP_SUIRPAUD_MSG_INT "SUIRPAUD"
#define RCP_SUIRPAUD_MSG_LIST_PTR "SUIRPAUD"
#define RCP_SUIRPMON_MSG_INT "SUIRPMON"
#define RCP_SUIRPMON_MSG_LIST_PTR "SUIRPMON"
#define RCP_SUIRPUSR_MSG_INT "SUIRPUSR"
#define RCP_SUIRPUSR_MSG_LIST_PTR "SUIRPUSR"
#define RCP_CAMMODE_MSG_INT "CAMMODE"
#define RCP_PLAYBACK_MSG_INT "PLAYBACK"
#define RCP_PREREC "PREREC"
#define RCP_PWRSAVE_MSG_INT "PWRSAVE"
#define RCP_RECORD_MSG_INT "RECORD"
#define RCP_SHUTDOWN "SHUTDOWN"
#define RCP_SHUTDWNC "SHUTDWNC"
#define RCP_TSRVSTAT_MSG_INT "TSRVSTAT"
#define RCP_AUDIOVU_MSG_AUDIO_VU_DATA "AUDIOVU"
#define RCP_BCLIP_MSG_INT "BCLIP"
#define RCP_DSHIST_MSG_STR_PTR "DSHIST"
#define RCP_GCLIP_MSG_INT "GCLIP"
#define RCP_HISTTYPE_MSG_INT "HISTTYPE"
#define RCP_HISTTYPE_MSG_LIST_PTR "HISTTYPE"
#define RCP_MPITCH_MSG_INT "MPITCH"
#define RCP_MROLL_MSG_INT "MROLL"
#define RCP_RCLIP_MSG_INT "RCLIP"
#define RCP_CAMFWVER_MSG_STR_PTR "CAMFWVER"
#define RCP_CAMID_MSG_STR_PTR "CAMID"
#define RCP_CAMINFO_MSG_CAMINFO_PTR "CAMINFO"
#define RCP_CAMNAME_MSG_STR_PTR "CAMNAME"
#define RCP_CAMSER_MSG_STR_PTR "CAMSER"
#define RCP_CAMVCREV_MSG_STR_PTR "CAMVCREV"
#define RCP_GROUPID_MSG_STR_PTR "GROUPID"
#define RCP_HWCAP_MSG_HW_CAP_PTR "HWCAP"
#define RCP_MODCAP_MSG_LIST_PTR "MODCAP"
#define RCP_PHYSENSH_MSG_INT "PHYSENSH"
#define RCP_PHYSENSW_MSG_INT "PHYSENSW"
#define RCP_RCPPSVER_MSG_UINT "RCPPSVER"
#define RCP_RCPVER_MSG_INT "RCPVER"
#define RCP_RUNTIME_MSG_INT "RUNTIME"
#define RCP_SENSNAME_MSG_STR_PTR "SENSNAME"
#define RCP_SUPPORT_MSG_STR_PTR "SUPPORT"
#define RCP_TARGETID_MSG_STR_PTR "TARGETID"
#define RCP_ACTION_MSG_LIST_PTR "ACTION"
#define RCP_AFRCKNPT_MSG_INT "AFRCKNPT"
#define RCP_AFRCKNPT_MSG_LIST_PTR "AFRCKNPT"
#define RCP_AFRCKSPD_MSG_UINT "AFRCKSPD"
#define RCP_AFRCKTO_MSG_INT "AFRCKTO"
#define RCP_APAUMOTN_MSG_INT "APAUMOTN"
#define RCP_APAUPLAY_MSG_INT "APAUPLAY"
#define RCP_APAUSTIL_MSG_INT "APAUSTIL"
#define RCP_APMOTION_MSG_STR_PTR "APMOTION"
#define RCP_APMOTION_MSG_LIST_PTR "APMOTION"
#define RCP_APPLAY_MSG_STR_PTR "APPLAY"
#define RCP_APPLAY_MSG_LIST_PTR "APPLAY"
#define RCP_APSTART_MSG_STR_PTR "APSTART"
#define RCP_APSTART_MSG_LIST_PTR "APSTART"
#define RCP_APSTILLS_MSG_STR_PTR "APSTILLS"
#define RCP_APSTILLS_MSG_LIST_PTR "APSTILLS"
#define RCP_BATTMODE_MSG_INT "BATTMODE"
#define RCP_BATTMODE_MSG_LIST_PTR "BATTMODE"
#define RCP_BATTRTM_MSG_INT "BATTRTM"
#define RCP_BEEPEN_MSG_INT "BEEPEN"
#define RCP_BEEPREC_MSG_INT "BEEPREC"
#define RCP_BEEPREC_MSG_LIST_PTR "BEEPREC"
#define RCP_BEEPSTOP_MSG_INT "BEEPSTOP"
#define RCP_BEEPSTOP_MSG_LIST_PTR "BEEPSTOP"
#define RCP_BEEPTAGS_MSG_INT "BEEPTAGS"
#define RCP_BEEPTAGS_MSG_LIST_PTR "BEEPTAGS"
#define RCP_BEVFFM2_MSG_INT "BEVFFM2"
#define RCP_BEVFFMSP_MSG_INT "BEVFFMSP"
#define RCP_BHDSGLO_MSG_INT "BHDSGLO"
#define RCP_BHDSGLO_MSG_REL "BHDSGLO"
#define RCP_CALAUTO "CALAUTO"
#define RCP_CALENTRY_MSG_STR_PTR "CALENTRY"
#define RCP_CALINT_MSG_INT "CALINT"
#define RCP_CALMANC "CALMANC"
#define RCP_CALMAND "CALMAND"
#define RCP_CALSTAT_MSG_UINT "CALSTAT"
#define RCP_CALTEMP_MSG_INT "CALTEMP"
#define RCP_CAMUPG "CAMUPG"
#define RCP_CCAL_MSG_LIST_PTR "CCAL"
#define RCP_CCALAPLY_MSG_STR_PTR "CCALAPLY"
#define RCP_CCALDEL_MSG_STR_PTR "CCALDEL"
#define RCP_CCALE2M_MSG_STR_PTR "CCALE2M"
#define RCP_CCALEA2M "CCALEA2M"
#define RCP_CCDL_MSG_LIST_PTR "CCDL"
#define RCP_CCDLAPLY_MSG_STR_PTR "CCDLAPLY"
#define RCP_CCDLCREA "CCDLCREA"
#define RCP_CCDLDEL_MSG_STR_PTR "CCDLDEL"
#define RCP_CCDLE2M_MSG_STR_PTR "CCDLE2M"
#define RCP_CCDLEA2M "CCDLEA2M"
#define RCP_CLIPNAME_MSG_STR_PTR "CLIPNAME"
#define RCP_CLIPNMST_MSG_INT "CLIPNMST"
#define RCP_CLOK_MSG_LIST_PTR "CLOK"
#define RCP_CLOKAPLY_MSG_STR_PTR "CLOKAPLY"
#define RCP_CLOKDEL_MSG_STR_PTR "CLOKDEL"
#define RCP_CLOKE2M_MSG_STR_PTR "CLOKE2M"
#define RCP_CLOKEA2M "CLOKEA2M"
#define RCP_CLUT_MSG_LIST_PTR "CLUT"
#define RCP_CLUTCH0_MSG_STR_PTR "CLUTCH0"
#define RCP_CLUTCH0_MSG_LIST_PTR "CLUTCH0"
#define RCP_CLUTCH1_MSG_STR_PTR "CLUTCH1"
#define RCP_CLUTCH1_MSG_LIST_PTR "CLUTCH1"
#define RCP_CLUTCH2_MSG_STR_PTR "CLUTCH2"
#define RCP_CLUTCH2_MSG_LIST_PTR "CLUTCH2"
#define RCP_CLUTCH3_MSG_STR_PTR "CLUTCH3"
#define RCP_CLUTCH3_MSG_LIST_PTR "CLUTCH3"
#define RCP_CLUTDEL_MSG_STR_PTR "CLUTDEL"
#define RCP_CLUTE2M_MSG_STR_PTR "CLUTE2M"
#define RCP_CLUTEA2M "CLUTEA2M"
#define RCP_CLUTF1_MSG_STR_PTR "CLUTF1"
#define RCP_CLUTF1_MSG_LIST_PTR "CLUTF1"
#define RCP_CLUTF1EN_MSG_INT "CLUTF1EN"
#define RCP_CNA1ADDR_MSG_STR_PTR "CNA1ADDR"
#define RCP_CNA1ENA_MSG_INT "CNA1ENA"
#define RCP_CNA1STA_MSG_INT "CNA1STA"
#define RCP_COLORSCI_MSG_INT "COLORSCI"
#define RCP_COLORSCI_MSG_LIST_PTR "COLORSCI"
#define RCP_COVR_MSG_LIST_PTR "COVR"
#define RCP_COVRDEL_MSG_STR_PTR "COVRDEL"
#define RCP_COVRE2M_MSG_STR_PTR "COVRE2M"
#define RCP_COVREA2M "COVREA2M"
#define RCP_CPRE_MSG_LIST_PTR "CPRE"
#define RCP_CPREAPLY_MSG_STR_PTR "CPREAPLY"
#define RCP_CPREDEL_MSG_STR_PTR "CPREDEL"
#define RCP_CPREE2M_MSG_STR_PTR "CPREE2M"
#define RCP_CPREEA2M "CPREEA2M"
#define RCP_CPREUP_MSG_STR_PTR "CPREUP"
#define RCP_CSCR_MSG_LIST_PTR "CSCR"
#define RCP_CTRLSCRN_MSG_STR_PTR "CTRLSCRN"
#define RCP_CURRTEMP_MSG_INT "CURRTEMP"
#define RCP_CURSENST_MSG_INT "CURSENST"
#define RCP_DATETIME_MSG_INT "DATETIME"
#define RCP_DIALOGS_MSG_LIST_PTR "DIALOGS"
#define RCP_DRPFRMS_MSG_INT "DRPFRMS"
#define RCP_EJECT_MSG_INT "EJECT"
#define RCP_EVF3FM2_MSG_INT "EVF3FM2"
#define RCP_EVF3FMSP_MSG_INT "EVF3FMSP"
#define RCP_EVFTALLY_MSG_INT "EVFTALLY"
#define RCP_EVOLTHDC_MSG_INT "EVOLTHDC"
#define RCP_EVOLTHSH_MSG_INT "EVOLTHSH"
#define RCP_FANPCTF_MSG_INT "FANPCTF"
#define RCP_FANPCTT_MSG_INT "FANPCTT"
#define RCP_FANTRGTT_MSG_INT "FANTRGTT"
#define RCP_FANTRGTT_MSG_LIST_PTR "FANTRGTT"
#define RCP_FMTCAMID_MSG_INT "FMTCAMID"
#define RCP_FMTCAMID_MSG_LIST_PTR "FMTCAMID"
#define RCP_FMTCAMPO_MSG_INT "FMTCAMPO"
#define RCP_FMTCAMPO_MSG_LIST_PTR "FMTCAMPO"
#define RCP_FMTETCS_MSG_INT "FMTETCS"
#define RCP_FMTFSYS_MSG_INT "FMTFSYS"
#define RCP_FMTFSYS_MSG_LIST_PTR "FMTFSYS"
#define RCP_FMTMEDIA_MSG_INT "FMTMEDIA"
#define RCP_FMTREELN_MSG_INT "FMTREELN"
#define RCP_FPRDELAY_MSG_INT "FPRDELAY"
#define RCP_FPRDELAY_MSG_LIST_PTR "FPRDELAY"
#define RCP_FSMODE_MSG_INT "FSMODE"
#define RCP_FSMODE_MSG_LIST_PTR "FSMODE"
#define RCP_GEC2C_MSG_INT "GEC2C"
#define RCP_GEDHCP_MSG_INT "GEDHCP"
#define RCP_GEEXT_MSG_INT "GEEXT"
#define RCP_GEGWADDR_MSG_UINT "GEGWADDR"
#define RCP_GEIPADDR_MSG_UINT "GEIPADDR"
#define RCP_GEMAC_MSG_STR_PTR "GEMAC"
#define RCP_GENETMSK_MSG_UINT "GENETMSK"
#define RCP_GESTDTL_MSG_INT "GESTDTL"
#define RCP_GESTDTR_MSG_INT "GESTDTR"
#define RCP_GESTPNCH_MSG_INT "GESTPNCH"
#define RCP_GPIN_MSG_INT "GPIN"
#define RCP_GPIN_MSG_LIST_PTR "GPIN"
#define RCP_GPOUT_MSG_INT "GPOUT"
#define RCP_GPOUT_MSG_LIST_PTR "GPOUT"
#define RCP_IMGPIPEM_MSG_INT "IMGPIPEM"
#define RCP_IMGPIPEM_MSG_LIST_PTR "IMGPIPEM"
#define RCP_KEYACNOT_MSG_INT "KEYACNOT"
#define RCP_LCD3FM2_MSG_INT "LCD3FM2"
#define RCP_LCD3FMSP_MSG_INT "LCD3FMSP"
#define RCP_MCAL_MSG_LIST_PTR "MCAL"
#define RCP_MCALAPLY_MSG_STR_PTR "MCALAPLY"
#define RCP_MCALI2C_MSG_STR_PTR "MCALI2C"
#define RCP_MCALIA2C "MCALIA2C"
#define RCP_MCDL_MSG_LIST_PTR "MCDL"
#define RCP_MCDLI2C_MSG_STR_PTR "MCDLI2C"
#define RCP_MCDLIA2C "MCDLIA2C"
#define RCP_MEDACLPC_MSG_INT "MEDACLPC"
#define RCP_MEDAGCII_MSG_EXTENDED_CLIPINFO_PTR "MEDAGCII"
#define RCP_MEDASRNU_MSG_STR_PTR "MEDASRNU"
#define RCP_MEDATCHD_MSG_INT "MEDATCHD"
#define RCP_MEDIA_MSG_INT "MEDIA"
#define RCP_MEDIA_MSG_LIST_PTR "MEDIA"
#define RCP_MEDIAMIN_MSG_INT "MEDIAMIN"
#define RCP_MEDIAMOD_MSG_INT "MEDIAMOD"
#define RCP_MEDIAMOD_MSG_LIST_PTR "MEDIAMOD"
#define RCP_MEDIANUM_MSG_STR_PTR "MEDIANUM"
#define RCP_MEDIAPCT_MSG_INT "MEDIAPCT"
#define RCP_MEDIASZ_MSG_UINT "MEDIASZ"
#define RCP_MEDIASZA_MSG_UINT "MEDIASZA"
#define RCP_MEDIAUPG "MEDIAUPG"
#define RCP_MEDIAVER_MSG_STR_PTR "MEDIAVER"
#define RCP_MEDPRSNT_MSG_INT "MEDPRSNT"
#define RCP_MENUST_MSG_RCP_API_MENU_NODE_ENABLE "MENUST"
#define RCP_MENUTREE_MSG_MENU_TREE_CHILDREN "MENUTREE"
#define RCP_MENUTREE_MSG_LIST_PTR "MENUTREE"
#define RCP_MLABEL_MSG_STR_PTR "MLABEL"
#define RCP_MLOK_MSG_LIST_PTR "MLOK"
#define RCP_MLOKI2C_MSG_STR_PTR "MLOKI2C"
#define RCP_MLOKIA2C "MLOKIA2C"
#define RCP_MLUT_MSG_LIST_PTR "MLUT"
#define RCP_MLUTI2C_MSG_STR_PTR "MLUTI2C"
#define RCP_MLUTIA2C "MLUTIA2C"
#define RCP_MONLIST_MSG_LIST_PTR "MONLIST"
#define RCP_MOVR_MSG_LIST_PTR "MOVR"
#define RCP_MOVRI2C_MSG_STR_PTR "MOVRI2C"
#define RCP_MOVRIA2C "MOVRIA2C"
#define RCP_MPRE_MSG_LIST_PTR "MPRE"
#define RCP_MPREI2C_MSG_STR_PTR "MPREI2C"
#define RCP_MPREIA2C "MPREIA2C"
#define RCP_MTMST0_MSG_INT "MTMST0"
#define RCP_MTMST1_MSG_INT "MTMST1"
#define RCP_MTMST2_MSG_INT "MTMST2"
#define RCP_MXFDRPFM_MSG_INT "MXFDRPFM"
#define RCP_MXFST_MSG_INT "MXFST"
#define RCP_MXFSTD_MSG_STR_PTR "MXFSTD"
#define RCP_NOTIFY_MSG_NOTIFICATION_PTR "NOTIFY"
#define RCP_NOTIFYF_MSG_NOTIFICATION_RESPONSE_PTR "NOTIFYF"
#define RCP_NOTIFYR_MSG_NOTIFICATION_RESPONSE_PTR "NOTIFYR"
#define RCP_NWSTAT_MSG_INT "NWSTAT"
#define RCP_OLPF_MSG_INT "OLPF"
#define RCP_OLPF_MSG_LIST_PTR "OLPF"
#define RCP_OLPFTPEM_MSG_INT "OLPFTPEM"
#define RCP_OLPFTPEM_MSG_LIST_PTR "OLPFTPEM"
#define RCP_OLPFTPNM_MSG_STR_PTR "OLPFTPNM"
#define RCP_PLABEL_MSG_STR_PTR "PLABEL"
#define RCP_POBAC_MSG_INT "POBAC"
#define RCP_POBAE_MSG_INT "POBAE"
#define RCP_POBAR "POBAR"
#define RCP_POBAS_MSG_INT "POBAS"
#define RCP_POPIOAE_MSG_INT "POPIOAE"
#define RCP_POPIOGE_MSG_INT "POPIOGE"
#define RCP_POPIOGR "POPIOGR"
#define RCP_POPIOGS_MSG_INT "POPIOGS"
#define RCP_POPIOPE_MSG_INT "POPIOPE"
#define RCP_POPIOPR "POPIOPR"
#define RCP_POPIOPS_MSG_INT "POPIOPS"
#define RCP_POPOPE_MSG_INT "POPOPE"
#define RCP_POPOPR "POPOPR"
#define RCP_POPOPS_MSG_INT "POPOPS"
#define RCP_POPTPE_MSG_INT "POPTPE"
#define RCP_POPTPR "POPTPR"
#define RCP_POPTPS_MSG_INT "POPTPS"
#define RCP_PORXTCE_MSG_INT "PORXTCE"
#define RCP_PORXTCR "PORXTCR"
#define RCP_PORXTCS_MSG_INT "PORXTCS"
#define RCP_POSTTC_MSG_INT "POSTTC"
#define RCP_PREVFS_MSG_INT "PREVFS"
#define RCP_PREVFS_MSG_LIST_PTR "PREVFS"
#define RCP_PSLEVEL1_MSG_UINT "PSLEVEL1"
#define RCP_PSLEVEL1_MSG_LIST_PTR "PSLEVEL1"
#define RCP_PSLEVEL2_MSG_UINT "PSLEVEL2"
#define RCP_PSLEVEL2_MSG_LIST_PTR "PSLEVEL2"
#define RCP_PSLEVEL3_MSG_UINT "PSLEVEL3"
#define RCP_PSLEVEL3_MSG_LIST_PTR "PSLEVEL3"
#define RCP_PWIAMPS_MSG_INDEXED_INT "PWIAMPS"
#define RCP_PWIBDA_MSG_INDEXED_BATTERY_DATA "PWIBDA"
#define RCP_PWIBTLVL_MSG_INDEXED_INT "PWIBTLVL"
#define RCP_PWIBTRT_MSG_INDEXED_INT "PWIBTRT"
#define RCP_PWILIST_MSG_LIST_PTR "PWILIST"
#define RCP_PWIPRST_MSG_INDEXED_INT "PWIPRST"
#define RCP_PWISRCI_MSG_INT "PWISRCI"
#define RCP_PWITYPE_MSG_INDEXED_INT "PWITYPE"
#define RCP_PWIVBT_MSG_INDEXED_INT "PWIVBT"
#define RCP_PWIVOLT_MSG_INDEXED_INT "PWIVOLT"
#define RCP_PWOIAMPS_MSG_INDEXED_INT "PWOIAMPS"
#define RCP_PWOIEN_MSG_INDEXED_INT "PWOIEN"
#define RCP_PWOIRST_MSG_INT "PWOIRST"
#define RCP_PWOIST_MSG_INDEXED_INT "PWOIST"
#define RCP_PWOLIST_MSG_LIST_PTR "PWOLIST"
#define RCP_PWRBATL_MSG_INT "PWRBATL"
#define RCP_PWRSRC_MSG_INT "PWRSRC"
#define RCP_PWRSRC_MSG_LIST_PTR "PWRSRC"
#define RCP_QTDRPFRM_MSG_INT "QTDRPFRM"
#define RCP_QTST_MSG_INT "QTST"
#define RCP_QTSTD_MSG_STR_PTR "QTSTD"
#define RCP_R3DST_MSG_INT "R3DST"
#define RCP_R3DSTD_MSG_STR_PTR "R3DSTD"
#define RCP_RCPCLL_MSG_LIST_PTR "RCPCLL"
#define RCP_RCPID_MSG_RCP_ID "RCPID"
#define RCP_RCPPING_MSG_STR_PTR "RCPPING"
#define RCP_RECFS_MSG_INT "RECFS"
#define RCP_RECFS_MSG_LIST_PTR "RECFS"
#define RCP_REQFILE_MSG_REQFILE_PTR "REQFILE"
#define RCP_RESETDEF "RESETDEF"
#define RCP_RESETHW "RESETHW"
#define RCP_RESETUSR "RESETUSR"
#define RCP_REVFFM2_MSG_INT "REVFFM2"
#define RCP_REVFFMSP_MSG_INT "REVFFMSP"
#define RCP_RFTPABOR_MSG_RFTP_ABORT "RFTPABOR"
#define RCP_RFTPDATA_MSG_RFTP_DATA "RFTPDATA"
#define RCP_RFTPDELE_MSG_RFTP_DELETE "RFTPDELE"
#define RCP_RFTPLIST_MSG_RFTP_LIST "RFTPLIST"
#define RCP_RFTPPAUS_MSG_RFTP_PAUSE_STATE "RFTPPAUS"
#define RCP_RFTPRETR_MSG_RFTP_RETRIEVE "RFTPRETR"
#define RCP_RFTPSTOR_MSG_RFTP_STORE "RFTPSTOR"
#define RCP_RIGSTATE_MSG_INT "RIGSTATE"
#define RCP_RMCAMMAC_MSG_STR_PTR "RMCAMMAC"
#define RCP_RMCH_MSG_INT "RMCH"
#define RCP_RMCH_MSG_LIST_PTR "RMCH"
#define RCP_RMDMAC_MSG_LIST_PTR "RMDMAC"
#define RCP_RMEN_MSG_INT "RMEN"
#define RCP_RMMAC_MSG_STR_PTR "RMMAC"
#define RCP_RMPAIR_MSG_STR_PTR "RMPAIR"
#define RCP_RMPMAC_MSG_LIST_PTR "RMPMAC"
#define RCP_RMSCAN "RMSCAN"
#define RCP_RMSTATE_MSG_INT "RMSTATE"
#define RCP_RMUNPAIR_MSG_STR_PTR "RMUNPAIR"
#define RCP_RMUPG "RMUPG"
#define RCP_SAVELOG "SAVELOG"
#define RCP_SENSTVTY_MSG_INT "SENSTVTY"
#define RCP_SENSTVTY_MSG_LIST_PTR "SENSTVTY"
#define RCP_SERPROT2_MSG_INT "SERPROT2"
#define RCP_SERPROT2_MSG_LIST_PTR "SERPROT2"
#define RCP_SERPROTO_MSG_INT "SERPROTO"
#define RCP_SERPROTO_MSG_LIST_PTR "SERPROTO"
#define RCP_SFMTMEDI_MSG_INT "SFMTMEDI"
#define RCP_SMDLG9IN_MSG_INT "SMDLG9IN"
#define RCP_SMLCKKEY_MSG_INT "SMLCKKEY"
#define RCP_SMLCKNAV_MSG_INT "SMLCKNAV"
#define RCP_SMLCKREC_MSG_INT "SMLCKREC"
#define RCP_SSDTALLY_MSG_INT "SSDTALLY"
#define RCP_SUNAME_MSG_STR_PTR "SUNAME"
#define RCP_TAGGED_MSG_TAG_PTR "TAGGED"
#define RCP_TARGET_MSG_INT "TARGET"
#define RCP_TARGET_MSG_LIST_PTR "TARGET"
#define RCP_TCJAM_MSG_INT "TCJAM"
#define RCP_TCSOURCE_MSG_INT "TCSOURCE"
#define RCP_TCSOURCE_MSG_LIST_PTR "TCSOURCE"
#define RCP_TETHERS_MSG_INT "TETHERS"
#define RCP_TETHERSI_MSG_INT "TETHERSI"
#define RCP_TIMEZONE_MSG_INT "TIMEZONE"
#define RCP_TIMEZONE_MSG_LIST_PTR "TIMEZONE"
#define RCP_TPATTERN_MSG_INT "TPATTERN"
#define RCP_TPATTERN_MSG_LIST_PTR "TPATTERN"
#define RCP_TPATTONE_MSG_INT "TPATTONE"
#define RCP_TSRVCN_MSG_INT "TSRVCN"
#define RCP_TSRVRN_MSG_INT "TSRVRN"
#define RCP_TSRVSPR_MSG_UINT "TSRVSPR"
#define RCP_TSRVSPT_MSG_UINT "TSRVSPT"
#define RCP_TURRGLO_MSG_INT "TURRGLO"
#define RCP_TURRGLO_MSG_REL "TURRGLO"
#define RCP_TWARN1_MSG_INT "TWARN1"
#define RCP_TWARN2_MSG_INT "TWARN2"
#define RCP_TWARN3_MSG_INT "TWARN3"
#define RCP_UILOCK_MSG_INT "UILOCK"
#define RCP_USER_MSG_USER_DATA "USER"
#define RCP_USERKEY_MSG_KEY_MAPPING "USERKEY"
#define RCP_VOLTHSDC_MSG_INT "VOLTHSDC"
#define RCP_VOLTHSH_MSG_INT "VOLTHSH"
#define RCP_WLANAHEN_MSG_INT "WLANAHEN"
#define RCP_WLANAHEN_MSG_LIST_PTR "WLANAHEN"
#define RCP_WLANAHID_MSG_STR_PTR "WLANAHID"
#define RCP_WLANAHPW_MSG_STR_PTR "WLANAHPW"
#define RCP_WLANAPEN_MSG_INT "WLANAPEN"
#define RCP_WLANAPEN_MSG_LIST_PTR "WLANAPEN"
#define RCP_WLANAPID_MSG_STR_PTR "WLANAPID"
#define RCP_WLANAPPW_MSG_STR_PTR "WLANAPPW"
#define RCP_WLANCHAN_MSG_INT "WLANCHAN"
#define RCP_WLANCHAN_MSG_LIST_PTR "WLANCHAN"
#define RCP_WLANCONN "WLANCONN"
#define RCP_WLANDHCP_MSG_INT "WLANDHCP"
#define RCP_WLANGATE_MSG_UINT "WLANGATE"
#define RCP_WLANIP_MSG_UINT "WLANIP"
#define RCP_WLANMAC_MSG_STR_PTR "WLANMAC"
#define RCP_WLANMODE_MSG_INT "WLANMODE"
#define RCP_WLANMODE_MSG_LIST_PTR "WLANMODE"
#define RCP_WLANNETM_MSG_UINT "WLANNETM"
#define RCP_WLANSCAN "WLANSCAN"
#define RCP_WLANSCRL_MSG_LIST_PTR "WLANSCRL"
#define RCP_WLANSCS_MSG_STR_PTR "WLANSCS"
#define RCP_WLANSIG_MSG_INT "WLANSIG"
#define RCP_WLANSTAT_MSG_INT "WLANSTAT"
#define RCP_WSHFOCUS_MSG_INT "WSHFOCUS"

#endif
/********** End file: rcp_parameter_types_public.h ******************************/

/********** Begin file: rcp_api_discovery.h *************************************/
#ifndef RCP_API_DISCOVERY_H
#define RCP_API_DISCOVERY_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#endif
/********** End file: rcp_api_discovery.h ***************************************/

/********** Begin file: rcp_api_send_current.h **********************************/
#ifndef RCP_API_SEND_CURRENT
#define RCP_API_SEND_CURRENT

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE void _rcp_send_current_int(rcp_camera_connection_t * con, rcp_param_t id, int target_val_updated);
RCP_API_PRIVATE void _rcp_send_current_uint(rcp_camera_connection_t * con, rcp_param_t id, int target_val_updated);
RCP_API_PRIVATE void _rcp_send_current_list(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_t send_as_id);
RCP_API_PRIVATE void _rcp_send_current_str(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_send_current_composite_string(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_send_current_status(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_send_current_default_int(rcp_camera_connection_t * con, rcp_param_t id);
RCP_API_PRIVATE void _rcp_send_current_default_uint(rcp_camera_connection_t * con, rcp_param_t id);

#endif
/********** End file: rcp_api_send_current.h ************************************/

/********** Begin file: rcp_api_get_default.h ***********************************/
#ifndef RCP_API_GET_DEFAULT_H
#define RCP_API_GET_DEFAULT_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#endif
/********** End file: rcp_api_get_default.h *************************************/

/********** Begin file: rcp_api_get_list.h **************************************/
#ifndef RCP_API_GET_LIST_H
#define RCP_API_GET_LIST_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_get_list(rcp_camera_connection_t * con, rcp_param_t id);

#endif
/********** End file: rcp_api_get_list.h ****************************************/

/********** Begin file: rcp_api_get_periodic.h **********************************/
#ifndef RCP_API_GET_PERIODIC
#define RCP_API_GET_PERIODIC

/* #include "rcp_api.h" */

#endif
/********** End file: rcp_api_get_periodic.h ************************************/

/********** Begin file: rcp_api_get_status.h ************************************/
#ifndef RCP_API_GET_STATUS_H
#define RCP_API_GET_STATUS_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_get_status(rcp_camera_connection_t * con, rcp_param_t id);

#endif
/********** End file: rcp_api_get_status.h **************************************/

/********** Begin file: rcp_api_hist.h ******************************************/
#ifndef RCP_API_HIST_H
#define RCP_API_HIST_H

/* #include "rcp_api.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

RCP_API_PRIVATE void _rcp_process_hist_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);

#endif
/********** End file: rcp_api_hist.h ********************************************/

/********** Begin file: base64.h ************************************************/
#ifndef BASE64_H_
#define BASE64_H_

#include <stdlib.h>

#ifdef __cplusplus
extern "C"
{
#endif

/**
 * encode an array of bytes using Base64 (RFC 3548)
 *
 * @param source the source buffer
 * @param sourcelen the length of the source buffer
 * @param target the target buffer
 * @param targetlen the length of the target buffer
 * @return 1 on success, 0 otherwise
 */
int base64_encode(const unsigned char * source, size_t sourcelen, char * target, size_t targetlen);

/**
 * decode base64 encoded data
 *
 * @param source the encoded data (zero terminated)
 * @param target pointer to the target buffer
 * @param targetlen length of the target buffer
 * @return length of converted data on success, -1 otherwise
 */
size_t base64_decode(const char * source, unsigned char * target, size_t targetlen);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: base64.h **************************************************/

/********** Begin file: rcp_api_hw_cap.h ****************************************/
#ifndef RCP_API_HW_CAP_H
#define RCP_API_HW_CAP_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_api_camera_connection.h" */

RCP_API_PRIVATE void _rcp_process_hw_cap_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
RCP_API_PRIVATE void _rcp_hw_cap_not_supported(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_hw_cap_update_status(rcp_camera_connection_t * con);
RCP_API_PRIVATE int _rcp_get_hw_cap(const rcp_camera_connection_t * con, hw_cap_t hw_cap);

#endif
/********** End file: rcp_api_hw_cap.h ******************************************/

/********** Begin file: rcp_api_key_mapping.h ***********************************/
#ifndef RCP_API_KEY_MAPPING_H
#define RCP_API_KEY_MAPPING_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

RCP_API_PRIVATE void _rcp_key_mapping_preset_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_key_mapping_look_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_key_mapping_action_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_key_mapping_dialog_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_key_mapping_script_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
RCP_API_PRIVATE void _rcp_key_mapping_hw_cap_changed(rcp_camera_connection_t * con);
RCP_API_PRIVATE void _rcp_process_key_mapping_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);

#endif
/********** End file: rcp_api_key_mapping.h *************************************/

/********** Begin file: rcp_api_set_int.h ***************************************/
#ifndef RCP_API_SET_INT_H
#define RCP_API_SET_INT_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_set_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val);
RCP_API_PRIVATE void _rcp_create_set_int_message(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t val);

#ifdef RCP_API_ENABLE_RELATIVE
RCP_API_PRIVATE rcp_error_t _rcp_set_int_from_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t val, int32_t offset);
#endif

#endif
/********** End file: rcp_api_set_int.h *****************************************/

/********** Begin file: rcp_api_set_uint.h **************************************/
#ifndef RCP_API_SET_UINT_H
#define RCP_API_SET_UINT_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

RCP_API_PRIVATE rcp_error_t _rcp_set_uint(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val);
#ifdef RCP_API_ENABLE_RELATIVE
RCP_API_PRIVATE rcp_error_t _rcp_set_uint_from_relative(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val, int32_t offset);
#endif

#endif
/********** End file: rcp_api_set_uint.h ****************************************/

/********** Begin file: rcp_api_process_data.h **********************************/
#ifndef RCP_API_PROCESS_DATA_H
#define RCP_API_PROCESS_DATA_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#endif
/********** End file: rcp_api_process_data.h ************************************/

/********** Begin file: rcp_config.h ********************************************/
#define GPERF_LEN_TYPE unsigned int
/********** End file: rcp_config.h **********************************************/

/********** Begin file: rcp_api_parameters_hash_table.h *************************/
#ifndef RCP_API_PARAMETERS_HASH_TABLE_H
#define RCP_API_PARAMETERS_HASH_TABLE_H

/* #include "rcp_api.h" */
/* #include "rcp_config.h" */

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct rcp_current_table {
    const char * msg;
    rcp_param_t id;
} cur_msg_to_param_id_t;

RCP_API_PRIVATE const cur_msg_to_param_id_t * _rcp_get_id_from_cur_msg(register const char * str, register GPERF_LEN_TYPE len);

#ifdef __cplusplus
}
#endif

#endif
/********** End file: rcp_api_parameters_hash_table.h ***************************/

/********** Begin file: rcp_api_user.h ******************************************/
#ifndef RCP_API_USER_H
#define RCP_API_USER_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_parser/rcp_parser2.h" */

RCP_API_PRIVATE void _rcp_process_user_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
RCP_API_PRIVATE void _rcp_process_user_metadata_reg_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);

#endif
/********** End file: rcp_api_user.h ********************************************/

/********** Begin file: rcp_api_send.h ******************************************/
#ifndef RCP_API_GET_STATUS_H
#define RCP_API_GET_STATUS_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#endif
/********** End file: rcp_api_send.h ********************************************/

/********** Begin file: rcp_api_set_list.h **************************************/
#ifndef RCP_API_SET_LIST_H
#define RCP_API_SET_LIST_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#ifdef RCP_API_ENABLE_RELATIVE
RCP_API_PRIVATE rcp_error_t _rcp_set_list_from_relative(rcp_camera_connection_t * con, rcp_param_t id, const char * list_val, int32_t offset);
RCP_API_PRIVATE rcp_error_t _rcp_get_current_entry_from_list(const rcp_camera_connection_t * con, const char * list_val, c_list_entry_t * entry);
#endif

#endif
/********** End file: rcp_api_set_list.h ****************************************/

/********** Begin file: rcp_api_version.h ***************************************/
#ifndef RCP_API_VERSION_H
#define RCP_API_VERSION_H

/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */

#endif
/********** End file: rcp_api_version.h *****************************************/

/********** Begin file: rcp_sdk_version.h ***************************************/
#ifndef RCP_SDK_VERSION_H 
#define RCP_SDK_VERSION_H 
#define RCP_SDK_VERSION "6.62.0" 
#endif 
/********** End file: rcp_sdk_version.h *****************************************/

/********** Begin file: rcp_api_auto_gen_tables.h *******************************/
/* This file is auto-generated; do not modify by hand! */

#define POWER_OUT_CUR_TO_GET_STATUS_DEPENEDENCIES \
    {RCP_PARAM_POWER_OUT_ENABLE_0, RCP_PARAM_POWER_OUT_STATUS_0},\
    {RCP_PARAM_POWER_OUT_ENABLE_0, RCP_PARAM_POWER_OUT_RESET_0},\
    {RCP_PARAM_POWER_OUT_STATUS_0, RCP_PARAM_POWER_OUT_RESET_0},\
    {RCP_PARAM_POWER_OUT_ENABLE_0, RCP_PARAM_POWER_OUT_CURRENT_0},\
    {RCP_PARAM_POWER_OUT_STATUS_0, RCP_PARAM_POWER_OUT_CURRENT_0},\
    {RCP_PARAM_POWER_OUT_ENABLE_1, RCP_PARAM_POWER_OUT_STATUS_1},\
    {RCP_PARAM_POWER_OUT_ENABLE_1, RCP_PARAM_POWER_OUT_RESET_1},\
    {RCP_PARAM_POWER_OUT_STATUS_1, RCP_PARAM_POWER_OUT_RESET_1},\
    {RCP_PARAM_POWER_OUT_ENABLE_1, RCP_PARAM_POWER_OUT_CURRENT_1},\
    {RCP_PARAM_POWER_OUT_STATUS_1, RCP_PARAM_POWER_OUT_CURRENT_1},\
    {RCP_PARAM_POWER_OUT_ENABLE_2, RCP_PARAM_POWER_OUT_STATUS_2},\
    {RCP_PARAM_POWER_OUT_ENABLE_2, RCP_PARAM_POWER_OUT_RESET_2},\
    {RCP_PARAM_POWER_OUT_STATUS_2, RCP_PARAM_POWER_OUT_RESET_2},\
    {RCP_PARAM_POWER_OUT_ENABLE_2, RCP_PARAM_POWER_OUT_CURRENT_2},\
    {RCP_PARAM_POWER_OUT_STATUS_2, RCP_PARAM_POWER_OUT_CURRENT_2},\
    {RCP_PARAM_POWER_OUT_ENABLE_3, RCP_PARAM_POWER_OUT_STATUS_3},\
    {RCP_PARAM_POWER_OUT_ENABLE_3, RCP_PARAM_POWER_OUT_RESET_3},\
    {RCP_PARAM_POWER_OUT_STATUS_3, RCP_PARAM_POWER_OUT_RESET_3},\
    {RCP_PARAM_POWER_OUT_ENABLE_3, RCP_PARAM_POWER_OUT_CURRENT_3},\
    {RCP_PARAM_POWER_OUT_STATUS_3, RCP_PARAM_POWER_OUT_CURRENT_3},\
    {RCP_PARAM_POWER_OUT_ENABLE_4, RCP_PARAM_POWER_OUT_STATUS_4},\
    {RCP_PARAM_POWER_OUT_ENABLE_4, RCP_PARAM_POWER_OUT_RESET_4},\
    {RCP_PARAM_POWER_OUT_STATUS_4, RCP_PARAM_POWER_OUT_RESET_4},\
    {RCP_PARAM_POWER_OUT_ENABLE_4, RCP_PARAM_POWER_OUT_CURRENT_4},\
    {RCP_PARAM_POWER_OUT_STATUS_4, RCP_PARAM_POWER_OUT_CURRENT_4},\
    {RCP_PARAM_POWER_OUT_ENABLE_5, RCP_PARAM_POWER_OUT_STATUS_5},\
    {RCP_PARAM_POWER_OUT_ENABLE_5, RCP_PARAM_POWER_OUT_RESET_5},\
    {RCP_PARAM_POWER_OUT_STATUS_5, RCP_PARAM_POWER_OUT_RESET_5},\
    {RCP_PARAM_POWER_OUT_ENABLE_5, RCP_PARAM_POWER_OUT_CURRENT_5},\
    {RCP_PARAM_POWER_OUT_STATUS_5, RCP_PARAM_POWER_OUT_CURRENT_5},\
    {RCP_PARAM_POWER_OUT_ENABLE_6, RCP_PARAM_POWER_OUT_STATUS_6},\
    {RCP_PARAM_POWER_OUT_ENABLE_6, RCP_PARAM_POWER_OUT_RESET_6},\
    {RCP_PARAM_POWER_OUT_STATUS_6, RCP_PARAM_POWER_OUT_RESET_6},\
    {RCP_PARAM_POWER_OUT_ENABLE_6, RCP_PARAM_POWER_OUT_CURRENT_6},\
    {RCP_PARAM_POWER_OUT_STATUS_6, RCP_PARAM_POWER_OUT_CURRENT_6},\
    {RCP_PARAM_POWER_OUT_ENABLE_7, RCP_PARAM_POWER_OUT_STATUS_7},\
    {RCP_PARAM_POWER_OUT_ENABLE_7, RCP_PARAM_POWER_OUT_RESET_7},\
    {RCP_PARAM_POWER_OUT_STATUS_7, RCP_PARAM_POWER_OUT_RESET_7},\
    {RCP_PARAM_POWER_OUT_ENABLE_7, RCP_PARAM_POWER_OUT_CURRENT_7},\
    {RCP_PARAM_POWER_OUT_STATUS_7, RCP_PARAM_POWER_OUT_CURRENT_7},\
    {RCP_PARAM_POWER_OUT_ENABLE_8, RCP_PARAM_POWER_OUT_STATUS_8},\
    {RCP_PARAM_POWER_OUT_ENABLE_8, RCP_PARAM_POWER_OUT_RESET_8},\
    {RCP_PARAM_POWER_OUT_STATUS_8, RCP_PARAM_POWER_OUT_RESET_8},\
    {RCP_PARAM_POWER_OUT_ENABLE_8, RCP_PARAM_POWER_OUT_CURRENT_8},\
    {RCP_PARAM_POWER_OUT_STATUS_8, RCP_PARAM_POWER_OUT_CURRENT_8},\
    {RCP_PARAM_POWER_OUT_ENABLE_9, RCP_PARAM_POWER_OUT_STATUS_9},\
    {RCP_PARAM_POWER_OUT_ENABLE_9, RCP_PARAM_POWER_OUT_RESET_9},\
    {RCP_PARAM_POWER_OUT_STATUS_9, RCP_PARAM_POWER_OUT_RESET_9},\
    {RCP_PARAM_POWER_OUT_ENABLE_9, RCP_PARAM_POWER_OUT_CURRENT_9},\
    {RCP_PARAM_POWER_OUT_STATUS_9, RCP_PARAM_POWER_OUT_CURRENT_9}

#define POWER_OUT_CUR_LIST_TO_GET_STATUS_DEPENEDENCIES \
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_0},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_0},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_0},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_0},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_1},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_1},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_1},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_1},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_2},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_2},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_2},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_2},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_3},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_3},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_3},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_3},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_4},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_4},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_4},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_4},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_5},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_5},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_5},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_5},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_6},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_6},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_6},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_6},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_7},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_7},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_7},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_7},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_8},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_8},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_8},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_8},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_ENABLE_9},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_STATUS_9},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_RESET_9},\
    {RCP_PARAM_POWER_OUT_LIST, RCP_PARAM_POWER_OUT_CURRENT_9}

#define POWER_IN_CUR_LIST_TO_GET_STATUS_DEPENEDENCIES \
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_0},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_1},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_2},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_3},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_4},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_5},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_6},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_7},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_8},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PERCENT_9},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_RUNTIME_9},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_VOLTAGE_9},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_CURRENT_9},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_PRESENT_9},\
    {RCP_PARAM_POWER_IN_LIST, RCP_PARAM_POWER_IN_TYPE_9}

#define POWER_IN_CUR_TO_GET_STATUS_DEPENEDENCIES \
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_PERCENT_0},\
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_RUNTIME_0},\
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_VOLTAGE_0},\
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_CURRENT_0},\
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_TYPE_0},\
    {RCP_PARAM_POWER_IN_PRESENT_0, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_PERCENT_1},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_RUNTIME_1},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_VOLTAGE_1},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_CURRENT_1},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_TYPE_1},\
    {RCP_PARAM_POWER_IN_PRESENT_1, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_1},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_PERCENT_2},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_RUNTIME_2},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_VOLTAGE_2},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_CURRENT_2},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_TYPE_2},\
    {RCP_PARAM_POWER_IN_PRESENT_2, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_2},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_PERCENT_3},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_RUNTIME_3},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_VOLTAGE_3},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_CURRENT_3},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_TYPE_3},\
    {RCP_PARAM_POWER_IN_PRESENT_3, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_3},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_PERCENT_4},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_RUNTIME_4},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_VOLTAGE_4},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_CURRENT_4},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_TYPE_4},\
    {RCP_PARAM_POWER_IN_PRESENT_4, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_4},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_PERCENT_5},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_RUNTIME_5},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_VOLTAGE_5},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_CURRENT_5},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_TYPE_5},\
    {RCP_PARAM_POWER_IN_PRESENT_5, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_5},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_PERCENT_6},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_RUNTIME_6},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_VOLTAGE_6},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_CURRENT_6},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_TYPE_6},\
    {RCP_PARAM_POWER_IN_PRESENT_6, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_6},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_PERCENT_7},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_RUNTIME_7},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_VOLTAGE_7},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_CURRENT_7},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_TYPE_7},\
    {RCP_PARAM_POWER_IN_PRESENT_7, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_7},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_PERCENT_8},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_RUNTIME_8},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_VOLTAGE_8},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_CURRENT_8},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_TYPE_8},\
    {RCP_PARAM_POWER_IN_PRESENT_8, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_8},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_PERCENT_9},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_RUNTIME_9},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_VOLTAGE_9},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_CURRENT_9},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_TYPE_9},\
    {RCP_PARAM_POWER_IN_PRESENT_9, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_9}

#define POWER_IN_CUR_TO_GET_DEPENEDENCIES \
    {RCP_PARAM_POWER_IN_VOLTAGE_0, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_0, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_0, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_0, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_1, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_1, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_1, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_1, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_1, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_2, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_2, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_2, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_2, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_2, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_3, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_3, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_3, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_3, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_3, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_4, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_4, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_4, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_4, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_4, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_5, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_5, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_5, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_5, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_5, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_6, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_6, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_6, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_6, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_6, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_7, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_7, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_7, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_7, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_7, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_8, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_8, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_8, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_8, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_8, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_9, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_RUNTIME_9, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_PERCENT_9, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_TYPE_9, RCP_PARAM_POWER_DISPLAY_VAL},\
    {RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_9, RCP_PARAM_POWER_DISPLAY_VAL}

/********** End file: rcp_api_auto_gen_tables.h *********************************/

/********** Begin file: rcp_api_audio_vu.c **************************************/
/* #include "rcp_api_audio_vu.h" */

/* #include "rcp_api_get.h" */

#include <string.h>
/* #include "decorated_string/decorated_string.h" */
/* #include "stringl/stringl.h" */

RCP_API_PRIVATE void _rcp_process_audio_vu_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con)
    {
        if (con->cur_audio_vu_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_audio_vu_cb_data_t audio_vu_data;

            int valid = 1;
            const rcp_param_state_t * const varispeed_state = &con->param_state[RCP_PARAM_VARISPEED_MODE];
            const rcp_param_state_t * const project_fps_state = &con->param_state[RCP_PARAM_PROJECT_FRAME_RATE];
            const rcp_param_state_t * const ch1_name_state = &con->param_state[RCP_PARAM_AUDIO_CH1_NAME];
            const rcp_param_state_t * const ch2_name_state = &con->param_state[RCP_PARAM_AUDIO_CH2_NAME];
            const rcp_param_state_t * const ch3_name_state = &con->param_state[RCP_PARAM_AUDIO_CH3_NAME];
            const rcp_param_state_t * const ch4_name_state = &con->param_state[RCP_PARAM_AUDIO_CH4_NAME];
            const rcp_param_state_t * const vu_meter_source_state = &con->param_state[RCP_PARAM_AUDIO_VU_METER_SOURCE];
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const ch12_state = &con->param_state[RCP_PARAM_AUDIO_CH12_STATE];
            const rcp_param_state_t * const ch34_state = &con->param_state[RCP_PARAM_AUDIO_CH34_STATE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
            const rcp_param_state_t * const ch12_output_name = &con->param_state[RCP_PARAM_AUDIO_CH12_OUTPUT_NAME];
            const rcp_param_state_t * const ch34_output_name = &con->param_state[RCP_PARAM_AUDIO_CH34_OUTPUT_NAME];
            const rcp_param_state_t * const ch56_output_name = &con->param_state[RCP_PARAM_AUDIO_CH56_OUTPUT_NAME];
            const rcp_param_state_t * const bwf_valid = &con->param_state[RCP_PARAM_BWF_VALID];

            char output1_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char output2_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char output3_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char output4_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char output5_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char output6_label[RCP_API_DISPLAY_STR_SIZE] = {0};

            int bwfVal = 0;

            audio_vu_data.con = con;

            if (!varispeed_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_VARISPEED_MODE);
                valid = 0;
            }

            if (!project_fps_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_PROJECT_FRAME_RATE);
                valid = 0;
            }

            if (!ch1_name_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH1_NAME);
                valid = 0;
            }

            if (!ch2_name_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH2_NAME);
                valid = 0;
            }

            if (!ch3_name_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH3_NAME);
                valid = 0;
            }

            if (!ch4_name_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH4_NAME);
                valid = 0;
            }

            if (!vu_meter_source_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_VU_METER_SOURCE);
                valid = 0;
            }

            if (!record_mode_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_RECORD_MODE);
                valid = 0;
            }

            if (!ch12_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH12_STATE);
                valid = 0;
            }

            if (!ch34_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_AUDIO_CH34_STATE);
                valid = 0;
            }

            if (!playback_state->val_valid)
            {
                (void) _rcp_get(con, RCP_PARAM_PLAYBACK_STATE);
                valid = 0;
            }

            if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH12_OUTPUT_NAME, NULL))
            {
                if (!ch12_output_name->val_valid)
                {
                    (void) _rcp_get(con, RCP_PARAM_AUDIO_CH12_OUTPUT_NAME);
                    valid = 0;
                }
            }

            if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH34_OUTPUT_NAME, NULL))
            {
                if (!ch34_output_name->val_valid)
                {
                    (void) _rcp_get(con, RCP_PARAM_AUDIO_CH34_OUTPUT_NAME);
                    valid = 0;
                }
            }

            if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH56_OUTPUT_NAME, NULL))
            {
                if (!ch56_output_name->val_valid)
                {
                    (void) _rcp_get(con, RCP_PARAM_AUDIO_CH56_OUTPUT_NAME);
                    valid = 0;
                }
            }

            if (rcp_get_is_supported(con, RCP_PARAM_BWF_VALID, NULL))
            {
                if (bwf_valid->val_valid)
                {
                    bwfVal = bwf_valid->val.int_val;
                }
                else
                {
                    (void) _rcp_get(con, RCP_PARAM_BWF_VALID);
                    valid = 0;
                }
            }

            if (valid)
            {
                char input1_label[RCP_API_DISPLAY_STR_SIZE] = {0};
                char input2_label[RCP_API_DISPLAY_STR_SIZE] = {0};
                char input3_label[RCP_API_DISPLAY_STR_SIZE] = {0};
                char input4_label[RCP_API_DISPLAY_STR_SIZE] = {0};
                char no_audio_vu_info_label1[RCP_API_DISPLAY_STR_SIZE] = {0};
                char no_audio_vu_info_label2[RCP_API_DISPLAY_STR_SIZE] = {0};
                const record_mode_t record_mode = (record_mode_t) record_mode_state->val.int_val;
                int audio_enabled = 0;

                strlcpy(input1_label, ch1_name_state->val.str_val, sizeof(input1_label));
                strlcpy(input2_label, ch2_name_state->val.str_val, sizeof(input2_label));
                strlcpy(input3_label, ch3_name_state->val.str_val, sizeof(input3_label));
                strlcpy(input4_label, ch4_name_state->val.str_val, sizeof(input4_label));
                if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH12_OUTPUT_NAME, NULL))
                {
                    strlcpy(output1_label, ch12_output_name->val.str_val, sizeof(output1_label));
                    strlcpy(output2_label, ch12_output_name->val.str_val, sizeof(output2_label));
                }
                else
                {
                    strlcpy(output1_label, "CAM", sizeof(output1_label));
                    strlcpy(output2_label, "CAM", sizeof(output2_label));
                }
                if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH34_OUTPUT_NAME, NULL))
                {
                    strlcpy(output3_label, ch34_output_name->val.str_val, sizeof(output3_label));
                    strlcpy(output4_label, ch34_output_name->val.str_val, sizeof(output4_label));
                }
                else
                {
                    strlcpy(output3_label, "REAR", sizeof(output3_label));
                    strlcpy(output4_label, "REAR", sizeof(output4_label));
                }
                if (rcp_get_is_supported(con, RCP_PARAM_AUDIO_CH56_OUTPUT_NAME, NULL))
                {
                    strlcpy(output5_label, ch56_output_name->val.str_val, sizeof(output5_label));
                    strlcpy(output6_label, ch56_output_name->val.str_val, sizeof(output6_label));
                }
                else
                {
                    strlcpy(output5_label, "MON", sizeof(output5_label));
                    strlcpy(output6_label, "MON", sizeof(output6_label));
                }

                if ((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK)
                {
                    audio_enabled = 1;
                    strlcpy(no_audio_vu_info_label1, "", sizeof(no_audio_vu_info_label1));
                    strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                }
                else
                {
                    switch (record_mode)
                    {
                        case RECORD_MODE_TIMELAPSE:
                            strlcpy(no_audio_vu_info_label1, "Timer", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        case RECORD_MODE_PREVIEW_OVERDRIVE:
                            strlcpy(no_audio_vu_info_label1, "REDCAST PVW", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        case RECORD_MODE_FRAME_TRIGGER:
                            strlcpy(no_audio_vu_info_label1, "Trigger", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        case RECORD_MODE_RAMP:
                            strlcpy(no_audio_vu_info_label1, "Ramp", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        case RECORD_MODE_BURST:
                            strlcpy(no_audio_vu_info_label1, "REDCODE&reg; Burst", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        case RECORD_MODE_MULTI_SHOT:
                            strlcpy(no_audio_vu_info_label1, "Multi-Shot", sizeof(no_audio_vu_info_label1));
                            strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            break;

                        default:
                            if (varispeed_state->val.int_val && !bwfVal)
                            {
                                char project_fps_label[RCP_API_DISPLAY_STR_SIZE];
                                decorated_string_create_fps_label(project_fps_label, sizeof(project_fps_label), DECORATED_STRING_LEN_NORMAL, project_fps_state->val.int_val);

                                strlcpy(no_audio_vu_info_label1, "Varispeed", sizeof(no_audio_vu_info_label1));
                                strlcpy(no_audio_vu_info_label2, "Project: ", sizeof(no_audio_vu_info_label2));
                                strlcat(no_audio_vu_info_label2, project_fps_label, sizeof(no_audio_vu_info_label2));
                            }
                            else
                            {
                                audio_enabled = 1;
                                strlcpy(no_audio_vu_info_label1, "", sizeof(no_audio_vu_info_label1));
                                strlcpy(no_audio_vu_info_label2, "", sizeof(no_audio_vu_info_label2));
                            }
                            break;
                    }
                }

                audio_vu_data.show_audio_vu_meters = audio_enabled;
                audio_vu_data.input_label[0] = input1_label;
                audio_vu_data.input_label[1] = input2_label;
                audio_vu_data.input_label[2] = input3_label;
                audio_vu_data.input_label[3] = input4_label;
                audio_vu_data.output_label[0] = output1_label;
                audio_vu_data.output_label[1] = output2_label;
                audio_vu_data.output_label[2] = output3_label;
                audio_vu_data.output_label[3] = output4_label;
                audio_vu_data.output_label[4] = output5_label;
                audio_vu_data.output_label[5] = output6_label;
                audio_vu_data.vu_meter_source = (vu_meter_source_t) vu_meter_source_state->val.int_val;
                audio_vu_data.no_audio_vu_info[0] = no_audio_vu_info_label1;
                audio_vu_data.no_audio_vu_info[1] = no_audio_vu_info_label2;
                audio_vu_data.input_state[0] = ch12_state->val.int_val;
                audio_vu_data.input_state[1] = ch12_state->val.int_val;
                audio_vu_data.input_state[2] = ch34_state->val.int_val;
                audio_vu_data.input_state[3] = ch34_state->val.int_val;
                audio_vu_data.bwf_valid = bwfVal;

                if (packet && packet->argc == 10)
                {
                    audio_vu_data.input_db[0] = atoi(packet->argv[0]);
                    audio_vu_data.input_db[1] = atoi(packet->argv[1]);
                    audio_vu_data.input_db[2] = atoi(packet->argv[2]);
                    audio_vu_data.input_db[3] = atoi(packet->argv[3]);
                    audio_vu_data.output_db[0] = atoi(packet->argv[4]);
                    audio_vu_data.output_db[1] = atoi(packet->argv[5]);
                    audio_vu_data.output_db[2] = atoi(packet->argv[6]);
                    audio_vu_data.output_db[3] = atoi(packet->argv[7]);
                    audio_vu_data.output_db[4] = atoi(packet->argv[8]);
                    audio_vu_data.output_db[5] = atoi(packet->argv[9]);
                    audio_vu_data.is_db_data_valid = 1;
                }
                else
                {
                    audio_vu_data.is_db_data_valid = 0;
                    memset(audio_vu_data.input_db, 0, sizeof(audio_vu_data.input_db));
                    memset(audio_vu_data.output_db, 0, sizeof(audio_vu_data.output_db));
                }

                con->cur_audio_vu_cb(&audio_vu_data, con->cur_audio_vu_cb_user_data);
            }
        }
    }
}
/********** End file: rcp_api_audio_vu.c ****************************************/

/********** Begin file: rcp_api_camera_connection.c *****************************/
/* #include "rcp_api_camera_connection.h" */

/* #include "rcp_api_clip_list.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_notifications.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_state.h" */
/* #include "rcp_api_utils.h" */
/* #include "rcp_api_uuid.h" */

#include <string.h>

rcp_camera_connection_t * rcp_create_camera_connection(const rcp_camera_connection_info_t * info)
{
    _rcp_log_info(NULL, "creating camera connection\n");

    if (info)
    {
        /* Allocate and initialize camera connection structure. */
        rcp_camera_connection_t * const con = RCP_MALLOC(rcp_camera_connection_t *, sizeof(rcp_camera_connection_t));
        if (con)
        {
            size_t id;
            con->state = RCP_CONNECTION_STATE_COUNT;
            con->send_data_to_camera_cb = info->send_data_to_camera_cb;
            con->send_data_to_camera_cb_user_data = info->send_data_to_camera_cb_user_data;
            con->cur_int_cb = info->cur_int_cb;
            con->cur_int_cb_user_data = info->cur_int_cb_user_data;
            con->cur_uint_cb = info->cur_uint_cb;
            con->cur_uint_cb_user_data = info->cur_uint_cb_user_data;
            con->cur_list_cb = info->cur_list_cb;
            con->cur_list_cb_user_data = info->cur_list_cb_user_data;
            con->cur_hist_cb = info->cur_hist_cb;
            con->cur_hist_cb_user_data = info->cur_hist_cb_user_data;
            con->cur_str_cb = info->cur_str_cb;
            con->cur_str_cb_user_data = info->cur_str_cb_user_data;
            con->clip_list_cb = info->clip_list_cb;
            con->clip_list_cb_user_data = info->clip_list_cb_user_data;
            con->cur_tag_cb = info->cur_tag_cb;
            con->cur_tag_cb_user_data = info->cur_tag_cb_user_data;
            con->cur_status_cb = info->cur_status_cb;
            con->cur_status_cb_user_data = info->cur_status_cb_user_data;
            con->notification_cb = info->notification_cb;
            con->notification_cb_user_data = info->notification_cb_user_data;
            con->cur_audio_vu_cb = info->cur_audio_vu_cb;
            con->cur_audio_vu_cb_user_data = info->cur_audio_vu_cb_user_data;
            con->cur_menu_cb = info->cur_menu_cb;
            con->cur_menu_cb_user_data = info->cur_menu_cb_user_data;
            con->cur_menu_node_status_cb = info->cur_menu_node_status_cb;
            con->cur_menu_node_status_cb_user_data = info->cur_menu_node_status_cb_user_data;
            con->rftp_status_cb = info->rftp_status_cb;
            con->rftp_status_cb_user_data = info->rftp_status_cb_user_data;
            con->handle_user_set_cb = info->handle_user_set_cb;
            con->handle_user_set_cb_user_data = info->handle_user_set_cb_user_data;
            con->handle_user_get_cb = info->handle_user_get_cb;
            con->handle_user_get_cb_user_data = info->handle_user_get_cb_user_data;
            con->handle_user_current_cb = info->handle_user_current_cb;
            con->handle_user_current_cb_user_data = info->handle_user_current_cb_user_data;
            con->handle_user_metadata_cb = info->handle_user_metadata_cb;
            con->handle_user_metadata_cb_user_data = info->handle_user_metadata_cb_user_data;
            con->cur_default_int_cb = info->cur_default_int_cb;
            con->cur_default_int_cb_user_data = info->cur_default_int_cb_user_data;
            con->cur_default_uint_cb = info->cur_default_uint_cb;
            con->cur_default_uint_cb_user_data = info->cur_default_uint_cb_user_data;
            con->cur_action_list_cb = info->cur_action_list_cb;
            con->cur_action_list_cb_user_data = info->cur_action_list_cb_user_data;
            con->cur_key_mapping_cb = info->cur_key_mapping_cb;
            con->cur_key_mapping_cb_user_data = info->cur_key_mapping_cb_user_data;
            con->state_cb = info->state_cb;
            con->state_cb_user_data = info->state_cb_user_data;

            for (id = 0; id < (size_t) RCP_PARAM_COUNT; id++)
            {
                con->param_state[id].val_valid = 0;
                con->param_state[id].target_val_valid = 0;
                con->param_state[id].default_val_valid = 0;
                con->param_state[id].list_val = NULL;
                con->param_state[id].list_val_valid = 0;
                con->param_state[id].list_current_val_valid = 0;
                con->param_state[id].val.str_val = NULL;
                con->param_state[id].is_enabled = 0;
                con->param_state[id].is_hw_supported = 0;
                con->param_state[id].is_hw_supported_valid = 0;
                con->param_state[id].is_color_science_supported = 0;
                con->param_state[id].is_color_science_supported_valid = 0;
                con->param_state[id].is_enabled_valid = 0;
                con->param_state[id].get_pending = 0;
                con->param_state[id].get_target_pending = 0;
                con->param_state[id].get_list_pending = 0;
                con->param_state[id].edit_info = _rcp_param_def[id].default_edit_info;
                con->param_state[id].generated_label = NULL;
#ifdef RCP_API_ENABLE_RELATIVE
                con->param_state[id].pending_relative_offset_value = 0;
                con->param_state[id].pending_relative_list_offset_value = 0;
                con->param_state[id].expected_retry_count = 0;
#endif
            }
            con->parser_state.buf = con->parser_buffer;
            con->parser_state.buf_len = sizeof(con->parser_buffer);
            con->parser_state.initialized = 0;
#ifdef RCP_API_ENABLE_CLIP_LIST
            if (con->clip_list_cb)
            {
                con->clip_list_state = CLIP_LIST_STATE_GET_RECORD_STATE;
            }
            else
            {
                con->clip_list_state = CLIP_LIST_STATE_DISABLED;
            }
            con->clip_list = NULL;
            _rcp_clip_list_clear(con);
            con->last_media_label[0] = 0;
#endif
            con->last_record_state = RECORD_STATE_COUNT;
            con->last_test_pattern = MONITOR_TEST_PATTERN_COUNT;
            con->last_magnify_state = MAGNIFY_MODE_COUNT;
            con->last_playback_state = PLAYBACK_STATE_COUNT;
            con->last_playback_file_format_type = FILE_FORMAT_TYPE_COUNT;
            con->last_raw_mode = RAW_MODE_COUNT;
            con->last_video_source = VIDEO_SOURCE_COUNT;
            con->last_output_transform= OUTPUT_TRANSFORM_COUNT;
            con->last_color_science = COLOR_SCIENCE_COUNT;

            con->rcp_version = 0;
            con->rcp_version_valid = 0;
            con->parameter_set_version_major = 0;
            con->parameter_set_version_minor = 0;
            con->parameter_set_newer = 0;
            con->parameter_set_version_valid = 0;
            con->deferred_error = RCP_SUCCESS;
            memset(&con->cam_info, 0, sizeof(con->cam_info));
            con->cam_info_valid = 0;
#ifdef RCP_API_ENABLE_NOTIFICATIONS
            con->notification_list = NULL;
#endif

#ifdef RCP_API_ENABLE_MENU
            _rcp_menu_init(con);
#endif

#ifdef RCP_API_ENABLE_STATS
            memset(&(con->stats), 0, sizeof(con->stats));
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
            con->rftp_transfer = NULL;
#endif

            memset(con->hw_cap_data, 0, sizeof(con->hw_cap_data));

            if (!_rcp_create_uuid(&con->uuid))
            {
                _rcp_log_error(con, "cannot create UUID\n");
            }

            if (info->client_name)
            {
                con->client_name = _rcp_strdup(info->client_name);
            }
            else
            {
                con->client_name = _rcp_strdup("");
            }

            if (info->client_version)
            {
                con->client_version = _rcp_strdup(info->client_version);
            }
            else
            {
                con->client_version = _rcp_strdup("");
            }

            if (info->client_user)
            {
                con->client_user = _rcp_strdup(info->client_user);
            }
            else
            {
                con->client_user = _rcp_strdup("");
            }

            con->key_mapping_action_list = NULL;
            con->key_action_apply_look_prefix[0] = 0;
            con->key_action_apply_preset_prefix[0] = 0;
            con->key_action_show_dialog_prefix[0] = 0;
            con->key_action_run_script_prefix[0] = 0;
            con->key_mapping_key_code_queue_length = 0;
            con->key_mapping_key_code_queue = NULL;

            _rcp_log_info(con, "camera connection created\n");

            _rcp_set_state(con, RCP_CONNECTION_STATE_INIT);
        }

        return con;
    }
    else
    {
        _rcp_log_error(NULL, "null info passed in\n");
    }
    return NULL;
}

void rcp_delete_camera_connection(rcp_camera_connection_t * con)
{
    size_t id;

    rcp_mutex_lock(RCP_MUTEX_CONNECTION);

    _rcp_log_info(NULL, "deleting camera connection\n");

    if (con)
    {
        /* delete any allocated memory for each parameter */
        for (id = 0; id < (size_t) RCP_PARAM_COUNT; id++)
        {
            if (con->param_state[id].list_val)
            {
                rcp_free(con->param_state[id].list_val);
            }

            if (_rcp_param_def[id].current_type == RCP_TYPE_STR && con->param_state[id].val.str_val)
            {
                rcp_free(con->param_state[id].val.str_val);
            }

            if (con->param_state[id].generated_label)
            {
                rcp_free(con->param_state[id].generated_label);
            }
        }

#ifdef RCP_API_ENABLE_CLIP_LIST
        _rcp_clip_list_clear(con);
#endif

#ifdef RCP_API_ENABLE_NOTIFICATIONS
        while (con->notification_list)
        {
            _rcp_notification_remove(con, con->notification_list);
        }
#endif

#ifdef RCP_API_ENABLE_MENU
        _rcp_menu_clear(con);
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
        _rcp_rftp_free_all_data(con);
#endif

        rcp_free(con->client_name);
        rcp_free(con->client_version);
        rcp_free(con->client_user);

        if (con->key_mapping_action_list)
        {
            (void) c_list_delete(con->key_mapping_action_list);
        }
        if (con->key_mapping_key_code_queue)
        {
            rcp_free(con->key_mapping_key_code_queue);
        }

        /* delete connection object itself */
        rcp_free(con);
    }
    else
    {
        _rcp_log_error(NULL, "null camera connection passed in\n");
    }

    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
}

RCP_API_PRIVATE void _rcp_connection_send_packet(rcp_camera_connection_t * con, const char * buf, size_t len)
{
    if (con->send_data_to_camera_cb)
    {
#ifdef RCP_API_ENABLE_STATS
        con->stats.tx_packets++;
        con->stats.tx_bytes += len;
#endif
        _rcp_set_deferred_error(con, con->send_data_to_camera_cb(buf, len, con->send_data_to_camera_cb_user_data));
    }
}

rcp_error_t rcp_camera_connection_stats(const rcp_camera_connection_t * con, rcp_camera_connection_stats_t * stats)
{
    if (stats)
    {
        memset(stats, 0, sizeof(rcp_camera_connection_stats_t));
    }

#ifdef RCP_API_ENABLE_STATS
    if (con)
    {
        if (stats)
        {
            *stats = con->stats;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
#endif

    return RCP_SUCCESS;
}

int rcp_is_get_pending(const rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con && id < RCP_PARAM_COUNT)
    {
        return con->param_state[id].get_pending;
    }
    return 0;
}

int rcp_is_get_target_pending(const rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con && id < RCP_PARAM_COUNT)
    {
        return con->param_state[id].get_target_pending;
    }
    return 0;
}

RCP_API_PRIVATE int _rcp_version_in_range(const rcp_camera_connection_t * con, const rcp_version_range_t * range)
{
    if (range)
    {
        return _rcp_version_in_range_ext(con, range->first.major, range->first.minor, range->last.major, range->last.minor);
    }
    else
    {
        return 0;
    }
}

/* return 1 if the connection paramter set version is withing min and
 * max (inclusive) else return 0.
 *
 * note: a version of 0.0 will be ignored in the test.
 * */
RCP_API_PRIVATE int _rcp_version_in_range_ext(const rcp_camera_connection_t * con, uint16_t min_major, uint16_t min_minor, uint16_t max_major, uint16_t max_minor)
{
    int greater_than_or_equal_to_min = 0;
    int less_than_or_equal_to_max = 0;

    if (con)
    {
        if (min_major == 0 && min_minor == 0)
        {
            greater_than_or_equal_to_min = 1;
        }
        else
        {
            if (con->parameter_set_version_major > min_major || (con->parameter_set_version_major == min_major && con->parameter_set_version_minor >= min_minor))
            {
                greater_than_or_equal_to_min = 1;
            }
        }

        if (max_major == 0 && max_minor == 0)
        {
            less_than_or_equal_to_max = 1;
        }
        else
        {
            if (con->parameter_set_version_major < max_major || (con->parameter_set_version_major == max_major && con->parameter_set_version_minor <= max_minor))
            {
                less_than_or_equal_to_max = 1;
            }
        }

        return greater_than_or_equal_to_min && less_than_or_equal_to_max;
    }
    else
    {
        return 0;
    }
}

RCP_API_PRIVATE int _rcp_version_less_or_equal_to(const rcp_camera_connection_t * con, uint16_t max_major, uint16_t max_minor)
{
    return _rcp_version_in_range_ext(con, 0, 0, max_major, max_minor);
}

RCP_API_PRIVATE int _rcp_version_greater_or_equal_to(const rcp_camera_connection_t * con, uint16_t min_major, uint16_t min_minor)
{
    return _rcp_version_in_range_ext(con, min_major, min_minor, 0, 0);
}

RCP_API_PRIVATE int _rcp_has_feature(const rcp_camera_connection_t * con, rcp_feature_t feature)
{
    if (!con)
    {
        return 0;
    }

    switch (feature)
    {
#ifdef RCP_API_ENABLE_MENU
        case RCP_FEATURE_MENU:
            return _rcp_version_greater_or_equal_to(con, 6, 0);

        case RCP_FEATURE_MENU_NODE_STATUS:
            return _rcp_version_greater_or_equal_to(con, 6, 1);

        case RCP_FEATURE_MENU_NODE_STATUS_IN_NODE_INFO:
            return _rcp_version_greater_or_equal_to(con, 6, 20);
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
        case RCP_FEATURE_RFTP:
            return _rcp_version_greater_or_equal_to(con, 6, 30);

        case RCP_FEATURE_RFTP_TETHERED:
            return _rcp_version_greater_or_equal_to(con, 6, 40);
#endif

        case RCP_FEATURE_USER_PASS_THROUGH:
            return _rcp_version_greater_or_equal_to(con, 6, 40);

        case RCP_FEATURE_MIN_CODEC_FROM_CAMERA:
            return _rcp_version_greater_or_equal_to(con, 6, 43);

        case RCP_FEATURE_USER_METADATA:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_CLIENT_ID:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_GET_PERIODIC:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_GET_DEFAULT:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_KEY_MAPPING:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_DYNAMIC_MONITOR_LABELS:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        case RCP_FEATURE_INDEXED_POWER_IN:
            return _rcp_version_greater_or_equal_to(con, 6, 50);

        default:
            return 0;
    }
}
/********** End file: rcp_api_camera_connection.c *******************************/

/********** Begin file: rcp_api_client_id.c *************************************/
/* #include "rcp_api_client_id.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_set_str.h" */

/* #include "rcp_parser/rcp_parameter_types_public.h" */

#include <string.h>

RCP_API_PRIVATE rcp_error_t _rcp_send_client_id(rcp_camera_connection_t * con)
{
    if (con)
    {
        return _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RCPID_MSG_RCP_ID, 5, con->uuid.str, con->client_name, con->client_version, con->client_user, rcp_api_get_version());
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}

RCP_API_PRIVATE void _rcp_client_id_ping(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    /* If ping is for us (uuid matches) respond */
    if (con && packet)
    {
        if (strcmp(con->uuid.str, packet->argv[0]) == 0)
        {
            _rcp_create_set_str_message(con, RCP2_CMD_SET, packet->pParam, packet->argv[0]);
        }
    }
}
/********** End file: rcp_api_client_id.c ***************************************/

/********** Begin file: rcp_api_clip_list.c *************************************/
/* The clip list is the list of clips on the camera's current media.
 *
 * Note: The clip list can only be retrieved while the camera is not
 * actively recording (otherwise we can cause record errors).  This
 * means we cannot start retrieving the clip list if the camera is in
 * record, and we must pause retrieving the clip list if the camera
 * starts recording in the middle of the process.
 *
 * If the media label changes that signifies the media has been changed.
 * This can occur if we switch between rear and side SSDs, ejected
 * active media, inserted new media, etc.  In this case we will clear
 * the list and retrieve a new one.
 *
 * If the record state of the camera changes we need to continue
 * getting the list or update the list we have.
 *
 */

/* #include "rcp_api_clip_list.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */

#include <string.h>
#include <stdio.h>
/* #include "stringl/stringl.h" */

#ifdef RCP_API_ENABLE_CLIP_LIST

static void _rcp_handle_media_label_changed(rcp_camera_connection_t * con);
static void _rcp_clip_list_send(rcp_camera_connection_t * con);
static int _rcp_get_clip_info_from_packet(extended_clipinfo_t * clipinfo, const tRCPParsedPacket2 * packet);
static void _rcp_clip_list_add(rcp_camera_connection_t * con, const extended_clipinfo_t * clipinfo);
static void _rcp_get_thumbnail_path(char * thumbnail_path, size_t length, const char * clip_name);

/* extract clip information from RCP packet and fill in clipinfo.
 * returns 0 on success, -1 on error. */
static int _rcp_get_clip_info_from_packet(extended_clipinfo_t * clipinfo, const tRCPParsedPacket2 * packet)
{
    if (clipinfo && packet && packet->argc >= 9)
    {
        memset(clipinfo, 0, sizeof(*clipinfo));

        clipinfo->index = atoi(packet->argv[0]);
        strlcpy(clipinfo->clip_name, packet->argv[1], sizeof(clipinfo->clip_name));
        strlcpy(clipinfo->clip_date, packet->argv[2], sizeof(clipinfo->clip_date));
        strlcpy(clipinfo->clip_time, packet->argv[3], sizeof(clipinfo->clip_time));
        clipinfo->sensor_fps = atoi(packet->argv[4]);
        strlcpy(clipinfo->edge_start_timecode, packet->argv[5], sizeof(clipinfo->edge_start_timecode));
        strlcpy(clipinfo->edge_end_timecode, packet->argv[6], sizeof(clipinfo->edge_end_timecode));
        strlcpy(clipinfo->tod_start_timecode, packet->argv[7], sizeof(clipinfo->tod_start_timecode));
        strlcpy(clipinfo->tod_end_timecode, packet->argv[8], sizeof(clipinfo->tod_end_timecode));

        if (packet->argc >= 11)
        {
            clipinfo->has_r3d = atoi(packet->argv[9]);
            clipinfo->has_qt = atoi(packet->argv[10]);
        }
        else
        {
            clipinfo->has_r3d = 1;
        }

        if (packet->argc >= 12)
        {
            clipinfo->has_mxf = atoi(packet->argv[11]);
        }

        if (packet->argc >= 23)
        {
            strlcpy(clipinfo->duration, packet->argv[12], sizeof(clipinfo->duration));
            clipinfo->record_mode = (record_mode_t) atoi(packet->argv[13]);
            strlcpy(clipinfo->compression, packet->argv[14], sizeof(clipinfo->compression));
            strlcpy(clipinfo->format, packet->argv[15], sizeof(clipinfo->format));
            strlcpy(clipinfo->project_fps, packet->argv[16], sizeof(clipinfo->project_fps));
            strlcpy(clipinfo->iso, packet->argv[17], sizeof(clipinfo->iso));
            strlcpy(clipinfo->kelvin, packet->argv[18], sizeof(clipinfo->kelvin));
            strlcpy(clipinfo->tint, packet->argv[19], sizeof(clipinfo->tint));
            strlcpy(clipinfo->num_frames, packet->argv[20], sizeof(clipinfo->num_frames));
            clipinfo->camera_mode = (camera_capture_mode_t) atoi(packet->argv[21]);
            strlcpy(clipinfo->sensor_fps_str, packet->argv[22], sizeof(clipinfo->sensor_fps_str));
        }
        else
        {
            clipinfo->record_mode = RECORD_MODE_COUNT;
            clipinfo->camera_mode = CAMERA_CAPTURE_MODE_MOTION;
        }

        if (packet->argc >= 25)
        {
            clipinfo->drop_frame_display_mode = (tc_drop_frame_display_t) atoi(packet->argv[23]);
            strlcpy(clipinfo->thumbnail_path, packet->argv[24], sizeof(clipinfo->thumbnail_path));
        }
        else
        {
            _rcp_get_thumbnail_path(clipinfo->thumbnail_path, sizeof(clipinfo->thumbnail_path), clipinfo->clip_name);
        }

        if (packet->argc >= 26)
        {
            strlcpy(clipinfo->display_clip_name, packet->argv[25], sizeof(clipinfo->display_clip_name));
        }
        else
        {
            const size_t display_len = 9;
            strncpy(clipinfo->display_clip_name, clipinfo->clip_name, display_len);
            clipinfo->display_clip_name[display_len] = 0;
        }

        return 0;
    }

    return -1;
}

/* clear clip list for connection con. */
RCP_API_PRIVATE void _rcp_clip_list_clear(rcp_camera_connection_t * con)
{
    if (con)
    {
        rcp_clip_info_list_t * cur = con->clip_list;

        while (cur)
        {
            rcp_clip_info_list_t * const next = cur->next;
            rcp_free(cur);
            cur = next;
        }

        con->clip_list = NULL;
        con->clip_list_tail = NULL;
        con->clip_list_cur = 0;
        con->clip_list_count = 0;
    }
}

/* Append clipinfo to end of con's clip list */
static void _rcp_clip_list_add(rcp_camera_connection_t * con, const extended_clipinfo_t * clipinfo)
{
    if (con)
    {
        if (con->clip_list == NULL)
        {
            con->clip_list = RCP_MALLOC(rcp_clip_info_list_t *, sizeof(rcp_clip_info_list_t));
            con->clip_list_tail = con->clip_list;
        }
        else
        {
            con->clip_list_tail->next = RCP_MALLOC(rcp_clip_info_list_t *, sizeof(rcp_clip_info_list_t));
            con->clip_list_tail = con->clip_list_tail->next;
        }

        if (con->clip_list_tail)
        {
            con->clip_list_tail->info = *clipinfo;
            con->clip_list_tail->next = NULL;
        }
    }
}

/* get the path to the thumbnail using the clip's name */
static void _rcp_get_thumbnail_path(char * thumbnail_path, size_t length, const char * clip_name)
{
    if (!thumbnail_path)
    {
        return;
    }

    memset(thumbnail_path, 0, length);

    if (clip_name)
    {
        const size_t clip_length = strlen(clip_name);
        const char * clip_ptr = clip_name + clip_length;

        while (clip_ptr != clip_name && *clip_ptr != '_')
        {
            clip_ptr--;
        }

        if (clip_ptr != clip_name)
        {
            const char * const thumbnail_prefix = "/thumbnails/";
            const char * const thumbnail_extension = ".rtn";

            const size_t prefix_length = strlen(thumbnail_prefix);
            const size_t extension_length = strlen(thumbnail_extension);
            const size_t base_length = clip_ptr - clip_name;

            if (prefix_length + base_length + extension_length + 1 <= length)
            {
                strlcpy(thumbnail_path, thumbnail_prefix, length);
                strncat(thumbnail_path, clip_name, base_length);
                strncat(thumbnail_path, thumbnail_extension, extension_length);
            }
        }
    }
}

rcp_error_t rcp_get_clip_list(rcp_camera_connection_t * con)
{
    if (!con)
        return RCP_ERROR_BAD_PARAM;

    _rcp_clip_list_send(con);
    return RCP_SUCCESS;
}

/* send clip list to client */
static void _rcp_clip_list_send(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->clip_list_cb)
        {
            rcp_cur_clip_list_cb_data_t data;
            data.con = con;
            data.clip_list = con->clip_list;
            data.clip_list_status = CLIP_LIST_DONE;
            con->clip_list_cb(&data, con->clip_list_cb_user_data);
        }
    }
}

RCP_API_PRIVATE void _rcp_handle_media_label(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            if (strcmp(con->last_media_label, state->val.str_val) != 0)
            {
                strlcpy(con->last_media_label, state->val.str_val, sizeof(con->last_media_label));
                _rcp_handle_media_label_changed(con);
            }
        }
    }
}

static void _rcp_handle_media_label_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        switch (con->clip_list_state)
        {
            case CLIP_LIST_STATE_DISABLED:
            case CLIP_LIST_STATE_GET_RECORD_STATE:
            case CLIP_LIST_STATE_RECORDING:
                break;

            case CLIP_LIST_STATE_INIT_LIST:
            case CLIP_LIST_STATE_HAVE_LIST:
            case CLIP_LIST_STATE_GET_LIST:
                _rcp_clip_list_clear(con);
                _rcp_log_info(con, "getting media clip list\n");
                (void) _rcp_get(con, RCP_PARAM_MEDIA_CLIP_COUNT);
                con->clip_list_state = CLIP_LIST_STATE_INIT_LIST;
                break;
        }
    }
}

RCP_API_PRIVATE void _rcp_clip_list_handle_record_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_RECORD_STATE_BASE];
        if (state->val_valid && state->val.int_val == RECORD_STATE_NOT_RECORDING)
        {
            /* stopped recording */
            switch (con->clip_list_state)
            {
                case CLIP_LIST_STATE_DISABLED:
                case CLIP_LIST_STATE_INIT_LIST:
                    break;

                case CLIP_LIST_STATE_GET_RECORD_STATE:
                case CLIP_LIST_STATE_RECORDING:
                    _rcp_log_info(con, "getting media clip list\n");
                    (void) _rcp_get(con, RCP_PARAM_MEDIA_CLIP_COUNT);
                    con->clip_list_state = CLIP_LIST_STATE_INIT_LIST;
                    break;

                case CLIP_LIST_STATE_GET_LIST:
                case CLIP_LIST_STATE_HAVE_LIST:
                    _rcp_log_info(con, "updating media clip list count\n");
                    (void) _rcp_get(con, RCP_PARAM_MEDIA_CLIP_COUNT);
                    con->clip_list_state = CLIP_LIST_STATE_INIT_LIST;
                    break;
            }
        }
        else
        {
            /* started recording */
            switch (con->clip_list_state)
            {
                case CLIP_LIST_STATE_DISABLED:
                case CLIP_LIST_STATE_RECORDING:
                case CLIP_LIST_STATE_HAVE_LIST:
                    break;

                case CLIP_LIST_STATE_GET_RECORD_STATE:
                case CLIP_LIST_STATE_INIT_LIST:
                case CLIP_LIST_STATE_GET_LIST:
                    if (con->clip_list_cb)
                    {
                        rcp_cur_clip_list_cb_data_t data;
                        data.con = con;
                        data.clip_list = NULL;
                        data.clip_list_status = CLIP_LIST_BLOCKED;
                        con->clip_list_cb(&data, con->clip_list_cb_user_data);
                    }
                    con->clip_list_state = CLIP_LIST_STATE_RECORDING;
                    break;
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_handle_media_clip_count(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            switch (con->clip_list_state)
            {
                case CLIP_LIST_STATE_GET_RECORD_STATE:
                case CLIP_LIST_STATE_RECORDING:
                case CLIP_LIST_STATE_DISABLED:
                    break;

                case CLIP_LIST_STATE_GET_LIST:
                case CLIP_LIST_STATE_HAVE_LIST:
                    if (con->clip_list_count != state->val.int_val)
                    {
                        _rcp_log_debug(con, "clip count mismatch\n");
                        _rcp_clip_list_clear(con);
                        _rcp_log_info(con, "getting media clip list\n");
                        (void) _rcp_get(con, RCP_PARAM_MEDIA_CLIP_COUNT);
                        con->clip_list_state = CLIP_LIST_STATE_INIT_LIST;
                    }
                    break;

                case CLIP_LIST_STATE_INIT_LIST:
                    con->clip_list_count = state->val.int_val;
                    if (con->clip_list_count == 0)
                    {
                        _rcp_clip_list_clear(con);
                        con->clip_list_state = CLIP_LIST_STATE_HAVE_LIST;
                        _rcp_clip_list_send(con);
                    }
                    else if (con->clip_list_cur < con->clip_list_count)
                    {
                        const rcp_param_def_t * const def = &_rcp_param_def[RCP_PARAM_MEDIA_CLIP_EXT_INFO];

                        con->clip_list_state = CLIP_LIST_STATE_GET_LIST;
                        _rcp_log_debug(con, "asking for clip info for clip: %d\n", con->clip_list_cur);
                        _rcp_create_get_with_int_arg_message(con, RCP2_CMD_GET, def->get_msg, con->clip_list_cur);

                        if (con->clip_list_cb)
                        {
                            rcp_cur_clip_list_cb_data_t data;
                            data.con = con;
                            data.clip_list = NULL;
                            data.clip_list_status = CLIP_LIST_LOADING;
                            con->clip_list_cb(&data, con->clip_list_cb_user_data);
                        }
                    }
                    else if (con->clip_list_cur == con->clip_list_count)
                    {
                        con->clip_list_state = CLIP_LIST_STATE_HAVE_LIST;
                    }
                    else
                    {
                        _rcp_log_error(con, "clip count mismatch\n");
                        _rcp_clip_list_clear(con);
                        _rcp_log_info(con, "getting media clip list\n");
                        (void) _rcp_get(con, RCP_PARAM_MEDIA_CLIP_COUNT);
                    }

                    break;
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_handle_media_clip_ext_info(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        extended_clipinfo_t clipinfo;
        if (-1 == _rcp_get_clip_info_from_packet(&clipinfo, packet))
        {
            _rcp_log_error(con, "unable to parse clip info packet\n");
            return;
        }

        switch (con->clip_list_state)
        {
            case CLIP_LIST_STATE_DISABLED:
            case CLIP_LIST_STATE_GET_RECORD_STATE:
            case CLIP_LIST_STATE_RECORDING:
            case CLIP_LIST_STATE_INIT_LIST:
                break;

            case CLIP_LIST_STATE_HAVE_LIST:
                if (clipinfo.index == con->clip_list_cur)
                {
                    _rcp_clip_list_add(con, &clipinfo);
                    con->clip_list_cur++;
                    con->clip_list_count = con->clip_list_cur;
                    _rcp_clip_list_send(con);
                }
                break;

            case CLIP_LIST_STATE_GET_LIST:
                if (clipinfo.index == con->clip_list_cur)
                {
                    _rcp_clip_list_add(con, &clipinfo);
                    con->clip_list_cur++;
                    if (con->clip_list_cur == con->clip_list_count)
                    {
                        con->clip_list_state = CLIP_LIST_STATE_HAVE_LIST;
                        _rcp_clip_list_send(con);
                    }
                    else
                    {
                        const rcp_param_def_t * const def = &_rcp_param_def[RCP_PARAM_MEDIA_CLIP_EXT_INFO];
                        _rcp_log_debug(con, "asking for clip info for clip: %d\n", con->clip_list_cur);
                        _rcp_create_get_with_int_arg_message(con, RCP2_CMD_GET, def->get_msg, con->clip_list_cur);
                    }
                }
                break;
        }
    }
}

#endif
/********** End file: rcp_api_clip_list.c ***************************************/

/********** Begin file: rcp_api_discovery.c *************************************/
/* #include "rcp_api_discovery.h" */

#ifdef RCP_API_ENABLE_DISCOVERY

/* #include "rcp_api_log.h" */

#include <string.h>
/* #include "stringl/stringl.h" */
/* #include "rcp_parser/rcp_parser2.h" */
/* #include "rcp_parser/rcp_parameter_types_public.h" */

static rcp_broadcast_data_to_cameras_cb_t _rcp_discovery_cb = NULL;
static void * _rcp_discovery_cb_user_data = NULL;
static char _rcp_discovery_parser_buffer[RCP_API_PARSER_BUFFER_SIZE];
static tRCPParsedPacketState _rcp_discovery_parser_state = {_rcp_discovery_parser_buffer, sizeof(_rcp_discovery_parser_buffer), 0};
static rcp_discovery_cam_info_list_t * _rcp_discovery_cam_info_list = NULL;

static void _rcp_discovery_get_cam_info(void);
static void _rcp_discovery_handle_packet(const tRCPParsedPacket2 * packet, const char * from_ipv4);
static void _rcp_discovery_add_cam_info_to_list(const rcp_cam_info_t * cam_info, const char * from_ipv4);

/* create broadcast GET CAMINFO RCP packet and call user supplied
 * callback function to sent it.  */
static void _rcp_discovery_get_cam_info(void)
{
    if (_rcp_discovery_cb)
    {
        char buf[RCP_API_OUTGOING_PACKET_BUFFER_SIZE];
        size_t len = 0;
        tRCP rcpBuffer;

        if (RCP2_PARSER_OK != RCP_buildHeader(&rcpBuffer, buf, sizeof(buf), RCP_API_SOURCE_NAME, "", RCP2_CMD_GET))
        {
            return;
        }

        if (RCP2_PARSER_OK != RCP_addToken(&rcpBuffer, RCP_CAMINFO_MSG_CAMINFO_PTR))
        {
            return;
        }

        if (RCP2_PARSER_OK != RCP_addChecksum(&rcpBuffer))
        {
            return;
        }

        len = RCP_finalizeMessage(&rcpBuffer);

        _rcp_discovery_cb(buf, len, _rcp_discovery_cb_user_data);
    }
}

static void _rcp_discovery_add_cam_info_to_list(const rcp_cam_info_t * cam_info, const char * from_ipv4)
{
    if (_rcp_discovery_cam_info_list == NULL)
    {
        /* list is empty, add this entry as head of list */
        _rcp_discovery_cam_info_list = RCP_MALLOC(rcp_discovery_cam_info_list_t *, sizeof(rcp_discovery_cam_info_list_t));
        if (_rcp_discovery_cam_info_list)
        {
            _rcp_discovery_cam_info_list->info = *cam_info;
            strlcpy(_rcp_discovery_cam_info_list->ip_address, from_ipv4, sizeof(_rcp_discovery_cam_info_list->ip_address));
            _rcp_discovery_cam_info_list->next = NULL;
        }
    }
    else
    {
        rcp_discovery_cam_info_list_t * cur = _rcp_discovery_cam_info_list;
        rcp_discovery_cam_info_list_t * last = cur;
        rcp_discovery_cam_info_list_t * add_after = NULL;
        rcp_discovery_cam_info_list_t * add_before = NULL;
        rcp_discovery_cam_info_list_t * new_entry = NULL;

        /* Iterate over list looking for entry with same PIN and ip
         * address.  Replace data if one is found, else add it to the
         * list alphabetically. */
        while (cur)
        {
            const int id_cmp = strcmp(cur->info.id, cam_info->id);
            const int pin_cmp = strcmp(cur->info.pin, cam_info->pin);
            const int ip_cmp = strcmp(cur->ip_address, from_ipv4);

            if (pin_cmp == 0 && ip_cmp == 0)
            {
                cur->info = *cam_info;
                strlcpy(cur->ip_address, from_ipv4, sizeof(cur->ip_address));
                return;
            }

            if (!add_before && ((id_cmp == 0 && pin_cmp > 0) || id_cmp > 0))
            {
                add_before = cur;
                add_after = last;
            }

            last = cur;
            cur = cur->next;
        }

        /* this is a new camera.  add it to the list */
        new_entry = RCP_MALLOC(rcp_discovery_cam_info_list_t *, sizeof(rcp_discovery_cam_info_list_t));
        if (new_entry)
        {
            new_entry->info = *cam_info;
            strlcpy(new_entry->ip_address, from_ipv4, sizeof(new_entry->ip_address));
            new_entry->next = NULL;

            if (add_before == _rcp_discovery_cam_info_list)
            {
                /* add to beginning */
                new_entry->next = _rcp_discovery_cam_info_list;
                _rcp_discovery_cam_info_list = new_entry;
            }
            else if (add_before == NULL)
            {
                /* add to end */
                last->next = new_entry;
            }
            else
            {
                /* add in middle */
                new_entry->next = add_before;
                if (add_after)
                {
                    add_after->next = new_entry;
                }
            }
        }
    }
}

static void _rcp_discovery_handle_packet(const tRCPParsedPacket2 * packet, const char * from_ipv4)
{
    if (packet)
    {
        if (
            (packet->pCmd[0] == RCP2_CMD_CURRENT) &&
            (packet->pCmd[1] == 0) &&
            (strcmp(packet->pParam, RCP_CAMINFO_MSG_CAMINFO_PTR) == 0)
           )
        {
            rcp_cam_info_t cam_info;

            /* copy data from RCP packet into camera info structure. */
            strlcpy(cam_info.id, packet->pSource, sizeof(cam_info.id));
            strlcpy(cam_info.pin, packet->argv[0], sizeof(cam_info.pin));
            strlcpy(cam_info.type, packet->argv[1], sizeof(cam_info.type));
            strlcpy(cam_info.version, packet->argv[2], sizeof(cam_info.version));

            /* argv[3] is deprecated - it used to be the ip address,
             * which is now provided by the client */

            if (packet->argc > 4)
            {
                cam_info.rcp_interface = (rcp_interface_t) atoi(packet->argv[4]);
            }
            else
            {
                cam_info.rcp_interface = RCP_INTERFACE_UNKNOWN;
            }

            /* We don't reliably know from the cam info received via discovery
             * if the interface in enabled or not.  For example, in the
             * case of Ethernet the UDP port and TCP port are
             * independently enabled, but we only use the UDP port for
             * discovery. It's not that important here anyway; once we
             * try to connect we will be notified correctly. */
            cam_info.rcp_interface_enabled = 0;
            cam_info.rcp_interface_enabled_valid = 0;

            if (from_ipv4 && strcmp(from_ipv4, "0.0.0.0") == 0)
            {
                /* not a valid IP address, don't add to the camera list */
            }
            else
            {
                _rcp_discovery_add_cam_info_to_list(&cam_info, from_ipv4 ? from_ipv4 : "");
            }
        }
    }
}
#endif

void rcp_discovery_start(rcp_broadcast_data_to_cameras_cb_t cb, void * cb_user_data)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    rcp_mutex_lock(RCP_MUTEX_DISCOVERY);

    _rcp_log_info(NULL, "starting camera discovery\n");

    _rcp_discovery_cb = cb;
    _rcp_discovery_cb_user_data = cb_user_data;

    /* erase the existing list */
    if (_rcp_discovery_cam_info_list)
    {
        rcp_discovery_free_list(_rcp_discovery_cam_info_list);
        _rcp_discovery_cam_info_list = NULL;
    }

    /* send the broadcast out looking for cameras */
    _rcp_discovery_get_cam_info();

    rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);
#endif
}

void rcp_discovery_step(void)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    rcp_mutex_lock(RCP_MUTEX_DISCOVERY);

    _rcp_log_info(NULL, "continuing camera discovery\n");

    /* send another broadcast out looking for cameras */
    _rcp_discovery_get_cam_info();
    rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);
#endif
}

rcp_discovery_cam_info_list_t * rcp_discovery_get_list(void)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    rcp_mutex_lock(RCP_MUTEX_DISCOVERY);

    _rcp_log_info(NULL, "getting list of discovered cameras\n");

    if (_rcp_discovery_cam_info_list)
    {
        /* Make a copy of the list to return to the user. we make a
         * copy so that they can use the list while the internal list
         * continues to be manipulated. Making the copy while protected
         * by the mutex ensures thread safety. */
        rcp_discovery_cam_info_list_t * head = NULL;
        rcp_discovery_cam_info_list_t * cur_dst = NULL;
        const rcp_discovery_cam_info_list_t * cur_src = NULL;
        int count = 0;

        head = RCP_MALLOC(rcp_discovery_cam_info_list_t *, sizeof(rcp_discovery_cam_info_list_t));
        cur_dst = head;
        cur_src = _rcp_discovery_cam_info_list;

        while (cur_src && cur_dst)
        {
            cur_dst->info = cur_src->info;
            strlcpy(cur_dst->ip_address, cur_src->ip_address, sizeof(cur_dst->ip_address));
            cur_src = cur_src->next;
            if (cur_src)
            {
                cur_dst->next = RCP_MALLOC(rcp_discovery_cam_info_list_t *, sizeof(rcp_discovery_cam_info_list_t));
                cur_dst = cur_dst->next;
            }
            else
            {
                cur_dst->next = NULL;
            }
            count++;
        }

        _rcp_log_info(NULL, "%d camera%s found. (%p returned)\n", count, (count == 1) ? "" : "s", head);

        rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);

        return head;
    }
    else
    {
        _rcp_log_info(NULL, "0 cameras found\n");

        rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);

        return NULL;
    }
#else
    return NULL;
#endif
}

void rcp_discovery_free_list(rcp_discovery_cam_info_list_t * list)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    /* delete all the entries of the given list.  no need to protect
     * with a mutex since we are working on a user provided list (not
     * our global list). */

    rcp_discovery_cam_info_list_t * cur = list;

    _rcp_log_info(NULL, "freeing camera list: %p%s\n", list, (list == _rcp_discovery_cam_info_list) ? " (global list)" : "");

    while (cur)
    {
        rcp_discovery_cam_info_list_t * const next = cur->next;
        rcp_free(cur);
        cur = next;
    }
#endif
}

void rcp_discovery_process_data(const char * data, size_t len, const char * from_ipv4)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    rcp_mutex_lock(RCP_MUTEX_DISCOVERY);

    while (len--)
    {
        const int res = RCP_get_and_parse_packet(&_rcp_discovery_parser_state, *data++);

        switch (res)
        {
            case RCP2_PARSER_OK:
                _rcp_discovery_handle_packet(&_rcp_discovery_parser_state.parsed, from_ipv4);
                break;

            case RCP2_PARSER_INCOMPLETE_PACKET:
                /* this is not an error, just an incomplete RCP
                 * packet, continue on. */
                break;

            default:
                _rcp_log_error(NULL, "RCP parser error: %d\n", res);
                break;
        }
    }

    rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);
#endif
}

void rcp_discovery_end(void)
{
#ifdef RCP_API_ENABLE_DISCOVERY
    rcp_mutex_lock(RCP_MUTEX_DISCOVERY);

    _rcp_log_info(NULL, "ending camera discovery\n");

    /* free the global discovery list when we are done. */
    if (_rcp_discovery_cam_info_list)
    {
        rcp_discovery_free_list(_rcp_discovery_cam_info_list);
        _rcp_discovery_cam_info_list = NULL;
    }

    rcp_mutex_unlock(RCP_MUTEX_DISCOVERY);
#endif
}
/********** End file: rcp_api_discovery.c ***************************************/

/********** Begin file: rcp_api_error.c *****************************************/
/* #include "rcp_api_error.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_state.h" */

RCP_API_PRIVATE void _rcp_handle_deferred_error(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->deferred_error != RCP_SUCCESS)
        {
            _rcp_set_state(con, RCP_CONNECTION_STATE_COMMUNICATION_ERROR);
        }
    }
}

RCP_API_PRIVATE void _rcp_set_deferred_error(rcp_camera_connection_t * con, rcp_error_t error)
{
    if (con)
    {
        if (error != RCP_SUCCESS)
        {
            con->deferred_error = error;
        }
    }
}
/********** End file: rcp_api_error.c *******************************************/

/********** Begin file: rcp_api_get.c *******************************************/
/* #include "rcp_api_get.h" */

/* #include "rcp_api_audio_vu.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_send_current.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>

static void _rcp_create_get_message_with_index(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t idx);

rcp_error_t rcp_get(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "get: %s\n", rcp_get_name(con, id));
    err = _rcp_get(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_get(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];
        int has_get = 0;
#ifdef RCP_API_ENABLE_CACHING
        int sent_out_get_message = 0;
        int sent_out_get_target_message = 0;
#endif

        if (!properties.has_get)
        {
            if (id == RCP_PARAM_AUDIO_VU_DATA)
            {
                /* There is no GET for audio vu data, so instead call
                 * the process packet function with a dummy packet.
                 * This will cause the user callback to be called. */
                _rcp_process_audio_vu_packet(con, NULL, id);
                return RCP_SUCCESS;
            }

            return RCP_ERROR_NO_GET;
        }

        /* If the parameter is cacheable and we have a valid value,
         * there is no reason to ask the camera for the current value,
         * instead send the application the cached value. */
#ifdef RCP_API_ENABLE_CACHING
        if (def->val_cacheable && state->val_valid)
        {
            has_get = 1;
            switch (def->current_type)
            {
                case RCP_TYPE_INT:
                    _rcp_send_current_int(con, id, 0);
                    break;

                case RCP_TYPE_UINT:
                    _rcp_send_current_uint(con, id, 0);
                    break;

                case RCP_TYPE_STR:
                    _rcp_send_current_str(con, id);
                    break;

                default:
                    _rcp_log_debug(con, "todo: get value from cache for %s!\n", rcp_get_name(con, id));
                    state->val_valid = 0;
                    break;
            }
        }
        else
#endif
        if (def->get_msg)
        {
            /* There is an associated get message for this parameter,
             * and we don't have a valid cached value, so ask the
             * camera for the value */
            has_get = 1;
            if (!state->get_pending)
            {
#ifdef RCP_API_ENABLE_CACHING
                sent_out_get_message = 1;
#endif
                if (def->is_indexed)
                {
                    _rcp_create_get_message_with_index(con, RCP2_CMD_GET, def->get_msg, def->index);
                }
                else
                {
                    _rcp_create_get_message(con, RCP2_CMD_GET, def->get_msg);
                }
            }
        }

        /* If the target value for the parameter is cacheable and we
         * have a valid value, there is no reason to ask the camera
         * for the current target value, instead send the application
         * the cached target value.*/
#ifdef RCP_API_ENABLE_CACHING
        if (def->target_val_cacheable && state->target_val_valid)
        {
            has_get = 1;

            switch (def->current_type)
            {
                case RCP_TYPE_INT:
                    _rcp_send_current_int(con, id, 1);
                    break;

                case RCP_TYPE_UINT:
                    _rcp_send_current_uint(con, id, 1);
                    break;

                default:
                    _rcp_log_debug(con, "todo: get value from cache for %s!\n", rcp_get_name(con, id));
                    state->target_val_valid = 0;
                    break;
            }
        }
        else
#endif
        if (def->get_target_msg && _rcp_version_in_range(con, &def->target_version_range))
        {
            /* There is an associated get target message for this parameter,
             * and we don't have a valid cached target value, so ask the
             * camera for the target value. */
            has_get = 1;
            if (!state->get_target_pending)
            {
#ifdef RCP_API_ENABLE_CACHING
                sent_out_get_target_message = 1;
#endif
                if (def->is_indexed)
                {
                    _rcp_create_get_message_with_index(con, RCP2_CMD_GET, def->get_target_msg, def->index);
                }
                else
                {
                    _rcp_create_get_message(con, RCP2_CMD_GET, def->get_target_msg);
                }
            }
        }

        if (!has_get)
        {
            if (def->create_int_fp)
            {
                /* If none of the above methods have resulted in a valid
                 * GET request to the camera or cached value, but we have a
                 * create integer function pointer, that means it is a
                 * composite parameter and we can create the integer value from
                 * the values of other parameters. */
                has_get = 1;
                def->create_int_fp(con, id);

                if (state->val_valid)
                {
                    _rcp_send_current_int(con, id, 0);
                    _rcp_get_dependencies(con, id);
                }
            }

            if (def->create_string_fp)
            {
                /* If none of the above methods have resulted in a valid
                 * GET request to the camera or cached value, but we have a
                 * create string function pointer, that means it is a
                 * composite parameter and we can create the string from
                 * the values of other parameters. */
                has_get = 1;
                _rcp_send_current_composite_string(con, id);
            }
        }

        if (!has_get)
        {
            /* We have no way of getting this parameter, that's an error. */
            return RCP_ERROR_NO_GET;
        }

#ifdef RCP_API_ENABLE_CACHING
        if (!state->get_pending && def->val_cacheable && sent_out_get_message)
        {
            state->get_pending = 1;
        }

        if (!state->get_target_pending && def->target_val_cacheable && sent_out_get_target_message)
        {
            state->get_target_pending = 1;
        }
#endif
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

/* create RCP message for GET and send to camera */
RCP_API_PRIVATE void _rcp_create_get_message(rcp_camera_connection_t * con, char cmd, const char * msg)
{
    if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 0))
    {
        _rcp_log_error(con, "could not create get packet\n");
    }
}

RCP_API_PRIVATE void _rcp_create_get_with_int_arg_message(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t arg)
{
    char arg_str[RCP_STR_LEN_FOR_INT32];
    snprintf(arg_str, sizeof(arg_str), "%d", arg);
    if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 1, arg_str))
    {
        _rcp_log_error(con, "could not create get packet\n");
    }
}

static void _rcp_create_get_message_with_index(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t idx)
{
    _rcp_create_get_with_int_arg_message(con, cmd, msg, idx);
}
/********** End file: rcp_api_get.c *********************************************/

/********** Begin file: rcp_api_get_default.c ***********************************/
/* #include "rcp_api_get_default.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_send_current.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>

static rcp_error_t _rcp_get_default(rcp_camera_connection_t * con, rcp_param_t id);

rcp_error_t rcp_get_default(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "get default: %s\n", rcp_get_name(con, id));
    err = _rcp_get_default(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

static rcp_error_t _rcp_get_default(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con && rcp_get_is_supported(con, id, NULL))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        const rcp_param_state_t * const state = &con->param_state[id];
        const char * get_default_msg = NULL;

        if (!_rcp_has_feature(con, RCP_FEATURE_GET_DEFAULT))
        {
            return RCP_ERROR_NO_GET_DEFAULT;
        }

        /* In order for a get default to be applicapable, the parameters set and current types must
         * be the same, and must be INT or UINT.  Furthermore, the parameter needs a SET, GET, and
         * CURRENT message (or SET TARGET, GET TARGET and CURRENT TARGET). */

        /* check that the set and current types match */
        if (def->set_type != def->current_type)
        {
            return RCP_ERROR_NO_GET_DEFAULT;
        }

        /* check that the type is one that supports a default value */
        switch (def->current_type)
        {
            case RCP_TYPE_INT:
            case RCP_TYPE_UINT:
                break;

            default:
                return RCP_ERROR_NO_GET_DEFAULT;
        }

        /* check the appropriate messages exist */
        if (def->set_target_msg && _rcp_version_in_range(con, &def->target_version_range))
        {
            get_default_msg = def->set_target_msg;
            if (!def->get_target_msg || !def->cur_target_msg)
            {
                return RCP_ERROR_NO_GET_DEFAULT;
            }
        }
        else if (def->set_msg)
        {
            get_default_msg = def->set_msg;
            if (!def->get_msg || !def->cur_msg)
            {
                return RCP_ERROR_NO_GET_DEFAULT;
            }
        }
        else
        {
            return RCP_ERROR_NO_GET_DEFAULT;
        }

        /* check if we have a cached default value, if so, send it back */
        if (state->default_val_valid)
        {
            switch (def->current_type)
            {
                case RCP_TYPE_INT:
                    _rcp_send_current_default_int(con, id);
                    break;

                case RCP_TYPE_UINT:
                    _rcp_send_current_default_uint(con, id);
                    break;

                default:
                    /* we shouldn't get here, but just in case return the error. */
                    return RCP_ERROR_NO_GET_DEFAULT;
            }
        }
        else
        {
            if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_GET_DEFAULT, get_default_msg, 0))
            {
                _rcp_log_error(con, "could not create get default packet\n");
            }
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}
/********** End file: rcp_api_get_default.c *************************************/

/********** Begin file: rcp_api_get_list.c **************************************/
/* #include "rcp_api_get_list.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_send_current.h" */

rcp_error_t rcp_get_list(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "get list: %s\n", rcp_get_name(con, id));
    err = _rcp_get_list(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_get_list(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_get_list)
        {
            return RCP_ERROR_NO_GET_LIST;
        }

        if (def->get_list_msg)
        {
            /* to have a fully cached list we need both a valid list
             * that is cached and if we can cache the current value it
             * also needs to be valid.  This is so that if we have the
             * list, but the current value is out of sync we don't send
             * the cached list. */
#ifdef RCP_API_ENABLE_CACHING
            if (def->list_cacheable && state->list_val_valid && (state->val_valid || !def->val_cacheable))
            {
                _rcp_send_current_list(con, id, id);
            }
            else
#endif
            {
                /* Some lists have associated min and max values (used
                 * to indicate which values in the list are valid at
                 * the moment).  If we have these messages request them. */
                if (def->min_param != RCP_MIN_NONE())
                {
                    (void) _rcp_get(con, def->min_param);
                }
                if (def->max_param != RCP_MAX_NONE())
                {
                    (void) _rcp_get(con, def->max_param);
                }

#ifdef RCP_API_ENABLE_CACHING
                if (!def->list_cacheable || !state->list_val_valid)
#endif
                {
                    /* ask for the list. */
                    if (!state->get_list_pending)
                    {
                        state->get_list_pending = 1;
                        _rcp_create_get_message(con, RCP2_CMD_GET_LIST, def->get_list_msg);
                    }
                }
#ifdef RCP_API_ENABLE_CACHING
                else if (def->val_cacheable && !state->val_valid)
                {
                    /* We are asking for the current value so we can update the list
                     * appropriately. Set the get_list_pending flag to true so when
                     * the current value returns we will always send the list; even
                     * if the current value is not new. */
                    state->get_list_pending = 1;
                    (void) _rcp_get(con, id);
                }
#endif
            }
        }
        else if (def->create_list_fp)
        {
            /* If we don't have a get list message, but we do have
             * a create_list_fp that means this is a composite list
             * that can be created by combining other parameters.*/
            def->create_list_fp(con, id, id);
        }
        else
        {
            /* we don't have a get list message for this parameter. */
            return RCP_ERROR_NO_GET_LIST;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}
/********** End file: rcp_api_get_list.c ****************************************/

/********** Begin file: rcp_api_get_periodic.c **********************************/
/* #include "rcp_api_get_periodic.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>

static rcp_error_t _rcp_send_get_periodic_packet(rcp_camera_connection_t * con, rcp_param_t id, int val);

int rcp_get_periodic_is_supported(rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_RFTP);
}

static rcp_error_t _rcp_send_get_periodic_packet(rcp_camera_connection_t * con, rcp_param_t id, int val)
{
    rcp_param_properties_t properties;

    if (con && rcp_get_is_supported(con, id, &properties))
    {
        if (properties.has_get_periodic)
        {
            const rcp_param_def_t * const def = &_rcp_param_def[id];
            char val_str[RCP_STR_LEN_FOR_INT32];
            snprintf(val_str, sizeof(val_str), "%d", val);

            return _rcp_create_and_send_packet(con, RCP2_CMD_GET_PERIODIC, def->get_periodic_msg, 1, val_str);
        }
        else
        {
            return RCP_ERROR_NO_GET_PERIODIC;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}

rcp_error_t rcp_get_periodic_on(rcp_camera_connection_t * con, rcp_param_t id)
{
    return _rcp_send_get_periodic_packet(con, id, 1);
}

rcp_error_t rcp_get_periodic_off(rcp_camera_connection_t * con, rcp_param_t id)
{
    return _rcp_send_get_periodic_packet(con, id, 0);
}
/********** End file: rcp_api_get_periodic.c ************************************/

/********** Begin file: rcp_api_get_status.c ************************************/
/* #include "rcp_api_get_status.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_send_current.h" */

rcp_error_t rcp_get_status(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "get status: %s\n", rcp_get_name(con, id));
    err = _rcp_get_status(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_get_status(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con && id < RCP_PARAM_COUNT)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];

        if (def->create_status_fp)
        {
            def->create_status_fp(con, id);
        }
        else
        {
            rcp_param_state_t * const state = &con->param_state[id];
            state->is_enabled = 1;
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}
/********** End file: rcp_api_get_status.c **************************************/

/********** Begin file: rcp_api_hist.c ******************************************/
/* #include "rcp_api_hist.h" */

/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */

#include <stdio.h>
#include <string.h>
/* #include "base64/base64.h" */
/* #include "decorated_string/decorated_string.h" */
/* #include "stringl/stringl.h" */

static int32_t get_hex_encoded_byte(const char * data)
{
    int32_t value = 0;
    int num_digits = 2;

    if (!data)
    {
        return -1;
    }

    while (num_digits--)
    {
        const char digit = *data;
        value *= 16;

        if (digit >= 'A' && digit <= 'F')
        {
            value += 10 + digit - 'A';
        }
        else if (digit >= 'a' && digit <= 'f')
        {
            value += 10 + digit - 'a';
        }
        else if (digit >= '0' && digit <= '9')
        {
            value += digit - '0';
        }
        else
        {
            return -1;
        }

        data++;
    }

    return value;
}

RCP_API_PRIVATE void _rcp_process_hist_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        if (con->cur_hist_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_hist_cb_data_t hist_data;
            const char * param = packet->argv[0];
            uint32_t * channel_data[4];
            size_t channel;
            int valid = 1;
            const rcp_param_state_t * const hdr_state = &con->param_state[RCP_PARAM_HDR_MODE];
            const rcp_param_state_t * const hdr_track_state = &con->param_state[RCP_PARAM_HDR_MONITOR_TRACK];
            char hist_label[RCP_API_DISPLAY_STR_SIZE] = {0};
            char hist_label_abbr[RCP_API_DISPLAY_STR_SIZE] = {0};

            if (rcp_get_is_supported(con, RCP_PARAM_HDR_MODE, NULL))
            {
                if (!hdr_state->val_valid)
                {
                    (void) _rcp_get(con, RCP_PARAM_HDR_MODE);
                    valid = 0;
                }
            }

            if (rcp_get_is_supported(con, RCP_PARAM_HDR_MONITOR_TRACK, NULL))
            {
                if (!hdr_track_state->val_valid)
                {
                    (void) _rcp_get(con, RCP_PARAM_HDR_MONITOR_TRACK);
                    valid = 0;
                }
            }

            if (valid)
            {
                const hdr_mode_t hdr_mode = (hdr_mode_t) hdr_state->val.int_val;
                const hdr_track_t hdr_track = (hdr_track_t) hdr_track_state->val.int_val;

                if (hdr_mode == HDR_MODE_HDRX)
                {
                    if (hdr_track == HDR_TRACK_A)
                    {
                        strlcat(hist_label, "A-Track", sizeof(hist_label));
                        strlcat(hist_label_abbr, "A", sizeof(hist_label_abbr));
                    }
                    else
                    {
                        strlcat(hist_label, "X-Track", sizeof(hist_label));
                        strlcat(hist_label_abbr, "X", sizeof(hist_label_abbr));
                    }
                }

                hist_data.display_str = hist_label;
                hist_data.display_str_decoded = hist_label;
                hist_data.display_str_abbr = hist_label_abbr;
                hist_data.display_str_abbr_decoded = hist_label_abbr;
            }
            else
            {
                hist_data.display_str = NULL;
                hist_data.display_str_decoded = NULL;
                hist_data.display_str_abbr = NULL;
                hist_data.display_str_abbr_decoded = NULL;
            }

            hist_data.con = con;
            hist_data.id = id;
            if (-1 == (hist_data.bottom_clip = get_hex_encoded_byte(param)))
            {
                _rcp_log_error(con, "bad histogram packet\n");
                return;
            }

            param += 2;
            if (-1 == (hist_data.top_clip = get_hex_encoded_byte(param)))
            {
                _rcp_log_error(con, "bad histogram packet\n");
                return;
            }
            param += 2;

            channel_data[0] = hist_data.red;
            channel_data[1] = hist_data.green;
            channel_data[2] = hist_data.blue;
            channel_data[3] = hist_data.luma;

            for (channel = 0; channel < sizeof(channel_data) / sizeof(channel_data[0]); channel++)
            {
                uint32_t * const data = channel_data[channel];
                int start_index = 0;
                int len = 0;
                int num_packed_bytes = 0;
                int base64_len = 0;
                char * base64_data = NULL;
                unsigned char raw_data[128];
                int ii = 0;

                if (-1 == (start_index = get_hex_encoded_byte(param)))
                {
                    _rcp_log_error(con, "bad histogram packet\n");
                    return;
                }
                param += 2;
                if (-1 == (len = get_hex_encoded_byte(param)))
                {
                    _rcp_log_error(con, "bad histogram packet\n");
                    return;
                }
                param += 2;
                num_packed_bytes = (len + 1) / 2;
                base64_len = (((((num_packed_bytes * 4) + 2) / 3) + 3) / 4) * 4;
                base64_data = RCP_MALLOC(char *, base64_len + 1);
                if (!base64_data)
                {
                    return;
                }

                memcpy(base64_data, param, base64_len);
                base64_data[base64_len] = 0;
                param += base64_len;

                if ((size_t) -1 == base64_decode(base64_data, raw_data, sizeof(raw_data)))
                {
                    rcp_free(base64_data);
                    return;
                }

                rcp_free(base64_data);

                /* Unpack the data.  assume 4-bit packing for now  */
                while (ii < 128)
                {
                    int32_t value;

                    if (ii > start_index && ii < start_index + len)
                    {
                        if ((ii - start_index) % 2 == 0)
                        {
                            value = (raw_data[(ii - start_index) / 2] & 0xF0) >> 4;
                        }
                        else
                        {
                            value = (raw_data[(ii - start_index) / 2] & 0x0F);
                        }
                    }
                    else
                    {
                        value = 0;
                    }

                    data[ii++] = value;
                }
            }
            con->cur_hist_cb(&hist_data, con->cur_hist_cb_user_data);
        }
    }
}
/********** End file: rcp_api_hist.c ********************************************/

/********** Begin file: rcp_api_hw_cap.c ****************************************/
/* #include "rcp_api_hw_cap.h" */

/* #include "rcp_api_key_mapping.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_send_current.h" */

static void _rcp_hw_cap_handle_older_firmware(rcp_camera_connection_t * con);
static void _rcp_set_hw_cap(rcp_camera_connection_t * con, hw_cap_t hw_cap, int value);

RCP_API_PRIVATE void _rcp_process_hw_cap_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con)
    {
        if (packet)
        {
            int ii;
            rcp_param_state_t * const hw_cap_state = &con->param_state[RCP_PARAM_HARDWARE_CAPABILITIES];
            int modified = 0;

            /* If this is the first HWCAP packet we receive mark as
             * modified.  Otherwise, we will compare each incoming word
             * and mark as modified if any one of them has changed. */

            if (!hw_cap_state->val_valid)
            {
                hw_cap_state->val_valid = 1;
                modified = 1;
            }

            for (ii = 0; ii < packet->argc; ii++)
            {
                const uint32_t data = (uint32_t) strtoul(packet->argv[ii], NULL, 16);
                if (ii < (HW_CAP_COUNT + 31) / 32)
                {
                    if (con->hw_cap_data[ii] != data)
                    {
                        con->hw_cap_data[ii] = data;
                        modified = 1;
                    }
                }
            }

            if (modified)
            {
                _rcp_hw_cap_handle_older_firmware(con);
                _rcp_hw_cap_update_status(con);
                _rcp_key_mapping_hw_cap_changed(con);
            }
        }
    }
}

/* This function is called if the hardware capabilities parameter is
 * not implemented on the connected camera (older firmware).  In this
 * case we will initialize to enabling all features (since we don't
 * know what is connected to the camera).  */
RCP_API_PRIVATE void _rcp_hw_cap_not_supported(rcp_camera_connection_t * con)
{
    int ii;

    for (ii = 0; ii < HW_CAP_COUNT; ii++)
    {
        _rcp_set_hw_cap(con, (hw_cap_t) ii, 1);
    }

    for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
    {
        rcp_param_state_t * const state = &con->param_state[ii];

        if (!state->is_hw_supported_valid)
        {
            /* If we have never notified the client code,
             * notify it now that this parameter is supported. */
            state->is_hw_supported_valid = 1;
            state->is_hw_supported = 1;
            _rcp_send_current_status(con, (rcp_param_t) ii);
        }
    }
}

static void _rcp_set_hw_cap(rcp_camera_connection_t * con, hw_cap_t hw_cap, int value)
{
    if (con)
    {
        const uint8_t idx = (uint8_t) hw_cap / 32;
        const uint8_t bit = (uint8_t) hw_cap % 32;
        const uint32_t mask = (1U << bit);

        if (value)
        {
            con->hw_cap_data[idx] |= mask;
        }
        else
        {
            con->hw_cap_data[idx] &= ~mask;
        }
    }
}

RCP_API_PRIVATE int _rcp_get_hw_cap(const rcp_camera_connection_t * con, hw_cap_t hw_cap)
{
    if (con)
    {
        const uint8_t idx = (uint8_t) hw_cap / 32;
        const uint8_t bit = (uint8_t) hw_cap % 32;
        const uint32_t mask = (1U << bit);

        if (con->hw_cap_data[idx] & mask)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

    return 0;
}

RCP_API_PRIVATE void _rcp_hw_cap_update_status(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            int ii;
            for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];
                rcp_param_state_t * const state = &con->param_state[ii];

                if (def->hw_cap == HW_CAP_COUNT)
                {
                    /* This parameter has no hardware dependencies */
                    if (!state->is_hw_supported_valid)
                    {
                        /* If we have never notified the client code,
                         * notify it now that this parameter is supported. */
                        state->is_hw_supported_valid = 1;
                        state->is_hw_supported = 1;
                        _rcp_send_current_status(con, (rcp_param_t) ii);
                    }
                }
                else
                {
                    if (!state->is_hw_supported_valid)
                    {
                        /* If we have never notified the client code,
                         * notify it now whether or not this parameter is
                         * supported. */
                        state->is_hw_supported_valid = 1;
                        state->is_hw_supported = _rcp_get_hw_cap(con, def->hw_cap);

                        if (state->is_hw_supported)
                        {
                            _rcp_clear_cache_val(con, (rcp_param_t) ii);
                            _rcp_clear_cache_list(con, (rcp_param_t) ii);
                        }

                        _rcp_send_current_status(con, (rcp_param_t) ii);
                    }
                    else
                    {
                        /* Only send an update if the support status has
                         * changed. */
                        const int is_hw_supported = _rcp_get_hw_cap(con, def->hw_cap);
                        if (state->is_hw_supported != is_hw_supported)
                        {
                            state->is_hw_supported = is_hw_supported;

                            if (state->is_hw_supported)
                            {
                                _rcp_clear_cache_val(con, (rcp_param_t) ii);
                                _rcp_clear_cache_list(con, (rcp_param_t) ii);
                            }

                            _rcp_send_current_status(con, (rcp_param_t) ii);
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_hw_cap_handle_older_firmware(rcp_camera_connection_t * con)
{
    /* As the firmware evolves we add/remove/modify hardware
     * capabilities.  This function will be called whenever we get new
     * hardware capabilities from the camera. Its job is to do any
     * necessary translations between the older firmware's hardware
     * capabilities and the current set.  Note: if we simply add a
     * hardware capability that is tied to new RCP parameters there is
     * nothing to do as the older firmware doesn't support the new
     * parameter anyway.  We only need to translate functional changes.
     * */

    if (con)
    {
        if (_rcp_version_in_range_ext(con, 6, 20, 6, 29))
        {
            /* New capabilities:
             * - HW_CAP_MULTI_MONITOR_FEED_0:
             * - HW_CAP_MULTI_MONITOR_FEED_1:
             * - HW_CAP_MULTI_MONITOR_FEED_1_AND_3D_LUT:
             * */

            /* If we have multi monitor feeds assume we have both feed
             * 0 and feed 1 */
            if (_rcp_get_hw_cap(con, HW_CAP_MULTI_MONITOR_FEEDS))
            {
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_0, 1);
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_1, 1);
            }
            else
            {
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_0, 0);
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_1, 0);
            }

            /* If we have multi monitor feed 1 and 3D LUT support set
             * the meta capability HW_CAP_MULTI_MONITOR_FEED_1_AND_3D_LUT */
            if (_rcp_get_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_1) && _rcp_get_hw_cap(con, HW_CAP_3D_LUT))
            {
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_1_AND_3D_LUT, 1);
            }
            else
            {
                _rcp_set_hw_cap(con, HW_CAP_MULTI_MONITOR_FEED_1_AND_3D_LUT, 0);
            }
        }

        if (_rcp_version_less_or_equal_to(con, 6, 40))
        {
            /* Parameter set 6.41 introduced HW_CAP_GENLOCK_MUXED to
             * determine the genlock source can be selected by the
             * user.  Older firware doesn't have this so we should just
             * set it to true of the camera has HW_CAP_GENLOCK */

            if (_rcp_get_hw_cap(con, HW_CAP_GENLOCK))
            {
                _rcp_set_hw_cap(con, HW_CAP_GENLOCK_MUXED, 1);
            }
        }

        if (_rcp_version_less_or_equal_to(con, 6, 49))
        {
            /* Parameter set 6.50 introduced hardware capabilities for
             * Power PL Lens and Force PL Detect. Older versions need
             * to always enable these features to avoid user inconvenience. */
            _rcp_set_hw_cap(con, HW_CAP_PL_POWER, 1);
            _rcp_set_hw_cap(con, HW_CAP_PL_DETECT, 1);

             /* Parameter set 6.50 introduced HW_CAP_SENSOR_FLIP.
              * Default to true for older firmware so sensor flip will
              * still function */
            _rcp_set_hw_cap(con, HW_CAP_SENSOR_FLIP, 1);
        }

        if (_rcp_version_less_or_equal_to(con, 6, 59))
        {
            /* Parameter set 6.60 introduced HW_CAP_SENSOR_SYNC.
             * Default to true for older firmware so sensor sync will
             * still function */
            _rcp_set_hw_cap(con, HW_CAP_SENSOR_SYNC, 1);

            /* Parameter set 6.60 introduced HW_CAP_AUDIO_IN_GAIN_CONTROL_12
             * and HW_CAP_AUDIO_IN_GAIN_CONTROL_34. Default to true for
             * older firmware so software gain control will still function. */
            _rcp_set_hw_cap(con, HW_CAP_AUDIO_IN_GAIN_CONTROL_12, 1);
            _rcp_set_hw_cap(con, HW_CAP_AUDIO_IN_GAIN_CONTROL_34, 1);
        }
    }
}
/********** End file: rcp_api_hw_cap.c ******************************************/

/********** Begin file: rcp_api_key_mapping.c ***********************************/
/* #include "rcp_api_key_mapping.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_get_list.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>
#include <string.h>
/* #include "stringl/stringl.h" */
/* #include "rcp_parser/rcp_parameter_types_public.h" */

static rcp_error_t _rcp_key_mapping_get_action_list(rcp_camera_connection_t * con);
static rcp_error_t _rcp_key_mapping_get_mapping(rcp_camera_connection_t * con, int keycode);
static rcp_error_t _rcp_key_mapping_set_mapping(rcp_camera_connection_t * con, int keycode, key_action_t action, const char * param);
static void _rcp_send_action_list(rcp_camera_connection_t * con);
static int _rcp_get_dialog_name(const rcp_camera_connection_t * con, int dialog_num, char * dialog_name, size_t dialog_name_len);
static int _rcp_get_dialog_num(const rcp_camera_connection_t * con, const char * dialog_name, int * dialog_num);

int rcp_key_mapping_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_KEY_MAPPING);
}

rcp_error_t rcp_key_mapping_get_action_list(rcp_camera_connection_t * con)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "key_mapping_get_action_list\n");
    err = _rcp_key_mapping_get_action_list(con);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_key_mapping_get_mapping(rcp_camera_connection_t * con, int keycode)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "key_mapping_get_mapping: %d\n", keycode);
    err = _rcp_key_mapping_get_mapping(con, keycode);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_key_mapping_set_mapping(rcp_camera_connection_t * con, int keycode, key_action_t action, const char * param)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "key_mapping_set_mapping: %d %d:%s\n", keycode, action, param ? param : "");
    err = _rcp_key_mapping_set_mapping(con, keycode, action, param);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

void * rcp_malloc(size_t NBYTES)
{
	return malloc(NBYTES);
}

void rcp_free(void * APTR)
{
	free(APTR);
}

void rcp_log(rcp_log_t severity, const rcp_camera_connection_t * con, const char * msg) {

}

int rcp_rand(void)
{
	static int seed = 1;
	if (seed)
	{
		//srand(time(NULL));
		seed = 0;
	}
	return rand();
}

uint32_t rcp_timestamp(void) {
	return 0;
}

static rcp_error_t _rcp_key_mapping_get_action_list(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (rcp_key_mapping_is_supported(con))
        {
            int required_data = 0;
            const rcp_param_state_t * const preset_list_param = &con->param_state[RCP_PARAM_CAMERA_PRESET_LIST];
            const rcp_param_state_t * const look_list_param = &con->param_state[RCP_PARAM_CAMERA_LOOK_LIST];
            const rcp_param_state_t * const action_list_param = &con->param_state[RCP_PARAM_KEY_MAPPING_ACTION_LIST];
            const rcp_param_state_t * const dialog_list_param = &con->param_state[RCP_PARAM_DIALOG_LIST];
            const rcp_param_state_t * const script_list_param = &con->param_state[RCP_PARAM_CAMERA_SCRIPT_LIST];

            if (!preset_list_param->list_val_valid)
            {
                if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_CAMERA_PRESET_LIST))
                {
                    _rcp_log_error(con, "cannot get camera preset list\n");
                    return RCP_ERROR_INTERNAL;
                }
                required_data = 1;
            }
            if (!look_list_param->list_val_valid)
            {
                if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_CAMERA_LOOK_LIST))
                {
                    _rcp_log_error(con, "cannot get camera look list\n");
                    return RCP_ERROR_INTERNAL;
                }
                required_data = 1;
            }
            if (!action_list_param->list_val_valid)
            {
                if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_KEY_MAPPING_ACTION_LIST))
                {
                    _rcp_log_error(con, "cannot get action list\n");
                    return RCP_ERROR_INTERNAL;
                }
                required_data = 1;
            }
            if (!dialog_list_param->list_val_valid)
            {
                if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_DIALOG_LIST))
                {
                    _rcp_log_error(con, "cannot get dialog list\n");
                    return RCP_ERROR_INTERNAL;
                }
                required_data = 1;
            }
            if (!script_list_param->list_val_valid)
            {
                if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_CAMERA_SCRIPT_LIST))
                {
                    _rcp_log_error(con, "cannot get script list\n");
                    return RCP_ERROR_INTERNAL;
                }
                required_data = 1;
            }

            if (!required_data)
            {
                _rcp_send_action_list(con);
            }
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

static void _rcp_key_code_queue_add(rcp_camera_connection_t * con, int keycode)
{
    if (con)
    {
        int * new_queue;

        _rcp_log_info(con, "adding keycode %d to queue\n", keycode);

        /* Check if keycode is already in queue or not.  If so, no need
         * to add it again. */
        if (con->key_mapping_key_code_queue)
        {
            size_t ii;
            for (ii = 0; ii < con->key_mapping_key_code_queue_length; ii++)
            {
                if (con->key_mapping_key_code_queue[ii] == keycode)
                {
                    _rcp_log_info(con, "keycode %d already in queue\n");
                    return;
                }
            }
        }

        /* Increase size of queue, allocate new queue, copy existing
         * items to new queue and delete old queue.  Note: this could
         * be optimized/simplified by introducing an rcp_realloc
         * function. */
        con->key_mapping_key_code_queue_length++;
        new_queue = RCP_MALLOC(int *, sizeof(int) * con->key_mapping_key_code_queue_length);

        if (con->key_mapping_key_code_queue)
        {
            if (new_queue)
            {
                memcpy(new_queue, con->key_mapping_key_code_queue, sizeof(int) * (con->key_mapping_key_code_queue_length - 1));
            }
            rcp_free(con->key_mapping_key_code_queue);
        }
        con->key_mapping_key_code_queue = new_queue;

        /* Add new keycode to end of queue */
        if (con->key_mapping_key_code_queue)
        {
            con->key_mapping_key_code_queue[con->key_mapping_key_code_queue_length - 1] = keycode;
        }
    }
}

static void _rcp_key_code_queue_clear(rcp_camera_connection_t * con)
{
    if (con->key_mapping_key_code_queue)
    {
        rcp_free(con->key_mapping_key_code_queue);
        con->key_mapping_key_code_queue = NULL;
        con->key_mapping_key_code_queue_length = 0;
    }
}

static rcp_error_t _rcp_key_mapping_get_mapping(rcp_camera_connection_t * con, int keycode)
{
    if (con)
    {
        if (rcp_key_mapping_is_supported(con))
        {
            if (con->key_mapping_action_list)
            {
                _rcp_create_get_with_int_arg_message(con, RCP2_CMD_GET, RCP_USERKEY_MSG_KEY_MAPPING, keycode);
            }
            else
            {
                /* Need to get action list first; queue this request. */
                _rcp_key_code_queue_add(con, keycode);
                return _rcp_key_mapping_get_action_list(con);
            }
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

static const char * get_action_param(const char * label)
{
    const char * cur = label;
    const char * last_colon = NULL;

    if (!label)
    {
        return NULL;
    }

    while (*cur)
    {
        if (*cur == ':')
        {
            last_colon = cur;
        }
        cur++;
    }

    if (last_colon)
    {
        cur = last_colon;
        cur++;

        while (*cur && *cur == ' ')
        {
            cur++;
        }

        return cur;
    }

    return label;
}

static rcp_error_t _rcp_key_mapping_set_mapping(rcp_camera_connection_t * con, int keycode, key_action_t action, const char * param)
{
    if (con)
    {
        if (rcp_key_mapping_is_supported(con))
        {
            char keycode_str[RCP_STR_LEN_FOR_INT32];
            char action_str[RCP_STR_LEN_FOR_INT32];
            char dialog_num_str[RCP_STR_LEN_FOR_INT32];
            const char * action_param = NULL;
            snprintf(keycode_str, sizeof(keycode_str), "%d", keycode);
            snprintf(action_str, sizeof(action_str), "%d", action);

            if (
                action == KEY_ACTION_APPLY_LOOK ||
                action == KEY_ACTION_APPLY_PRESET ||
                action == KEY_ACTION_RUN_SCRIPT
               )
            {
                action_param = get_action_param(param);
            }
            else if (action == KEY_ACTION_SHOW_DIALOG)
            {
                int dialog_num;
                const char * const dialog_name = get_action_param(param);

                if (!_rcp_get_dialog_num(con, dialog_name, &dialog_num))
                {
                    _rcp_log_error(con, "cannot get dialog num\n");
                    dialog_num = 0;
                }
                snprintf(dialog_num_str, sizeof(dialog_num_str), "%d", dialog_num);
                action_param = dialog_num_str;
            }

            if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_USERKEY_MSG_KEY_MAPPING, 3, keycode_str, action_str, action_param ? action_param : ""))
            {
                _rcp_log_error(con, "cannot create set key mapping packet\n");
            }
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

static void _rcp_create_key_mapping_action_list(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const preset_list_param = &con->param_state[RCP_PARAM_CAMERA_PRESET_LIST];
        const rcp_param_state_t * const look_list_param = &con->param_state[RCP_PARAM_CAMERA_LOOK_LIST];
        const rcp_param_state_t * const action_list_param = &con->param_state[RCP_PARAM_KEY_MAPPING_ACTION_LIST];
        const rcp_param_state_t * const dialog_list_param = &con->param_state[RCP_PARAM_DIALOG_LIST];
        const rcp_param_state_t * const script_list_param = &con->param_state[RCP_PARAM_CAMERA_SCRIPT_LIST];

        if (action_list_param->list_val_valid && preset_list_param->list_val_valid && look_list_param->list_val_valid && dialog_list_param->list_val_valid && script_list_param->list_val_valid)
        {
            c_list_t * action_c_list;
            c_list_t * preset_c_list;
            c_list_t * look_c_list;
            c_list_t * dialog_c_list;
            c_list_t * script_c_list;

            if (con->key_mapping_action_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(con->key_mapping_action_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }

            action_c_list = c_list_create(rcp_malloc, rcp_free);
            preset_c_list = c_list_create(rcp_malloc, rcp_free);
            look_c_list = c_list_create(rcp_malloc, rcp_free);
            dialog_c_list = c_list_create(rcp_malloc, rcp_free);
            script_c_list = c_list_create(rcp_malloc, rcp_free);
            con->key_mapping_action_list = c_list_create(rcp_malloc, rcp_free);

            if (con->key_mapping_action_list && action_c_list && preset_c_list && look_c_list && dialog_c_list)
            {
                size_t action_list_len;
                size_t preset_list_len;
                size_t look_list_len;
                size_t dialog_list_len;
                size_t script_list_len;
                size_t ii;

                /* Add normal actions to complete list */
                if (C_LIST_SUCCESS != c_list_import_from_string(action_c_list, action_list_param->list_val))
                {
                    _rcp_log_error(con, "cannot import action list string\n");
                }

                action_list_len = c_list_get_length(action_c_list);
                for (ii = 0; ii < action_list_len; ii++)
                {
                    c_list_entry_t entry;
                    if (c_list_get_entry(action_c_list, ii, &entry) == C_LIST_SUCCESS)
                    {
                        if (entry.num == KEY_ACTION_APPLY_LOOK)
                        {
                            strlcpy(con->key_action_apply_look_prefix, entry.str, sizeof(con->key_action_apply_look_prefix));
                        }
                        else if (entry.num == KEY_ACTION_APPLY_PRESET)
                        {
                            strlcpy(con->key_action_apply_preset_prefix, entry.str, sizeof(con->key_action_apply_preset_prefix));
                        }
                        else if (entry.num == KEY_ACTION_SHOW_DIALOG)
                        {
                            strlcpy(con->key_action_show_dialog_prefix, entry.str, sizeof(con->key_action_show_dialog_prefix));
                        }
                        else if (entry.num == KEY_ACTION_RUN_SCRIPT)
                        {
                            strlcpy(con->key_action_run_script_prefix, entry.str, sizeof(con->key_action_run_script_prefix));
                        }
                        else
                        {
                            const user_defined_t user_defined_null = {0};
                            if (C_LIST_SUCCESS != c_list_insert_in_alphabetical_order(con->key_mapping_action_list, entry.num, entry.str, user_defined_null))
                            {
                                _rcp_log_error(con, "cannot add item to list\n");
                            }
                        }
                    }
                }

                /* Add "Apply Preset"s to complete list */
                if (strlen(con->key_action_apply_preset_prefix))
                {
                    if (C_LIST_SUCCESS != c_list_import_from_string(preset_c_list, preset_list_param->list_val))
                    {
                        _rcp_log_error(con, "cannot import preset list string\n");
                    }

                    preset_list_len = c_list_get_length(preset_c_list);
                    for (ii = 0; ii < preset_list_len; ii++)
                    {
                        c_list_entry_t entry;
                        if (c_list_get_entry(preset_c_list, ii, &entry) == C_LIST_SUCCESS)
                        {
                            const user_defined_t user_defined_null = {0};
                            char action_label[RCP_API_DISPLAY_STR_SIZE];

                            snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_apply_preset_prefix, entry.str);
                            if (C_LIST_SUCCESS != c_list_insert_in_alphabetical_order(con->key_mapping_action_list, KEY_ACTION_APPLY_PRESET, action_label, user_defined_null))
                            {
                                _rcp_log_error(con, "cannot add item to list\n");
                            }
                        }
                    }
                }

                /* Add "Apply Look"s to complete list */
                if (strlen(con->key_action_apply_look_prefix))
                {
                    if (C_LIST_SUCCESS != c_list_import_from_string(look_c_list, look_list_param->list_val))
                    {
                        _rcp_log_error(con, "cannot import look list string\n");
                    }

                    look_list_len = c_list_get_length(look_c_list);
                    for (ii = 0; ii < look_list_len; ii++)
                    {
                        c_list_entry_t entry;
                        if (c_list_get_entry(look_c_list, ii, &entry) == C_LIST_SUCCESS)
                        {
                            const user_defined_t user_defined_null = {0};
                            char action_label[RCP_API_DISPLAY_STR_SIZE];

                            snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_apply_look_prefix, entry.str);
                            if (C_LIST_SUCCESS != c_list_insert_in_alphabetical_order(con->key_mapping_action_list, KEY_ACTION_APPLY_LOOK, action_label, user_defined_null))
                            {
                                _rcp_log_error(con, "cannot add item to list\n");
                            }
                        }
                    }
                }

                /* Add "Show Dialog"s to complete list */
                if (strlen(con->key_action_show_dialog_prefix))
                {
                    if (C_LIST_SUCCESS != c_list_import_from_string(dialog_c_list, dialog_list_param->list_val))
                    {
                        _rcp_log_error(con, "cannot import dialog list string\n");
                    }

                    dialog_list_len = c_list_get_length(dialog_c_list);
                    for (ii = 0; ii < dialog_list_len; ii++)
                    {
                        c_list_entry_t entry;
                        if (c_list_get_entry(dialog_c_list, ii, &entry) == C_LIST_SUCCESS)
                        {
                            const user_defined_t user_defined_null = {0};
                            char action_label[RCP_API_DISPLAY_STR_SIZE];

                            /* If the SHOW DIALOG prefix is "_", don't
                             * show it, just show the dialog name */
                            if (strcmp(con->key_action_show_dialog_prefix, "_") == 0)
                            {
                                snprintf(action_label, sizeof(action_label), "%s", entry.str);
                            }
                            else
                            {
                                snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_show_dialog_prefix, entry.str);
                            }

                            if (C_LIST_SUCCESS != c_list_insert_in_alphabetical_order(con->key_mapping_action_list, KEY_ACTION_SHOW_DIALOG, action_label, user_defined_null))
                            {
                                _rcp_log_error(con, "cannot add item to list\n");
                            }
                        }
                    }
                }

                /* Add "Run Scripts"s to complete list */
                if (strlen(con->key_action_run_script_prefix))
                {
                    if (C_LIST_SUCCESS != c_list_import_from_string(script_c_list, script_list_param->list_val))
                    {
                        _rcp_log_error(con, "cannot import script list string\n");
                    }

                    script_list_len = c_list_get_length(script_c_list);
                    for (ii = 0; ii < script_list_len; ii++)
                    {
                        c_list_entry_t entry;
                        if (c_list_get_entry(script_c_list, ii, &entry) == C_LIST_SUCCESS)
                        {
                            const user_defined_t user_defined_null = {0};
                            char action_label[RCP_API_DISPLAY_STR_SIZE];

                            snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_run_script_prefix, entry.str);
                            if (C_LIST_SUCCESS != c_list_insert_in_alphabetical_order(con->key_mapping_action_list, KEY_ACTION_RUN_SCRIPT, action_label, user_defined_null))
                            {
                                _rcp_log_error(con, "cannot add item to list\n");
                            }
                        }
                    }
                }
            }

            if (action_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(action_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }

            if (preset_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(preset_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }

            if (look_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(look_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }

            if (dialog_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(dialog_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }

            if (script_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(script_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }
        }
    }
}

static void _rcp_send_action_list(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->key_mapping_action_list)
        {
            if (con->cur_action_list_cb)
            {
                rcp_cur_action_list_cb_data_t data;
                data.con = con;
                data.action_c_list = con->key_mapping_action_list;
                con->cur_action_list_cb(&data, con->cur_action_list_cb_user_data);
            }
        }
    }
}

static void _rcp_key_mapping_updated_sub_list(rcp_camera_connection_t * con)
{
    if (con)
    {
        _rcp_create_key_mapping_action_list(con);

        if (con->key_mapping_action_list)
        {
            _rcp_send_action_list(con);

            if (con->key_mapping_key_code_queue)
            {
                size_t ii;
                for (ii = 0; ii < con->key_mapping_key_code_queue_length; ii++)
                {
                    if (RCP_SUCCESS != _rcp_key_mapping_get_mapping(con, con->key_mapping_key_code_queue[ii]))
                    {
                        _rcp_log_error(con, "cannot get key mapping\n");
                    }
                }

                _rcp_key_code_queue_clear(con);
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_key_mapping_preset_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    _rcp_key_mapping_updated_sub_list(con);
}

RCP_API_PRIVATE void _rcp_key_mapping_look_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    _rcp_key_mapping_updated_sub_list(con);
}

RCP_API_PRIVATE void _rcp_key_mapping_action_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    _rcp_key_mapping_updated_sub_list(con);
}

RCP_API_PRIVATE void _rcp_key_mapping_dialog_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    _rcp_key_mapping_updated_sub_list(con);
}

RCP_API_PRIVATE void _rcp_key_mapping_script_list(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    _rcp_key_mapping_updated_sub_list(con);
}

RCP_API_PRIVATE void _rcp_key_mapping_hw_cap_changed(rcp_camera_connection_t * con)
{
    if (con->key_mapping_action_list)
    {
        /* we need to get the action list again, since it can change based
         * on camera hardware configuration */

        if (RCP_SUCCESS != _rcp_get_list(con, RCP_PARAM_KEY_MAPPING_ACTION_LIST))
        {
            _rcp_log_error(con, "cannot get action list\n");
        }
    }
}

static int _rcp_get_dialog_name(const rcp_camera_connection_t * con, int dialog_num, char * dialog_name, size_t dialog_name_len)
{
    int success = 0;

    if (!dialog_name)
    {
        return 0;
    }

    if (con)
    {
        const rcp_param_state_t * const dialog_list_param = &con->param_state[RCP_PARAM_DIALOG_LIST];

        if (dialog_list_param->list_val_valid)
        {
            c_list_t * const dialog_c_list = c_list_create(rcp_malloc, rcp_free);

            if (dialog_c_list)
            {
                if (C_LIST_SUCCESS != c_list_import_from_string(dialog_c_list, dialog_list_param->list_val))
                {
                    _rcp_log_error(con, "cannot import dialog list string\n");
                }
                else
                {
                    c_list_entry_t entry;

                    if (C_LIST_SUCCESS != c_list_find_num(dialog_c_list, dialog_num, &entry, C_LIST_FIND_EXACT))
                    {
                        _rcp_log_error(con, "cannot find current dialog in list\n");
                    }
                    else
                    {
                        strlcpy(dialog_name, entry.str, dialog_name_len);
                        success = 1;
                    }
                }

                if (C_LIST_SUCCESS != c_list_delete(dialog_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }
        }
    }

    return success;
}

static int _rcp_get_dialog_num(const rcp_camera_connection_t * con, const char * dialog_name, int * dialog_num)
{
    int success = 0;

    if (!dialog_num)
    {
        return 0;
    }

    if (con)
    {
        const rcp_param_state_t * const dialog_list_param = &con->param_state[RCP_PARAM_DIALOG_LIST];

        if (dialog_list_param->list_val_valid)
        {
            c_list_t * const dialog_c_list = c_list_create(rcp_malloc, rcp_free);

            if (dialog_c_list)
            {
                if (C_LIST_SUCCESS != c_list_import_from_string(dialog_c_list, dialog_list_param->list_val))
                {
                    _rcp_log_error(con, "cannot import dialog list string\n");
                }
                else
                {
                    c_list_entry_t entry;

                    if (C_LIST_SUCCESS != c_list_find_str(dialog_c_list, dialog_name, &entry))
                    {
                        _rcp_log_error(con, "cannot find current dialog in list\n");
                    }
                    else
                    {
                        *dialog_num = entry.num;
                        success = 1;
                    }
                }

                if (C_LIST_SUCCESS != c_list_delete(dialog_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }
        }
    }

    return success;
}

RCP_API_PRIVATE void _rcp_process_key_mapping_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        int key_code;
        key_action_t key_action;
        const char * key_action_param;

        if (packet->argc < 3)
        {
            _rcp_log_error(con, "invalid current key mapping packet\n");
            return;
        }

        key_code = atoi(packet->argv[0]);
        key_action = (key_action_t) atoi(packet->argv[1]);
        key_action_param = packet->argv[2];

        if (con->cur_key_mapping_cb)
        {
            c_list_t * action_c_list = NULL;
            rcp_cur_key_mapping_cb_data_t data = {0};

            if (con->key_mapping_action_list)
            {
                action_c_list = c_list_create(rcp_malloc, rcp_free);

                if (action_c_list)
                {
                    if (C_LIST_SUCCESS != c_list_copy(action_c_list, con->key_mapping_action_list))
                    {
                        _rcp_log_error(con, "cannot copy list\n");
                    }

                    if (key_action == KEY_ACTION_APPLY_LOOK)
                    {
                        char action_label[RCP_API_DISPLAY_STR_SIZE];
                        c_list_entry_t entry;
                        snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_apply_look_prefix, key_action_param);

                        if (C_LIST_SUCCESS != c_list_find_str(action_c_list, action_label, &entry))
                        {
                            _rcp_log_error(con, "cannot find current action in list\n");
                        }
                    }
                    else if (key_action == KEY_ACTION_APPLY_PRESET)
                    {
                        char action_label[RCP_API_DISPLAY_STR_SIZE];
                        c_list_entry_t entry;
                        snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_apply_preset_prefix, key_action_param);

                        if (C_LIST_SUCCESS != c_list_find_str(action_c_list, action_label, &entry))
                        {
                            _rcp_log_error(con, "cannot find current action in list\n");
                        }
                    }
                    else if (key_action == KEY_ACTION_SHOW_DIALOG)
                    {
                        char action_label[RCP_API_DISPLAY_STR_SIZE];
                        char dialog_name[RCP_API_DISPLAY_STR_SIZE];
                        c_list_entry_t entry;

                        if (!_rcp_get_dialog_name(con, atoi(key_action_param), dialog_name, sizeof(dialog_name)))
                        {
                            dialog_name[0] = 0;
                            _rcp_log_error(con, "cannot get dialog name\n");
                        }

                        /* If the SHOW DIALOG prefix is "_", don't
                         * show it, just show the dialog name */
                        if (strcmp(con->key_action_show_dialog_prefix, "_") == 0)
                        {
                            snprintf(action_label, sizeof(action_label), "%s", dialog_name);
                        }
                        else
                        {
                            snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_show_dialog_prefix, dialog_name);
                        }

                        if (C_LIST_SUCCESS != c_list_find_str(action_c_list, action_label, &entry))
                        {
                            _rcp_log_error(con, "cannot find current action in list\n");
                        }
                    }
                    else if (key_action == KEY_ACTION_RUN_SCRIPT)
                    {
                        char action_label[RCP_API_DISPLAY_STR_SIZE];
                        c_list_entry_t entry;
                        snprintf(action_label, sizeof(action_label), "%s: %s", con->key_action_run_script_prefix, key_action_param);

                        if (C_LIST_SUCCESS != c_list_find_str(action_c_list, action_label, &entry))
                        {
                            _rcp_log_error(con, "cannot find current action in list\n");
                        }
                    }
                    else
                    {
                        c_list_entry_t entry;
                        if (C_LIST_SUCCESS != c_list_find_num(action_c_list, key_action, &entry, C_LIST_FIND_EXACT))
                        {
                            _rcp_log_warning(con, "cannot find current action in list\n");
                            if (C_LIST_SUCCESS != c_list_find_num(action_c_list, KEY_ACTION_KEY_DISABLED, &entry, C_LIST_FIND_EXACT))
                            {
                                _rcp_log_error(con, "cannot set action to disabled\n");
                            }
                        }
                    }
                }
            }

            data.con = con;
            data.action_c_list = action_c_list;
            data.key_code = key_code;
            data.key_action = key_action;
            data.key_action_param = key_action_param;

            con->cur_key_mapping_cb(&data, con->cur_key_mapping_cb_user_data);

            if (action_c_list)
            {
                if (C_LIST_SUCCESS != c_list_delete(action_c_list))
                {
                    _rcp_log_error(con, "cannot delete list\n");
                }
            }
        }
    }
}
/********** End file: rcp_api_key_mapping.c *************************************/

/********** Begin file: rcp_api_log.c *******************************************/
/* #include "rcp_api.h" */
/* #include "rcp_api_log.h" */
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>

#ifdef RCP_API_ENABLE_LOGGING

/* log message with client code. */
RCP_API_PRIVATE void _rcp_log(const char * file, const char * func, int line, rcp_log_t severity, const rcp_camera_connection_t * con, const char * fmt, ...)
{
    static int first_log = 1;
    char log_buffer[RCP_API_LOG_LINE_SIZE];
    size_t len;
    unsigned int ts;
    static unsigned int start_ts = UINT_MAX;
    unsigned int ms;
    unsigned int s;
    unsigned int m;
    unsigned int h;
    va_list args;
    const char * short_file = NULL;

    ts = rcp_timestamp();
    if (start_ts == UINT_MAX)
    {
        start_ts = ts;
    }
    ts -= start_ts;

    ms = ts % 1000;
    s = (ts / 1000) % 60;
    m = ((ts / 1000) / 60) % 60;
    h = ((ts / 1000) / 60) / 60;

    /* the first time anything is logged, show the SDK version number */
    if (first_log)
    {
        first_log = 0;

        snprintf(log_buffer, sizeof(log_buffer), "RCP SDK Version: %s\n", rcp_api_get_version());
        rcp_log(RCP_LOG_INFO, NULL, log_buffer);
    }

    short_file = strrchr(file, '/');
    if (!short_file)
    {
        short_file = strrchr(file, '\\');
        if (!short_file)
        {
            short_file = file;
        }
        else
        {
            short_file += 1;
        }
    }
    else
    {
        short_file += 1;
    }

    snprintf(log_buffer, sizeof(log_buffer), "[%d:%02d:%02d:%03d] %s:%s (%d): ", h, m, s, ms, short_file, func, line);
    len = strlen(log_buffer);

    va_start(args, fmt);
    (void) vsnprintf(log_buffer + len, sizeof(log_buffer) - len, fmt, args);
    va_end(args);

    rcp_log(severity, con, log_buffer);
}

#endif
/********** End file: rcp_api_log.c *********************************************/

/********** Begin file: rcp_api_menu.c ******************************************/
/*
 * The camera menu tree is described by a set of nodes.  Each node is
 * either the start of a new branch (RCP_MENU_NODE_TYPE_BRANCH) or a
 * leaf.  Leafs represent the end nodes that contain controls.  That
 * is, either a list, action, number or text entry, etc.  Each node has
 * a unique ID, which is used to reference it and find its parent node.
 *
 * Each node is described by rcp_menu_node_info_t.  This structure
 * contains information such as the node type, its ID, its parent's ID,
 * title, and RCP parameter associated with the node (if it is a leaf
 * node), etc.
 *
 * The RCP API caches the menu structure as it receives it from the
 * camera.  The cached nodes are maintained in a number of lists as
 * shown below:
 *
 * +-------------------------+
 * | Camera Connection       |
 * |                         |
 * | O menu_parent_node_list |
 * +-+-----------------------+
 *   |
 *   v
 * +------------+             +----------+
 * |parent:   O-+------------>|parent: X |
 * +------------+             +----------+   +-----------+
 * |children: O-+---------+   |info:   O-+-->| Node Data |
 * |            |<------+ |   +----------+   | "Menu"    |
 * +------------+       | |   |next:   X |   | ID: 0     |
 * |next:     O |       | |   +----------+   +-----------+
 * +----------+-+       | |
 *            |         | |   +----------+
 *            v         | +-->|parent:   |
 * +------------+       +-----+--------O |
 * |parent:   O-+->...  |     +----------+   +-----------+
 * +------------+       |     |info:   O-+-->| Node Data |
 * |children: O-+->...  |     +----------+   | "Child1"  |
 * +------------+       |     |next:   O |   | ID: 1     |
 * |next:     O |       |     +--------+-+   +-----------+
 * +----------+-+       |              |
 *            |         |              v
 *           ...        |     +----------+
 *            |         |     |parent:   |
 *            v         +-----+--------O |
 * +------------+             +----------+   +-----------+
 * |parent:   O-+->...        |info:   O-+-->| Node Data |
 * +------------+             +----------+   | "Child2"  |
 * |children: O-+->...        |next:   X |   | ID: 2     |
 * +------------+             +----------+   +-----------+
 * |next:     X |
 * +------------+
 *
 * The Parent/Children list is the master list.  Each entry in the list
 * points to: the parent, the list of children, and the next entry in
 * the list.  That is, each entry associates a parent node with a list
 * of children nodes.
 *
 * Each entry of the children lists (also know as the Sibling Lists)
 * contains a pointer back to the entry in the Parent/Children List
 * (parent), a pointer to the node data itself (info), and a pointer to
 * the next sibling in the children list.
 *
 * With this structure we can easily lookup the children of a given
 * parent id by traversing through the Parent/Child List.  We can also
 * find the ancestor path back to the root node by following the parent
 * pointers (to build a breadcrumb trail to the current node).
 *
 */

/* #include "rcp_api_menu.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_utils.h" */

/* #include "rcp_parser/rcp_parameter_types_public.h" */
/* #include "stringl/stringl.h" */
#include <string.h>
#include <stdlib.h>

#ifdef RCP_API_ENABLE_MENU

#define ROOT_LABEL  "Menu"

static rcp_menu_node_info_t * _rcp_menu_handle_node(rcp_camera_connection_t * con, char * node_string);
static void _rcp_menu_delete_siblings(const rcp_camera_connection_t * con, rcp_menu_sibling_node_list_t * siblings);
static void _rcp_menu_delete_list(const rcp_camera_connection_t * con, rcp_menu_node_list_t * node_list);
static void _rcp_menu_delete_node(const rcp_camera_connection_t * con, rcp_menu_node_info_t * info);
static rcp_menu_parent_node_list_t * _rcp_menu_find_parent(const rcp_camera_connection_t * con, rcp_menu_node_id_t parent_id);
static rcp_menu_parent_node_list_t * _rcp_menu_create_parent(const rcp_camera_connection_t * con);
static rcp_menu_sibling_node_list_t * _rcp_menu_find_child(const rcp_camera_connection_t * con, rcp_menu_node_id_t child_id);
static void _rcp_menu_send_children(rcp_camera_connection_t * con, rcp_menu_parent_node_list_t * parent);
static void _rcp_menu_send_node_status(rcp_camera_connection_t * con, const rcp_menu_node_info_t * node);
static char * _rcp_get_next_token(char * str, char delim, char * * saveptr);
static void _rcp_cleanup_label(char * label);

RCP_API_PRIVATE void _rcp_menu_handle_node_list(rcp_camera_connection_t * con, const char * node_list_string)
{
    if (con)
    {
        c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);
        if (!c_list)
        {
            _rcp_log_error(con, "could not allocate memory\n");
            return;
        }

        if (C_LIST_SUCCESS != c_list_import_from_string(c_list, node_list_string))
        {
            _rcp_log_error(con, "could not import list\n");
        }
        else
        {
            const size_t list_len = c_list_get_length(c_list);

            if (list_len == 0)
            {
                /* list is empty, there are no children */
                _rcp_log_debug(con, "children list is empty\n");
            }
            else
            {
                c_list_entry_t e;

                /* get the first entry in the list, so we can determine the
                 * parent node id */
                if (C_LIST_SUCCESS != c_list_get_entry(c_list, 0, &e))
                {
                    _rcp_log_error(con, "could not get first entry\n");
                }
                else
                {
                    rcp_menu_node_info_t * const first_info = _rcp_menu_handle_node(con, e.str);
                    if (!first_info)
                    {
                        _rcp_log_error(con, "could not parse first entry\n");
                    }
                    else
                    {
                        const rcp_menu_node_id_t parent_id = first_info->parent_id;
                        rcp_menu_parent_node_list_t * parent = _rcp_menu_find_parent(con, parent_id);

                        _rcp_menu_delete_node(con, first_info);

                        /* if we already have this parent, we don't need to parse this
                         * data */
                        if (parent)
                        {
                            /* We already have the child data for this
                             * parent.  We don't need to parse this
                             * data again. */
                            _rcp_menu_send_children(con, parent);
                        }
                        else
                        {
                            /* We need to have a pointer to the parent so we can add
                             * the backwards pointers; search for it now.  If we don't
                             * have the parent in the child list, we can't get it's
                             * children.  As long as the calling code only asks for
                             * children of nodes we have told it about, everything will
                             * work out OK.*/
                            rcp_menu_sibling_node_list_t * const parent_as_child = _rcp_menu_find_child(con, parent_id);
                            if (!parent_as_child)
                            {
                                _rcp_log_debug(con, "received list of children for a parent node (%d) we don't have cached; ignoring\n", parent_id);
                            }
                            else
                            {
                                /* create a new entry in the parent list */
                                parent = _rcp_menu_create_parent(con);
                                if (!parent)
                                {
                                    _rcp_log_error(con, "could not create entry in parent/children list\n");
                                }
                                else
                                {
                                    parent->parent = parent_as_child;
                                    parent->children = RCP_MALLOC(rcp_menu_sibling_node_list_t *, sizeof(rcp_menu_sibling_node_list_t));
                                    if (parent->children)
                                    {
                                        rcp_menu_sibling_node_list_t * cur = parent->children;
                                        size_t ii;

                                        if (cur)
                                        {
                                            cur->parent = parent;
                                            cur->info = NULL;
                                            cur->next = NULL;
                                        }

                                        for (ii = 0; ii < list_len; ii++)
                                        {
                                            if (C_LIST_SUCCESS == c_list_get_entry(c_list, ii, &e))
                                            {
                                                rcp_menu_node_info_t * const info = _rcp_menu_handle_node(con, e.str);
                                                if (info && cur)
                                                {
                                                    cur->parent = parent;
                                                    cur->info = info;

                                                    if (ii != list_len - 1)
                                                    {
                                                        cur->next = RCP_MALLOC(rcp_menu_sibling_node_list_t *, sizeof(rcp_menu_sibling_node_list_t));
                                                        cur = cur->next;
                                                        cur->parent = parent;
                                                        cur->info = NULL;
                                                        cur->next = NULL;
                                                    }
                                                }
                                            }
                                        }

                                        _rcp_menu_send_children(con, parent);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (C_LIST_SUCCESS != c_list_delete(c_list))
        {
            _rcp_log_error(con, "could not delete list\n");
        }
    }
}

RCP_API_PRIVATE void _rcp_menu_handle_node_status(rcp_camera_connection_t * con, rcp_menu_node_id_t node_id, int is_enabled, int is_supported)
{
    if (con)
    {
        if (rcp_menu_node_status_is_supported(con))
        {
            const rcp_menu_sibling_node_list_t * const node = _rcp_menu_find_child(con, node_id);

            if (node)
            {
                /* if we have this node cached, update its cached
                 * values */
                node->info->is_enabled = is_enabled;
                node->info->is_enabled_valid = 1;

                node->info->is_supported = is_supported;
                node->info->is_supported_valid = 1;

                _rcp_menu_send_node_status(con, node->info);
            }
            else
            {
                /* if not, just pass the node status info along to the
                 * client code */
                rcp_menu_node_info_t node_info;
                memset(&node_info, 0, sizeof(node_info));
                node_info.id = node_id;

                node_info.is_enabled = is_enabled;
                node_info.is_enabled_valid = 1;

                node_info.is_supported = is_supported;
                node_info.is_supported_valid = 1;

                _rcp_menu_send_node_status(con, &node_info);
            }
        }
    }
}

/* this is similar to strtok_r except:
 * - there is only one delimiter char
 * - repeated delimiters are treated as separate delimiters with an
 * empty string between them */
static char * _rcp_get_next_token(char * str, char delim, char * * saveptr)
{
    char * start_of_token;

    if (!saveptr)
    {
        /* saveptr not provided, we need one. */
        return NULL;
    }

    if (str)
    {
        /* if the original string is provided, this is the start of the
         * next token*/
        start_of_token = str;
    }
    else
    {
        /* otherwise we start where we left off last time */
        start_of_token = *saveptr;
    }

    if (!start_of_token)
    {
        /* we don't have a valid string to parse */
        return NULL;
    }

    if (*start_of_token == '\0')
    {
        /* we are at the end of the string */
        return NULL;
    }

    *saveptr = start_of_token;
    while (**saveptr != '\0' && **saveptr != delim)
    {
        (*saveptr)++;
    }

    if (**saveptr != '\0')
    {
        *(*saveptr)++ = '\0';
    }
    return start_of_token;
}

static rcp_menu_node_info_t * _rcp_menu_handle_node(rcp_camera_connection_t * con, char * node_string)
{
    if (con)
    {
        char * saveptr;
        const char * token;
        int token_count = 0;
        int token_offset = 0;
        int has_node_status = 1;
        rcp_menu_node_info_t * info = NULL;

        if (!_rcp_has_feature(con, RCP_FEATURE_MENU_NODE_STATUS_IN_NODE_INFO))
        {
            token_offset = -2;
            has_node_status = 0;
        }

        info = RCP_MALLOC(rcp_menu_node_info_t *, sizeof(rcp_menu_node_info_t));
        if (info)
        {
            memset(info, 0, sizeof(rcp_menu_node_info_t));
            info->title = NULL;
            info->arg_c_list = NULL;
            info->param_id = RCP_PARAM_COUNT;

            token = _rcp_get_next_token(node_string, ',', &saveptr);

            do
            {
                if (token)
                {
                    if (has_node_status)
                    {
                        if (token_count == token_offset + 1)
                        {
                            info->is_enabled = atoi(token);
                            info->is_enabled_valid = 1;
                        }
                        else if (token_count == token_offset + 2)
                        {
                            info->is_supported = atoi(token);
                            info->is_supported_valid = 1;
                        }
                    }

                    if (token_count == 0)
                    {
                        info->type = (rcp_menu_node_type_t) atoi(token);
                    }
                    else if (token_count == token_offset + 3)
                    {
                        info->filter = (rcp_menu_node_filter_t) atoi(token);
                    }
                    else if (token_count == token_offset + 4)
                    {
                        info->id = (rcp_menu_node_id_t) atoi(token);
                    }
                    else if (token_count == token_offset + 5)
                    {
                        info->parent_id = (rcp_menu_node_id_t) atoi(token);
                    }
                    else if (token_count == token_offset + 6)
                    {
                        info->title = _rcp_strdup(token);
                    }
                    else if (token_count == token_offset + 7)
                    {
                        rcp_param_properties_t properties;
                        info->param_id = rcp_get_id(con, token);
                        (void) rcp_get_is_supported(con, info->param_id, &properties);

                        /* we don't want to check the return value
                         * of rcp_get_is_supported here as it will
                         * return false if the parameter isn't
                         * currently supported with the attached
                         * hardware.  Instead we will rely on
                         * properties.name being set if it is a
                         * valid parameter given the camera's
                         * parameter set version.  */
                        if (properties.name)
                        {
                            info->send_int = properties.has_set_int;
                            info->send_uint = properties.has_set_uint;
                            info->send_str = properties.has_set_str;
                        }
                        else
                        {
                            info->param_id = RCP_PARAM_COUNT;
                        }
                    }
                    else if (token_count == token_offset + 8)
                    {
                        if (info->type == RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF)
                        {
                            info->key_code = atoi(token);
                        }
                        else if (info->type == RCP_MENU_NODE_TYPE_MULTI_ACTION_LIST_LEAF)
                        {
                            info->arg_c_list = c_list_create(rcp_malloc, rcp_free);
                            if (info->arg_c_list)
                            {
                                size_t ii = 0;
                                const size_t num_actions = atoi(token);
                                token = _rcp_get_next_token(NULL, ',', &saveptr);

                                for (ii = 0; ii < num_actions; ii++)
                                {
                                    if (token)
                                    {
                                        c_list_entry_t e;
                                        e.user_defined.int32 = atoi(token);
                                        token = _rcp_get_next_token(NULL, ',', &saveptr);

                                        if (token)
                                        {
                                            e.num = (int) rcp_get_id(con, token);
                                            token = _rcp_get_next_token(NULL, ',', &saveptr);

                                            if (token)
                                            {
                                                strlcpy(e.str, token, sizeof(e.str));
                                                token = _rcp_get_next_token(NULL, ',', &saveptr);

                                                if (C_LIST_SUCCESS != c_list_append(info->arg_c_list, e.num, e.str, e.user_defined))
                                                {
                                                    _rcp_log_error(con, "could not append item to list\n");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            token = NULL;
                        }
                        else
                        {
                            info->arg_c_list = c_list_create(rcp_malloc, rcp_free);
                            if (info->arg_c_list)
                            {
                                if (C_LIST_SUCCESS != c_list_import_from_string(info->arg_c_list, token))
                                {
                                    _rcp_log_error(con, "could not import list\n");
                                }
                            }
                        }
                    }
                    else if (token_count == token_offset + 9)
                    {
                        info->has_payload = atoi(token);
                    }
                    else if (token_count == token_offset + 10)
                    {
                        info->payload = atoi(token);
                    }
                }

                token = _rcp_get_next_token(NULL, ',', &saveptr);
                token_count++;
            }
            while (token);
        }
        return info;
    }
    return NULL;
}

RCP_API_PRIVATE void _rcp_menu_clear(const rcp_camera_connection_t * con)
{
    if (con)
    {
        rcp_menu_parent_node_list_t * cur = con->menu_parent_node_list;
        while (cur)
        {
            rcp_menu_parent_node_list_t * const next = cur->next;
            _rcp_menu_delete_siblings(con, cur->children);
            rcp_free(cur);
            cur = next;
        }
    }
}

static void _rcp_menu_delete_siblings(const rcp_camera_connection_t * con, rcp_menu_sibling_node_list_t * siblings)
{
    if (con)
    {
        rcp_menu_sibling_node_list_t * cur = siblings;
        while (cur)
        {
            rcp_menu_sibling_node_list_t * const next = cur->next;
            _rcp_menu_delete_node(con, cur->info);
            rcp_free(cur);
            cur = next;
        }
    }
}

static void _rcp_menu_delete_list(const rcp_camera_connection_t * con, rcp_menu_node_list_t * node_list)
{
    if (con)
    {
        rcp_menu_node_list_t * cur = node_list;
        while (cur)
        {
            rcp_menu_node_list_t * const next = cur->next;
            rcp_free(cur);
            cur = next;
        }
    }
}

static void _rcp_menu_delete_node(const rcp_camera_connection_t * con, rcp_menu_node_info_t * info)
{
    if (info)
    {
        if (info->title)
        {
            rcp_free(info->title);
        }

        if (info->arg_c_list)
        {
            if (C_LIST_SUCCESS != c_list_delete(info->arg_c_list))
            {
                _rcp_log_error(con, "could not delete list\n");
            }
        }
        rcp_free(info);
    }
}

/* find parent_id in parent/children list, return NULL if not found */
static rcp_menu_parent_node_list_t * _rcp_menu_find_parent(const rcp_camera_connection_t * con, rcp_menu_node_id_t parent_id)
{
    if (con)
    {
        rcp_menu_parent_node_list_t * cur = con->menu_parent_node_list;
        while (cur)
        {
            if (cur->parent && cur->parent->info && (cur->parent->info->id == parent_id))
            {
                return cur;
            }
            cur = cur->next;
        }
    }

    return NULL;
}

/* find child_in in all sibling lists, return NULL if not found */
static rcp_menu_sibling_node_list_t * _rcp_menu_find_child(const rcp_camera_connection_t * con, rcp_menu_node_id_t child_id)
{
    if (con)
    {
        const rcp_menu_parent_node_list_t * cur = con->menu_parent_node_list;
        while (cur)
        {
            rcp_menu_sibling_node_list_t * cur_child = cur->children;
            while (cur_child)
            {
                if (cur_child->info && (cur_child->info->id == child_id))
                {
                    return cur_child;
                }
                cur_child = cur_child->next;
            }

            cur = cur->next;
        }
    }

    return NULL;
}

static rcp_menu_parent_node_list_t * _rcp_menu_create_parent(const rcp_camera_connection_t * con)
{
    if (con)
    {
        /* find last entry in linked list */
        rcp_menu_parent_node_list_t * last = NULL;
        rcp_menu_parent_node_list_t * cur = con->menu_parent_node_list;
        while (cur)
        {
            last = cur;
            cur = cur->next;
        }

        /* create and return new entry to end of list */
        if (last)
        {
            last->next = RCP_MALLOC(rcp_menu_parent_node_list_t *, sizeof(rcp_menu_parent_node_list_t));
            if (last->next)
            {
                last->next->parent = NULL;
                last->next->children = NULL;
                last->next->next = NULL;
            }

            return last->next;
        }
    }

    return NULL;
}

RCP_API_PRIVATE void _rcp_menu_init(rcp_camera_connection_t * con)
{
    if (con)
    {
        /* create "root" node info */
        rcp_menu_node_info_t * const root = RCP_MALLOC(rcp_menu_node_info_t *, sizeof(rcp_menu_node_info_t));
        rcp_menu_sibling_node_list_t * const siblings = RCP_MALLOC(rcp_menu_sibling_node_list_t *, sizeof(rcp_menu_sibling_node_list_t));

        if (root)
        {
            memset(root, 0, sizeof(rcp_menu_node_info_t));
            root->type = RCP_MENU_NODE_TYPE_BRANCH;
            root->filter = RCP_MENU_NODE_FILTER_RECORD_AND_PLAYBACK;
            root->id = RCP_MENU_NODE_ID_ROOT;
            root->parent_id = RCP_MENU_NODE_ID_NULL;
            root->title = _rcp_strdup(ROOT_LABEL);
            root->is_enabled = 1;
            root->is_enabled_valid = 1;
            root->is_supported = 1;
            root->is_supported_valid = 1;
            root->param_id = RCP_PARAM_COUNT;
            root->arg_c_list = NULL;
        }

        /* create sibling linked list with just the root entry in it */
        if (siblings)
        {
            siblings->parent = NULL;
            siblings->info = root;
            siblings->next = NULL;
        }

        /* create entry in parent/children list and add root siblings */
        con->menu_parent_node_list = RCP_MALLOC(rcp_menu_parent_node_list_t *, sizeof(rcp_menu_parent_node_list_t));
        if (con->menu_parent_node_list)
        {
            con->menu_parent_node_list->parent = NULL;
            con->menu_parent_node_list->children = siblings;
            con->menu_parent_node_list->next = NULL;
        }

        con->menu_last_sent_parent = NULL;
    }
}

/* remove all leading/trailing white-space and any colons */
static void _rcp_cleanup_label(char * label)
{
    const char * cur_in = label;
    char * cur_out = label;
    char * last_whitespace = NULL;
    int trimming_leading_whitespace = 1;

    if (!label)
    {
        return;
    }

    while (*cur_in != '\0')
    {
        /* skip over any colons */
        if (*cur_in == ':')
        {
            /* do nothing */
        }
        else
        {
            if (trimming_leading_whitespace)
            {
                if (*cur_in == ' ')
                {
                    /* do nothing */
                }
                else
                {
                    /* found our first non-white-space */
                    trimming_leading_whitespace = 0;
                    *cur_out++ = *cur_in;
                }
            }
            else
            {
                /* we need to keep track of where the first space of
                 * any trailing white-space occurs */
                if (*cur_in == ' ')
                {
                    if (!last_whitespace)
                    {
                        /* this is the first space of the current
                         * trailing sequence of white-spaces */
                        last_whitespace = cur_out;
                    }
                }
                else
                {
                    /* we found non-white-space; clear the white-space
                     * marker */
                    last_whitespace = NULL;
                }

                *cur_out++ = *cur_in;
            }
        }
        cur_in++;
    }

    /* Add the NULL terminator to the string, either at the end of the
     * string or where the trailing white-space begins */
    if (last_whitespace)
    {
        *last_whitespace = '\0';
    }
    else
    {
        *cur_out = '\0';
    }
}

/* Generates the menu title based on a format string and parameter id.
 * The format of these special strings is:
 *
 * If the first character of the format string is a '_':
 * _[menu_label_t value](:[argument])*
 * else:
 * return a copy of the format string itself
 *
 * That is, after the underscore we have an integer (that should be
 * cast to menu_label_t).  This value tells us how to generate the
 * title.  Furthermore, some methods may require one or more arguments
 * */
char * _rcp_allocate_and_format_menu_title(rcp_camera_connection_t * con, char * fmt, rcp_param_t param_id)
{
    const char * token;
    char * saveptr;
    char * title = NULL;
    menu_label_t menu_label = MENU_LABEL_COUNT;

    if (fmt[0] != '_')
    {
        return _rcp_strdup(fmt);
    }

    fmt++;
    token = _rcp_get_next_token(fmt, ':', &saveptr);
    if (token)
    {
        menu_label = (menu_label_t) atoi(token);
    }

    switch (menu_label)
    {
        case MENU_LABEL_FULL:
        {
            const char * const param_label = rcp_get_label(con, param_id);
            if (param_label)
            {
                title = _rcp_strdup(param_label);
            }
            break;
        }

        case MENU_LABEL_PARENT:
        {
            char * label = NULL;
            const char * const param_label = rcp_get_label(con, param_id);
            if (param_label)
            {
                label = _rcp_strdup(param_label);
            }

            if (label)
            {
                char * const last_colon = strrchr(label, ':');
                if (last_colon)
                {
                    *last_colon = '\0';
                }
                title = _rcp_strdup(label);
                rcp_free(label);
            }
            break;
        }

        case MENU_LABEL_CHILD:
        {
            char * label = NULL;
            const char * const param_label = rcp_get_label(con, param_id);
            if (param_label)
            {
                label = _rcp_strdup(param_label);
            }

            if (label)
            {
                const char * const last_colon = strrchr(label, ':');
                if (last_colon)
                {
                    title = _rcp_strdup(last_colon + 1);
                }
                else
                {
                    title = _rcp_strdup(label);
                }
                rcp_free(label);
            }
            break;
        }

        case MENU_LABEL_FROM_LIST_VAL_WITH_INDEX:
            token = _rcp_get_next_token(NULL, ':', &saveptr);
            if (token)
            {
                const int idx = atoi(token);
                c_list_entry_t e;
                if (_rcp_get_indexed_parameter_info(con, param_id, idx, &e))
                {
                    title = _rcp_strdup(e.str);
                }
            }
            break;

        case MENU_LABEL_COUNT:
            break;
    }

    if (title)
    {
        _rcp_cleanup_label(title);
    }

    return title;
}

static void _rcp_menu_send_children(rcp_camera_connection_t * con, rcp_menu_parent_node_list_t * parent)
{
    if (con && parent && con->cur_menu_cb)
    {
        const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
        rcp_cur_menu_cb_data_t data;
        rcp_menu_node_list_t * cur_child;
        rcp_menu_node_list_t * cur_ancestor;
        const rcp_menu_parent_node_list_t * ancestor;
        rcp_menu_parent_node_list_t * first_ancestor_in_group;

        con->menu_last_sent_parent = parent;

        if (!playback_state->val_valid)
        {
            /* if we don't know the playback state we need to ask for
             * it and defer sending the menu info (so we can filter it
             * accordingly */
            (void) _rcp_get(con, RCP_PARAM_PLAYBACK_STATE);
            return;
        }

        /* find the first parent in the ancestor list that is in the
         * current filter group */
        first_ancestor_in_group = parent;
        ancestor = parent;
        while (ancestor)
        {
            if ((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK)
            {
                if (!(ancestor->parent->info->filter & RCP_MENU_NODE_FILTER_PLAYBACK_ONLY))
                {
                    first_ancestor_in_group = ancestor->parent->parent;
                }
            }
            else
            {
                if (!(ancestor->parent->info->filter & RCP_MENU_NODE_FILTER_RECORD_ONLY))
                {
                    first_ancestor_in_group = ancestor->parent->parent;
                }
            }
            ancestor = ancestor->parent->parent;
        }
        parent = first_ancestor_in_group;

        /* initialize data structure to send out */
        data.con = con;
        if (parent && parent->parent && parent->parent->info)
        {
            data.id = parent->parent->info->id;
        }
        else
        {
            data.id = RCP_MENU_NODE_ID_NULL;
        }

        data.children_list = RCP_MALLOC(rcp_menu_node_list_t *, sizeof(rcp_menu_node_list_t));
        data.ancestor_list = RCP_MALLOC(rcp_menu_node_list_t *, sizeof(rcp_menu_node_list_t));
        cur_child = data.children_list;
        cur_ancestor = data.ancestor_list;

        if (cur_child)
        {
            cur_child->info = NULL;
            cur_child->next = NULL;
        }

        if (cur_ancestor)
        {
            cur_ancestor->info = NULL;
            cur_ancestor->next = NULL;
        }

        /* build ancestor list starting with current node and working up */
        ancestor = parent;
        while (ancestor)
        {
            if (cur_ancestor)
            {
                cur_ancestor->info = ancestor->parent->info;
            }

            ancestor = ancestor->parent->parent;

            if (ancestor && cur_ancestor)
            {
                cur_ancestor->next = RCP_MALLOC(rcp_menu_node_list_t *, sizeof(rcp_menu_node_list_t));
                cur_ancestor = cur_ancestor->next;
                if (cur_ancestor)
                {
                    cur_ancestor->info = NULL;
                    cur_ancestor->next = NULL;
                }
            }
        }

        /* build children list, filtering out nodes that aren't
         * available in the current filter group. */
        if (parent)
        {
            const rcp_menu_sibling_node_list_t * cur = parent->children;
            while (cur)
            {
                int in_filter = 0;

                if ((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK)
                {
                    if (cur->info->filter & RCP_MENU_NODE_FILTER_PLAYBACK_ONLY)
                    {
                        if (
                            cur->info->type != RCP_MENU_NODE_TYPE_BRANCH &&
                            cur->info->type != RCP_MENU_NODE_TYPE_NOT_YET_SUPPORTED_LEAF &&
                            cur->info->type != RCP_MENU_NODE_TYPE_CLIP_LIST_LEAF &&
                            cur->info->type != RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF
                           )
                        {
                            in_filter = rcp_get_is_supported(con, cur->info->param_id, NULL);
                        }
                        else if (
                                 !cur->info->is_supported_valid ||
                                 cur->info->is_supported
                                )
                        {
                            in_filter = 1;
                        }
                    }
                }
                else
                {
                    if (cur->info->filter & RCP_MENU_NODE_FILTER_RECORD_ONLY)
                    {
                        if (
                            cur->info->type != RCP_MENU_NODE_TYPE_BRANCH &&
                            cur->info->type != RCP_MENU_NODE_TYPE_NOT_YET_SUPPORTED_LEAF &&
                            cur->info->type != RCP_MENU_NODE_TYPE_CLIP_LIST_LEAF &&
                            cur->info->type != RCP_MENU_NODE_TYPE_KEY_MAPPING_LEAF
                           )
                        {
                            in_filter = rcp_get_is_supported(con, cur->info->param_id, NULL);
                        }
                        else if (
                                 !cur->info->is_supported_valid ||
                                 cur->info->is_supported
                                )
                        {
                            in_filter = 1;
                        }
                    }
                }

                if (in_filter)
                {
                    if (cur_child)
                    {
                        cur_child->info = cur->info;

                        /* If the title contains a '_' as its first
                         * character, that means we need to generate
                         * the title */
                        if (cur_child->info->title[0] == '_')
                        {
                            char * const fmt = _rcp_strdup(cur_child->info->title);
                            rcp_free(cur_child->info->title);
                            cur_child->info->title = _rcp_allocate_and_format_menu_title(con, fmt, cur_child->info->param_id);
                            if (!cur_child->info->title)
                            {
                                cur_child->info->title = _rcp_strdup("N/A");
                            }
                            rcp_free(fmt);
                        }
                    }
                }

                cur = cur->next;

                if (in_filter)
                {
                    if (cur && cur_child)
                    {
                        cur_child->next = RCP_MALLOC(rcp_menu_node_list_t *, sizeof(rcp_menu_node_list_t));
                        cur_child = cur_child->next;
                        if (cur_child)
                        {
                            cur_child->info = NULL;
                            cur_child->next = NULL;
                        }
                    }
                }
            }
        }

        /* call the application callback */
        con->cur_menu_cb(&data, con->cur_menu_cb_user_data);

        /* free up memory */
        if (data.children_list)
        {
            _rcp_menu_delete_list(con, data.children_list);
        }
        if (data.ancestor_list)
        {
            _rcp_menu_delete_list(con, data.ancestor_list);
        }
    }
}

void _rcp_menu_send_node_status(rcp_camera_connection_t * con, const rcp_menu_node_info_t * node)
{
    if (con && node && con->cur_menu_node_status_cb)
    {
        rcp_cur_menu_node_status_cb_data_t data;

        data.con = con;
        data.id = node->id;
        data.is_enabled = node->is_enabled;
        data.is_enabled_valid = node->is_enabled_valid;
        data.is_supported = node->is_supported;
        data.is_supported_valid = node->is_supported_valid;

        con->cur_menu_node_status_cb(&data, con->cur_menu_node_status_cb_user_data);
    }
}

RCP_API_PRIVATE void _rcp_menu_handle_playback_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->menu_last_sent_parent)
        {
            _rcp_menu_send_children(con, con->menu_last_sent_parent);
        }
    }
}

#endif

rcp_error_t rcp_menu_get_children(rcp_camera_connection_t * con, rcp_menu_node_id_t id)
{
#ifdef RCP_API_ENABLE_MENU
    _rcp_log_info(con, "getting children for menu node: %d\n", id);

    if (con)
    {
        if (rcp_menu_is_supported(con))
        {
            rcp_menu_parent_node_list_t * const parent = _rcp_menu_find_parent(con, id);

            if (parent)
            {
                /* If we already have the children for the given parent,
                 * send the results back now. */
                _rcp_menu_send_children(con, parent);
            }
            else
            {
                /* If we don't have the children for the given parent id we
                 * must request them from the camera.*/
                _rcp_create_get_with_int_arg_message(con, RCP2_CMD_GET_LIST, RCP_MENUTREE_MSG_MENU_TREE_CHILDREN, id);
            }
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_menu_get_node_status(rcp_camera_connection_t * con, rcp_menu_node_id_t id)
{
#ifdef RCP_API_ENABLE_MENU
    _rcp_log_info(con, "getting status for menu node: %d\n", id);

    if (con)
    {
        if (rcp_menu_node_status_is_supported(con))
        {
            const rcp_menu_sibling_node_list_t * const node = _rcp_menu_find_child(con, id);

            if (node && node->info->is_enabled_valid)
            {
                _rcp_menu_send_node_status(con, node->info);
            }
            else
            {
                /* If we don't have the status for the given id we
                 * must request it from the camera.*/
                _rcp_create_get_with_int_arg_message(con, RCP2_CMD_GET, RCP_MENUST_MSG_RCP_API_MENU_NODE_ENABLE, id);
            }
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
#else
    return RCP_SUCCESS;
#endif
}

int rcp_menu_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_MENU);
}

int rcp_menu_node_status_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_MENU_NODE_STATUS);
}

uint32_t rcp_menu_get_multi_action_list_leaf_flags(const rcp_camera_connection_t * con, int32_t data)
{
    uint32_t out = 0;

    out |= (uint32_t) 1 << (MULTI_ACTION_LIST_LEAF_ENABLE_MASK & (uint32_t) data);
    out |= (MULTI_ACTION_LIST_LEAF_PROPERTY_MASK & (uint32_t) data) << MULTI_ACTION_LIST_LEAF_PROPERTY_BIT_SHIFT;

    return out;
}
/********** End file: rcp_api_menu.c ********************************************/

/********** Begin file: rcp_api_notifications.c *********************************/
/* #include "rcp_api_notifications.h" */

/* #include "rcp_api.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_utils.h" */

/* #include "rcp_parser/rcp_parameter_types_public.h" */
//#ifdef __cplusplus
//extern "C" {
//#endif
#include <stdio.h>
#include <string.h>


#ifdef RCP_API_ENABLE_NOTIFICATIONS
static void _rcp_notification_send(rcp_camera_connection_t * con, rcp_notification_action_t action, const rcp_notification_t * notification);
static rcp_notification_list_t * _rcp_notification_find_by_id(const rcp_camera_connection_t * con, const char * id);
static rcp_notification_list_t * _rcp_notification_find_by_type(const rcp_camera_connection_t * con, int type);
static void _rcp_notification_set(const rcp_notification_list_t * entry, const char * id, const char * title, const char * message, notification_progress_t progress_type, uint8_t progress_percent, const char * response_list, int32_t timeout, int32_t type);
static void _rcp_notification_delete(rcp_notification_list_t * entry);
static void _rcp_notification_add(rcp_camera_connection_t * con, const char * id, const char * title, const char * message, notification_progress_t progress_type, uint8_t progress_percent, const char * response_list, int32_t timeout, int32_t type);
static void _rcp_notification_update(rcp_camera_connection_t * con, const rcp_notification_list_t * found, const char * id, const char * title, const char * message, notification_progress_t progress_type, uint8_t progress_percent, const char * response_list, int32_t timeout, int32_t type);
static void _rcp_create_set_notifyr_message(rcp_camera_connection_t * con, const char * id, int32_t val);

/* create RCP message for SET NOTIFYR and send to camera */
static void _rcp_create_set_notifyr_message(rcp_camera_connection_t * con, const char * id, int32_t val)
{
    if (con)
    {
        char val_str[RCP_STR_LEN_FOR_INT32];
        snprintf(val_str, sizeof(val_str), "%d", val);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_NOTIFYR_MSG_NOTIFICATION_RESPONSE_PTR, 2, id, val_str))
        {
            _rcp_log_error(con, "cannot create notification response packet\n");
        }
    }
}

RCP_API_PRIVATE rcp_error_t _rcp_notification_get(rcp_camera_connection_t * con)
{
    if (con)
    {
        if (con->notification_list)
        {
            _rcp_notification_send(con, NOTIFICATION_ACTION_OPEN, con->notification_list->info);
        }
    }

    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_notification_timeout(rcp_camera_connection_t * con, const char * id)
{
    if (con)
    {
        if (con->notification_list)
        {
            if (con->notification_list->info)
            {
                if (strcmp(con->notification_list->info->id, id) == 0)
                {
                    /* this call is only valid for timeout based
                     * notifications */
                    if (con->notification_list->info->timeout)
                    {
                        _rcp_notification_remove(con, con->notification_list);
                    }
                }
            }
        }
    }

    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_notification_response(rcp_camera_connection_t * con, const char * id, int32_t response)
{
    if (con)
    {
        if (con->notification_list)
        {
            if (con->notification_list->info)
            {
                if (strcmp(con->notification_list->info->id, id) == 0)
                {
                    _rcp_create_set_notifyr_message(con, con->notification_list->info->id, response);
                }
            }
        }
    }

    return RCP_SUCCESS;
}

static void _rcp_notification_send(rcp_camera_connection_t * con, rcp_notification_action_t action, const rcp_notification_t * notification)
{
    if (con)
    {
        if (con->notification_cb)
        {
            rcp_notification_cb_data_t data;

            data.con = con;
            data.action = action;
            data.notification = notification;
            con->notification_cb(&data, con->notification_cb_user_data);
        }
    }
}

static rcp_notification_list_t * _rcp_notification_find_by_id(const rcp_camera_connection_t * con, const char * id)
{
    if (con)
    {
        rcp_notification_list_t * cur = con->notification_list;

        while (cur)
        {
            if (cur->info)
            {
                if (strcmp(cur->info->id, id) == 0)
                {
                    break;
                }
            }

            cur = cur->next;
        }

        return cur;
    }

    return NULL;
}

static rcp_notification_list_t * _rcp_notification_find_by_type(const rcp_camera_connection_t * con, int type)
{
    if (con)
    {
        rcp_notification_list_t * cur = con->notification_list;

        while (cur)
        {
            if (cur->info)
            {
                if (cur->info->type == type)
                {
                    break;
                }
            }

            cur = cur->next;
        }

        return cur;
    }

    return NULL;
}

static void _rcp_notification_set(const rcp_notification_list_t * entry,
                                  const char * id,
                                  const char * title,
                                  const char * message,
                                  notification_progress_t progress_type,
                                  uint8_t progress_percent,
                                  const char * response_list,
                                  int32_t timeout,
                                  int32_t type)
{
    if (entry && entry->info)
    {
        entry->info->id = _rcp_strdup(id);
        entry->info->title = _rcp_strdup(title);
        entry->info->message = _rcp_strdup(message);
        entry->info->progress_type = progress_type;
        entry->info->progress_percent = progress_percent;
        entry->info->response_list = _rcp_strdup(response_list);
        entry->info->timeout = timeout;
        entry->info->type = type;
    }
}

static void _rcp_notification_delete(rcp_notification_list_t * entry)
{
    if (entry)
    {
        if (entry->info)
        {
            if (entry->info->id)
            {
                rcp_free(entry->info->id);
            }

            if (entry->info->title)
            {
                rcp_free(entry->info->title);
            }

            if (entry->info->message)
            {
                rcp_free(entry->info->message);
            }

            if (entry->info->response_list)
            {
                rcp_free(entry->info->response_list);
            }

            rcp_free(entry->info);
        }

        rcp_free(entry);
    }
}

RCP_API_PRIVATE void _rcp_notification_remove(rcp_camera_connection_t * con, rcp_notification_list_t * entry)
{
    if (con && entry)
    {
        int was_active = 0;
        if (con->notification_list == entry)
        {
            was_active = 1;
            _rcp_notification_send(con, NOTIFICATION_ACTION_CLOSE, con->notification_list->info);
            con->notification_list = entry->next;
        }
        else
        {
            if (entry->prev)
            {
                entry->prev->next = entry->next;
            }

            if (entry->next)
            {
                entry->next->prev = entry->prev;
            }
        }

        _rcp_notification_delete(entry);

        if (con->notification_list && was_active)
        {
            _rcp_notification_send(con, NOTIFICATION_ACTION_OPEN, con->notification_list->info);
        }
    }
}

static void _rcp_notification_add(rcp_camera_connection_t * con,
                                  const char * id,
                                  const char * title,
                                  const char * message,
                                  notification_progress_t progress_type,
                                  uint8_t progress_percent,
                                  const char * response_list,
                                  int32_t timeout,
                                  int32_t type)
{
    if (con)
    {
        /* we only want to keep track of notifications if the user has a
         * callback registered - otherwise timeout notificaitons won't
         * be cleared out and will create a memory leak. */
        if (con->notification_cb)
        {
            int send_open = 0;
            rcp_notification_list_t * cur = NULL;

            if (!con->notification_list)
            {
                con->notification_list = RCP_MALLOC(rcp_notification_list_t *, sizeof(rcp_notification_list_t));
                cur = con->notification_list;

                if (cur)
                {
                    cur->next = NULL;
                    cur->prev = NULL;
                }

                send_open = 1;
            }
            else
            {
                /* find last entry in linked list */
                rcp_notification_list_t * last = cur;
                cur = con->notification_list;

                while (cur)
                {
                    last = cur;
                    cur = cur->next;
                }

                /* add entry to end of list */
                if (last)
                {
                    last->next = RCP_MALLOC(rcp_notification_list_t *, sizeof(rcp_notification_list_t));
                    cur = last->next;
                }

                if (cur)
                {
                    cur->next = NULL;
                    cur->prev = last;
                }
            }

            if (cur)
            {
                cur->info = RCP_MALLOC(rcp_notification_t *, sizeof(rcp_notification_t));
                if (cur->info)
                {
                    cur->info->title = NULL;
                    cur->info->message = NULL;
                    cur->info->response_list = NULL;

                    _rcp_notification_set(cur, id, title, message, progress_type, progress_percent, response_list, timeout, type);
                }

                if (send_open)
                {
                    _rcp_notification_send(con, NOTIFICATION_ACTION_OPEN, cur->info);
                }
            }
        }
    }
}

static void _rcp_notification_update(rcp_camera_connection_t * con,
                                     const rcp_notification_list_t * found,
                                     const char * id,
                                     const char * title,
                                     const char * message,
                                     notification_progress_t progress_type,
                                     uint8_t progress_percent,
                                     const char * response_list,
                                     int32_t timeout,
                                     int32_t type)
{
    if (con && found && found->info)
    {
        if (found->info->id)
        {
            rcp_free(found->info->id);
        }

        if (found->info->title)
        {
            rcp_free(found->info->title);
        }

        if (found->info->message)
        {
            rcp_free(found->info->message);
        }

        if (found->info->response_list)
        {
            rcp_free(found->info->response_list);
        }

        _rcp_notification_set(found, id, title, message, progress_type, progress_percent, response_list, timeout, type);

        if (found == con->notification_list)
        {
            _rcp_notification_send(con, NOTIFICATION_ACTION_UPDATE, found->info);
        }
    }
}

RCP_API_PRIVATE void _rcp_process_packet_notification(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        if (packet->argc == 1)
        {
            const char * const id = packet->argv[0];
            if (id[0] == 0)
            {
                /* an empty id string indicates there are no active notifications; nothing to do here. */
            }
            else
            {
                rcp_notification_list_t * const found = _rcp_notification_find_by_id(con, id);
                if (found)
                {
                    _rcp_notification_remove(con, found);
                }
            }
        }
        else
        {
            const char * const id = packet->argv[0];
            const char * const title = packet->argv[1];
            const char * const message = packet->argv[2];
            const notification_progress_t progress_type = (notification_progress_t) atoi(packet->argv[3]);
            const uint8_t progress_percent = (uint8_t) atoi(packet->argv[4]);
            const char * const response_list = packet->argv[5];
            const int32_t timeout = (int32_t) atoi(packet->argv[6]);
            const int32_t type = atoi(packet->argv[7]);

            const rcp_notification_list_t * const found = _rcp_notification_find_by_id(con, id);
            if (found)
            {
                /* this is an update to an existing notification */
                _rcp_notification_update(con, found, id, title, message, progress_type, progress_percent, response_list, timeout, type);
            }
            else
            {
                if (timeout && _rcp_notification_find_by_type(con, type))
                {
                    /* this is a timeout based notification and we
                     * already have one of the same type in the
                     * notification list - throw this one out. */
                }
                else
                {
                    _rcp_notification_add(con, id, title, message, progress_type, progress_percent, response_list, timeout, type);
                }
            }
        }
    }
}

#endif

rcp_error_t rcp_notification_get(rcp_camera_connection_t * con)
{
#ifdef RCP_API_ENABLE_NOTIFICATIONS
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "notification get\n");
    err = _rcp_notification_get(con);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_notification_timeout(rcp_camera_connection_t * con, const char * id)
{
#ifdef RCP_API_ENABLE_NOTIFICATIONS
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "notification timeout: %s\n", id);
    err = _rcp_notification_timeout(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_notification_response(rcp_camera_connection_t * con, const char * id, int32_t response)
{
#ifdef RCP_API_ENABLE_NOTIFICATIONS
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "notification response: %s:%d\n", id, response);
    err = _rcp_notification_response(con, id, response);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}
/********** End file: rcp_api_notifications.c ***********************************/

/********** Begin file: rcp_api_packet.c ****************************************/
/* #include "rcp_api_packet.h" */

/* #include "rcp_api_log.h" */
/* #include "rcp_api_uuid.h" */

/* #include "rcp_parser/rcp_parser2.h" */
#include <stdarg.h>

RCP_API_PRIVATE rcp_error_t _rcp_create_and_send_packet(rcp_camera_connection_t * con, char cmd, const char * param, size_t count, ...)
{
    if (con)
    {
        char buf[RCP_API_OUTGOING_PACKET_BUFFER_SIZE];
        size_t len = 0;
        tRCP rcpBuffer;
        va_list arg_list;
        size_t ii;

        if (RCP2_PARSER_OK != RCP_buildHeader(&rcpBuffer, buf, sizeof(buf), RCP_API_SOURCE_NAME, "", cmd))
        {
            _rcp_log_error(con, "cannot create RCP packet header\n");
            return RCP_ERROR_INTERNAL;
        }

        if (RCP2_PARSER_OK != RCP_addToken(&rcpBuffer, param))
        {
            _rcp_log_error(con, "cannot add parameter to RCP packet\n");
            return RCP_ERROR_INTERNAL;
        }

        va_start(arg_list, count);
        for (ii = 0; ii < count; ii++)
        {
            if (RCP2_PARSER_OK != RCP_addToken(&rcpBuffer, va_arg(arg_list, const char *)))
            {
                _rcp_log_error(con, "cannot add parameter to RCP packet\n");
                return RCP_ERROR_INTERNAL;
            }
        }
        va_end(arg_list);

        if (RCP2_PARSER_OK != RCP_addChecksum(&rcpBuffer))
        {
            _rcp_log_error(con, "cannot add checksum to RCP packet\n");
            return RCP_ERROR_INTERNAL;
        }

        len = RCP_finalizeMessage(&rcpBuffer);

        _rcp_connection_send_packet(con, buf, len);
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}
/********** End file: rcp_api_packet.c ******************************************/

/********** Begin file: rcp_api_parameters.c ************************************/
/* #include "rcp_api_parameters.h" */

/* #include "rcp_api_audio_vu.h" */
/* #include "rcp_api_auto_gen_tables.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_get_list.h" */
/* #include "rcp_api_get_status.h" */
/* #include "rcp_api_hw_cap.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_send_current.h" */
/* #include "rcp_api_set_int.h" */
/* #include "rcp_api_set_uint.h" */
/* #include "rcp_api_set_str.h" */
/* #include "rcp_api_utils.h" */

/* #include "decorated_string/decorated_string.h" */
/* #include "rcp_parser/rcp_parameter_types_public.h" */
/* #include "rcp_parser/rcp_parser2.h" */
/* #include "stringl/stringl.h" */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>

typedef enum
{
    POWER_IN_VOLTAGE,
    POWER_IN_PERCENT,
    POWER_IN_TIME_REMAINING,
    POWER_IN_ALL
} power_in_display_t;

static void _rcp_create_iso_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_playback_metadata_iso_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_redcode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_file_format_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_nd_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_sensor_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_project_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_qt_encode_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_aperture_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_integration_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_cal_integration_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_color_temp_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_fixed_point_3_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_timecode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_focus_dist_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_focal_length_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_angle_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_gamma_space_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_color_space_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_output_transform_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_core_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_fanspeed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_media_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_media_percent_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_media_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_display_string_indexed_power_in(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_display_string_non_indexed_power_in(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_media_display_label_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_exposure_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_gyro_angle_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_calibration_status_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_calibration_status_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_calibration_status_exposure_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_int_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_clip_name_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_format_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_ipaddress_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_timecode_offset_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_hdr_mode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_hdr_mode_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_timecode_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_timecode_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_magnify_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_false_color_mode_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_gige_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_gige_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_rig_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_rig_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_sync_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_sync_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_genlock_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_genlock_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_wifi_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_wifi_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_fiz_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_fiz_state_string_detailed(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_redmote_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_date_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_clips_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_metadata_date_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_metadata_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_runtime_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_hdr_factor_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_media_size_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_wifi_rssi_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_out_status_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_in_out_current_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_quality_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_prores_dimension_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_mxf_dimension_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_mxf_compression_id_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_sensor_physical_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_format_physical_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_format_pixel_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_list_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_fixed_point_5_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_in_voltage_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_in_percent_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_create_power_in_runtime_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status);
static void _rcp_indexed_power_in_status_voltage(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index);
static void _rcp_indexed_power_in_status_percent(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index);
static void _rcp_indexed_power_in_status_time_remaining(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index);
static void _rcp_indexed_power_in_status(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index, power_in_display_t power_in_display);

static void _rcp_create_status_aperture(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_exposure_display(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_focus(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_fan_record_speed(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_fan_preview_speed(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_fan_delay(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_fan_target_temperature(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_color_space(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_gamma_space(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_monitor_overlay(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_video_flip(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_monitor_enable(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_monitor_curve(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_metadata_curve(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_set_timecode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_guide_normal_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_guide_user_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_guide_abs_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_guide_line_attributes(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_enhanced_af(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ae_mode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ae(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_beeps(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_frame_processing(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_gige_addresses(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_audio_48v(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_audio_limiter(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_slate_take_shot(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_record_limit_enable(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_record_limit_frames(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_record_timer_settings(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_record_prepost_settings(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_record_ramp_settings(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_zebra(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_hdr(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_hdr_mode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_target_id(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ch12_gain(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ch34_gain(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ch1_vol(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ch2_vol(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_flip_mirror(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ui_flip_mirror(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_attached(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_present(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_gio_scope(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_af_zone(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_af_size(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_af_window_move(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_rack(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_presets(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_presets_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_presets_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_looks(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_looks_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_looks_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_overlays(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_overlays_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_overlays_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_luts(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_luts_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_luts_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_cal_files(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_cal_files_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_cal_files_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_discovered_redmotes(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_paired_redmotes(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_color_temp(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_video_codec(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_video_mxf_codec(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_video_codec_any(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_voltage_threshold(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_voltage_threshold_dc_in(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_redcode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_remote_control_panel(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_ad_hoc(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_ad_hoc_pw(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_pw(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_connected(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_connect(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_scan(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_select(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_wifi_infra_addresses(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_power_out_reset(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_power_out_current(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_power_out_status(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_third_pary_olpf(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_audio_channel_mode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_bwf_enable(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_tc_channel(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_cdls(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_camera_cdls_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_media_cdls_media(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_side_ui_auto_home_timeout(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_uhd_monitor(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_power_in_present(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_pre_record(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_not_external_record(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_ipp2_output_options(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_lookaround(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_drop_frame_display_mode(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_output_color_space(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_cdl(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_status_lut_feed_1(rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_create_label_power_in(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_power_out(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_monitor(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_monitor_mux(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_side_ui(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_lut_feed_1(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_gamma_space(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_label_r3d_metadata_curve(rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_create_hdr_mode_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_record_state_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_exposure_display_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_metadata_date_time_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_min_record_codec_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_min_record_mxf_codec_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_format_phy_width_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_format_phy_height_int(rcp_camera_connection_t * con, rcp_param_t id);
static void _rcp_create_dropped_frames_int(rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_create_edit_info_pw(rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_create_exposure_display_list(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_t id_incoming);

static void _rcp_set_int_exposure_display(rcp_camera_connection_t * con, rcp_param_t id, int32_t val);

static int _rcp_check_parameter_status_dependencies(rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_handle_has_list_exceptions(const rcp_camera_connection_t * con, rcp_param_t id, rcp_param_properties_t * properties);

static int _rcp_monitor_is_enabled(rcp_camera_connection_t * con, rcp_param_t id);

static int _rcp_monitor_is_enhanced_af(const rcp_camera_connection_t * con, rcp_param_t rcp_param);

static monitor_t _rcp_get_monitor(rcp_param_t rcp_param);

static int _rcp_get_string_from_list(const rcp_camera_connection_t * con, rcp_param_t id, char * dest, size_t dest_size);
static int _rcp_get_string_from_list_by_value(const rcp_camera_connection_t * con, rcp_param_t id, int value, char * dest, size_t dest_size);

static size_t _rcp_get_size_of_list(const rcp_camera_connection_t * con, rcp_param_t id);

static void _rcp_get_video_codec_string(video_codec_t video_codec, int mxf_compression_id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size);

static void _rcp_get_mxf_compression_id_family_string(int id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size);
static void _rcp_get_mxf_compression_id_string(int id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size);

static int _rcp_get_monitor_list_entry(rcp_camera_connection_t * con, monitor_t monitor_id, c_list_entry_t * e);

static void _rcp_get_format_dimensions_string(char * buf, size_t buf_size, int width, int height, int sigfigs, float divider, const char * suffix, int abbr);

typedef struct
{
    rcp_param_t source;
    rcp_param_t target;
} rcp_dependency_t;

/* *INDENT-OFF* */
                                                                            /*  version range,     min,       max,      div, dig, step,       prefix, prefix,        suffix,    suffix*/
static const rcp_cur_int_edit_info_t _rcp_edit_info_nd_val =                {VER_RANGE_NONE(),     160,       400,      100,   2,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_sensor_fps =            {VER_RANGE_NONE(),       0,    999999,     1001,   3,    1,         NULL,   NULL,    "&redfps;",    " FPS"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_aperture =              {VER_RANGE_NONE(),       0,       999,       10,   1,    1, "&redfover;",   "f/",          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_int_time =              {VER_RANGE_NONE(),    1000, 999999999,     1000,   0, 1000, "&red1over;",   "1/",          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_color_temp =            {VER_RANGE_NONE(),    1700,    100000,        1,   0,    1,         NULL,   NULL, "&redkelvin;",       "K"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_contrast   =            {VER_RANGE_NONE(),   -1000,      1000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_saturation =            {VER_RANGE_NONE(),       0,      4000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_brightness =            {VER_RANGE_NONE(),  -10000,     10000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_exp_comp =              {VER_RANGE_NONE(),   -7000,      7000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_rgb_gain =              {VER_RANGE_NONE(),       0,     10000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_flut =                  {VER_RANGE_NONE(),   -8000,      8000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_shadow =                {VER_RANGE_NONE(),   -2000,      2000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_shutter_angle =         {VER_RANGE_NONE(),       0,    360000,     1000,   1,    1,         NULL,   NULL,       "&deg;",      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_tint =                  {VER_RANGE_NONE(), -100000,    100000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_fan_speed =             {VER_RANGE_NONE(),       0,       100,        1,   0,    1,         NULL,   NULL,           "%",       "%"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_ire =                   {VER_RANGE_NONE(),       1,       100,        1,   0,    1,         NULL,   NULL,        " IRE",    " IRE"};
static const rcp_cur_uint_edit_info_t _rcp_edit_info_hc =                   {VER_RANGE_NONE(),       0,     65535,        1,   0,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_target_temp =           {VER_RANGE_NONE(),       0,        99,        1,   0,    1,         NULL,   NULL,      "&deg;C",      " C"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_frame_scale =           {VER_RANGE_NONE(),       0,     10000,      100,   2,    1,         NULL,   NULL,           "%",       "%"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_frame_offset =          {VER_RANGE_NONE(),  -10000,     10000,      100,   2,    1,         NULL,   NULL,           "%",       "%"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_frame_ar_num =          {VER_RANGE_NONE(),       1,   1000000,    10000,   4,    1,         NULL,   NULL,          ":1",      ":1"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_frame_abs_offset =      {VER_RANGE_NONE(),   -9999,      9999,        1,   0,    1,         NULL,   NULL,          "px",      "px"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_frame_abs_dim =         {VER_RANGE_NONE(),       0,      9999,        1,   0,    1,         NULL,   NULL,          "px",      "px"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_ae_ev_shift =           {VER_RANGE_NONE(),     -40,        28,       10,   1,    2,         NULL,   NULL,         " EV",     " EV"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_lgg_lift =              {VER_RANGE_NONE(),   -1000,      1000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_lgg_gamma =             {VER_RANGE_NONE(),       0,      4000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_lgg_gain =              {VER_RANGE_NONE(),       0,      2000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_slate_take =            {VER_RANGE_NONE(),       1,       999,        1,   0,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_uint_edit_info_t _rcp_edit_info_limit_frames =         {VER_RANGE_NONE(),       1,  10000000,        1,   0,    1,         NULL,   NULL,     " frames", " frames"};
static const rcp_cur_uint_edit_info_t _rcp_edit_info_prepost_frames =       {VER_RANGE_NONE(),       0,      2048,        1,   0,    1,         NULL,   NULL,     " frames", " frames"};
static const rcp_cur_uint_edit_info_t _rcp_edit_info_tl_frames =            {VER_RANGE_NONE(),       1,      1024,        1,   0,    1,         NULL,   NULL,     " frames", " frames"};
static const rcp_cur_uint_edit_info_t _rcp_edit_info_tl_interval =          {VER_RANGE_NONE(),       0,    360000,      100,   2,    1,         NULL,   NULL,        " sec",     "sec"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_reel_no =               {VER_RANGE_NONE(),       1,       999,        1,   0,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_user_matrix =           {VER_RANGE_NONE(),   -2000,      2000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_auto_slate_frames =     {VER_RANGE_NONE(),       0,       255,        1,   0,    1,         NULL,   NULL,     " frames", " frames"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_curve_component =       {VER_RANGE_NONE(),       0,      1000,     1000,   3,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_ramp_fps =              {VER_RANGE_NONE(),       0,    999999,     1001,   3,    1,         NULL,   NULL,    "&redfps;",    " FPS"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_ramp_duration =         {VER_RANGE_NONE(),       0,       120,        1,   0,    1,         NULL,   NULL,        " sec",    " sec"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_rack_speed =            {VER_RANGE_NONE(),       1,        50,        1,   0,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_genlock_offset =        {VER_RANGE_NONE(),   -8000,      8000,        1,   0,    1,         NULL,   NULL,     " pixels", " pixels"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_mixer_volume =          {VER_RANGE_NONE(),       0,       100,        1,   0,    1,         NULL,   NULL,           "%",       "%"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_mixer_pan =             {VER_RANGE_NONE(),    -100,       100,        1,   0,    1,         NULL,   NULL,          NULL,      NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_audio_gain_db =         {VER_MIN(6, 20),      -100,       100,        1,   0,    1,         NULL,   NULL,          " dB",    " dB"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_audio_vol_db =          {VER_MIN(6, 20),      -100,       100,        1,   0,    1,         NULL,   NULL,          " dB",    " dB"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_overdrive_fps =         {VER_RANGE_NONE(),       0,     12012,     1001,   3,    1,         NULL,   NULL,     "&redfps;",    "FPS"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_stops =                 {VER_RANGE_NONE(),       0,      1600,      100,   2,   10,         NULL,   NULL,       " stops", " stops"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_lens_focal_length =     {VER_RANGE_NONE(),       0,     65535,        1,   0,    1,         NULL,   NULL,           NULL,     NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_cdl_saturation =        {VER_RANGE_NONE(),       0,    400000,   100000,   5,    1,         NULL,   NULL,           NULL,     NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_cdl_offset =            {VER_RANGE_NONE(), -100000,    100000,   100000,   5,    1,         NULL,   NULL,           NULL,     NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_cdl_power =             {VER_RANGE_NONE(),       0,    400000,   100000,   5,    1,         NULL,   NULL,           NULL,     NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_cdl_slope =             {VER_RANGE_NONE(),       0,    200000,   100000,   5,    1,         NULL,   NULL,           NULL,     NULL};
static const rcp_cur_int_edit_info_t _rcp_edit_info_voltage_threshold =     {VER_RANGE_NONE(),   11500,     17000,     1000,   1,  100,         NULL,   NULL,            "V",      "V"};
static const rcp_cur_int_edit_info_t _rcp_edit_info_voltage_threshold_dc_in={VER_RANGE_NONE(),   11500,     32000,     1000,   1,  100,         NULL,   NULL,            "V",      "V"};
                                                                            /*  version range, min, max, pw,   allowed chars,                    prefix, prefix, suffix, suffix*/
static const rcp_cur_str_edit_info_t _rcp_edit_info_slate_data =            {VER_RANGE_NONE(),   0, 254,  0,   ALLOWED_NAME_CHARS,                 NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_slate_scene =           {VER_RANGE_NONE(),   0,   8,  0,   ALLOWED_SCENE_CHARS,                NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_slate_shot =            {VER_RANGE_NONE(),   0,   1,  0,   ALLOWED_SHOT_CHARS,                 NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_audio_channel =         {VER_RANGE_NONE(),   0,   6,  0,   ALLOWED_AUDIO_CHANNEL_CHARS,        NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_comm_name_scene =       {VER_RANGE_NONE(),   0,   8,  0,   ALLOWED_COMM_NAME_CHARS,            NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_ip_or_host =            {VER_RANGE_NONE(),   0, 254,  0,   ALLOWED_HOST_IP_CHARS,              NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_ssid =                  {VER_RANGE_NONE(),   0,  32,  0,   ALLOWED_SSID_CHARS,                 NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_wep_pw =                {VER_RANGE_NONE(),  10,  10,  1,   ALLOWED_WEP_PW_CHARS,               NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_wpa_pw =                {VER_RANGE_NONE(),   8,  63,  1,   ALLOWED_WPA_PW_CHARS,               NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_lens_name =             {VER_RANGE_NONE(),   0, 254,  0,   ALLOWED_LENS_NAME_CHARS,            NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_info_lens_serial =           {VER_RANGE_NONE(),   0, 254,  0,   ALLOWED_LENS_SERIAL_CHARS,          NULL,   NULL,   NULL,   NULL};
static const rcp_cur_str_edit_info_t _rcp_edit_olpf_third_party_name =      {VER_RANGE_NONE(),   0, 254,  0,   ALLOWED_NAME_CHARS,                 NULL,   NULL,   NULL,   NULL};

/* RCP Parameter strings needed for backwards compatibility - they are
 * no longer in the current rcp_parameter_types_public.h header file. */
#define RCP_WLANSCRL_MSG_STR_PTR "WLANSCRL"             /* the SET command was removed for RCP_PARAM_WIFI_SCAN_RESULTS in parameter set version 6.30 */
#define RCP_ACES_MSG_INT "ACES"                         /* RCP_PARAM_ACES_PROXY was removed in parameter set version 6.32 */
#define RCP_MMSHCOLR_MSG_UINT "MMSHCOLR"                /* RCP_PARAM_MM_SHUTTER_COLOR was removed in parameter set version 6.33 */
#define RCP_MMSHTIME_MSG_UINT "MMSHTIME"                /* RCP_PARAM_MM_INTEGRATION_TIME was removed in parameter set version 6.33 */
#define RCP_MMSHANGL_MSG_UINT "MMSHANGL"                /* RCP_PARAM_MM_SHUTTER_ANGLE was removed in parameter set version 6.33 */
#define RCP_TCSET_MSG_INT "TCSET"                       /* RCP_PARAM_SET_TIMECODE was removed in parameter set version 6.50 */
#define RCP_VIDEOSRC_MSG_INT "VIDEOSRC"                 /* RCP_PARAM_VIDEO_SOURCE was removed in parameter set version 6.50 */
#define RCP_VIDEOSRC_MSG_LIST_PTR "VIDEOSRC"            /* RCP_PARAM_VIDEO_SOURCE was removed in parameter set version 6.50 */
#define RCP_LCDCV_MSG_INT "LCDCV"                       /* RCP_PARAM_MONITOR_CURVE_LCD was removed in parameter set version 6.50 */
#define RCP_LCDCV_MSG_LIST_PTR "LCDCV"                  /* RCP_PARAM_MONITOR_CURVE_LCD was removed in parameter set version 6.50 */
#define RCP_HDMICV_MSG_INT "HDMICV"                     /* RCP_PARAM_MONITOR_CURVE_HDMI was removed in parameter set version 6.50 */
#define RCP_HDMICV_MSG_LIST_PTR "HDMICV"                /* RCP_PARAM_MONITOR_CURVE_HDMI was removed in parameter set version 6.50 */
#define RCP_HDSDICV_MSG_INT "HDSDICV"                   /* RCP_PARAM_MONITOR_CURVE_HDSDI was removed in parameter set version 6.50 */
#define RCP_HDSDICV_MSG_LIST_PTR "HDSDICV"              /* RCP_PARAM_MONITOR_CURVE_HDSDI was removed in parameter set version 6.50 */
#define RCP_EVFCV_MSG_INT "EVFCV"                       /* RCP_PARAM_MONITOR_CURVE_EVF was removed in parameter set version 6.50 */
#define RCP_EVFCV_MSG_LIST_PTR "EVFCV"                  /* RCP_PARAM_MONITOR_CURVE_EVF was removed in parameter set version 6.50 */
#define RCP_PLCDCV_MSG_INT "PLCDCV"                     /* RCP_PARAM_MONITOR_CURVE_REAR_LCD was removed in parameter set version 6.50 */
#define RCP_PLCDCV_MSG_LIST_PTR "PLCDCV"                /* RCP_PARAM_MONITOR_CURVE_REAR_LCD was removed in parameter set version 6.50 */
#define RCP_PHDSD1CV_MSG_INT "PHDSD1CV"                 /* RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1 was removed in parameter set version 6.50 */
#define RCP_PHDSD1CV_MSG_LIST_PTR "PHDSD1CV"            /* RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1 was removed in parameter set version 6.50 */
#define RCP_PHDSD2CV_MSG_INT "PHDSD2CV"                 /* RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2 was removed in parameter set version 6.50 */
#define RCP_PHDSD2CV_MSG_LIST_PTR "PHDSD2CV"            /* RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2 was removed in parameter set version 6.50 */
#define RCP_REVFCV_MSG_INT "REVFCV"                     /* RCP_PARAM_MONITOR_CURVE_REAR_EVF was removed in parameter set version 6.50 */
#define RCP_REVFCV_MSG_LIST_PTR "REVFCV"                /* RCP_PARAM_MONITOR_CURVE_REAR_EVF was removed in parameter set version 6.50 */
#define RCP_LCD3CV_MSG_INT "LCD3CV"                     /* RCP_PARAM_MONITOR_CURVE_LCD3 was removed in parameter set version 6.50 */
#define RCP_LCD3CV_MSG_LIST_PTR "LCD3CV"                /* RCP_PARAM_MONITOR_CURVE_LCD3 was removed in parameter set version 6.50 */
#define RCP_EVF3CV_MSG_INT "EVF3CV"                     /* RCP_PARAM_MONITOR_CURVE_EVF3 was removed in parameter set version 6.50 */
#define RCP_EVF3CV_MSG_LIST_PTR "EVF3CV"                /* RCP_PARAM_MONITOR_CURVE_EVF3 was removed in parameter set version 6.50 */
#define RCP_PORXAE_MSG_INT "PORXAE"                     /* RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE was removed in parameter set version 6.50 */
#define RCP_PORXAS_MSG_INT "PORXAS"                     /* RCP_PARAM_POWER_OUT_REAR_AUX_STATUS was removed in parameter set version 6.50 */
#define RCP_PORXAR "PORXAR"                             /* RCP_PARAM_POWER_OUT_REAR_AUX_RESET was removed in parameter set version 6.50 */
#define RCP_PORXAC_MSG_INT "PORXAC"                     /* RCP_PARAM_POWER_OUT_REAR_AUX_CURRENT was removed in parameter set version 6.50 */
#define RCP_POJPUE_MSG_INT "POJPUE"                     /* RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE was removed in parameter set version 6.50 */
#define RCP_POJPUS_MSG_INT "POJPUS"                     /* RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS was removed in parameter set version 6.50 */
#define RCP_POJPUR "POJPUR"                             /* RCP_PARAM_POWER_OUT_JETPACK_USB_RESET was removed in parameter set version 6.50 */
#define RCP_BLCDVF_MSG_INT "BLCDVF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_LCD was removed in parameter set version 6.50 */
#define RCP_BEVFVF_MSG_INT "BEVFVF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_EVF was removed in parameter set version 6.50 */
#define RCP_BHDMIVF_MSG_INT "BHDMIVF"                   /* RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI was removed in parameter set version 6.50 */
#define RCP_BHDSDIVF_MSG_INT "BHDSDIVF"                 /* RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI was removed in parameter set version 6.50 */
#define RCP_LCD3VF_MSG_INT "LCD3VF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3 was removed in parameter set version 6.50 */
#define RCP_EVF3VF_MSG_INT "EVF3VF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3 was removed in parameter set version 6.50 */
#define RCP_PLCDVF_MSG_INT "PLCDVF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD was removed in parameter set version 6.50 */
#define RCP_PSDI1VF_MSG_INT "PSDI1VF"                   /* RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1 was removed in parameter set version 6.50 */
#define RCP_PSDI2VF_MSG_INT "PSDI2VF"                   /* RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2 was removed in parameter set version 6.50 */
#define RCP_REVFVF_MSG_INT "REVFVF"                     /* RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF was removed in parameter set version 6.50 */
#define RCP_VLTBLWTH_MSG_INT "VLTBLWTH"                 /* RCP_PARAM_VOLTAGE_BELOW_THRESHOLD was removed in parameter set version 6.61 */
const rcp_param_def_t _rcp_param_def[RCP_PARAM_COUNT] =
{
    /* Table describing each parameter in detail.
     * NOTE: any changes to this table require that
     * rcp_api_parameters_hash_table.c be regenerated*/

    /* ID                                                                                             Parameter Version Range        Set Version Range Label                                                  Set Type       Current Type            Cacheable       S/G/C/I Message                                         Set Relative and Version Range                  Set List Relative and Version Range                      S/G/C Target Message and Version Range                S/G/C/ List Messages                           Min Value for List                                   Max Value for List                                   Create String FP                                   Create Int FP                       Create List FP                        Set Int FP                     Create Status FP                              Edit Info                                    Update List When       Globals Disables                    Color Science        Hardware Capabilities */
    {PARAM_NOR(RCP_PARAM_HISTOGRAM),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Histogram"),                                    RCP_TYPE_NULL, RCP_TYPE_HIST,          CACHE_VAL,      RCP_IC(RCP_DSHIST_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_VU_DATA),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio VU Data"),                                RCP_TYPE_NULL, RCP_TYPE_AUDIOVU,       CACHE_VAL,      RCP_IC(RCP_AUDIOVU_MSG_AUDIO_VU_DATA),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PITCH),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera Pitch"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_IC(RCP_MPITCH_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_gyro_angle_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_ROLL),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera Roll"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_IC(RCP_MROLL_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_gyro_angle_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_VAL),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power Level"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWRBATL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_TIME_REMAINING),                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power Time"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_BATTRTM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_SPEED_TOP),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan Speed: 2"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FANPCTT_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fanspeed_string,                       NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_DISABLED,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_SPEED_FRONT),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan Speed: 1"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FANPCTF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fanspeed_string,                       NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_DISABLED,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CORE_TEMP),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Temperature: Core"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CURRTEMP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_core_temperature_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_DISABLED,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_TEMP),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Temperature: Sensor"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CURSENST_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_temperature_string,                    NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_DISABLED,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TIMECODE),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Timecode"),                                     RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_C(RCP_POSTTC_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_timecode_string,                       NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ISO),                                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("ISO"),                                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ISO_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_ISO_MSG_LIST_REL, VER_MIN(6, 1)),       RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ISO_MSG_LIST_PTR),             RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_iso_string,                            NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_REDCODE),                                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("REDCODE&reg;"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_REDCODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_REDCODE_MSG_LIST_REL, VER_MIN(6, 1)),   RCP_TGT_SGC(RCP_RCTARGET_MSG_INT, VER_MIN(5, 0)),     RCP_LIST_GC(RCP_REDCODE_MSG_LIST_PTR),         RCP_MIN(RCP_PARAM_MIN_REDCODE),                      RCP_MAX(RCP_PARAM_MAX_REDCODE),                      _rcp_create_redcode_string,                        NULL,                               NULL,                                 NULL,                          _rcp_create_status_redcode,                   EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHUTDOWN),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Shutdown"),                                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_SC(RCP_SHUTDOWN),                                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MM_ISO_PULL),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Motion Mount: ISO Pull"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_MMMISOND_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MMMISOND_MSG_INT),             RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_ND_VAL),                                                                     VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("ND (Stops)"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MMNDV_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MMNDV_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_nd_val),            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_ND_DISPLAY_VAL),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("ND"),                                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_nd_string,                             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_SENSOR_FRAME_RATE),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Recording Frame Rate"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SENSFPS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SENSFPS_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_sensor_fps_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_sensor_fps),        UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PROJECT_FRAME_RATE),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Project Time Base"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_PROJFPS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PROJFPS_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_project_fps_string,                    NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_APERTURE),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Aperture"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_APRTR_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_APRTR_MSG_LIST_REL, VER_MIN(6, 1)),     RCP_TGT_SGC(RCP_APRTRT_MSG_INT, VER_MIN(6, 1)),       RCP_LIST_GC(RCP_APRTR_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_aperture_string,                       NULL,                               NULL,                                 NULL,                          _rcp_create_status_aperture,                  EDIT_INFO(_rcp_edit_info_aperture),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PB,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_EXPOSURE_INTEGRATION_TIME),                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure: Shutter Speed"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SHTIME_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_SHTIME_MSG_LIST_REL, VER_MIN(6, 1)),    RCP_TGT_SGC(RCP_SHTIMET_MSG_INT, VER_MIN(5, 0)),      RCP_LIST_GC(RCP_SHTIME_MSG_LIST_PTR),          RCP_MIN(RCP_PARAM_MAX_EXPOSURE_INTEGRATION_TIME),    RCP_MAX(RCP_PARAM_MIN_EXPOSURE_INTEGRATION_TIME),    _rcp_create_integration_time_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_exposure_display,          EDIT_INFO(_rcp_edit_info_int_time),          UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_COLOR_TEMPERATURE),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Color Temperature"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_COLTMP_MSG_INT),                            RCP_REL(RCP_COLTMP_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL(RCP_COLTMP_MSG_LIST_REL, VER_MIN(6, 1)),    RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_COLTMP_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_color_temp_string,                     NULL,                               NULL,                                 NULL,                          _rcp_create_status_color_temp,                EDIT_INFO(_rcp_edit_info_color_temp),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_RCP_VERSION),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("RCP Version"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RCPVER_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RCP_PARAMETER_SET_VERSION),                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("RCP Parameter Set Version"),                    RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_RCPPSVER_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Format"),                                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_FORMAT2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FORMAT2_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_string,                         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_NAME),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Format Name"),                                  RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC2(RCP_FORMAT2_MSG_INT, RCP_FORMATST_MSG_STR_PTR), RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_STATE_BASE),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Record State Base"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RECORD_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_STATE),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Record State"),                                 RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RECORD_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_record_state_int,       NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SATURATION),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Saturation"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SATURAT_MSG_INT),                           RCP_REL(RCP_SATURAT_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SATURAT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_saturation),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_CDL_ENABLE),                                                                 VER_MIN(6, 62),                VER_RANGE_NONE(), LABEL("CDL: Enable"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CDLEN_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_PB_ACES_RAW,        COLOR_SCIENCE(IPP2), HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_CDL_SATURATION),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Saturation"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CSATURAT_MSG_INT),                          RCP_REL(RCP_CSATURAT_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CSATURAT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_saturation),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_CONTRAST),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Contrast"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CONTRST_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CONTRST_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_contrast),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BRIGHTNESS),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Brightness"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BRIGHT_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BRIGHT_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_brightness),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_EXPOSURE_COMPENSATION),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure Compensation"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_EXPCOMP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EXPCOMP_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_exp_comp),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_GAIN),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Gain: Red"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_REDG_MSG_INT),                              RCP_REL(RCP_REDG_MSG_REL, VER_MIN(6, 1)),       RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REDG_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_rgb_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_GAIN),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Gain: Green"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GREENG_MSG_INT),                            RCP_REL(RCP_GREENG_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GREENG_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_rgb_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_GAIN),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Gain: Blue"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BLUEG_MSG_INT),                             RCP_REL(RCP_BLUEG_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BLUEG_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_rgb_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FLUT),                                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("FLUT&reg;"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FLUT_MSG_INT),                              RCP_REL(RCP_FLUT_MSG_REL, VER_MIN(6, 1)),       RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FLUT_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_flut),              UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_EXPOSURE_ADJUST),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Exposure Adjust"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FLUT_MSG_INT),                              RCP_REL(RCP_FLUT_MSG_REL, VER_MIN(6, 1)),       RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FLUT_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_flut),              UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW),                                                                     VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Shadow"),                                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHADOW_MSG_INT),                            RCP_REL(RCP_SHADOW_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHADOW_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_shadow),            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCUS_DIST),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focus Distance"),                               RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FOCUS_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_FOCUS_MSG_LIST_REL, VER_MIN(6, 1)),     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FOCUS_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_focus_dist_string,                     NULL,                               NULL,                                 NULL,                          _rcp_create_status_focus,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PB,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCUS_DIST_NEAR),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focus Distance: Near"),                         RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FOCUSN_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PB,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCUS_DIST_FAR),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focus Distance: Far"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FOCUSF_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PB,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCUS_DIST_DISPLAY_MODE),                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focus Distance: Display Mode"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_LENSFDMD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LENSFDMD_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_PROCESSING_MODE),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Frame Processing: Mode"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FRPRMODE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_FRPRMODE_MSG_LIST_REL, VER_MIN(6, 50)), RCP_TGT_SGC(RCP_FRPRMODT_MSG_INT, VER_MIN(6, 50)),    RCP_LIST_GC(RCP_FRPRMODE_MSG_LIST_PTR),        RCP_MIN(RCP_PARAM_MIN_FRAME_PROCESSING_MODE),        RCP_MAX(RCP_PARAM_MAX_FRAME_PROCESSING_MODE),        _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_FRAME_PROCESSING_NUM),                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Frame Processing: Number of Frames"),           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FRPRNUM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_FRPRNUM_MSG_LIST_REL, VER_MIN(6, 50)),  RCP_TGT_SGC(RCP_FRPRNUMT_MSG_INT, VER_MIN(6, 50)),    RCP_LIST_GC(RCP_FRPRNUM_MSG_LIST_PTR),         RCP_MIN(RCP_PARAM_MIN_FRAME_PROCESSING_FRAME_COUNT), RCP_MAX(RCP_PARAM_MAX_FRAME_PROCESSING_FRAME_COUNT), _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          _rcp_create_status_frame_processing,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_EXPOSURE_ANGLE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure: Shutter Angle"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_SHANGLE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_SHANGLET_MSG_INT, VER_MIN(5, 0)),     RCP_LIST_GC(RCP_SHANGLE_MSG_LIST_PTR),         RCP_MIN(RCP_PARAM_MIN_EXPOSURE_ANGLE),               RCP_MAX(RCP_PARAM_MAX_EXPOSURE_ANGLE),               _rcp_create_angle_string,                          NULL,                               NULL,                                 NULL,                          _rcp_create_status_exposure_display,          EDIT_INFO(_rcp_edit_info_shutter_angle),     UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_MODE),                                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("AF: Mode"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFMODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFMODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MIN_REDCODE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("REDCODE&reg;: Min"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MINRC_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MAX_REDCODE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("REDCODE&reg;: Max"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MAXRC_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MIN_EXPOSURE_INTEGRATION_TIME),                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure: Min"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MINSHT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MAX_EXPOSURE_INTEGRATION_TIME),                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure: Max"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MAXSHT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MIN_EXPOSURE_ANGLE),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Shutter Angle: Min"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MINSHA_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MAX_EXPOSURE_ANGLE),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Shutter Angle: Max"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MAXSHA_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CLIP_NAME),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Name"),                                    RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CLIPNAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_clip_name_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_ID),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera ID"),                                    RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMID_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_comm_name_scene),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GAMMA_SPACE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_gamma_space),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GSPACE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GSPACE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_gamma_space_string,                    NULL,                               NULL,                                 NULL,                          _rcp_create_status_gamma_space,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_COLOR_SPACE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Color Space"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CSPACE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CSPACE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_color_space_string,                    NULL,                               NULL,                                 NULL,                          _rcp_create_status_color_space,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAW_MODE),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("RAW"),                                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAWMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT,                COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_HDR_MODE),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("HDRx&reg;: Mode"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_HDRMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDRMODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_hdr_mode,                  EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HDR_MONITOR_TRACK),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("HDRx&reg;: Monitor Track"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDRXMONX_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDRXMONX_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_hdr,                       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HDR_FACTOR),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("HDRx&reg;: Factor"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_HDRFACT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDRFACT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_hdr_factor_string,                     NULL,                               NULL,                                 NULL,                          _rcp_create_status_hdr,                       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FALSE_COLOR_MODE),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("False Color"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FALSEC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FALSEC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FALSE_COLOR_MODE_STATE),                                                     VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("False Color State"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FALSEC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_false_color_mode_state_string,         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TINT),                                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Tint"),                                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TINT_MSG_INT),                              RCP_REL(RCP_TINT_MSG_INT, VER_MIN(6, 1)),       RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TINT_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_tint),              UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_MAGNIFY_STATE),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Magnify"),                                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_MAGNIFY_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MAGNIFY_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_magnify_state_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RIG_STATE),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Rig State"),                                    RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RIGSTATE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_rig_state_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RIG_STATE_DETAILED),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Rig Status"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RIGSTATE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_rig_state_detailed_string,             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GIGE_STATE),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("GigE State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_NWSTAT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_gige_state_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGE_STATE_DETAILED),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("GigE Status"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_NWSTAT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_gige_state_detailed_string,            NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_SYNC_STATE),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Sync State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_SYNC_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_sync_state_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GENLOCK)},
    {PARAM_NOR(RCP_PARAM_SYNC_STATE_DETAILED),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Sync Status"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_SYNC_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_sync_state_detailed_string,            NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GENLOCK)},
    {PARAM_NOR(RCP_PARAM_GENLOCK_STATE),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Genlock State"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_GENLOC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_genlock_state_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GENLOCK)},
    {PARAM_NOR(RCP_PARAM_GENLOCK_STATE_DETAILED),                                                     VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Genlock Status"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_GENLOC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_genlock_state_detailed_string,         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GENLOCK)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_STATE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Timecode State"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TCJAM_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_timecode_state_string,                 NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TIMECODE_IN)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_STATE_DETAILED),                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Timecode Status"),                              RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TCJAM_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_timecode_state_detailed_string,        NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TIMECODE_IN)},
    {PARAM_NOR(RCP_PARAM_FAN_MODE),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan: Mode"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FSMODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FSMODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_REC_SPEED),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan: Maximum Record Speed"),                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RECFS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RECFS_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fanspeed_string,                       NULL,                               NULL,                                 NULL,                          _rcp_create_status_fan_record_speed,          EDIT_INFO(_rcp_edit_info_fan_speed),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_PREVIEW_SPEED),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan: Maximum Preview Speed"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_PREVFS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PREVFS_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fanspeed_string,                       NULL,                               NULL,                                 NULL,                          _rcp_create_status_fan_preview_speed,         EDIT_INFO(_rcp_edit_info_fan_speed),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_DELAY),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Fan: Post Record Delay"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FPRDELAY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FPRDELAY_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_fan_delay,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_ZONE),                                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("AF: Zone"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFZONE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFZONE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_af_zone,                   EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_GAIN),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Gain"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1GAIN_MSG_INT),                           RCP_REL(RCP_CH1GAIN_MSG_INT, VER_MIN(6, 40)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH1GAIN_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch12_gain,                 EDIT_INFO(_rcp_edit_info_audio_gain_db),     UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_GAIN),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Gain"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2GAIN_MSG_INT),                           RCP_REL(RCP_CH1GAIN_MSG_INT, VER_MIN(6, 40)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH2GAIN_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch12_gain,                 EDIT_INFO(_rcp_edit_info_audio_gain_db),     UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_GAIN),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Gain"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3GAIN_MSG_INT),                           RCP_REL(RCP_CH1GAIN_MSG_INT, VER_MIN(6, 40)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH3GAIN_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch34_gain,                 EDIT_INFO(_rcp_edit_info_audio_gain_db),     UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_GAIN),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Gain"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4GAIN_MSG_INT),                           RCP_REL(RCP_CH1GAIN_MSG_INT, VER_MIN(6, 40)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH4GAIN_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch34_gain,                 EDIT_INFO(_rcp_edit_info_audio_gain_db),     UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_VOL),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Volume"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CH1VOL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH1VOL_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch1_vol,                   EDIT_INFO(_rcp_edit_info_audio_vol_db),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_VOL),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Volume"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CH2VOL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH2VOL_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch2_vol,                   EDIT_INFO(_rcp_edit_info_audio_vol_db),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_VOL),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Volume"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CH3VOL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH3VOL_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_vol_db),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_VOL),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Volume"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CH4VOL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH4VOL_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_vol_db),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_R3D_DROPPED_FRAMES),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("R3D Dropped Frames"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_DRPFRMS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_LCD),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCDM_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCDM_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_HDMI),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDMIM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMIM_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_HDSDI),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDSDIM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDSDIM_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_EVF),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVFM_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVFM_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_LCD),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDM_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_HDSDI1),                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI1M_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI1M_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_HDSDI2),                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI2M_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI2M_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_EVF),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFM_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MM_MODE),                                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Motion Mount: Shutter Mode"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MMMODE_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MMMODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_STATE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Playback Mode"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLAYBACK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_MODE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Record: Mode"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RECMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RECMODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_LABEL),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power Label"),                                  RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_PLABEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_VAL),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media Level"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MEDIAPCT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_percent_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LABEL),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media Label"),                                  RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_MLABEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CLIP),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Red Clip"),                                     RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RCLIP_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CLIP),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Green Clip"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_GCLIP_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CLIP),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Blue Clip"),                                    RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_BCLIP_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH12_STATE),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("CH12 State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CH12ST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH34_STATE),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("CH34 State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CH34ST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_DISPLAY_MODE),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power: Display Mode"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BATTMODE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BATTMODE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_TIME_REMAINING),                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media Time"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MEDIAMIN_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_time_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_DISPLAY_MODE),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media: Display Mode"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_MEDIAMOD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MEDIAMOD_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS),                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Playback HDRX&reg; Tracks"),                    RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PBHDRTRC_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_DISPLAY_VAL),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media Display Level"),                          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_display_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_DISPLAY_VAL),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power Display Level"),                          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_display_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_DISPLAY_LABEL),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Media Display Label"),                          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_display_label_string,            NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HDR_MODE),                                                                   VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("HDRx&reg;: State"),                             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_hdr_mode_string,                       _rcp_create_hdr_mode_int,           NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HDR_MODE_DETAILED),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("HDRx&reg;: Mode"),                              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_hdr_mode_detailed_string,              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_FIRMWARE_VERSION),                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera: Firmware Version"),                     RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CAMFWVER_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_TYPE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera: Type"),                                 RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CAMNAME_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PIN),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera: PIN"),                                  RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CAMSER_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_KEYCODE),                                                                    VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Keycode"),                                      RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_KEYCODE_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LIST_SELECT_ISO),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Select List: ISO"),                             RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_SELISO_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LIST_SELECT_SHUTTER),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Select List: Shutter"),                         RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_SELSH_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_CAMERA_OPERATOR),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Camera Operator"),                       RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMERAOP_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_LOCATION),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Location"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMLOC_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_SCENE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Scene"),                                 RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMSCENE_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_scene),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_TAKE),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Take"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CAMTAKE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_int_string,                            NULL,                               NULL,                                 NULL,                          _rcp_create_status_slate_take_shot,           EDIT_INFO(_rcp_edit_info_slate_take),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_UNIT),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Unit"),                                  RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMUNIT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_DIRECTOR),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Director"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_DIRECTOR_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_DOP),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: DoP"),                                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_DOPNAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_PRODUCTION),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Production"),                            RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_PRODUCTN_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_COPYRIGHT),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Copyright"),                             RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_PROJINFO_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_slate_data),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_CAMERA_ID),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Camera ID"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CAMMEID_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CAMMEID_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_CAMERA_POS),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Slate: Camera Position"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CAMPOS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CAMPOS_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_ENABLE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 1: Enable"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ZEBRA1_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_MODE),                                                               VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 1: Mode"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA1M_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA1M_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_IRE_LOW),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 1: Low IRE"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA1LO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA1LO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_ire),               UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_IRE_HIGH),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 1: High IRE"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA1HI_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA1HI_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_ire),               UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_STOPS_LOW),                                                          VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 1: Low Stops"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA1LS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA1LS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_stops),             UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_STOPS_HIGH),                                                         VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 1: High Stops"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA1HS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA1HS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_stops),             UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_ENABLE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 2: Enable"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ZEBRA2_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_MODE),                                                               VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 2: Mode"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA2M_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA2M_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_IRE_LOW),                                                            VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 2: Low IRE"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA2LO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA2LO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_ire),               UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_IRE_HIGH),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Zebra 2: High IRE"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA2HI_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA2HI_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_ire),               UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_STOPS_LOW),                                                          VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 2: Low Stops"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA2LS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA2LS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_stops),             UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_STOPS_HIGH),                                                         VER_MIN(6, 31),                VER_RANGE_NONE(), LABEL("Zebra 2: High Stops"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEBRA2HS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEBRA2HS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO(_rcp_edit_info_stops),             UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCAL_LENGTH),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focal Length"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FLENGTH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_focal_length_string,                   NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_APERTURE_CONTROL),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Aperture Control"),                             RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_APERCTRL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FOCUS_CONTROL),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Focus Control"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FOCSCTRL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SET_TIMECODE),                                                               VER_RANGE(V(5, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL("Set Timecode"),                                 RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_TCSET_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_set_timecode,              EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_VARISPEED_MODE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Varispeed Mode"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VRISPDMD_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_SOURCE),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Power Source"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWRSRC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TEST_PATTERN),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Test Pattern: Signal"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TPATTERN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TPATTERN_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MIN_SENSOR_FRAME_RATE),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Sensor FPS Min"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MINFPS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MAX_SENSOR_FRAME_RATE),                                                      VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Sensor FPS Max"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MAXFPS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHUTTER_DISPLAY_MODE),                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure: Display Mode"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHDISP_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHDISP_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHUTTER_MODE),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Shutter Mode"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SHMODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Curve: Red"),                                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_RCURVE_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Curve: Green"),                                 RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_GCURVE_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Curve: Blue"),                                  RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_BCURVE_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE),                                                                 VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Curve: Luma"),                                  RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LCURVE_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_LENGTH),                                                       VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Length"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CLIPLEN_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_LOAD),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Load"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLIPLOAD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_LOAD_REL),                                                     VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Load Relative"),                           RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLPNUM_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_DIR),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Play Direction"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLPDIR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_IN_POINT),                                                          VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("In Point"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLPINPT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_OUT_POINT),                                                         VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Out Point"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLPOUTPT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_LOOP),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Loop"),                                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LOOP_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_PLAY),                                                              VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Play"),                                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SC(RCP_PLAY_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_PAUSE),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Pause"),                                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SC(RCP_PAUSE_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_PLAY_PAUSE),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Play/Pause"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLAYPAUS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_POS),                                                               VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Position"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLAYPOS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_POS_REL),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Position Relative"),                       RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PLAYRPOS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_SPEED),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Playback Speed"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLAYSPD_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CLIP_COUNT),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Count"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_MEDACLPC_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_clips_string,                          NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CLIP_EXT_INFO),                                                        VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Clip Info"),                                    RCP_TYPE_NULL, RCP_TYPE_EXT_CLIP_INFO, CACHE_NONE,     RCP_GC(RCP_MEDAGCII_MSG_EXTENDED_CLIPINFO_PTR),         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_KEYACTION),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Key Action"),                                   RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_KEYACT_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_TAG),                                                                  VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Frame Tag"),                                    RCP_TYPE_NULL, RCP_TYPE_TAG,           CACHE_NONE,     RCP_C(RCP_TAGGED_MSG_TAG_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_INFO),                                                                VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Camera Info"),                                  RCP_TYPE_NULL, RCP_TYPE_CAM_INFO,      CACHE_NONE,     RCP_GC(RCP_CAMINFO_MSG_CAMINFO_PTR),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HAND_CONTROLLER_FOCUS_POS),                                                  VER_MIN(5, 1),                 VER_RANGE_NONE(), LABEL("Focus Position"),                               RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_HCFOCUS_MSG_UINT),                          RCP_REL(RCP_HCFOCUS_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_focus,                     EDIT_INFO(_rcp_edit_info_hc),                UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HAND_CONTROLLER_IRIS_POS),                                                   VER_MIN(5, 1),                 VER_RANGE_NONE(), LABEL("Iris Position"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_HCIRIS_MSG_UINT),                           RCP_REL(RCP_HCIRIS_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_hc),                UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HAND_CONTROLLER_ZOOM_POS),                                                   VER_MIN(5, 1),                 VER_RANGE_NONE(), LABEL("Zoom Position"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_HCZOOM_MSG_UINT),                           RCP_REL(RCP_HCZOOM_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_hc),                UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HAND_CONTROLLER_REINIT),                                                     VER_MIN(5, 1),                 VER_RANGE_NONE(), LABEL("Reinitialize"),                                 RCP_TYPE_UINT, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_HCREINIT_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_focus,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_EXPOSURE_DISPLAY),                                                           VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Exposure"),                                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_exposure_display_string,               _rcp_create_exposure_display_int,   _rcp_create_exposure_display_list,    _rcp_set_int_exposure_display, _rcp_create_status_exposure_display,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MM_SHUTTER_COLOR),                                                           VER_RANGE(V(6, 0), V(6, 32)),  VER_RANGE_NONE(), LABEL("Motion Mount: Shutter Color"),                  RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_MMSHCOLR_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MM_INTEGRATION_TIME),                                                        VER_RANGE(V(6, 0), V(6, 32)),  VER_RANGE_NONE(), LABEL("Motion Mount: Integration Time"),               RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_MMSHTIME_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MM_SHUTTER_ANGLE),                                                           VER_RANGE(V(6, 0), V(6, 32)),  VER_RANGE_NONE(), LABEL("Motion Mount: Shutter Angle"),                  RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_MMSHANGL_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GROUP_ID),                                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Group ID"),                                     RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_GROUPID_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_comm_name_scene),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CORE_TEMP_WARNING_1),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Temperature: Core Warning 1"),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TWARN1_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CORE_TEMP_WARNING_2),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Temperature: Core Warning 2"),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TWARN2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CORE_TEMP_WARNING_3),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Temperature: Core Warning 3"),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TWARN3_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_MODE),                                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Mode"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AEMODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AEMODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae_mode,                   EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_EV_SHIFT),                                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Exposure Compensation"),                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AEEVSHFT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL(RCP_AEEVSHFT_MSG_LIST_REL, VER_MIN(6, 1)),  RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AEEVSHFT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO(_rcp_edit_info_ae_ev_shift),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_METERING_MODE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Metering Mode"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AEMETERM_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AEMETERM_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_SPEED),                                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Speed"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AESPEED_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AESPEED_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_SELECTION),                                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Selection"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AESELECT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AESELECT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_LOCK_APERTURE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Lockout Aperture"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AELOCKAP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_LOCK_EXPOSURE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AE: Lockout Shutter"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AELOCKEX_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CALIBRATION_STATUS),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Calibration Status"),                           RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_CALSTAT_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_calibration_status_string,             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CALIBRATION_STATUS_TEMPERATURE),                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Calibration Status Temperature"),               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_calibration_status_temperature_string, NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CALIBRATION_STATUS_EXPOSURE),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Calibration Status Exposure"),                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_calibration_status_exposure_string,    NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FAN_TARGET_TEMPERATURE),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Fan: Target Temperature"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FANTRGTT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FANTRGTT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_fan_target_temperature,    EDIT_INFO(_rcp_edit_info_target_temp),       UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_COLOR_TEMPERATURE_PRESET),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Color Temperature: Presets"),                   RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_VAL,      RCP_SGC(RCP_COLTMPP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_COLTMPP_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_RAW,        COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_SHOW_HORIZON_LINE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Horizon Line"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HORIZON_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TEST_PATTERN_TONE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Test Pattern: Tone"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TPATTONE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_LCD),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_BLCDOV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BLCDOV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_HDMI),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_BHDMIOV_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BHDMIOV_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_HDSDI),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIOV_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BHDSDIOV_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_EVF),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_BEVFOV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BEVFOV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_REAR_LCD),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_PLCDOV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDOV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_PHDS1OV_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDS1OV_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_PHDS2OV_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDS2OV_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_REAR_EVF),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_REVFOV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFOV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_RESOLUTION_HDMI),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDMIR_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMIR_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_RESOLUTION_HDSDI),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDSDIR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDSDIR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1),                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI1R_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI1R_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2),                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI2R_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI2R_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_LCD),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCDF_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCDF_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_HDMI),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDMIF_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMIF_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_HDSDI),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDSDIF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDSDIF_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_EVF),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVFF_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVFF_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_REAR_LCD),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDF_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDF_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI1F_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI1F_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSDI2F_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI2F_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_REAR_EVF),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFF_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFF_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_LCD),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDTL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_HDMI),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMITL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_HDSDI),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDITL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_EVF),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFTL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_REAR_LCD),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDTL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1TL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2TL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_REAR_EVF),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFTL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDFM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMIFM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI),                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIFM_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFFM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD),                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDFM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1),                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1FM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2),                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2FM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF),                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFFM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_LCD),                                                     VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDVF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI),                                                    VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMIVF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI),                                                   VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIVF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_EVF),                                                     VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFVF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD),                                                VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDVF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1),                                             VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1VF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2),                                             VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2VF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF),                                                VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFVF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDFO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMIFO_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI),                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIFO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFFO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD),                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDFO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1),                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1FO_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2),                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2FO_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF),                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFFO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_LCD),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDDM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_HDMI),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMIDM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIDM_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_EVF),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFDM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDDM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1),                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1DM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2),                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2DM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFDM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_LCD),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BLCDBR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BLCDBR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_EVF),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BEVFBR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BEVFBR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_REAR_LCD),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_PLCDBR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDBR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_REAR_EVF),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_REVFBR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFBR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_SIDE_UI),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_side_ui),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FUIBR_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FUIBR_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ENABLE_HDSDI),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIEN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDS1EN_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDS2EN_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_AUDIO_VU_METER_SOURCE),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("VU Meter: Source"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_VUSRC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_VUSRC_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_HISTOGRAM_TYPE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Histogram: Type"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_HISTTYPE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HISTTYPE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_APERTURE_LIST_MODE),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Aperture Increments"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_LDISPM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LDISPM_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MM_ND_MODE),                                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Motion Mount ND: Mode"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MMNDMODE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MMNDMODE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_SHOW_RACK_DISTANCES),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Rack: Show Distance"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHRCKDST_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHRCKDST_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_SAVE_LEVEL_1),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Power Save: Low Power Preview"),                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL_LIST, RCP_SGC(RCP_PSLEVEL1_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PSLEVEL1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_SAVE_LEVEL_2),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Power Save: Sleep"),                            RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL_LIST, RCP_SGC(RCP_PSLEVEL2_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PSLEVEL2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_SAVE_LEVEL_3),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Power Save: Auto Shutdown"),                    RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL_LIST, RCP_SGC(RCP_PSLEVEL3_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PSLEVEL3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_MODE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Mode"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0MODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0MODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_USER_AR_NUM),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: User Aspect Ratio"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F0NUM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_user_aspect_ratio,   EDIT_INFO(_rcp_edit_info_frame_ar_num),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_SCALE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Scale"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0SCL_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0SCL_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_scale),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_X_OFFSET),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Offset X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0OFFSX_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0OFFSX_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_Y_OFFSET),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Offset Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0OFFSY_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0OFFSY_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_ABS_X_OFFSET),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Absolute Offset X"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F0ABSXOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_ABS_Y_OFFSET),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Absolute Offset Y"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F0ABSYOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_ABS_W),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Absolute Width"),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F0ABSW_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_ABS_H),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Absolute Height"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F0ABSH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_LINE_STYLE),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Line Style"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0LNST_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0LNST_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_COLOR),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Color"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0COLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0COLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FRAME_GUIDE_OPACITY),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Frame Guide: Opacity"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F0OPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F0OPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_MODE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Mode"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1MODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1MODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_USER_AR_NUM),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: User Aspect Ratio"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1NUM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_user_aspect_ratio,   EDIT_INFO(_rcp_edit_info_frame_ar_num),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_SCALE),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Scale"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1SCL_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1SCL_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_scale),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_X_OFFSET),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Offset X"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1OFFSX_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1OFFSX_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_Y_OFFSET),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Offset Y"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1OFFSY_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1OFFSY_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_ABS_X_OFFSET),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Absolute Offset X"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1ABSXOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_ABS_Y_OFFSET),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Absolute Offset Y"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1ABSYOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_ABS_W),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Absolute Width"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1ABSW_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_ABS_H),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Absolute Height"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1ABSH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_LINE_STYLE),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Line Style"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1LNST_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1LNST_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_COLOR),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Color"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1COLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1COLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_OPACITY),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Opacity"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F1OPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F1OPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACTION_GUIDE_RELATIVE),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Action Guide: Relative"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F1RELF0_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_MODE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Mode"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2MODE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2MODE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_USER_AR_NUM),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: User Aspect Ratio"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2NUM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_user_aspect_ratio,   EDIT_INFO(_rcp_edit_info_frame_ar_num),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_SCALE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Scale"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2SCL_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2SCL_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_scale),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_X_OFFSET),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Offset X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2OFFSX_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2OFFSX_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_Y_OFFSET),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Offset Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2OFFSY_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2OFFSY_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO(_rcp_edit_info_frame_offset),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_ABS_X_OFFSET),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Absolute Offset X"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2ABSXOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_ABS_Y_OFFSET),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Absolute Offset Y"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2ABSYOF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_offset),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_ABS_W),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Absolute Width"),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2ABSW_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_ABS_H),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Absolute Height"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2ABSH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_abs_aspect_ratio,    EDIT_INFO(_rcp_edit_info_frame_abs_dim),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_LINE_STYLE),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Line Style"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2LNST_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2LNST_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_COLOR),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Color"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2COLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2COLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_OPACITY),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Opacity"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_F2OPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_F2OPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_line_attributes,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TITLE_GUIDE_RELATIVE),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Title Guide: Relative"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_F2RELF0_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_guide_normal_aspect_ratio, EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CENTER_GUIDE_GUIDE),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Center: Relative To"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CGGUIDE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CGGUIDE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CENTER_GUIDE_MARKER_TYPE),                                                   VER_MIN(6, 60),                VER_RANGE_NONE(), LABEL("Center: Mark"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CGMARK_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CGMARK_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CENTER_GUIDE_COLOR),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Center: Color"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CGCOLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CGCOLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CENTER_GUIDE_OPACITY),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Center: Opacity"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CGOPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CGOPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GRID_GUIDE_GUIDE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Grid: Relative To"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GGGUIDE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GGGUIDE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GRID_GUIDE_COLOR),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Grid: Color"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GGCOLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GGCOLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GRID_GUIDE_OPACITY),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Grid: Opacity"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GGOPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GGOPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADING_GUIDE),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Shading: Relative To"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHGUIDE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHGUIDE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADING_COLOR),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Shading: Color"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHCOLOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHCOLOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADING_OPACITY),                                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Shading: Opacity"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHOPAC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHOPAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ACES_PROXY),                                                                 VER_RANGE(V(6, 0), V(6, 31)),  VER_RANGE_NONE(), LABEL("ACES Proxy"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ACES_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_SPLIT_CURVE),                                                        VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL("Independent Display LUT"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_IMGSPCRV_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_LCD),                                                          VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCDCV_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCDCV_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_HDMI),                                                         VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDMICV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMICV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_HDSDI),                                                        VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_HDSDICV_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDSDICV_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_EVF),                                                          VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVFCV_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVFCV_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_REAR_LCD),                                                     VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDCV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDCV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1),                                                  VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSD1CV_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSD1CV_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2),                                                  VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PHDSD2CV_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSD2CV_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_REAR_EVF),                                                     VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFCV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFCV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_DISPLAY_MODE),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Timecode: Display Mode"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TCDMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TCDMODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_SOURCE),                                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Timecode: Source"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TCSOURCE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TCSOURCE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(TIMECODE_IN)},
    {PARAM_NOR(RCP_PARAM_SAVE_LOG),                                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Save Log"),                                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_SAVELOG),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_SIZE),                                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AF: Size"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AFSIZE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFSIZE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_af_size,                   EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_ENHANCED_ENABLE),                                                         VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Enhanced AF: Enable"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFENHNCD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_ENHANCED_MONITOR),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Enhanced AF: Monitor"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFENHMON_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFENHMON_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_enhanced_af,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("AF: Confirm Style"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AFENCONS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFENCONS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_enhanced_af,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BEEP_ENABLE),                                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Beep: Enable Sounds"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEEPEN_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BEEP_RECORD_START),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Beep: Record Start"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BEEPREC_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BEEPREC_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_beeps,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BEEP_RECORD_STOP),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Beep: Record Stop"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BEEPSTOP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BEEPSTOP_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_beeps,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BEEP_TAG_STILL_FRAME),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Beep: Tag Still Frame"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BEEPTAGS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BEEPTAGS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_beeps,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_EVF_TALLY_LIGHT),                                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("EVF Tally Light"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVFTALLY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PRE_RECORD_DURATION),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Pre-Record: Duration"),                         RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL_LIST, RCP_SGC(RCP_PRERECDR_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PRERECDR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_pre_record,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PRE_RECORD_ALWAYS_TRIGGER),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Pre-Record: Always Trigger"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PRERECON_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_pre_record,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_LIFT_RED),                                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Red Lift"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RLIFT_MSG_INT),                             RCP_REL(RCP_RLIFT_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RLIFT_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_lift),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_OFFSET_RED),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Red Offset"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ROFFSET_MSG_INT),                           RCP_REL(RCP_ROFFSET_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ROFFSET_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_offset),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_LIFT_GREEN),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Green Lift"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GLIFT_MSG_INT),                             RCP_REL(RCP_GLIFT_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GLIFT_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_lift),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_OFFSET_GREEN),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Green Offset"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GOFFSET_MSG_INT),                           RCP_REL(RCP_GOFFSET_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GOFFSET_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_offset),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_LIFT_BLUE),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Blue Lift"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BLIFT_MSG_INT),                             RCP_REL(RCP_BLIFT_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BLIFT_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_lift),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_OFFSET_BLUE),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Blue Offset"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BOFFSET_MSG_INT),                           RCP_REL(RCP_BOFFSET_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BOFFSET_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_offset),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAMMA_RED),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Red Gamma"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RGAMMA_MSG_INT),                            RCP_REL(RCP_RGAMMA_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RGAMMA_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gamma),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_POWER_RED),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Red Power"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RPOWER_MSG_INT),                            RCP_REL(RCP_RPOWER_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RPOWER_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_power),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAMMA_GREEN),                                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Green Gamma"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GGAMMA_MSG_INT),                            RCP_REL(RCP_GGAMMA_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GGAMMA_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gamma),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_POWER_GREEN),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Green Power"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GPOWER_MSG_INT),                            RCP_REL(RCP_GPOWER_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GPOWER_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_power),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAMMA_BLUE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Blue Gamma"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BGAMMA_MSG_INT),                            RCP_REL(RCP_BGAMMA_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BGAMMA_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gamma),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_POWER_BLUE),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Blue Power"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BPOWER_MSG_INT),                            RCP_REL(RCP_BPOWER_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BPOWER_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_power),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAIN_RED),                                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Red Gain"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RGAIN_MSG_INT),                             RCP_REL(RCP_RGAIN_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RGAIN_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_SLOPE_RED),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Red Slope"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RSLOPE_MSG_INT),                            RCP_REL(RCP_RSLOPE_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RSLOPE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_slope),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAIN_GREEN),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Green Gain"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GGAIN_MSG_INT),                             RCP_REL(RCP_GGAIN_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GGAIN_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_SLOPE_GREEN),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Green Slope"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GSLOPE_MSG_INT),                            RCP_REL(RCP_GSLOPE_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GSLOPE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_slope),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LGG_GAIN_BLUE),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("LGG: Blue Gain"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BGAIN_MSG_INT),                             RCP_REL(RCP_BGAIN_MSG_REL, VER_MIN(6, 1)),      RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BGAIN_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_3_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lgg_gain),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CDL_SLOPE_BLUE),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("CDL: Blue Slope"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_BSLOPE_MSG_INT),                            RCP_REL(RCP_BSLOPE_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_BSLOPE_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fixed_point_5_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_cdl,                       EDIT_INFO(_rcp_edit_info_cdl_slope),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: IP Address"),                             RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_GEIPADDR_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_gige_addresses,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_NETMASK),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: Netmask"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_GENETMSK_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_gige_addresses,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_GATEWAY),                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: Gateway"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_GEGWADDR_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_gige_addresses,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE),                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: DHCP"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GEDHCP_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_C2C_ENABLE),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: Camera to Camera"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GEC2C_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_EXT_ENABLE),                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GigE: External Control"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GEEXT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_GIGABIT_ETHERNET_MAC_ADDRESS),                                               VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("GigE: MAC"),                                    RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_GEMAC_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_SERIAL_PROTOCOL),                                                            VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Ctrl: Protocol"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SERPROTO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SERPROTO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(CONTROL_UART)},
    {PARAM_NOR(RCP_PARAM_SERIAL_2_PROTOCOL),                                                          VER_MIN(6, 32),                VER_RANGE_NONE(), LABEL("Serial: Protocol"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SERPROT2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SERPROT2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(CONTROL_UART_2)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH12_SOURCE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1/2 Source"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH12SRC_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH12SRC_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH34_SOURCE),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3/4 Source"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH34SRC_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH34SRC_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH12_LINK_GAIN),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1/2 Link Gain"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH12ILNK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch12_gain,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH34_LINK_GAIN),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3/4 Link Gain"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH34ILNK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ch34_gain,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_IN_GAIN_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH12_LINK_VOL),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1/2 Link Volume"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH12OLNK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH34_LINK_VOL),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3/4 Link Volume"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH34OLNK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_NAME),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Name"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CH1NAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_channel),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_MODE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Mode"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1MODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH1MODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_UI_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_48V_POWER),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 48V Power"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1_48V_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_48v,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_48V_PRESENT),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 48V Power Present"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1_48VP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_LIMITER),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Limiter"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1LIMIT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_limiter,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_LIMITER_PRESENT),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH1 Limiter Present"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1LIMPR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_NAME),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Name"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CH2NAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_channel),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_MODE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Mode"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2MODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH2MODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_UI_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_48V_POWER),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 48V Power"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2_48V_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_48v,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_48V_PRESENT),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 48V Power Present"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2_48VP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_LIMITER),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Limiter"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2LIMIT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_limiter,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_LIMITER_PRESENT),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH2 Limiter Present"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2LIMPR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_NAME),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Name"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CH3NAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_channel),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_MODE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Mode"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3MODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH3MODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_UI_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_48V_POWER),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 48V Power"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3_48V_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_48v,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_48V_PRESENT),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 48V Power Present"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3_48VP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_LIMITER),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Limiter"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3LIMIT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_limiter,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_LIMITER_PRESENT),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH3 Limiter Present"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH3LIMPR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_NAME),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Name"),                              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CH4NAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_audio_channel),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_MODE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Mode"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4MODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CH4MODE_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_UI_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_48V_POWER),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 48V Power"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4_48V_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_48v,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_48V_PRESENT),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 48V Power Present"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4_48VP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_PHANTOM_POWER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_LIMITER),                                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Limiter"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4LIMIT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_limiter,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_LIMITER_PRESENT),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Audio: CH4 Limiter Present"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH4LIMPR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_LIMITER)},
    {PARAM_NOR(RCP_PARAM_CLIP_NAME_STATUS),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Clip Name Status"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLIPNMST_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_SYNC_MODE),                                                           VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Sensor Sync Mode"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SHSYNC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SHSYNC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(SENSOR_SYNC)},
    {PARAM_NOR(RCP_PARAM_GPI_FUNCTION),                                                               VER_MIN(6, 0),                 VER_MAX(6, 19),   LABEL("SS/GPI Function"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GPIN_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GPIN_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GPI_SYNC_IN_MUXED)},
    {PARAM_NOR(RCP_PARAM_GPO_FUNCTION),                                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("GPO Function"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GPOUT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GPOUT_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GPO_SYNC_OUT_MUXED)},
    {PARAM_NOR(RCP_PARAM_GENLOCK_SOURCE),                                                             VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Genlock Source"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_GENSRC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GENSRC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GENLOCK_MUXED)},
    {PARAM_NOR(RCP_PARAM_AWB_MODE),                                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Auto White Balance Mode"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AWBMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_PB_RAW,             COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_RECORD_LIMIT_ENABLE),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Limit Enable"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RECLIMEN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_limit_enable,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_LIMIT_FRAMES),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Limit Frames"),                         RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_RECLIMFR_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_limit_frames,       EDIT_INFO(_rcp_edit_info_limit_frames),      UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_TIMELAPSE_FRAMES),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Timelapse Frames"),                     RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_RECTLFR_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_timer_settings,     EDIT_INFO(_rcp_edit_info_tl_frames),         UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_TIMELAPSE_INTERVAL),                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Timelapse Interval"),                   RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_RECTLINT_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_timer_settings,     EDIT_INFO(_rcp_edit_info_tl_interval),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_PRE_FRAME_COUNT),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Pre Frame Count"),                      RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_RECPRE_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_POST_FRAME_COUNT),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Record: Post Frame Count"),                     RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_RECPOST_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_PRE_FRAME_COUNT_AVAILABLE),                                           VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Record: Pre Frame Count Available"),            RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_RECPREA_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_POST_FRAME_COUNT_AVAILABLE),                                          VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Record: Post Frame Count Available"),           RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_RECPOSTA_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_PRE_FRAME_COUNT_ACTUAL),                                              VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Record: Pre Frame Count Actual"),               RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_RECPREB_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_POST_FRAME_COUNT_ACTUAL),                                             VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Record: Post Frame Count Actual"),              RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_VAL,      RCP_GC(RCP_RECPOSTB_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_prepost_settings,   EDIT_INFO(_rcp_edit_info_prepost_frames),    UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RTC_DATE_TIME),                                                              VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Date/Time"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_DATETIME_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_date_time_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_PRIORITY_LIST),                                                      VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Monitor Priority List"),                        RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_MONPRTY_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TARGET),                                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("RCP: Target"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TARGET_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TARGET_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TARGET_ID),                                                                  VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("RCP: Target ID"),                               RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_TARGETID_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_target_id,                 EDIT_INFO(_rcp_edit_info_comm_name_scene),   UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_EJECT),                                                                VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Media Eject"),                                  RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_EJECT_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TIMEZONE),                                                                   VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Time Zone"),                                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TIMEZONE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TIMEZONE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT_REEL_NO),                                                       VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Format: Reel Number"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_FMTREELN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO(_rcp_edit_info_reel_no),           UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT_CAMERA_ID),                                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Format: Camera ID"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FMTCAMID_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FMTCAMID_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT_CAMERA_POS),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Format: Camera Position"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FMTCAMPO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FMTCAMPO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT_EDGE_TC_START),                                                 VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Format: Edge TC Start"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_FMTETCS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_timecode_offset_string,                NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT),                                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Format Media"),                                 RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FMTMEDIA_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_SECURE_FORMAT),                                                        VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL("Secure Format Media"),                          RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_SFMTMEDI_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD),                                          VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_BLCDFMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD),                                     VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RLCDFMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_LCD),                                                    VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDFM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD),                                               VER_MIN(6, 0),                 VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RLCDFM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Remote Control Panel: Enable"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CNA1ENA_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_REMOTE_CONTROL_PANEL_ADDRESS),                                               VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Remote Control Panel: Remote Address"),         RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CNA1ADDR_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_remote_control_panel,      EDIT_INFO(_rcp_edit_info_ip_or_host),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_REMOTE_CONTROL_PANEL_STATUS),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Remote Control Panel: Status"),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CNA1STA_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(GIG_ETHERNET)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_ADDRESS),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: Address"),                     RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_TSRVAD_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_STATE),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: State"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TSRVSTAT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_OUTPUT_SHARPNESS),                                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Output Sharpness"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FRSHARP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRSHARP_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_SHOT),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Slate: Shot"),                                  RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CAMSHOT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_slate_take_shot,           EDIT_INFO(_rcp_edit_info_slate_shot),        UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_WIFI_STATE),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("WiFi State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_WLANSTAT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_wifi_state_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_STATE_DETAILED),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("WiFi Status"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_WLANSTAT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_wifi_state_detailed_string,            NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_FOCUS_STATE),                                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Focus State"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST0_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_FOCUS_STATE_DETAILED),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Focus Status"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST0_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string_detailed,             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_IRIS_STATE),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Iris State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST1_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_IRIS_STATE_DETAILED),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Iris Status"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST1_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string_detailed,             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_ZOOM_STATE),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Zoom State"),                                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string,                      NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_ZOOM_STATE_DETAILED),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Zoom Status"),                                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MTMST2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_fiz_state_string_detailed,             NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FIZ)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_LTC_OUT_ENABLE),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Timecode: LTC Out"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TCLTCOUT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(TIMECODE_OUT)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_STATE),                                                              VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg; State"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RMSTATE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_redmote_state_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAPTURE_MODE),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Capture Mode"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CAMMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PRIMARY_STORAGE),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Record: Primary Storage"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PRISTOR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PRISTOR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_RR),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: RR"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATRR_MSG_INT),                            RCP_REL(RCP_CMATRR_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_RG),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: RG"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATRG_MSG_INT),                            RCP_REL(RCP_CMATRG_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_RB),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: RB"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATRB_MSG_INT),                            RCP_REL(RCP_CMATRB_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_GR),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: GR"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATGR_MSG_INT),                            RCP_REL(RCP_CMATGR_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_GG),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: GG"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATGG_MSG_INT),                            RCP_REL(RCP_CMATGG_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_GB),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: GB"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATGB_MSG_INT),                            RCP_REL(RCP_CMATGB_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_BR),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: BR"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATBR_MSG_INT),                            RCP_REL(RCP_CMATBR_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_BG),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: BG"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATBG_MSG_INT),                            RCP_REL(RCP_CMATBG_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USER_MATRIX_BB),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Custom Matrix: BB"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CMATBB_MSG_INT),                            RCP_REL(RCP_CMATBB_MSG_REL, VER_MIN(6, 1)),     RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_user_matrix),       UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB,            COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_MODEL_NUMBER),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Model Number"),                          RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_MEDIANUM_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_ACTIVE_MEDIA),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Active Media"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_MEDIA_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MEDIA_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_AUTO_HEAD_FRAMES),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Slate: Auto Head Frames"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SLHEAD_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_auto_slate_frames), UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_AUTO_TAIL_FRAMES),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Slate: Auto Tail Frames"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SLTAIL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_auto_slate_frames), UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GIO_SCOPE_PRIMARY_COLORS),                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gio Scope: Primary Colors"),                    RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GIOCPRI_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_gio_scope,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GIO_SCOPE_SECONDARY_COLORS),                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gio Scope: Secondary Colors"),                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_GIOCSEC_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_gio_scope,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GIO_SCOPE_ZONES),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gio Scope: Zones"),                             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_GIOZONE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_gio_scope,                 EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UI_GESTURE_PINCH_MAGNIFY),                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gesture: Pinch To Magnify"),                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GESTPNCH_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UI_GESTURE_DOUBLE_TAP_RIGHT_REC),                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gesture: Double Tap Right To Record"),          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GESTDTR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UI_GESTURE_DOUBLE_TAP_LEFT_AF),                                              VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Gesture: Double Tap Left To AF"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GESTDTL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UI_LOCK_TOUCHSCREEN),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Lock Touchscreen"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_UILOCK_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UI_SMALL_DIALOGS_ON_9_INCH),                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Small Dialogs on 9\" LCD"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SMDLG9IN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_DATE),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Clip Date"),                          RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_PBCLSTDT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_metadata_date_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_TIME),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Clip Time"),                          RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_PBCLSTTM_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_metadata_time_string,                  NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_CLIP_DATE_TIME),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Clip Date/Time"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_date_time_string,                      _rcp_create_metadata_date_time_int, NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_METADATA_FOCAL_LENGTH),                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Focal Length"),                       RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PBZOOM_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_focal_length_string,                   NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_METADATA_ISO),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: ISO"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PBISO_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_playback_metadata_iso_string,          NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE),                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Color Temperature"),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PBCOLTMP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_color_temp_string,                     NULL,                               NULL,                                 NULL,                          _rcp_create_status_color_temp,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_METADATA_TINT),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Metadata: Tint"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PBTINT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_tint),              UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_FIRMWARE_SVN_REVISION),                                               VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera: SVN Revision"),                         RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CAMVCREV_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_RUNTIME),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera: Runtime"),                              RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RUNTIME_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_runtime_string,                        NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_SHADOW_X),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Shadow X"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVESX_MSG_INT),                          RCP_REL(RCP_RCURVESX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_SHADOW_Y),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Shadow Y"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVESY_MSG_INT),                          RCP_REL(RCP_RCURVESY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_DARK_X),                                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Dark X"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEDX_MSG_INT),                          RCP_REL(RCP_RCURVEDX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_DARK_Y),                                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Dark Y"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEDY_MSG_INT),                          RCP_REL(RCP_RCURVEDY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_MIDTONE_X),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Midtone X"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEMX_MSG_INT),                          RCP_REL(RCP_RCURVEMX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_MIDTONE_Y),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Midtone Y"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEMY_MSG_INT),                          RCP_REL(RCP_RCURVEMY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_LIGHT_X),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Light X"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVELX_MSG_INT),                          RCP_REL(RCP_RCURVELX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_LIGHT_Y),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Light Y"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVELY_MSG_INT),                          RCP_REL(RCP_RCURVELY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_HIGHLIGHT_X),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Highlight X"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEHX_MSG_INT),                          RCP_REL(RCP_RCURVEHX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RED_CURVE_HIGHLIGHT_Y),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Red Curve: Highlight Y"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RCURVEHY_MSG_INT),                          RCP_REL(RCP_RCURVEHY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_SHADOW_X),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Shadow X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVESX_MSG_INT),                          RCP_REL(RCP_GCURVESX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_SHADOW_Y),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Shadow Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVESY_MSG_INT),                          RCP_REL(RCP_GCURVESY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_DARK_X),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Dark X"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEDX_MSG_INT),                          RCP_REL(RCP_GCURVEDX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_DARK_Y),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Dark Y"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEDY_MSG_INT),                          RCP_REL(RCP_GCURVEDY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_MIDTONE_X),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Midtone X"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEMX_MSG_INT),                          RCP_REL(RCP_GCURVEMX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_MIDTONE_Y),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Midtone Y"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEMY_MSG_INT),                          RCP_REL(RCP_GCURVEMY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_LIGHT_X),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Light X"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVELX_MSG_INT),                          RCP_REL(RCP_GCURVELX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_LIGHT_Y),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Light Y"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVELY_MSG_INT),                          RCP_REL(RCP_GCURVELY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_HIGHLIGHT_X),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Highlight X"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEHX_MSG_INT),                          RCP_REL(RCP_GCURVEHX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_GREEN_CURVE_HIGHLIGHT_Y),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Green Curve: Highlight Y"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_GCURVEHY_MSG_INT),                          RCP_REL(RCP_GCURVEHY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_SHADOW_X),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Shadow X"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVESX_MSG_INT),                          RCP_REL(RCP_BCURVESX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_SHADOW_Y),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Shadow Y"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVESY_MSG_INT),                          RCP_REL(RCP_BCURVESY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_DARK_X),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Dark X"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEDX_MSG_INT),                          RCP_REL(RCP_BCURVEDX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_DARK_Y),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Dark Y"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEDY_MSG_INT),                          RCP_REL(RCP_BCURVEDY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_MIDTONE_X),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Midtone X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEMX_MSG_INT),                          RCP_REL(RCP_BCURVEMX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_MIDTONE_Y),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Midtone Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEMY_MSG_INT),                          RCP_REL(RCP_BCURVEMY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_LIGHT_X),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Light X"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVELX_MSG_INT),                          RCP_REL(RCP_BCURVELX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_LIGHT_Y),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Light Y"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVELY_MSG_INT),                          RCP_REL(RCP_BCURVELY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_HIGHLIGHT_X),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Highlight X"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEHX_MSG_INT),                          RCP_REL(RCP_BCURVEHX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BLUE_CURVE_HIGHLIGHT_Y),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Blue Curve: Highlight Y"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BCURVEHY_MSG_INT),                          RCP_REL(RCP_BCURVEHY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_SHADOW_X),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Shadow X"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVESX_MSG_INT),                          RCP_REL(RCP_LCURVESX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_SHADOW_Y),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Shadow Y"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVESY_MSG_INT),                          RCP_REL(RCP_LCURVESY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_DARK_X),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Dark X"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEDX_MSG_INT),                          RCP_REL(RCP_LCURVEDX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_DARK_Y),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Dark Y"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEDY_MSG_INT),                          RCP_REL(RCP_LCURVEDY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_MIDTONE_X),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Midtone X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEMX_MSG_INT),                          RCP_REL(RCP_LCURVEMX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_MIDTONE_Y),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Midtone Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEMY_MSG_INT),                          RCP_REL(RCP_LCURVEMY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_LIGHT_X),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Light X"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVELX_MSG_INT),                          RCP_REL(RCP_LCURVELX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_LIGHT_Y),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Light Y"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVELY_MSG_INT),                          RCP_REL(RCP_LCURVELY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_HIGHLIGHT_X),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Highlight X"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEHX_MSG_INT),                          RCP_REL(RCP_LCURVEHX_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUMA_CURVE_HIGHLIGHT_Y),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Luma Curve: Highlight Y"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCURVEHY_MSG_INT),                          RCP_REL(RCP_LCURVEHY_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_curve_component),   UPDATE_LIST_ON_CHANGE, DISABLED_IN_PAT_BAKEDPB_ACES_RAW,   COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_IS_ATTACHED),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Attached"),                              RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MEDATCHD_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_IS_PRESENT),                                                           VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Media: Present"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MEDPRSNT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_SERIAL_NUMBER),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Serial Number"),                         RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_MEDASRNU_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FIRMWARE_VERSION),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Firmware Version"),                      RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_MEDIAVER_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_SIZE),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Size"),                                  RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_NONE,     RCP_GC(RCP_MEDIASZ_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_size_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_SIZE_AVIALABLE),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Size Available"),                        RCP_TYPE_NULL, RCP_TYPE_UINT,          CACHE_NONE,     RCP_GC(RCP_MEDIASZA_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_media_size_string,                     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_OLPF_TYPE),                                                                  VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("OLPF: Type"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_OLPF_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_OLPF_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_DOWNLOAD_FIRMWARE),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media: Download Firmware"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MEDIAUPG),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RESET_FACTORY_DEFAULTS),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Reset Defaults"),                               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RESETDEF),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_REDISCOVER_HARDWARE),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Rediscover"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RESETHW),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_A_FPS),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp A: FPS"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPAFPS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_fps),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_A_DURATION),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp A: Duration"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPADUR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_duration),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_B_FPS),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp B: FPS"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPBFPS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_fps),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_B_DURATION),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp B: Duration"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPBDUR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_duration),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_C_FPS),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp C: FPS"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPCFPS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_fps),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_C_DURATION),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp C: Duration"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPCDUR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_duration),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_D_FPS),                                                                 VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp D: FPS"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPDFPS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_fps),          UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_D_DURATION),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp D: Duration"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPDDUR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_duration),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RAMP_RESET_DURATION),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Ramp Reset: Duration"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RAMPRDUR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_record_ramp_settings,      EDIT_INFO(_rcp_edit_info_ramp_duration),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_LIST),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Presets"),                               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CPRE_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_APPLY),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Preset: Apply"),                         RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CPREAPLY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_presets,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_EXPORT_TO_MEDIA),                                              VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Preset: Export to Media"),               RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CPREE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_presets_media,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_EXPORT_ALL_TO_MEDIA),                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Preset: Export All to Media"),           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CPREEA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_presets_media,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_UPDATE),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Preset: Update"),                        RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CPREUP_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_presets,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_PRESET_DELETE),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Preset: Delete"),                        RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CPREDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_presets,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_PRESET_LIST),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Presets"),                                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MPRE_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_PRESET_IMPORT_TO_CAMERA),                                              VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Preset: Import to Camera"),               RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MPREI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_presets_media,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_PRESET_IMPORT_ALL_TO_CAMERA),                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Preset: Import All to Camera"),           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MPREIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_presets_media,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LOOK_LIST),                                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Looks"),                                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLOK_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LOOK_APPLY),                                                          VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Look: Apply"),                           RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLOKAPLY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_looks,              EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LOOK_EXPORT_TO_MEDIA),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Look: Export to Media"),                 RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLOKE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_looks_media,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LOOK_EXPORT_ALL_TO_MEDIA),                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Look: Export All to Media"),             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLOKEA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_looks_media,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LOOK_DELETE),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Look: Delete"),                          RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLOKDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_looks,              EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LOOK_LIST),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Looks"),                                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MLOK_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LOOK_IMPORT_TO_CAMERA),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Look: Import to Camera"),                 RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MLOKI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_looks_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LOOK_IMPORT_ALL_TO_CAMERA),                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Look: Import All to Camera"),             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MLOKIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_looks_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UPGRADE_CAMERA_FIRMWARE),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera: Upgrade Firmware"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CAMUPG),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_UPGRADE_REDMOTE_FIRMWARE),                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Upgrade Firmware"),               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RMUPG),                                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_AF_RACK_SPEED),                                                              VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Rack: Speed"),                                  RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_AFRCKSPD_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_rack,                      EDIT_INFO(_rcp_edit_info_rack_speed),        UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_RACK_NUMBER_OF_POINTS),                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Rack: Number of Points"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AFRCKNPT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AFRCKNPT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_rack,                      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_RACK_TO_POINT),                                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Rack: To Point"),                               RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_AFRCKTO_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_rack,                      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_OVERLAY_LIST),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Overlays"),                              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_COVR_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_OVERLAY_DELETE),                                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Overlay: Delete"),                       RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_COVRDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_overlays,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_OVERLAY_EXPORT_TO_MEDIA),                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Overlay: Export to Media"),              RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_COVRE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_overlays_media,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_OVERLAY_EXPORT_ALL_TO_MEDIA),                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Camera Overlay: Export All to Media"),          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_COVREA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_overlays_media,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_OVERLAY_LIST),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Overlays"),                               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MOVR_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_OVERLAY_IMPORT_TO_CAMERA),                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Overlay: Import to Camera"),              RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MOVRI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_overlays_media,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_OVERLAY_IMPORT_ALL_TO_CAMERA),                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Media Overlay: Import All to Camera"),          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MOVRIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_overlays_media,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CURRENT_CALIBRATION_TEMPERATURE),                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Calibration: Temperature"),                     RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CALTEMP_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_temperature_string,                    NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CURRENT_CALIBRATION_INTEGRATION_TIME),                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Calibration: Integration Time"),                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_CALINT_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_cal_integration_time_string,           NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_WIRELESS_ENABLE),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Wireless Enable"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RMEN_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_WIRELESS_CHANNEL),                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Wireless Channel"),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_RMCH_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RMCH_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_DISCOVERED_LIST),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Discovered List"),                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RMDMAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_PAIRED_LIST),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Paired List"),                    RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RMPMAC_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_SCAN),                                                               VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Scan"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RMSCAN),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_PAIR),                                                               VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Pair"),                           RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RMPAIR_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_discovered_redmotes,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_UNPAIR),                                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Unpair"),                         RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RMUNPAIR_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_paired_redmotes,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_CAMERA_MAC),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Camera MAC"),                     RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_RMCAMMAC_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_REDMOTE_ATTACHED_MAC),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("REDMOTE&reg;: Attached MAC"),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_RMMAC_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(REDMOTE_COMM)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_STARTUP),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Startup"),                         RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_APSTART_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_APSTART_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_MOTION),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Motion"),                          RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_APMOTION_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_APMOTION_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_MOTION_AUTO_UPDATE),                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Auto Save Motion"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_APAUMOTN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_STILLS),                                                         VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Stills"),                          RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_APSTILLS_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_APSTILLS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_STILLS_AUTO_UPDATE),                                             VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Auto Save Stills"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_APAUSTIL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_PLAYBACK),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Playback"),                        RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_APPLAY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_APPLAY_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_PRESET_PLAYBACK_AUTO_UPDATE),                                           VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Auto Preset: Auto Save Playback"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_APAUPLAY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TETHERING_SUPPORTED),                                                        VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethering Supported"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TETHERS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TETHERING_SUPPORTED_ON_THIS_INTERFACE),                                      VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethering Supported on this Interface"),        RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_TETHERSI_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_SPACE_TOTAL),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: Total Space"),                 RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_TSRVSPT_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TETHERING)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_SPACE_REMAINING),                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: Space Remaining"),             RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_TSRVSPR_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TETHERING)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_REEL_NO),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: Reel Number"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TSRVRN_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TETHERING)},
    {PARAM_NOR(RCP_PARAM_TETHERED_SERVER_CLIP_NO),                                                    VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Tethered Server: Clip Number"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TSRVCN_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(TETHERING)},
    {PARAM_NOR(RCP_PARAM_PL_POWER),                                                                   VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Lens: Power PL Lens"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLPOWER_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PL_POWER)},
    {PARAM_NOR(RCP_PARAM_PL_DETECT),                                                                  VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Lens: Force PL Detect"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLDETECT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PL_DETECT)},
    {PARAM_NOR(RCP_PARAM_GENLOCK_OFFSET_HDSDI),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Genlock Offset: BRAIN&reg; HDSDI"),             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSGLO_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_genlock_offset),    UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_GENLOCK_OFFSET_REDCAST),                                                     VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("Genlock Offset: REDCAST"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_TURRGLO_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_genlock_offset),    UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_RACK_POINT_SELECT),                                                       VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("AF: Rack Point Select"),                        RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_AFRCKSEL_MSG_INT),                            RCP_REL(RCP_AFRCKSEL_MSG_REL, VER_MIN(6, 1)),   RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_rack,                      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_WINDOW_POS_X),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("AF: Window Position X"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFWPOSX_MSG_INT),                           RCP_REL(RCP_AFWPOSX_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_af_window_move,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_WINDOW_POS_Y),                                                            VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("AF: Window Position Y"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AFWPOSY_MSG_INT),                           RCP_REL(RCP_AFWPOSY_MSG_REL, VER_MIN(6, 1)),    RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_af_window_move,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AF_WINDOW_POS_MOVE_COMPLETE),                                                VER_MIN(6, 1),                 VER_RANGE_NONE(), LABEL("AF: Window Move Complete"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_AFWPOSC),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_af_window_move,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LUT_LIST),                                                            VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Camera LUTs"),                                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUT_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LUT_EXPORT_TO_MEDIA),                                                 VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Camera LUT: Export to Media"),                  RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLUTE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_luts_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LUT_EXPORT_ALL_TO_MEDIA),                                             VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Camera LUT: Export All to Media"),              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLUTEA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_luts_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_CAMERA_LUT_DELETE),                                                          VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Camera LUT: Delete"),                           RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CLUTDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_luts,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LUT_LIST),                                                             VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Media LUTs"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MLUT_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LUT_IMPORT_TO_CAMERA),                                                 VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Media LUT: Import to Camera"),                  RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MLUTI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_luts_media,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_MEDIA_LUT_IMPORT_ALL_TO_CAMERA),                                             VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Media LUT: Import All to Camera"),              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MLUTIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_luts_media,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(3D_LUT)},
    {PARAM_NOR(RCP_PARAM_LUT_CH_0),                                                                   VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("LUT: Channel 0"),                               RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CLUTCH0_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUTCH0_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUT_CH_1),                                                                   VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("LUT: Channel 1"),                               RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CLUTCH1_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUTCH1_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUT_CH_2),                                                                   VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("LUT: Channel 2"),                               RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CLUTCH2_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUTCH2_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUT_CH_3),                                                                   VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("LUT: Channel 3"),                               RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CLUTCH3_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUTCH3_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF),                                    VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_BEVFFMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF),                                     VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_REVFFMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF),                                              VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFFM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF),                                               VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFFM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH12_OUTPUT_NAME),                                                     VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Audio: CH12 Output Name"),                      RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CH12ONME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH34_OUTPUT_NAME),                                                     VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Audio: CH34 Output Name"),                      RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CH34ONME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH56_OUTPUT_NAME),                                                     VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("Audio: CH56 Output Name"),                      RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CH56ONME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AE_EXPOSURE_PRIORITY),                                                       VER_MIN(6, 10),                VER_RANGE_NONE(), LABEL("AE: Exposure Priority"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_AEEXPRI_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AEEXPRI_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ae,                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FILE_FORMAT),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Record: File Format"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_FILEFMT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FILEFMT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_not_external_record,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_CODEC),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("ProRes: Video Codec"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_VCODEC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_VCODECT_MSG_INT, VER_MIN(6, 30)),     RCP_LIST_GC(RCP_VCODEC_MSG_LIST_PTR),          RCP_MIN(RCP_PARAM_MIN_RECORD_VIDEO_CODEC),           RCP_MAX_NONE(),                                      _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MIN_RECORD_VIDEO_CODEC),                                                     VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("ProRes: Min Video Codec"),                      RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_C(RCP_MIVCODEC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_min_record_codec_int,   NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION),                                              VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("ProRes: Resolution"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_VCODECR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_VCODECRT_MSG_INT, VER_MIN(6, 30)),    RCP_LIST_GC(RCP_VCODECR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_MXF_CODEC),                                                     VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Video Codec"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VMCODEC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_VMCODECT_MSG_INT, VER_MIN(6, 40)),    RCP_LIST_GC(RCP_VMCODEC_MSG_LIST_PTR),         RCP_MIN(RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC),       RCP_MAX_NONE(),                                      _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC),                                                 VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Min Video Codec"),                    RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_C(RCP_MVMCODEC_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_min_record_mxf_codec_int, NULL,                               NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION),                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Resolution"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VMCODECR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_VMCODCRT_MSG_INT, VER_MIN(6, 40)),    RCP_LIST_GC(RCP_VMCODECR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_list_string,                           NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID),                                            VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Compression ID"),                     RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_MXFCMPID_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_mxf_compression_id_string,             NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_HARDWARE_CAPABILITIES),                                                      VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Hardware Capabilities"),                        RCP_TYPE_NULL, RCP_TYPE_HW_CAP,        CACHE_NONE,     RCP_GC(RCP_HWCAP_MSG_HW_CAP_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_MUTE),                                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: CH1 Mute"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH1MUTE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_MUTE),                                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: CH2 Mute"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CH2MUTE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_VOL1),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Vol 1"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12VL1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12VL1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_PAN1),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Pan 1"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12PN1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12PN1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_VOL2),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Vol 2"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12VL2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12VL2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_PAN2),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Pan 2"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12PN2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12PN2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_VOL3),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Vol 3"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12VL3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12VL3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_PAN3),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Pan 3"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12PN3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12PN3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_VOL4),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Vol 4"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12VL4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12VL4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH12_PAN4),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH12 Pan 4"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX12PN4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX12PN4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(HEADPHONE)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_VOL1),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Vol 1"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34VL1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34VL1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_PAN1),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Pan 1"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34PN1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34PN1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_VOL2),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Vol 2"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34VL2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34VL2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_PAN2),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Pan 2"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34PN2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34PN2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_VOL3),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Vol 3"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34VL3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34VL3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_PAN3),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Pan 3"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34PN3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34PN3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_VOL4),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Vol 4"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34VL4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34VL4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_CH34_PAN4),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer CH34 Pan 4"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIX34PN4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIX34PN4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(AUDIO_OUT)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_VOL1),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Vol 1"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDVL1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDVL1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_PAN1),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Pan 1"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDPN1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDPN1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_VOL2),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Vol 2"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDVL2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDVL2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_PAN2),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Pan 2"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDPN2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDPN2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_VOL3),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Vol 3"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDVL3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDVL3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_PAN3),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Pan 3"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDPN3_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDPN3_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_VOL4),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Vol 4"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDVL4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDVL4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_volume),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_AUDIO_MIX_MON_PAN4),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Audio: Mixer Monitor Pan 4"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MIXHDPN4_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MIXHDPN4_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_mixer_pan),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MONITOR_WITH_AUDIO)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LCD_EVF_2_HDMI_MUX),                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor_mux),               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_HDMIMUX_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMIMUX_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(LCD_EVF_2_HDMI_MUX)},
    {PARAM_NOR(RCP_PARAM_WIFI_MODE),                                                                  VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi: Mode"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_WLANMODE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_WLANMODE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_AD_HOC_ENCRYPTION),                                                     VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi AdHoc: Encryption"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_WLANAHEN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_WLANAHEN_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_ad_hoc,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_AD_HOC_PASSPHRASE),                                                     VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Wifi AdHoc: Passphrase"),                       RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_NONE,     RCP_SGC(RCP_WLANAHPW_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_ad_hoc_pw,            EDIT_INFO_FP(_rcp_create_edit_info_pw),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_AD_HOC_SSID),                                                           VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi AdHoc: SSID"),                             RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_WLANAHID_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_ad_hoc,               EDIT_INFO(_rcp_edit_info_ssid),              UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_CHANNEL),                                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi: Channel"),                                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_WLANCHAN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_WLANCHAN_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_ad_hoc,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION),                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi Infrastructure: Encryption"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_WLANAPEN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_WLANAPEN_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE),                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi Infrastructure: Passphrase"),              RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_NONE,     RCP_SGC(RCP_WLANAPPW_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_pw,             EDIT_INFO_FP(_rcp_create_edit_info_pw),      UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_INFRASTRUCTURE_SSID),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi Infrastructure: SSID"),                    RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_NONE,     RCP_SGC(RCP_WLANAPID_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra,                EDIT_INFO(_rcp_edit_info_ssid),              UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_SIGNAL),                                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi: Signal"),                                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_WLANSIG_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_wifi_rssi_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_connected,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_CONNECT),                                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi: Connect"),                                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_WLANCONN),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_connect,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_SCAN),                                                                  VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("WiFi: Scan"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_VAL,      RCP_SC(RCP_WLANSCAN),                                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_scan,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_SCAN_RESULTS),                                                          VER_MIN(6, 20),                VER_MAX(6, 29),   LABEL("WiFi: Scan Result List"),                       RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_WLANSCRL_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_WLANSCRL_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_SCAN_SELECT),                                                           VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("WiFi: Select SSID"),                            RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_WLANSCS_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_select,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_IP_ADDRESS),                                                            VER_MIN(6, 21),                VER_MIN(6, 41),   LABEL("WiFi: IP Address"),                             RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_WLANIP_MSG_UINT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_addresses,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_NETMASK),                                                               VER_MIN(6, 41),                VER_RANGE_NONE(), LABEL("WiFi: Netmask"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_WLANNETM_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_addresses,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_GATEWAY),                                                               VER_MIN(6, 41),                VER_RANGE_NONE(), LABEL("WiFi: Gateway"),                                RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_NONE,     RCP_SGC(RCP_WLANGATE_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_ipaddress_string,                      NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra_addresses,      EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_DHCP_ENABLE),                                                           VER_MIN(6, 41),                VER_RANGE_NONE(), LABEL("WiFi: DHCP"),                                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_WLANDHCP_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_wifi_infra,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_WIFI_MAC_ADDRESS),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("WiFi: MAC"),                                    RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_WLANMAC_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(WIFI)},
    {PARAM_NOR(RCP_PARAM_MODULE_CAPABILITIES),                                                        VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Attached Modules"),                             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MODCAP_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE),                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O GPIO: Enable"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POPIOGE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_GPIO)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS),                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O GPIO: Status"),                         RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POPIOGS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_GPIO)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET),                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O GPIO: Reset"),                          RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_POPIOGR),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_GPIO)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE),                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O PWR: Enable"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POPIOPE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS),                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O PWR: Status"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POPIOPS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET),                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O PWR: Reset"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_POPIOPR),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PRO_IO_AUX_ENABLE),                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Pro I/O AUX: Enable"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POPIOAE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PRO_IO_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE),                                              VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("+1 PWR: Enable"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POPOPE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PLUS_ONE_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS),                                              VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("+1 PWR: Status"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POPOPS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PLUS_ONE_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET),                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("+1 PWR: Reset"),                                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_POPOPR),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_PLUS_ONE_PWR)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Battery Aux: Enable"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POBAE_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_BAT_AUX_WITH_ENABLE)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_BAT_AUX_STATUS),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Battery Aux: Status"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POBAS_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_BAT_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_BAT_AUX_CURRENT),                                                  VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Battery Aux: Current"),                         RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POBAC_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_BAT_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_BAT_AUX_RESET),                                                    VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Battery Aux: Reset"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_POBAR),                                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_BAT_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE),                                               VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Jetpack USB: Enable"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_POJPUE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_JETPACK_USB)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS),                                               VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Jetpack USB: Status"),                          RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_POJPUS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_JETPACK_USB)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_JETPACK_USB_RESET),                                                VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Jetpack USB: Reset"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_POJPUR),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_JETPACK_USB)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE),                                                  VER_RANGE(V(6, 32), V(6, 49)), VER_RANGE_NONE(), LABEL("Rear Aux: Enable"),                             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PORXAE_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_REAR_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_REAR_AUX_STATUS),                                                  VER_RANGE(V(6, 32), V(6, 49)), VER_RANGE_NONE(), LABEL("Rear Aux: Status"),                             RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PORXAS_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_REAR_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_REAR_AUX_RESET),                                                   VER_RANGE(V(6, 32), V(6, 49)), VER_RANGE_NONE(), LABEL("Rear Aux: Reset"),                              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PORXAR),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_REAR_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_REAR_AUX_CURRENT),                                                 VER_RANGE(V(6, 32), V(6, 49)), VER_RANGE_NONE(), LABEL("Rear Aux: Current"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PORXAC_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_REAR_AUX)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_TIMECODE_ENABLE),                                                  VER_MIN(6, 32),                VER_RANGE_NONE(), LABEL("Rear Timecode: Enable"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PORXTCE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_TIMECODE)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_TIMECODE_STATUS),                                                  VER_MIN(6, 32),                VER_RANGE_NONE(), LABEL("Rear Timecode: Status"),                        RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PORXTCS_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_TIMECODE)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_TIMECODE_RESET),                                                   VER_MIN(6, 32),                VER_RANGE_NONE(), LABEL("Rear Timecode: Reset"),                         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PORXTCR),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(POWER_OUT_TIMECODE)},
    {PARAM_NOR(RCP_PARAM_POWER_SAVE_STATE),                                                           VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Power Save: State"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWRSAVE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_QUALITY),                                                                    VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Record: Quality"),                              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_quality_string,                        NULL,                               NULL,                                 NULL,                          _rcp_create_status_not_external_record,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_SENSOR_FRAME_RATE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom Recording Frame Rate"),                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMFPS_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_SENSOR_FRAME_RATE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master Recording Frame Rate"),                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRFPS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_RECORD_FORMAT),                                                       VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom Format"),                                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMFMT_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_RECORD_FORMAT),                                                       VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master Format"),                                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRFMT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_SHUTTER_ANGLE),                                                       VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom Shutter Angle"),                         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMPHS_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_SHUTTER_ANGLE),                                                       VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master Shutter Angle"),                         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRPHS_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_INTEGRATION_TIME),                                                    VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom Integration Time"),                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMINT_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_INTEGRATION_TIME),                                                    VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master Integration Time"),                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRINT_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_ISO),                                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom ISO"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMISO_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_ISO),                                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master ISO"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRISO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_REDCODE),                                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom REDCODE&reg"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMRC_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MASTER_REDCODE),                                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master REDCODE&reg"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRRC_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CUSTOM_COLOR_TEMPERATURE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Custom Color Temperature"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_SGC(RCP_CUSTMAWB_MSG_LIST_PTR),       RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB_RAW,     COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_MASTER_COLOR_TEMPERATURE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Master Color Temperature"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MASTRAWB_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB_RAW,     COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_FORMAT),                                                          VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom Format List"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECFL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_FRAME_RATE),                                                      VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom Frame Rate List"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECFRL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_SHUTTER_ANGLE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom Shutter Angle List"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECPHSL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_INTEGRATION_TIME),                                                VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom Integration Time List"),             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECINTL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_ISO),                                                             VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom ISO List"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECISOL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_REDCODE),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom REDCODE&reg List"),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECRCL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_USE_CUSTOM_COLOR_TEMPERATURE),                                               VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Use Custom Color Temperature List"),            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_USECWBL_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB_RAW,     COLOR_SCIENCE(_),    HW_CAP(COLOR_SENSOR)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_LCD),                                                           VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_LCDG_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCDG_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_HDMI),                                                          VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_HDMIG_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDMIG_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_HDSDI),                                                         VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_HDSDIG_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_HDSDIG_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_EVF),                                                           VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_EVFG_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVFG_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_REAR_LCD),                                                      VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_PLCDG_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PLCDG_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_REAR_HDSDI1),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_PHDSDI1G_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI1G_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_REAR_HDSDI2),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_PHDSDI2G_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PHDSDI2G_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_enable,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_REAR_EVF),                                                      VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_REVFG_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_REVFG_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_VIDEO_SOURCE),                                                               VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Video Source"),                                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_VIDEOSRC_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_VIDEOSRC_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LUT_FEED_1_ENABLE),                                                          VER_MIN(6, 62),                VER_RANGE_NONE(), LABEL("Output Transform: 3D LUT: Enable"),             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_CLUTF1EN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(MULTI_MONITOR_FEED_1_AND_3D_LUT)},
    {PARAM_NOR(RCP_PARAM_LUT_FEED_1),                                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_lut_feed_1),                RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CLUTF1_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CLUTF1_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_lut_feed_1,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(MULTI_MONITOR_FEED_1_AND_3D_LUT)},
    {PARAM_NOR(RCP_PARAM_FLIP_MIRROR_FEED_0),                                                         VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Look A: Flip/Mirror"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ROTF0_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(MULTI_MONITOR_FEED_0)},
    {PARAM_NOR(RCP_PARAM_FLIP_MIRROR_FEED_1),                                                         VER_RANGE(V(6, 20), V(6, 49)), VER_RANGE_NONE(), LABEL("Look B: Flip/Mirror"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ROTF1_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(MULTI_MONITOR_FEED_1)},
    {PARAM_NOR(RCP_PARAM_FLIP_MIRROR_FEED_0_1),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Global Flip/Mirror"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ROTF01_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(MULTI_MONITOR_FEED_0)},
    {PARAM_NOR(RCP_PARAM_SSD_TALLY_LIGHT),                                                            VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("SSD Tally Light"),                              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SSDTALLY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(SSD_TALLY_LIGHT)},
    {PARAM_NOR(RCP_PARAM_OVERDRIVE_FRAME_RATE),                                                       VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Overdrive Frame Rate"),                         RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL,      RCP_SGC(RCP_PORECFPS_MSG_UINT),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_overdrive_fps),     UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PRE_RECORD),                                                                 VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Trigger Pre-Record"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PREREC),                                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_pre_record,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CALIBRATION_ENTRY),                                                          VER_MIN(6, 20),                VER_MAX(6, 29),   LABEL("Current Calibration Map"),                      RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_CALENTRY_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_VIDEO_CODEC_FEED),                                                    VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Video Codec: Look"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_VCODECG_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_VCODECG_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_REDCODE_RAW_STATE),                                                   VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("REDCODE RAW Record State"),                     RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_R3DST_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_REDCODE_RAW_STATE_DETAILED),                                          VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("REDCODE RAW Record Status"),                    RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_R3DSTD_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_QUICKTIME_STATE),                                                     VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Quicktime Record State"),                       RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_QTST_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_QUICKTIME_STATE_DETAILED),                                            VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Quicktime Record Status"),                      RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_QTSTD_MSG_STR_PTR),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_MXF_STATE),                                                           VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("MXF Record State"),                             RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MXFST_MSG_INT),                              RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_RECORD_MXF_STATE_DETAILED),                                                  VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("MXF Record Status"),                            RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_MXFSTD_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_SENSOR_SCAN_DIRECTION),                                                      VER_MIN(6, 20),                VER_RANGE_NONE(), LABEL("Sensor: Flip/Mirror Scan Direction"),           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SSCANDIR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(SENSOR_FLIP)},
    {PARAM_NOR(RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM),                                                   VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Format: File System"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_FMTFSYS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FMTFSYS_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_present,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_WIPE_CAMERA),                                                                VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Wipe Camera"),                                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_RESETUSR),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PROXY_ENCODE_FRAMERATE),                                                     VER_RANGE(V(6, 30), V(6, 49)), VER_MAX(6, 49),   LABEL("Video Codec: Frame Rate"),                      RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PROXYFPS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_qt_encode_fps_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec_any,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_PRORES_ENCODE_FRAMERATE),                                                    VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("ProRes: Frame Rate"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PROXYFPS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_qt_encode_fps_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MXF_ENCODE_FRAMERATE),                                                       VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Frame Rate"),                         RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_NONE,     RCP_GC(RCP_PROXYFPS_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_qt_encode_fps_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAL_LIST),                                                            VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Camera Calibration Files"),                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CCAL_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAL_APPLY),                                                           VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Camera Calibration File: Apply"),               RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCALAPLY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cal_files,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAL_EXPORT_TO_MEDIA),                                                 VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Camera Calibration File: Export to Media"),     RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCALE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cal_files_media,    EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAL_EXPORT_ALL_TO_MEDIA),                                             VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Camera Calibration File: Export All to Media"), RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCALEA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cal_files_media,    EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CAL_DELETE),                                                          VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Camera Calibration File Delete"),               RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCALDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cal_files,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CAL_LIST),                                                             VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Media Calibration Files"),                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MCAL_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CAL_APPLY),                                                            VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Media Calibration File: Apply"),                RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MCALAPLY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_cal_files_media,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CAL_IMPORT_TO_CAMERA),                                                 VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Media Calibration File: Import to Camera"),     RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MCALI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_cal_files_media,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CAL_IMPORT_ALL_TO_CAMERA),                                             VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Media Calibration File: Import All to Camera"), RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MCALIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_cal_files_media,     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PRORES_WIDTH),                                                               VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("ProRes: Width"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PRORESW_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_PRORES_HEIGHT),                                                              VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("ProRes: Height"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PRORESH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_PRORES_DIMENSION),                                                           VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("ProRes: Dimensions"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_prores_dimension_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MXF_WIDTH),                                                                  VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Width"),                              RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MXFW_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MXF_HEIGHT),                                                                 VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Height"),                             RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MXFH_MSG_INT),                               RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MXF_DIMENSION),                                                              VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("DNxHD/HR: Dimensions"),                         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_mxf_dimension_string,                  NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_mxf_codec,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_OPEN_GATE_MODE),                                                             VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Allow Reduced Judder Preview"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_OGTMODE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_OPEN_GATE_STATE),                                                            VER_MIN(6, 30),                VER_RANGE_NONE(), LABEL("Reduced Judder Preview State"),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_OGTSTATE_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_IMAGE_STABILIZATION_ENABLED),                                           VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens Image Stabilization Enabled"),             RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_LENSISEN_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_CAPABILITIES),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens Capabilities"),                            RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LENSCAP_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_FILE_FORMAT),                                                       VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Playback: File Format"),                        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_GC(RCP_PLAYFMT_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_PLAYFMTT_MSG_INT, VER_MIN(6, 40)),    RCP_LIST_GC(RCP_PLAYFMT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_file_format_string,                    NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_LCD3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3M_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3M_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_LCD3),                                                       VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LCD3OV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3OV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_LCD3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3F_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3F_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_LCD3),                                                         VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3CV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3CV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_LCD3),                                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3TL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3),                                                VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3FM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3),                                                    VER_RANGE(V(6, 40), V(6, 49)), VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3VF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3),                                                   VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3FM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3),                                                VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3FO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_LCD3),                                                    VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3DM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_LCD3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_LCD3G_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3G_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3),                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_LCD3FMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_EVF3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3M_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3M_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_OVERLAY_EVF3),                                                       VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_EVF3OV_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3OV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_EVF3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3F_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3F_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CURVE_EVF3),                                                         VER_RANGE(V(6, 0), V(6, 49)),  VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3CV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3CV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_TOOLS_EVF3),                                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3TL_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3),                                                VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3FM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_ui_flip_mirror,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3),                                                    VER_RANGE(V(6, 40), V(6, 49)), VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3VF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_flip,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3),                                                   VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3FM2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_flip_mirror,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3),                                                VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3FO_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_DOCK_MENUS_EVF3),                                                    VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3DM_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_overlay,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FEED_EVF3),                                                          VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_EVF3G_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3G_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3_MULTI_FEEDS)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3),                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_EVF3FMSP_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_LCD3),                                                    VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_LCD3BR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_LCD3BR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_MONITOR_BRIGHTNESS_EVF3),                                                    VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_EVF3BR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_EVF3BR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_PLAYBACK_FILE_FORMAT_TYPE),                                                  VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Playback: File Format Type"),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLAYTYPE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PREVIEW,                COLOR_SCIENCE(_),    HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_OLPF_THIRD_PARTY_NAME),                                                      VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("OLPF: 3rd Party Name"),                         RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_OLPFTPNM_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_third_pary_olpf,           EDIT_INFO(_rcp_edit_olpf_third_party_name),  UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(THIRD_PARTY_OLPFS)},
    {PARAM_NOR(RCP_PARAM_OLPF_THIRD_PARTY_EMULATED_TYPE),                                             VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("OLPF: 3rd Party Emulated Type"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_OLPFTPEM_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_OLPFTPEM_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_third_pary_olpf,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(THIRD_PARTY_OLPFS)},
    {PARAM_NOR(RCP_PARAM_LENS_META_NAME),                                                             VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Name"),                                   RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LNMTNAME_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_name),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_META_SERIAL),                                                           VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Serial Number"),                          RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LNMTSERL_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_serial),       UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_META_OWNER),                                                            VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Owner"),                                  RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LNMTOWNR_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_name),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_META_MANUFACTURER),                                                     VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Manufacturer"),                           RCP_TYPE_STR,  RCP_TYPE_STR,           CACHE_VAL,      RCP_SGC(RCP_LNMTMANU_MSG_STR_PTR),                      RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_name),         UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_META_FLEN_MIN),                                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Minimum Focal Length"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LNMTFLMN_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_focal_length), UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LENS_META_FLEN_MAX),                                                         VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL("Lens: Maximum Focal Length"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LNMTFLMX_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO(_rcp_edit_info_lens_focal_length), UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_R3D_METADATA_CURVE),                                                  VER_MIN(6, 40),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_r3d_metadata_curve),        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_METACV_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_METACV_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_metadata_curve,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(FLUT), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ND_INCREMENT_SIZE),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("ND Increment Size"),                            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_MMNDINSZ_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MMNDINSZ_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(ND_CONTROL)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_PATTERN),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Zebra 1: Raw Pattern"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEB1PAT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEB1PAT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_PATTERN),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Zebra 2: Raw Pattern"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEB2PAT_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEB2PAT_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_1_COLOR),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Zebra 1: Raw Color"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEB1CLR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEB1CLR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ZEBRA_2_COLOR),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Zebra 2: Raw Color"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ZEB2CLR_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ZEB2CLR_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_zebra,                     EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH1_MODE_STATUS),                                                      VER_MIN(6, 41),                VER_RANGE_NONE(), LABEL("Audio: CH1 Mode Status"),                       RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_AINSR1ST_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_channel_mode,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_NO_UI_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH2_MODE_STATUS),                                                      VER_MIN(6, 41),                VER_RANGE_NONE(), LABEL("Audio: CH2 Mode Status"),                       RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_AINSR2ST_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_channel_mode,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_NO_UI_CONTROL_12)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH3_MODE_STATUS),                                                      VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Audio: CH3 Mode Status"),                       RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_AINSR3ST_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_channel_mode,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_NO_UI_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_AUDIO_CH4_MODE_STATUS),                                                      VER_MIN(6, 42),                VER_RANGE_NONE(), LABEL("Audio: CH4 Mode Status"),                       RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_AINSR4ST_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_audio_channel_mode,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(AUDIO_MODE_NO_UI_CONTROL_34)},
    {PARAM_NOR(RCP_PARAM_START_USER_CAL_MANUAL_CURRENT_INT_TIME),                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Create Cal: Current Integration Time"),         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CALMANC),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_START_USER_CAL_MANUAL_DEFAULT_INT_TIME),                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Create Cal: Default Integration Time"),         RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CALMAND),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_START_USER_CAL_AUTO),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Create Cal: Auto"),                             RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CALAUTO),                                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_CONTROL_SCREEN),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Control Screen"),                               RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_CTRLSCRN_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RCP_CLIENT_LIST),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("RCP Connections"),                              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_RCPCLL_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BWF_ENABLE),                                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Broadcast Wave File: Enabled"),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BWFENABL_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_bwf_enable,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_BWF_VALID),                                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Broadcast Wave File: Valid"),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_BWFVALID_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_WSH_FOCUS_WHEEL),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side Handle: Focus"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_WSHFOCUS_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_MODULE_FOCUS_WHEEL)},
    {PARAM_NOR(RCP_PARAM_SIDE_MODULE_LOCK_KEYS),                                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side Module: Lock Keys"),                       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SMLCKKEY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_MODULE_KEYS)},
    {PARAM_NOR(RCP_PARAM_SIDE_MODULE_RECORD_KEY_LOCKABLE),                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side Module: Record Key Lockable"),             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SMLCKREC_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_MODULE_RECORD)},
    {PARAM_NOR(RCP_PARAM_SIDE_MODULE_NAV_KEYS_LOCKABLE),                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side Module: Navigation Keys Lockable"),        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_SMLCKNAV_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_MODULE_NAVIGATION)},
    {PARAM_NOR(RCP_PARAM_SHOW_KEY_ACTION_NOTIFICATIONS),                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Show key action notifications"),                RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_KEYACNOT_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_IN_LIST),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Power In"),                                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PWILIST_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PERCENT, 9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PERCENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTLVL_MSG_INDEXED_INT),                  RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_percent_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_RUNTIME, 9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_RUNTIME),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIBTRT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_runtime_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE, 9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_VOLTAGE),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWIVOLT_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_voltage_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_CURRENT, 9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_CURRENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIAMPS_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_PRESENT, 9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIPRST_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_TYPE,    9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWITYPE_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,0, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,1, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,2, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,3, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,4, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,5, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,6, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,7, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,8, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD,9, RCP_PARAM_POWER_IN_LIST, POWER_IN_PROPERTY_PRESENT),VER_MIN(6, 61),     VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_in),                  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWIVBT_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_in_present,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_OUT_LIST),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Power Out"),                                    RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PWOLIST_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 0, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 1, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 2, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 3, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 4, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 5, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 6, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 7, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 8, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_ENABLE, 9, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_ENABLE),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PWOIEN_MSG_INDEXED_INT),                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 0, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 1, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 2, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 3, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 4, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 5, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 6, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 7, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 8, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_STATUS, 9, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_STATUS),   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIST_MSG_INDEXED_INT),                     RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_out_status_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_status,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 0, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 1, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 2, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 3, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 4, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 5, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 6, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 7, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 8, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_RESET, 9, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_RESET),     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_PWOIRST_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_reset,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 0, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 1, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 2, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 3, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 4, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 5, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 6, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 7, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 8, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_IDX(RCP_PARAM_POWER_OUT_CURRENT, 9, RCP_PARAM_POWER_OUT_LIST, POWER_OUT_PROPERTY_CURRENT), VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_power_out),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWOIAMPS_MSG_INDEXED_INT),                   RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_power_in_out_current_string,           NULL,                               NULL,                                 NULL,                          _rcp_create_status_power_out_current,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LIST),                                                               VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Monitor"),                                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MONLIST_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_NAME),                                                               VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Name"),                                 RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_SUNAME_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_WIDTH_PHY),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Sensor: Width"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PHYSENSW_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_HEIGHT_PHY),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Sensor: Height"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PHYSENSH_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_DIMENSIONS_PHY),                                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Sensor: Dimensions"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_sensor_physical_dimensions_string,     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_WIDTH_PHY),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Physical Width"),                       RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_format_phy_width_int,   NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_HEIGHT_PHY),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Physical Height"),                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_format_phy_height_int,  NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_DIMENSIONS_PHY),                                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Physical Dimensions"),                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_physical_dimensions_string,     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_WIDTH_PIXELS),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Width"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PXFMTW_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_HEIGHT_PIXELS),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Height"),                               RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PXFMTH_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_FORMAT_DIMENSIONS_PIXELS),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Dimensions"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_pixel_dimensions_string,        NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_SPHERICAL),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Spherical"),                            RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FORMAT2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTSPH_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_string,                         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_ANA_1_3),                                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Anamorphic 1.3"),                       RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FORMAT2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTA13_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_string,                         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_ANA_1_25),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Anamorphic 1.25"),                      RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FORMAT2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTA125_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_string,                         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_ANA_2),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Anamorphic 2"),                         RCP_TYPE_INT,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_FORMAT2_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTA2_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_string,                         NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_MAG_PB,         COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_RESOLUTION),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Resolution"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_FRMTRES_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTRES_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_ASPECT_RATIO),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Aspect Ratio"),                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_FRMTAR_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTAR_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_ANAMORPHIC),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Anamorphic"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_FRMTANA_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_FRMTANA_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(ANAMORPHIC)},
    {PARAM_NOR(RCP_PARAM_RECORD_FORMAT_LOOKAROUND),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Format: Look Around"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_FRMTLA_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_lookaround,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_MAG,                COLOR_SCIENCE(_),    HW_CAP(LOOKAROUND)},
    {PARAM_NOR(RCP_PARAM_SENSOR_NAME),                                                                VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Sensor: Name"),                                 RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_SENSNAME_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Physical Width"),                RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_format_phy_width_int,   NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Physical Height"),               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_format_phy_height_int,  NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY),                                               VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Physical Dimensions"),           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_physical_dimensions_string,     NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Width"),                         RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PXSFMTW_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS),                                                VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Height"),                        RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PXSFMTH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS),                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Shadow Format: Dimensions"),                    RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_format_pixel_dimensions_string,        NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AMBIENT_CHANNEL),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Timecode: Wireless Channel"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AMBNTCH_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AMBNTCH_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_tc_channel,                EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(INTERNAL_AMBIENT)},
    {PARAM_NOR(RCP_PARAM_KEY_MAPPING_ACTION_LIST),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Actions"),                                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ACTION_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_DIALOG_LIST),                                                                VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Dialogs"),                                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_LIST,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DIALOGS_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_SCRIPT_LIST),                                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Scripts"),                                      RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CSCR_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_COLOR_SCIENCE),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Color Science"),                                RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_COLORSCI_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_COLORSCI_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_IMAGE_PIPELINE_MODE),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Mode"),                                         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_IMGPIPEM_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_IMGPIPEM_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SUPPORT_CONTACT),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Support Contact"),                              RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_VAL,      RCP_GC(RCP_SUPPORT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_LIST),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDLs"),                                  RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CCDL_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_APPLY),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDL: Apply"),                            RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCDLAPLY_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cdls,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_EXPORT_TO_MEDIA),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDL: Export to Media"),                  RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCDLE2M_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cdls_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_EXPORT_ALL_TO_MEDIA),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDL: Export All to Media"),              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCDLEA2M),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cdls_media,         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_CREATE),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDL: Create"),                           RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCDLCREA),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_CAMERA_CDL_DELETE),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Camera CDL: Delete"),                           RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_CCDLDEL_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_camera_cdls,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CDL_LIST),                                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Media CDLs"),                                   RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_MCDL_MSG_LIST_PTR),            RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_attached,            EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CDL_IMPORT_TO_CAMERA),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Media CDL: Import to Camera"),                  RCP_TYPE_STR,  RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MCDLI2C_MSG_STR_PTR),                         RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_cdls_media,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MEDIA_CDL_IMPORT_ALL_TO_CAMERA),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Media CDL: Import All to Camera"),              RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_MCDLIA2C),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_media_cdls_media,          EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SLATE_CAMERA_COLOR),                                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Slate: Camera Color"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_CAMCOLOR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_CAMCOLOR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_USER_LEFT),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Left: User Page"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUILPUSR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUILPUSR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_LEFT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_AUDIO_LEFT),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Left: Audio Page"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUILPAUD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUILPAUD_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_LEFT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_MONITOR_LEFT),                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Left: Monitor Page"),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUILPMON_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUILPMON_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_LEFT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Left: Auto Home"),                      RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUILAH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUILAH_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_LEFT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Left: Auto Home Timeout"),              RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUILAHTO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUILAHTO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_side_ui_auto_home_timeout, EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_LEFT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_USER_RIGHT),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Right: User Page"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUIRPUSR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUIRPUSR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_RIGHT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_AUDIO_RIGHT),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Right: Audio Page"),                    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUIRPAUD_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUIRPAUD_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_RIGHT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_PAGE_MONITOR_RIGHT),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Right: Monitor Page"),                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUIRPMON_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUIRPMON_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_RIGHT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Right: Auto Home"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUIRAH_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUIRAH_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_RIGHT)},
    {PARAM_NOR(RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT),                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Side UI Right: Auto Home Timeout"),             RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SUIRAHTO_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SUIRAHTO_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_side_ui_auto_home_timeout, EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(SIDE_UI_RIGHT)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1),                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_UHDSDI1M_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_UHDSDI1M_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_UHDSDI_1)},
    {PARAM_NOR(RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2),                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_UHDSDI2M_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_UHDSDI2M_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_UHDSDI_2)},
    {PARAM_NOR(RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI),                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("UHD: Frequency"),                               RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_UHDSDIF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_UHDSDIF_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_uhd_monitor,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_UHDSDI_1_2_SHARED)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("UHD: Display Preset"),                          RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPUHD_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPUHD_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_uhd_monitor,               EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_UHDSDI_1_2_SHARED)},
    {PARAM_NOR(RCP_PARAM_RETURN_FEED),                                                                VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Return Feed"),                                  RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_RTRNFEED_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_RETURN_FEED_STATE),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Return Feed: State"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_RTRNFST_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD),                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BLCDRF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDMIRF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI),                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BHDSDIRF_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF),                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_BEVFRF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD),                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PLCDRF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1),                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI1RF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2),                                      VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_PSDI2RF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF),                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_REVFRF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LCD3RF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVF3RF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT_PB,             COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3_RETURN_FEED)},
    {PARAM_NOR(RCP_PARAM_OUTPUT_TRANSFORM),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Output Transform: Output Color Space"),         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_OUTPUTTR_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_OUTPUTTR_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      _rcp_create_output_transform_string,               NULL,                               NULL,                                 NULL,                          _rcp_create_status_ipp2_output_options,       EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC,                    COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_LCD),                                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPLCD_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPLCD_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_HDMI),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPHDMI_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPHDMI_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDMI)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_HDSDI),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPHDSDI_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPHDSDI_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_HDSDI)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_EVF),                                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPEVF_MSG_INT),                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPEVF_MSG_LIST_PTR),           RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_BRAIN_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_REAR_LCD),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPRLCD_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPRLCD_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPPHDSD1_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPPHDSD1_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_1)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPPHDSD2_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPPHDSD2_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_HDSDI_2)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_REAR_EVF),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPREVF_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPREVF_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_REAR_LCD_EVF)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_LCD3),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPLCD3_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPLCD3_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_DISPLAY_PRESET_EVF3),                                                        VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_DPEVF3_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DPEVF3_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_monitor_curve,             EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(MON_LCD3_EVF3)},
    {PARAM_NOR(RCP_PARAM_OUTPUT_TONE_MAP),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Output Transform: Output Tone Map"),            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_NONE,     RCP_SGC(RCP_DEVCON_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_DEVCON_MSG_LIST_PTR),          RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_output_color_space,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT,                COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MIN_FRAME_PROCESSING_MODE),                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Frame Processing Mode: Min"),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MINFRPRM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_MAX_FRAME_PROCESSING_MODE),                                                  VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Frame Processing Mode: Max"),                   RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MAXFRPRM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_MIN_FRAME_PROCESSING_FRAME_COUNT),                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Frame Processing Frame Count: Min"),            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MINFRPRF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_MAX_FRAME_PROCESSING_FRAME_COUNT),                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Frame Processing Frame Count: Max"),            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MAXFRPRF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(FRAME_PROCESSING)},
    {PARAM_NOR(RCP_PARAM_ROLL_OFF),                                                                   VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Output Transform: Highlight Roll-Off"),         RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_ROLLOFF_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_ROLLOFF_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_output_color_space,        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PAT,                COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LOOKAROUND_AVAILABLE),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Look Around Available"),                        RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_FRMTLAST_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_LOG_VIEW_MODE),                                                              VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Log View"),                                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_LOGVWMDE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC_PAT,                COLOR_SCIENCE(IPP2), HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_AUTO_FOCUS_PEAK),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Lens: Auto Focus Peaking"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_AUTOPEAK_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_AUTOPEAK_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE),                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Timecode: Drop Frame Display Mode"),            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_TCDFMODE_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_TCDFMODE_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_drop_frame_display_mode,   EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(DROP_FRAME_TIMECODE)},
    {PARAM_NOR(RCP_PARAM_ISO_CAL2_ENABLED),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Image: Use updated ISO calibration"),            RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_ISOCAL2_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                        EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_PB,                     COLOR_SCIENCE(_),    HW_CAP(ALLOW_ISO_CALIBRATION1)},
    {PARAM_NOR(RCP_PARAM_SHUTDOWN_NOTIFICATION),                                                      VER_MIN(6, 60),                VER_RANGE_NONE(), LABEL("Shutdown"),                                     RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_S(RCP_SHUTDWNC),                                    RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, DISABLED_IN_REC,                    COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_LCD),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_BLCDLUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_EVF),                                                            VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_BEVFLUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_HDMI),                                                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_BHDMILUT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_HDSDI),                                                          VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_BSDILUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_REAR_LCD),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_RLCDLUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_REAR_EVF),                                                       VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_REVFLUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_REAR_HDSDI1),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_RSDI1FLT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_REAR_HDSDI2),                                                    VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_RSDI2FLT_MSG_STR_PTR),                       RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_BRAIN_LCD3),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_LCD3LUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MONITOR_LUT_BRAIN_EVF3),                                                     VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL_FP(_rcp_create_label_monitor),                   RCP_TYPE_NULL, RCP_TYPE_STR,           CACHE_NONE,     RCP_GC(RCP_EVF3LUT_MSG_STR_PTR),                        RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS),                                             VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Proxy: Baked-in Settings"),                     RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VCBAKED_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_SGC(RCP_VCBAKEDT_MSG_INT, VER_MIN(6, 50)),    RCP_LIST_GC(RCP_VCBAKED_MSG_LIST_PTR),         RCP_MIN(RCP_PARAM_MIN_RECORD_PROXY_BAKED_IN_SETTINGS), RCP_MAX(RCP_PARAM_MAX_RECORD_PROXY_BAKED_IN_SETTINGS), _rcp_create_list_string,                       NULL,                               NULL,                                 NULL,                          _rcp_create_status_video_codec_any,           EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PB,                 COLOR_SCIENCE(IPP2), HW_CAP(PRORES)},
    {PARAM_NOR(RCP_PARAM_MIN_RECORD_PROXY_BAKED_IN_SETTINGS),                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Proxy: Min Baked-in Settings"),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VCBAKMIN_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MAX_RECORD_PROXY_BAKED_IN_SETTINGS),                                         VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Proxy: Max Baked-in Settings"),                 RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_VCBAKMAX_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_SENSOR_SENSITIVITY),                           VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Sensor Sensitivity"),                           RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL_LIST, RCP_SGC(RCP_SENSTVTY_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_SENSTVTY_MSG_LIST_PTR),        RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CLOSE,  DISABLED_IN_REC_PB,                 COLOR_SCIENCE(_),    HW_CAP(SENSOR_SENSITIVITY)},    
    {PARAM_NOR(RCP_PARAM_QT_DROPPED_FRAMES),                                                          VER_MIN(6, 51),                VER_RANGE_NONE(), LABEL("QT Dropped Frames"),                            RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_QTDRPFRM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_MXF_DROPPED_FRAMES),                                                         VER_MIN(6, 51),                VER_RANGE_NONE(), LABEL("MXF Dropped Frames"),                           RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_MXFDRPFM_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_DROPPED_FRAMES),                                                             VER_MIN(5, 0),                 VER_RANGE_NONE(), LABEL("Dropped Frames"),                               RCP_TYPE_NULL, RCP_TYPE_NULL,          CACHE_NONE,     RCP_NONE(),                                             RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              _rcp_create_dropped_frames_int,     NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_PEAKING_LEVEL),                                VER_MIN(6, 60),                VER_RANGE_NONE(), LABEL("Peaking: Level"),                               RCP_TYPE_UINT, RCP_TYPE_UINT,          CACHE_VAL_LIST, RCP_SGC(RCP_PEAKLVL_MSG_UINT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_GC(RCP_PEAKLVL_MSG_LIST_PTR),         RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},                     
    {PARAM_NOR(RCP_PARAM_VOLTAGE_THRESHOLD),                                                          VER_MIN(6, 60),                VER_RANGE_NONE(), LABEL("Low Voltage Warning (Onboard): Voltage"),       RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_VOLTHSH_MSG_INT),                           RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_voltage_threshold,         EDIT_INFO(_rcp_edit_info_voltage_threshold), UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD),                                                   VER_MIN(6, 60),                VER_RANGE_NONE(), LABEL("Low Voltage Warning (Onboard): Enable"),        RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVOLTHSH_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_VOLTAGE_BELOW_THRESHOLD),                                                    VER_RANGE(V(6, 60), V(6, 60)), VER_RANGE_NONE(), LABEL("Voltage Below Low Voltage Warning Threshold"),  RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_VLTBLWTH_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_POWER_CURRENT_SOURCE_INDEX),                                                 VER_MIN(6, 50),                VER_RANGE_NONE(), LABEL("Power In Source Index"),                        RCP_TYPE_NULL, RCP_TYPE_INT,           CACHE_VAL,      RCP_GC(RCP_PWISRCI_MSG_INT),                            RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_VOLTAGE_THRESHOLD_DC_IN),                                                    VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL("Low Voltage Warning (DC-IN): DC IN Voltage"),   RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_VOLTHSDC_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          _rcp_create_status_voltage_threshold_dc_in,   EDIT_INFO(_rcp_edit_info_voltage_threshold_dc_in), UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,               COLOR_SCIENCE(_),    HW_CAP(_)},
    {PARAM_NOR(RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN),                                             VER_MIN(6, 61),                VER_RANGE_NONE(), LABEL("Low Voltage Warning (DC-IN): DC IN Enable"),    RCP_TYPE_INT,  RCP_TYPE_INT,           CACHE_VAL,      RCP_SGC(RCP_EVOLTHDC_MSG_INT),                          RCP_REL_NONE(),                                 RCP_LIST_REL_NONE(),                                     RCP_TGT_NONE(),                                       RCP_LIST_NONE(),                               RCP_MIN_NONE(),                                      RCP_MAX_NONE(),                                      NULL,                                              NULL,                               NULL,                                 NULL,                          NULL,                                         EDIT_INFO_NONE(),                            UPDATE_LIST_ON_CHANGE, ALWAYS_ENABLED,                     COLOR_SCIENCE(_),    HW_CAP(_)},

    /* ID                                                                                             Parameter Version Range        Set Version Range Label                                                  Set Type       Current Type            Cacheable       S/G/C/I Message                                         Set Relative and Version Range                  Set List Relative and Version Range                      S/G/C Target Message and Version Range                S/G/C/ List Messages                           Min Value for List                                   Max Value for List                                   Create String FP                                   Create Int FP                       Create List FP                        Set Int FP                     Create Status FP                              Edit Info                                    Update List When       Globals Disables                    Color Science        Hardware Capabilities */
    };

static const rcp_dependency_t rcp_dependency_table[] =
{
    /* Any incoming CURRENT for the items in the Source column will
     * re-trigger a GET for the item in the Target column.  This is
     * used primarily for composite parameters.  In this case, the
     * composite parameter is the Target, and the contributing
     * parameters are the Sources.*/

    /* Source                                     Target */
    {RCP_PARAM_RECORD_STATE_BASE,                 RCP_PARAM_RECORD_STATE                        },
    {RCP_PARAM_TETHERED_SERVER_STATE,             RCP_PARAM_RECORD_STATE                        },
    {RCP_PARAM_PRIMARY_STORAGE,                   RCP_PARAM_RECORD_STATE                        },
    /* note: since RCP_PARAM_TIMECODE is dependant on
     * RCP_PARAM_RECORD_STATE, it needs to be after it in this list,
     * and have the same dependencies as it.  */
    {RCP_PARAM_RECORD_STATE_BASE,                 RCP_PARAM_TIMECODE                            },
    {RCP_PARAM_TETHERED_SERVER_STATE,             RCP_PARAM_TIMECODE                            },
    {RCP_PARAM_PRIMARY_STORAGE,                   RCP_PARAM_TIMECODE                            },
    {RCP_PARAM_FRAME_PROCESSING_MODE,             RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_FRAME_PROCESSING_NUM,              RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_MM_SHUTTER_COLOR,                  RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_MM_INTEGRATION_TIME,               RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_MM_MODE,                           RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_AE_MODE,                           RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                  RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_EXPOSURE_INTEGRATION_TIME           },
    {RCP_PARAM_MM_SHUTTER_ANGLE,                  RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_MM_MODE,                           RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_MM_SHUTTER_COLOR,                  RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_AE_MODE,                           RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                  RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_EXPOSURE_ANGLE                      },
    {RCP_PARAM_MEDIA_VAL,                         RCP_PARAM_MEDIA_DISPLAY_VAL                   },
    {RCP_PARAM_MEDIA_TIME_REMAINING,              RCP_PARAM_MEDIA_DISPLAY_VAL                   },
    {RCP_PARAM_MEDIA_DISPLAY_MODE,                RCP_PARAM_MEDIA_DISPLAY_VAL                   },
    {RCP_PARAM_RECORD_MODE,                       RCP_PARAM_MEDIA_DISPLAY_VAL                   },
    {RCP_PARAM_POWER_VAL,                         RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_POWER_TIME_REMAINING,              RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_POWER_DISPLAY_MODE,                RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_PRIMARY_STORAGE,                   RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_POWER_CURRENT_SOURCE_INDEX,        RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_VOLTAGE_BELOW_THRESHOLD,           RCP_PARAM_POWER_DISPLAY_VAL                   },
    {RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD,          RCP_PARAM_POWER_DISPLAY_VAL                   },
    POWER_IN_CUR_TO_GET_DEPENEDENCIES,
    {RCP_PARAM_RECORD_MODE,                       RCP_PARAM_MEDIA_DISPLAY_LABEL                 },
    {RCP_PARAM_MEDIA_LABEL,                       RCP_PARAM_MEDIA_DISPLAY_LABEL                 },
    {RCP_PARAM_PRIMARY_STORAGE,                   RCP_PARAM_MEDIA_DISPLAY_LABEL                 },
    {RCP_PARAM_RECORD_HDR_MODE,                   RCP_PARAM_HDR_MODE                            },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_HDR_MODE                            },
    {RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,           RCP_PARAM_HDR_MODE                            },
    /* note: since RCP_PARAM_HDR_MODE_DETAILED is dependant on
     * RCP_PARAM_HDR_MODE, it needs to be after it in this list,
     * and have the same dependencies as it.  */
    {RCP_PARAM_RECORD_HDR_MODE,                   RCP_PARAM_HDR_MODE_DETAILED                   },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_HDR_MODE_DETAILED                   },
    {RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,           RCP_PARAM_HDR_MODE_DETAILED                   },
    /* note: since RCP_PARAM_HDR_MODE_DETAILED is dependant on
     * RCP_PARAM_HDR_MODE, it needs to be after it in this list,
     * and have the same dependencies as it.  */
    {RCP_PARAM_RECORD_HDR_MODE,                   RCP_PARAM_HDR_FACTOR                          },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_HDR_FACTOR                          },
    {RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,           RCP_PARAM_HDR_FACTOR                          },
    {RCP_PARAM_FOCUS_DIST_DISPLAY_MODE,           RCP_PARAM_FOCUS_DIST                          },
    {RCP_PARAM_FOCUS_DIST_NEAR,                   RCP_PARAM_FOCUS_DIST                          },
    {RCP_PARAM_FOCUS_DIST_FAR,                    RCP_PARAM_FOCUS_DIST                          },
    {RCP_PARAM_FRAME_PROCESSING_MODE,             RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_FRAME_PROCESSING_NUM,              RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_SHUTTER_DISPLAY_MODE,              RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_EXPOSURE_INTEGRATION_TIME,         RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_EXPOSURE_ANGLE,                    RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_MM_SHUTTER_COLOR,                  RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_MM_INTEGRATION_TIME,               RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_MM_SHUTTER_ANGLE,                  RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_MM_MODE,                           RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_AE_MODE,                           RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                  RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_EXPOSURE_DISPLAY                    },
    {RCP_PARAM_CORE_TEMP_WARNING_1,               RCP_PARAM_CORE_TEMP                           },
    {RCP_PARAM_CORE_TEMP_WARNING_2,               RCP_PARAM_CORE_TEMP                           },
    {RCP_PARAM_CORE_TEMP_WARNING_3,               RCP_PARAM_CORE_TEMP                           },
    {RCP_PARAM_CLIP_NAME_STATUS,                  RCP_PARAM_CLIP_NAME                           },
    {RCP_PARAM_MM_ISO_PULL,                       RCP_PARAM_ISO                                 },
    {RCP_PARAM_ND_VAL,                            RCP_PARAM_ISO                                 },
    {RCP_PARAM_SENSOR_SENSITIVITY,                RCP_PARAM_ISO                                 },
    {RCP_PARAM_SENSOR_SENSITIVITY,                RCP_PARAM_PLAYBACK_METADATA_ISO               },
    {RCP_PARAM_PROJECT_FRAME_RATE,                RCP_PARAM_SENSOR_FRAME_RATE                   },
    {RCP_PARAM_RECORD_FORMAT_NAME,                RCP_PARAM_RECORD_FORMAT                       },
    {RCP_PARAM_AE_MODE,                           RCP_PARAM_APERTURE                            },
    {RCP_PARAM_AE_LOCK_APERTURE,                  RCP_PARAM_APERTURE                            },
    {RCP_PARAM_APERTURE_CONTROL,                  RCP_PARAM_APERTURE                            },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_APERTURE                            },
    {RCP_PARAM_ND_VAL,                            RCP_PARAM_ND_DISPLAY_VAL                      },
    {RCP_PARAM_MM_MODE,                           RCP_PARAM_ND_DISPLAY_VAL                      },
    {RCP_PARAM_MM_ND_MODE,                        RCP_PARAM_ND_DISPLAY_VAL                      },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_REDCODE                             },
    {RCP_PARAM_CALIBRATION_STATUS,                RCP_PARAM_CALIBRATION_STATUS_TEMPERATURE      },
    {RCP_PARAM_CALIBRATION_STATUS,                RCP_PARAM_CALIBRATION_STATUS_EXPOSURE         },
    {RCP_PARAM_PROJECT_FRAME_RATE,                RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_RECORD_MODE,                       RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_VARISPEED_MODE,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH12_STATE,                  RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH34_STATE,                  RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH1_NAME,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH2_NAME,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH3_NAME,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH4_NAME,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_VU_METER_SOURCE,             RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH12_OUTPUT_NAME,            RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH34_OUTPUT_NAME,            RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_AUDIO_CH56_OUTPUT_NAME,            RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_BWF_VALID,                         RCP_PARAM_AUDIO_VU_DATA                       },
    {RCP_PARAM_PLAYBACK_CLIP_DATE,                RCP_PARAM_PLAYBACK_CLIP_DATE_TIME             },
    {RCP_PARAM_PLAYBACK_CLIP_TIME,                RCP_PARAM_PLAYBACK_CLIP_DATE_TIME             },
    {RCP_PARAM_WIFI_MODE,                         RCP_PARAM_WIFI_STATE_DETAILED                 },
    {RCP_PARAM_WIFI_AD_HOC_SSID,                  RCP_PARAM_WIFI_STATE_DETAILED                 },
    {RCP_PARAM_WIFI_INFRASTRUCTURE_SSID,          RCP_PARAM_WIFI_STATE_DETAILED                 },
    {RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE,      RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS        },
    {RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE,       RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS         },
    {RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE,     RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS       },
    {RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE,          RCP_PARAM_POWER_OUT_BAT_AUX_STATUS            },
    {RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE,      RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS        },
    {RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE,         RCP_PARAM_POWER_OUT_REAR_AUX_STATUS           },
    {RCP_PARAM_POWER_OUT_TIMECODE_ENABLE,         RCP_PARAM_POWER_OUT_TIMECODE_STATUS           },
    {RCP_PARAM_REDCODE,                           RCP_PARAM_QUALITY                             },
    {RCP_PARAM_RECORD_FILE_FORMAT,                RCP_PARAM_QUALITY                             },
    {RCP_PARAM_RECORD_VIDEO_CODEC,                RCP_PARAM_QUALITY                             },
    {RCP_PARAM_RECORD_VIDEO_MXF_CODEC,            RCP_PARAM_QUALITY                             },
    {RCP_PARAM_PLAYBACK_STATE,                    RCP_PARAM_QUALITY                             },
    {RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID,   RCP_PARAM_QUALITY                             },
    {RCP_PARAM_PRIMARY_STORAGE,                   RCP_PARAM_QUALITY                             },
    {RCP_PARAM_PRORES_WIDTH,                      RCP_PARAM_PRORES_DIMENSION                    },
    {RCP_PARAM_PRORES_HEIGHT,                     RCP_PARAM_PRORES_DIMENSION                    },
    {RCP_PARAM_MXF_WIDTH,                         RCP_PARAM_MXF_DIMENSION                       },
    {RCP_PARAM_MXF_HEIGHT,                        RCP_PARAM_MXF_DIMENSION                       },
    {RCP_PARAM_SENSOR_FRAME_RATE,                 RCP_PARAM_PROXY_ENCODE_FRAMERATE              },
    {RCP_PARAM_SENSOR_FRAME_RATE,                 RCP_PARAM_PRORES_ENCODE_FRAMERATE             },
    {RCP_PARAM_SENSOR_FRAME_RATE,                 RCP_PARAM_MXF_ENCODE_FRAMERATE                },
    {RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION,     RCP_PARAM_MIN_RECORD_VIDEO_CODEC              },
    {RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION, RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC          },
    {RCP_PARAM_TINT,                              RCP_PARAM_COLOR_TEMPERATURE                   },
    {RCP_PARAM_PLAYBACK_METADATA_TINT,            RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE },
    {RCP_PARAM_SENSOR_WIDTH_PHY,                  RCP_PARAM_SENSOR_DIMENSIONS_PHY               },
    {RCP_PARAM_SENSOR_HEIGHT_PHY,                 RCP_PARAM_SENSOR_DIMENSIONS_PHY               },
    {RCP_PARAM_SENSOR_WIDTH_PHY,                  RCP_PARAM_FORMAT_WIDTH_PHY                    },
    {RCP_PARAM_FORMAT_WIDTH_PIXELS,               RCP_PARAM_FORMAT_WIDTH_PHY                    },
    {RCP_PARAM_SENSOR_HEIGHT_PHY,                 RCP_PARAM_FORMAT_HEIGHT_PHY                   },
    {RCP_PARAM_FORMAT_HEIGHT_PIXELS,              RCP_PARAM_FORMAT_HEIGHT_PHY                   },
    {RCP_PARAM_FORMAT_WIDTH_PHY,                  RCP_PARAM_FORMAT_DIMENSIONS_PHY               },
    {RCP_PARAM_FORMAT_HEIGHT_PHY,                 RCP_PARAM_FORMAT_DIMENSIONS_PHY               },
    {RCP_PARAM_FORMAT_WIDTH_PIXELS,               RCP_PARAM_FORMAT_DIMENSIONS_PIXELS            },
    {RCP_PARAM_FORMAT_HEIGHT_PIXELS,              RCP_PARAM_FORMAT_DIMENSIONS_PIXELS            },
    {RCP_PARAM_SENSOR_WIDTH_PHY,                  RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY             },
    {RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS,        RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY             },
    {RCP_PARAM_SENSOR_HEIGHT_PHY,                 RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY            },
    {RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS,       RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY            },
    {RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY,           RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY        },
    {RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY,          RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY        },
    {RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS,        RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS     },
    {RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS,       RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS     },
    {RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE,      RCP_PARAM_GIGE_STATE_DETAILED                 },
    {RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS,       RCP_PARAM_GIGE_STATE_DETAILED                 },
    {RCP_PARAM_TIMECODE_SOURCE,                   RCP_PARAM_TIMECODE_STATE_DETAILED             },
    {RCP_PARAM_RECORD_FILE_FORMAT,                RCP_PARAM_DROPPED_FRAMES                      },
    {RCP_PARAM_R3D_DROPPED_FRAMES,                RCP_PARAM_DROPPED_FRAMES                      },
    {RCP_PARAM_QT_DROPPED_FRAMES,                 RCP_PARAM_DROPPED_FRAMES                      },
    {RCP_PARAM_MXF_DROPPED_FRAMES,                RCP_PARAM_DROPPED_FRAMES                      },

};

static const rcp_dependency_t rcp_dependency_table_cur_list_to_create_list[] =
{
    /* Any incoming CURRENT LIST for the items in the Source column will
     * re-trigger a GET LIST for the item in the Target column.  This is
     * used primarily for composite parameters.  In this case, the
     * composite parameter is the Target, and the contributing
     * parameters are the Sources.*/

    /* Source                             Target */
    {RCP_PARAM_EXPOSURE_INTEGRATION_TIME, RCP_PARAM_EXPOSURE_DISPLAY},
    {RCP_PARAM_EXPOSURE_ANGLE,            RCP_PARAM_EXPOSURE_DISPLAY}
};

static const rcp_dependency_t rcp_dependency_table_cur_to_get_list[] =
{
    /* Any incoming CURRENT for the items in the Source column will
     * re-trigger a GET LIST for the item in the Target column.  This is
     * used primarily for composite parameters.  In this case, the
     * composite parameter is the Target, and the contributing
     * parameters are the Sources.*/

    /* Source                                  Target */
    {RCP_PARAM_SHUTTER_DISPLAY_MODE,           RCP_PARAM_EXPOSURE_DISPLAY               },
    {RCP_PARAM_AUDIO_CH12_SOURCE,              RCP_PARAM_AUDIO_CH34_SOURCE              },
    {RCP_PARAM_AUDIO_CH12_SOURCE,              RCP_PARAM_AUDIO_CH1_MODE                 },
    {RCP_PARAM_AUDIO_CH12_SOURCE,              RCP_PARAM_AUDIO_CH2_MODE                 },
    {RCP_PARAM_AUDIO_CH12_SOURCE,              RCP_PARAM_AUDIO_CH1_GAIN                 },
    {RCP_PARAM_AUDIO_CH12_SOURCE,              RCP_PARAM_AUDIO_CH2_GAIN                 },
    {RCP_PARAM_AUDIO_CH34_SOURCE,              RCP_PARAM_AUDIO_CH12_SOURCE              },
    {RCP_PARAM_AUDIO_CH34_SOURCE,              RCP_PARAM_AUDIO_CH3_MODE                 },
    {RCP_PARAM_AUDIO_CH34_SOURCE,              RCP_PARAM_AUDIO_CH4_MODE                 },
    {RCP_PARAM_AUDIO_CH34_SOURCE,              RCP_PARAM_AUDIO_CH3_GAIN                 },
    {RCP_PARAM_AUDIO_CH34_SOURCE,              RCP_PARAM_AUDIO_CH4_GAIN                 },
    {RCP_PARAM_AUDIO_CH1_MODE,                 RCP_PARAM_AUDIO_CH1_GAIN                 },
    {RCP_PARAM_AUDIO_CH2_MODE,                 RCP_PARAM_AUDIO_CH2_GAIN                 },
    {RCP_PARAM_AUDIO_CH3_MODE,                 RCP_PARAM_AUDIO_CH3_GAIN                 },
    {RCP_PARAM_AUDIO_CH4_MODE,                 RCP_PARAM_AUDIO_CH4_GAIN                 },
    {RCP_PARAM_FOCUS_CONTROL,                  RCP_PARAM_AF_MODE                        },
    {RCP_PARAM_PRIMARY_STORAGE,                RCP_PARAM_RECORD_MODE                    },
    {RCP_PARAM_MONITOR_RESOLUTION_HDMI,        RCP_PARAM_MONITOR_FREQ_HDMI              },
    {RCP_PARAM_MONITOR_RESOLUTION_HDSDI,       RCP_PARAM_MONITOR_FREQ_HDSDI             },
    {RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1, RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1       },
    {RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2, RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_OVERLAY_LIST             },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_LUT_LIST                 },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_CAL_LIST                 },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_PRESET_LIST              },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_LOOK_LIST                },
    {RCP_PARAM_MEDIA_IS_ATTACHED,              RCP_PARAM_MEDIA_CDL_LIST                 },
    {RCP_PARAM_LUT_FEED_1,                     RCP_PARAM_OUTPUT_TONE_MAP                },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_LCD             },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_HDMI            },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_HDSDI           },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_EVF             },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_REAR_LCD        },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1     },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2     },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_REAR_EVF        },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_LCD3            },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_DISPLAY_PRESET_EVF3            },
    {RCP_PARAM_OUTPUT_TRANSFORM,               RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS }
};

static const rcp_dependency_t rcp_dependency_table_cur_list_to_get[] =
{
    /* Any incoming CURRENT LIST for the items in the Source column will
     * re-trigger a GET for the item in the Target column.  This is
     * used primarily for composite parameters.  In this case, the
     * composite parameter is the Target, and the contributing
     * parameters are the Sources.*/

    /* Source                                     Target */
    {RCP_PARAM_MM_MODE,                           RCP_PARAM_ND_DISPLAY_VAL                    },
    {RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS,    RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS    }
};

static const rcp_dependency_t rcp_dependency_table_cur_to_get_status[] =
{
    /* Any incoming CURRENT for the items in the Source column will
     * re-trigger a GET STATUS for the item in the Target column. */

    /* Source                                          Target */
    {RCP_PARAM_APERTURE_CONTROL,                       RCP_PARAM_APERTURE                             },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_APERTURE                             },
    {RCP_PARAM_AE_LOCK_APERTURE,                       RCP_PARAM_APERTURE                             },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_FOCUS_DIST                           },
    {RCP_PARAM_FOCUS_CONTROL,                          RCP_PARAM_FOCUS_DIST                           },
    {RCP_PARAM_FAN_MODE,                               RCP_PARAM_FAN_REC_SPEED                        },
    {RCP_PARAM_FAN_MODE,                               RCP_PARAM_FAN_PREVIEW_SPEED                    },
    {RCP_PARAM_FAN_MODE,                               RCP_PARAM_FAN_TARGET_TEMPERATURE               },
    {RCP_PARAM_FAN_MODE,                               RCP_PARAM_FAN_DELAY                            },
    {RCP_PARAM_ACES_PROXY,                             RCP_PARAM_COLOR_SPACE                          },
    {RCP_PARAM_VIDEO_SOURCE,                           RCP_PARAM_COLOR_SPACE                          },
    {RCP_PARAM_ACES_PROXY,                             RCP_PARAM_GAMMA_SPACE                          },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_GAMMA_SPACE                          },
    {RCP_PARAM_VIDEO_SOURCE,                           RCP_PARAM_GAMMA_SPACE                          },
    {RCP_PARAM_MONITOR_MODE_LCD,                       RCP_PARAM_MONITOR_OVERLAY_LCD                  },
    {RCP_PARAM_MONITOR_MODE_LCD,                       RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD           },
    {RCP_PARAM_MONITOR_MODE_LCD,                       RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD           },
    {RCP_PARAM_MONITOR_MODE_LCD,                       RCP_PARAM_MONITOR_DOCK_MENUS_LCD               },
    {RCP_PARAM_MONITOR_MODE_LCD,                       RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD        },
    {RCP_PARAM_MONITOR_MODE_HDMI,                      RCP_PARAM_MONITOR_OVERLAY_HDMI                 },
    {RCP_PARAM_MONITOR_MODE_HDMI,                      RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI          },
    {RCP_PARAM_MONITOR_MODE_HDMI,                      RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI          },
    {RCP_PARAM_MONITOR_MODE_HDMI,                      RCP_PARAM_MONITOR_DOCK_MENUS_HDMI              },
    {RCP_PARAM_MONITOR_MODE_HDMI,                      RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI       },
    {RCP_PARAM_MONITOR_MODE_HDSDI,                     RCP_PARAM_MONITOR_OVERLAY_HDSDI                },
    {RCP_PARAM_MONITOR_MODE_HDSDI,                     RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI         },
    {RCP_PARAM_MONITOR_MODE_HDSDI,                     RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI         },
    {RCP_PARAM_MONITOR_MODE_HDSDI,                     RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI             },
    {RCP_PARAM_MONITOR_MODE_HDSDI,                     RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI      },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_OVERLAY_HDSDI                },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI         },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI         },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI             },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_CURVE_HDSDI                  },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_DISPLAY_PRESET_HDSDI                 },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_MODE_HDSDI                   },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_RESOLUTION_HDSDI             },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_FREQ_HDSDI                   },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_TOOLS_HDSDI                  },
    {RCP_PARAM_MONITOR_ENABLE_HDSDI,                   RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI             },
    {RCP_PARAM_MONITOR_MODE_EVF,                       RCP_PARAM_MONITOR_OVERLAY_EVF                  },
    {RCP_PARAM_MONITOR_MODE_EVF,                       RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF           },
    {RCP_PARAM_MONITOR_MODE_EVF,                       RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF           },
    {RCP_PARAM_MONITOR_MODE_EVF,                       RCP_PARAM_MONITOR_DOCK_MENUS_EVF               },
    {RCP_PARAM_MONITOR_MODE_EVF,                       RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF        },
    {RCP_PARAM_MONITOR_MODE_REAR_LCD,                  RCP_PARAM_MONITOR_OVERLAY_REAR_LCD             },
    {RCP_PARAM_MONITOR_MODE_REAR_LCD,                  RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD      },
    {RCP_PARAM_MONITOR_MODE_REAR_LCD,                  RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD      },
    {RCP_PARAM_MONITOR_MODE_REAR_LCD,                  RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD          },
    {RCP_PARAM_MONITOR_MODE_REAR_LCD,                  RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD   },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1          },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1   },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1   },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1       },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI1,               RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1},
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1          },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1   },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1   },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1       },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1            },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1           },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_MODE_REAR_HDSDI1             },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1       },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1             },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1            },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1,             RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1       },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2          },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2   },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2   },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2       },
    {RCP_PARAM_MONITOR_MODE_REAR_HDSDI2,               RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2},
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2          },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2   },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2   },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2       },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2            },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2           },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_MODE_REAR_HDSDI2             },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2       },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2             },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2            },
    {RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2,             RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2       },
    {RCP_PARAM_MONITOR_MODE_REAR_EVF,                  RCP_PARAM_MONITOR_OVERLAY_REAR_EVF             },
    {RCP_PARAM_MONITOR_MODE_REAR_EVF,                  RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF      },
    {RCP_PARAM_MONITOR_MODE_REAR_EVF,                  RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF      },
    {RCP_PARAM_MONITOR_MODE_REAR_EVF,                  RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF          },
    {RCP_PARAM_MONITOR_MODE_REAR_EVF,                  RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_LCD                    },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_HDMI                   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_HDSDI                  },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_EVF                    },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_REAR_LCD               },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1            },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2            },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_REAR_EVF               },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_LCD                   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_HDMI                  },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_HDSDI                 },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_EVF                   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_REAR_LCD              },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1           },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2           },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_REAR_EVF              },
    {RCP_PARAM_TIMECODE_SOURCE,                        RCP_PARAM_SET_TIMECODE                         },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_USER_AR_NUM              },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_SCALE                    },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_X_OFFSET                 },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_Y_OFFSET                 },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_ABS_X_OFFSET             },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_ABS_Y_OFFSET             },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_ABS_W                    },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_ABS_H                    },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_LINE_STYLE               },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_COLOR                    },
    {RCP_PARAM_FRAME_GUIDE_MODE,                       RCP_PARAM_FRAME_GUIDE_OPACITY                  },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_USER_AR_NUM             },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_SCALE                   },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_X_OFFSET                },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_Y_OFFSET                },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_ABS_X_OFFSET            },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_ABS_Y_OFFSET            },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_ABS_W                   },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_ABS_H                   },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_LINE_STYLE              },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_COLOR                   },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_OPACITY                 },
    {RCP_PARAM_ACTION_GUIDE_MODE,                      RCP_PARAM_ACTION_GUIDE_RELATIVE                },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_USER_AR_NUM              },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_SCALE                    },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_X_OFFSET                 },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_Y_OFFSET                 },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_ABS_X_OFFSET             },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_ABS_Y_OFFSET             },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_ABS_W                    },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_ABS_H                    },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_LINE_STYLE               },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_COLOR                    },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_OPACITY                  },
    {RCP_PARAM_TITLE_GUIDE_MODE,                       RCP_PARAM_TITLE_GUIDE_RELATIVE                 },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_AF_ENHANCED_MONITOR                  },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE            },
    {RCP_PARAM_MM_MODE,                                RCP_PARAM_AE_MODE                              },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_EV_SHIFT                          },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_METERING_MODE                     },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_SPEED                             },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_SELECTION                         },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_LOCK_APERTURE                     },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_LOCK_EXPOSURE                     },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_AE_EXPOSURE_PRIORITY                 },
    {RCP_PARAM_BEEP_ENABLE,                            RCP_PARAM_BEEP_RECORD_START                    },
    {RCP_PARAM_BEEP_ENABLE,                            RCP_PARAM_BEEP_RECORD_STOP                     },
    {RCP_PARAM_BEEP_ENABLE,                            RCP_PARAM_BEEP_TAG_STILL_FRAME                 },
    {RCP_PARAM_FRAME_PROCESSING_MODE,                  RCP_PARAM_FRAME_PROCESSING_NUM                 },
    {RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE,           RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS          },
    {RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE,           RCP_PARAM_GIGABIT_ETHERNET_NETMASK             },
    {RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE,           RCP_PARAM_GIGABIT_ETHERNET_GATEWAY             },
    {RCP_PARAM_WIFI_DHCP_ENABLE,                       RCP_PARAM_WIFI_IP_ADDRESS                      },
    {RCP_PARAM_WIFI_DHCP_ENABLE,                       RCP_PARAM_WIFI_NETMASK                         },
    {RCP_PARAM_WIFI_DHCP_ENABLE,                       RCP_PARAM_WIFI_GATEWAY                         },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_NETMASK                         },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_GATEWAY                         },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_DHCP_ENABLE                     },
    {RCP_PARAM_AUDIO_CH1_48V_PRESENT,                  RCP_PARAM_AUDIO_CH1_48V_POWER                  },
    {RCP_PARAM_AUDIO_CH2_48V_PRESENT,                  RCP_PARAM_AUDIO_CH2_48V_POWER                  },
    {RCP_PARAM_AUDIO_CH3_48V_PRESENT,                  RCP_PARAM_AUDIO_CH3_48V_POWER                  },
    {RCP_PARAM_AUDIO_CH4_48V_PRESENT,                  RCP_PARAM_AUDIO_CH4_48V_POWER                  },
    {RCP_PARAM_AUDIO_CH1_LIMITER_PRESENT,              RCP_PARAM_AUDIO_CH1_LIMITER                    },
    {RCP_PARAM_AUDIO_CH2_LIMITER_PRESENT,              RCP_PARAM_AUDIO_CH2_LIMITER                    },
    {RCP_PARAM_AUDIO_CH3_LIMITER_PRESENT,              RCP_PARAM_AUDIO_CH3_LIMITER                    },
    {RCP_PARAM_AUDIO_CH4_LIMITER_PRESENT,              RCP_PARAM_AUDIO_CH4_LIMITER                    },
    {RCP_PARAM_SLATE_SCENE,                            RCP_PARAM_SLATE_TAKE                           },
    {RCP_PARAM_SLATE_SCENE,                            RCP_PARAM_SLATE_SHOT                           },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_LIMIT_ENABLE                  },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_RECORD_LIMIT_ENABLE                  },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_LIMIT_FRAMES                  },
    {RCP_PARAM_RECORD_LIMIT_ENABLE,                    RCP_PARAM_RECORD_LIMIT_FRAMES                  },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_RECORD_LIMIT_FRAMES                  },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_TIMELAPSE_FRAMES              },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_TIMELAPSE_INTERVAL            },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_PRE_FRAME_COUNT               },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_POST_FRAME_COUNT              },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_PRE_FRAME_COUNT_AVAILABLE     },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_POST_FRAME_COUNT_AVAILABLE    },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_PRE_FRAME_COUNT_ACTUAL        },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_POST_FRAME_COUNT_ACTUAL       },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_MODE                         },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_MODE                         },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_IRE_LOW                      },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_IRE_HIGH                     },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_PATTERN                      },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_COLOR                        },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_PATTERN                      },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_COLOR                        },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_IRE_LOW                      },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_IRE_HIGH                     },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_STOPS_LOW                    },
    {RCP_PARAM_ZEBRA_1_ENABLE,                         RCP_PARAM_ZEBRA_1_STOPS_HIGH                   },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_STOPS_LOW                    },
    {RCP_PARAM_ZEBRA_1_MODE,                           RCP_PARAM_ZEBRA_1_STOPS_HIGH                   },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_IRE_LOW                      },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_IRE_HIGH                     },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_IRE_LOW                      },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_IRE_HIGH                     },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_STOPS_LOW                    },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_STOPS_HIGH                   },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_STOPS_LOW                    },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_STOPS_HIGH                   },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_PATTERN                      },
    {RCP_PARAM_ZEBRA_2_ENABLE,                         RCP_PARAM_ZEBRA_2_COLOR                        },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_COLOR                        },
    {RCP_PARAM_ZEBRA_2_MODE,                           RCP_PARAM_ZEBRA_2_PATTERN                      },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_EXPOSURE_DISPLAY                     },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                       RCP_PARAM_EXPOSURE_DISPLAY                     },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_EXPOSURE_INTEGRATION_TIME            },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                       RCP_PARAM_EXPOSURE_INTEGRATION_TIME            },
    {RCP_PARAM_AE_MODE,                                RCP_PARAM_EXPOSURE_ANGLE                       },
    {RCP_PARAM_AE_LOCK_EXPOSURE,                       RCP_PARAM_EXPOSURE_ANGLE                       },
    /* note: since RCP_PARAM_HDR_MONITOR_TRACK is dependant on
     * RCP_PARAM_HDR_MODE, it needs to have the same dependants as
     * RCP_PARAM_HDR_MODE instead of RCP_PARAM_HDR_MODE  */
    {RCP_PARAM_RECORD_HDR_MODE,                        RCP_PARAM_HDR_MONITOR_TRACK                    },
    {RCP_PARAM_PLAYBACK_STATE,                         RCP_PARAM_HDR_MONITOR_TRACK                    },
    {RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,                RCP_PARAM_HDR_MONITOR_TRACK                    },
    /* note: since RCP_PARAM_HDR_FACTOR is dependant on
     * RCP_PARAM_HDR_MODE, it needs to have the same dependants as
     * RCP_PARAM_HDR_MODE instead of RCP_PARAM_HDR_MODE  */
    {RCP_PARAM_RECORD_HDR_MODE,                        RCP_PARAM_HDR_FACTOR                           },
    {RCP_PARAM_PLAYBACK_STATE,                         RCP_PARAM_HDR_FACTOR                           },
    {RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS,                RCP_PARAM_HDR_FACTOR                           },
    {RCP_PARAM_TARGET,                                 RCP_PARAM_TARGET_ID                            },
    {RCP_PARAM_AUDIO_CH12_SOURCE,                      RCP_PARAM_AUDIO_CH1_GAIN                       },
    {RCP_PARAM_AUDIO_CH12_SOURCE,                      RCP_PARAM_AUDIO_CH2_GAIN                       },
    {RCP_PARAM_AUDIO_CH34_SOURCE,                      RCP_PARAM_AUDIO_CH3_GAIN                       },
    {RCP_PARAM_AUDIO_CH34_SOURCE,                      RCP_PARAM_AUDIO_CH4_GAIN                       },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD,      RCP_PARAM_MONITOR_FLIP_MIRROR_LCD              },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD,      RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD           },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD,      RCP_PARAM_MONITOR_VIDEO_FLIP_LCD               },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD, RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD         },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD, RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD      },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD, RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD          },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF,RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF           },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF,RCP_PARAM_MONITOR_VIDEO_FLIP_EVF               },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF,RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF        },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF, RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF      },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF, RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF          },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF, RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF         },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM             },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT_REEL_NO                 },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT_CAMERA_ID               },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT_CAMERA_POS              },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT_EDGE_TC_START           },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_FORMAT                         },
    {RCP_PARAM_MEDIA_IS_PRESENT,                       RCP_PARAM_MEDIA_SECURE_FORMAT                  },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_EJECT                          },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM             },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT_REEL_NO                 },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT_CAMERA_ID               },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT_CAMERA_POS              },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT_EDGE_TC_START           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_FORMAT                         },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_SECURE_FORMAT                  },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_ACTIVE_MEDIA                   },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_DOWNLOAD_FIRMWARE              },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_PRESET_EXPORT_TO_MEDIA        },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_PRESET_EXPORT_ALL_TO_MEDIA    },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_PRESET_LIST                    },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_PRESET_IMPORT_TO_CAMERA        },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_PRESET_IMPORT_ALL_TO_CAMERA    },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_LOOK_EXPORT_TO_MEDIA          },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_LOOK_EXPORT_ALL_TO_MEDIA      },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LOOK_LIST                      },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LOOK_IMPORT_TO_CAMERA          },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LOOK_IMPORT_ALL_TO_CAMERA      },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_ZONE                              },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE            },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_SIZE                              },
    {RCP_PARAM_AF_ZONE,                                RCP_PARAM_AF_SIZE                              },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_RACK_SPEED                        },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_RACK_NUMBER_OF_POINTS             },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_RACK_TO_POINT                     },
    {RCP_PARAM_TEST_PATTERN,                           RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_SENSOR_SYNC_MODE,                       RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_MM_MODE,                                RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_FRAME_PROCESSING_MODE,                  RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_RECORD_HDR_MODE                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_A_FPS                           },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_A_DURATION                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_B_FPS                           },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_B_DURATION                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_C_FPS                           },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_C_DURATION                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_D_FPS                           },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_D_DURATION                      },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_RAMP_RESET_DURATION                  },
    {RCP_PARAM_RECORD_STATE_BASE,                      RCP_PARAM_EXPOSURE_INTEGRATION_TIME            },
    {RCP_PARAM_RECORD_STATE_BASE,                      RCP_PARAM_EXPOSURE_ANGLE                       },
    {RCP_PARAM_RECORD_STATE_BASE,                      RCP_PARAM_EXPOSURE_DISPLAY                     },
    {RCP_PARAM_RECORD_HDR_MODE,                        RCP_PARAM_EXPOSURE_INTEGRATION_TIME            },
    {RCP_PARAM_RECORD_HDR_MODE,                        RCP_PARAM_EXPOSURE_ANGLE                       },
    {RCP_PARAM_RECORD_HDR_MODE,                        RCP_PARAM_EXPOSURE_DISPLAY                     },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_OVERLAY_EXPORT_TO_MEDIA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_OVERLAY_EXPORT_ALL_TO_MEDIA   },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_OVERLAY_LIST                   },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_OVERLAY_IMPORT_TO_CAMERA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_OVERLAY_IMPORT_ALL_TO_CAMERA   },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_LUT_EXPORT_TO_MEDIA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_LUT_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LUT_LIST                       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LUT_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_LUT_IMPORT_ALL_TO_CAMERA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_CAL_LIST                      },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_CAL_EXPORT_TO_MEDIA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_CAL_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CAL_LIST                       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CAL_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CAL_IMPORT_ALL_TO_CAMERA       },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_RACK_POINT_SELECT                 },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_WINDOW_POS_X                      },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_WINDOW_POS_Y                      },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_AF_WINDOW_POS_MOVE_COMPLETE          },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_MODE_HDMI                    },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_MODE_HDSDI                   },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_MODE_HDMI                    },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_MODE_HDSDI                   },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_OVERLAY_HDMI                 },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_OVERLAY_HDSDI                },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_OVERLAY_HDMI                 },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_OVERLAY_HDSDI                },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_RESOLUTION_HDMI              },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_RESOLUTION_HDSDI             },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_RESOLUTION_HDMI              },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_RESOLUTION_HDSDI             },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_FREQ_HDMI                    },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_FREQ_HDSDI                   },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_FREQ_HDMI                    },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_FREQ_HDSDI                   },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_CURVE_HDMI                   },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_CURVE_HDSDI                  },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_CURVE_HDMI                   },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_CURVE_HDSDI                  },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_DISPLAY_PRESET_HDMI                  },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_DISPLAY_PRESET_HDSDI                 },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_DISPLAY_PRESET_HDMI                  },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_DISPLAY_PRESET_HDSDI                 },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_TOOLS_HDMI                   },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_TOOLS_HDSDI                  },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_TOOLS_HDMI                   },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_TOOLS_HDSDI                  },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI          },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI         },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI          },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI         },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI              },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI             },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI              },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI             },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI          },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI         },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI          },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI         },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_DOCK_MENUS_HDMI              },
    {RCP_PARAM_AF_ENHANCED_MONITOR,                    RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI             },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_DOCK_MENUS_HDMI              },
    {RCP_PARAM_AF_ENHANCED_ENABLE,                     RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI             },
    {RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE,    RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE  },
    {RCP_PARAM_COLOR_TEMPERATURE,                      RCP_PARAM_COLOR_TEMPERATURE                    },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_VIDEO_CODEC                   },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION        },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_VIDEO_MXF_CODEC               },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION    },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_VIDEO_CODEC_FEED              },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_REDCODE                              },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRORES_WIDTH                         },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRORES_HEIGHT                        },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRORES_DIMENSION                     },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_MXF_WIDTH                            },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_MXF_HEIGHT                           },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_MXF_DIMENSION                        },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PROXY_ENCODE_FRAMERATE               },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRORES_ENCODE_FRAMERATE              },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_MXF_ENCODE_FRAMERATE                 },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_REDCODE                              },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_RECORD_FILE_FORMAT                   },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_QUALITY                              },
    {RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE,            RCP_PARAM_REMOTE_CONTROL_PANEL_ADDRESS         },
    {RCP_PARAM_FALSE_COLOR_MODE,                       RCP_PARAM_GIO_SCOPE_PRIMARY_COLORS             },
    {RCP_PARAM_FALSE_COLOR_MODE,                       RCP_PARAM_GIO_SCOPE_SECONDARY_COLORS           },
    {RCP_PARAM_FALSE_COLOR_MODE,                       RCP_PARAM_GIO_SCOPE_ZONES                      },
    {RCP_PARAM_AUDIO_CH1_MUTE,                         RCP_PARAM_AUDIO_CH1_VOL                        },
    {RCP_PARAM_AUDIO_CH2_MUTE,                         RCP_PARAM_AUDIO_CH2_VOL                        },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_AD_HOC_ENCRYPTION               },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_AD_HOC_PASSPHRASE               },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_CHANNEL                         },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION       },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE       },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_CONNECT                         },
    {RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION,         RCP_PARAM_WIFI_CONNECT                         },
    {RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE,         RCP_PARAM_WIFI_CONNECT                         },
    {RCP_PARAM_WIFI_STATE,                             RCP_PARAM_WIFI_CONNECT                         },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_SCAN                            },
    {RCP_PARAM_WIFI_STATE,                             RCP_PARAM_WIFI_SCAN                            },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_SCAN_RESULTS                    },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_SCAN_SELECT                     },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_AD_HOC_SSID                     },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_INFRASTRUCTURE_SSID             },
    {RCP_PARAM_WIFI_AD_HOC_ENCRYPTION,                 RCP_PARAM_WIFI_AD_HOC_PASSPHRASE               },
    {RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION,         RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE       },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_SIGNAL                          },
    {RCP_PARAM_WIFI_STATE,                             RCP_PARAM_WIFI_SIGNAL                          },
    {RCP_PARAM_WIFI_MODE,                              RCP_PARAM_WIFI_IP_ADDRESS                      },
    {RCP_PARAM_WIFI_STATE,                             RCP_PARAM_WIFI_IP_ADDRESS                      },
    {RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE,           RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET          },
    {RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS,           RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET          },
    {RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE,            RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET           },
    {RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS,            RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET           },
    {RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE,          RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET         },
    {RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS,          RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET         },
    {RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE,               RCP_PARAM_POWER_OUT_BAT_AUX_RESET              },
    {RCP_PARAM_POWER_OUT_BAT_AUX_STATUS,               RCP_PARAM_POWER_OUT_BAT_AUX_RESET              },
    {RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE,           RCP_PARAM_POWER_OUT_JETPACK_USB_RESET          },
    {RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS,           RCP_PARAM_POWER_OUT_JETPACK_USB_RESET          },
    {RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE,              RCP_PARAM_POWER_OUT_REAR_AUX_RESET             },
    {RCP_PARAM_POWER_OUT_REAR_AUX_STATUS,              RCP_PARAM_POWER_OUT_REAR_AUX_RESET             },
    {RCP_PARAM_POWER_OUT_TIMECODE_ENABLE,              RCP_PARAM_POWER_OUT_TIMECODE_RESET             },
    {RCP_PARAM_POWER_OUT_TIMECODE_STATUS,              RCP_PARAM_POWER_OUT_TIMECODE_RESET             },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_HAND_CONTROLLER_FOCUS_POS            },
    {RCP_PARAM_FOCUS_CONTROL,                          RCP_PARAM_HAND_CONTROLLER_FOCUS_POS            },
    {RCP_PARAM_AF_MODE,                                RCP_PARAM_HAND_CONTROLLER_REINIT               },
    {RCP_PARAM_FOCUS_CONTROL,                          RCP_PARAM_HAND_CONTROLLER_REINIT               },
    {RCP_PARAM_MONITOR_MODE_LCD3,                      RCP_PARAM_MONITOR_OVERLAY_LCD3                 },
    {RCP_PARAM_MONITOR_MODE_LCD3,                      RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3          },
    {RCP_PARAM_MONITOR_MODE_LCD3,                      RCP_PARAM_MONITOR_DOCK_MENUS_LCD3              },
    {RCP_PARAM_MONITOR_MODE_LCD3,                      RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3       },
    {RCP_PARAM_MONITOR_MODE_EVF3,                      RCP_PARAM_MONITOR_OVERLAY_REAR_EVF             },
    {RCP_PARAM_MONITOR_MODE_EVF3,                      RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3          },
    {RCP_PARAM_MONITOR_MODE_EVF3,                      RCP_PARAM_MONITOR_DOCK_MENUS_EVF3              },
    {RCP_PARAM_MONITOR_MODE_EVF3,                      RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3       },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_LCD3                   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_MONITOR_CURVE_EVF3                   },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_LCD3                  },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_DISPLAY_PRESET_EVF3                  },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3,     RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3             },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3,     RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3          },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3,     RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3              },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3,     RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3          },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3,     RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3              },
    {RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3,     RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3             },
    {RCP_PARAM_OLPF_TYPE,                              RCP_PARAM_OLPF_THIRD_PARTY_NAME                },
    {RCP_PARAM_OLPF_TYPE,                              RCP_PARAM_OLPF_THIRD_PARTY_EMULATED_TYPE       },
    {RCP_PARAM_MONITOR_SPLIT_CURVE,                    RCP_PARAM_RECORD_R3D_METADATA_CURVE            },
    {RCP_PARAM_AUDIO_CH12_SOURCE,                      RCP_PARAM_AUDIO_CH1_MODE_STATUS                },
    {RCP_PARAM_AUDIO_CH12_SOURCE,                      RCP_PARAM_AUDIO_CH2_MODE_STATUS                },
    {RCP_PARAM_AUDIO_CH34_SOURCE,                      RCP_PARAM_AUDIO_CH3_MODE_STATUS                },
    {RCP_PARAM_AUDIO_CH34_SOURCE,                      RCP_PARAM_AUDIO_CH4_MODE_STATUS                },
    {RCP_PARAM_RECORD_MODE,                            RCP_PARAM_BWF_ENABLE                           },
    {RCP_PARAM_PRIMARY_STORAGE,                        RCP_PARAM_BWF_ENABLE                           },
    {RCP_PARAM_VARISPEED_MODE,                         RCP_PARAM_BWF_ENABLE                           },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_BWF_ENABLE                           },
    {RCP_PARAM_TIMECODE_SOURCE,                        RCP_PARAM_AMBIENT_CHANNEL                      },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_CDL_EXPORT_TO_MEDIA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_CAMERA_CDL_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CDL_LIST                       },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CDL_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_IS_ATTACHED,                      RCP_PARAM_MEDIA_CDL_IMPORT_ALL_TO_CAMERA       },
    {RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT,                 RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT       },
    {RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT,                RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT      },
    {RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1,              RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI             },
    {RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2,              RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI             },
    {RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1,              RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI           },
    {RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2,              RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI           },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRE_RECORD                           },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRE_RECORD_DURATION                  },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_PRE_RECORD_ALWAYS_TRIGGER            },
    {RCP_PARAM_IMAGE_PIPELINE_MODE,                    RCP_PARAM_OUTPUT_TONE_MAP                      },
    {RCP_PARAM_IMAGE_PIPELINE_MODE,                    RCP_PARAM_ROLL_OFF                             },
    {RCP_PARAM_IMAGE_PIPELINE_MODE,                    RCP_PARAM_OUTPUT_TRANSFORM                     },
    {RCP_PARAM_LOOKAROUND_AVAILABLE,                   RCP_PARAM_RECORD_FORMAT_LOOKAROUND             },
    {RCP_PARAM_PROJECT_FRAME_RATE,                     RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE     },
    {RCP_PARAM_RECORD_FILE_FORMAT,                     RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS       },
    {RCP_PARAM_AUDIO_CH12_SOURCE,                      RCP_PARAM_AUDIO_CH12_LINK_GAIN                 },
    {RCP_PARAM_AUDIO_CH34_SOURCE,                      RCP_PARAM_AUDIO_CH34_LINK_GAIN                 },
    {RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD,               RCP_PARAM_VOLTAGE_THRESHOLD                    },
    {RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN,         RCP_PARAM_VOLTAGE_THRESHOLD_DC_IN              },
    {RCP_PARAM_OUTPUT_TRANSFORM,                       RCP_PARAM_OUTPUT_TONE_MAP                      },
    {RCP_PARAM_OUTPUT_TRANSFORM,                       RCP_PARAM_ROLL_OFF                             },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_SATURATION                       },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_OFFSET_RED                       },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_OFFSET_GREEN                     },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_OFFSET_BLUE                      },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_POWER_RED                        },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_POWER_GREEN                      },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_POWER_BLUE                       },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_SLOPE_RED                        },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_SLOPE_GREEN                      },
    {RCP_PARAM_CDL_ENABLE,                             RCP_PARAM_CDL_SLOPE_BLUE                       },
    {RCP_PARAM_LUT_FEED_1_ENABLE,                      RCP_PARAM_LUT_FEED_1                           },

    POWER_IN_CUR_TO_GET_STATUS_DEPENEDENCIES,
    POWER_OUT_CUR_TO_GET_STATUS_DEPENEDENCIES
};

static const rcp_dependency_t rcp_dependency_table_cur_to_create_edit_info[] =
{
    {RCP_PARAM_WIFI_AD_HOC_ENCRYPTION,                 RCP_PARAM_WIFI_AD_HOC_PASSPHRASE           },
    {RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION,         RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE   }
};

static const rcp_dependency_t rcp_dependency_table_cur_list_to_get_status[] =
{
    /* Any incoming CURRENT LIST for the items in the Source column will
     * re-trigger a get STATUS for the item in the Target column. */

    /* Source                                          Target */
    {RCP_PARAM_CAMERA_PRESET_LIST,                     RCP_PARAM_CAMERA_PRESET_APPLY                  },
    {RCP_PARAM_CAMERA_PRESET_LIST,                     RCP_PARAM_CAMERA_PRESET_EXPORT_TO_MEDIA        },
    {RCP_PARAM_CAMERA_PRESET_LIST,                     RCP_PARAM_CAMERA_PRESET_EXPORT_ALL_TO_MEDIA    },
    {RCP_PARAM_CAMERA_PRESET_LIST,                     RCP_PARAM_CAMERA_PRESET_UPDATE                 },
    {RCP_PARAM_CAMERA_PRESET_LIST,                     RCP_PARAM_CAMERA_PRESET_DELETE                 },
    {RCP_PARAM_MEDIA_PRESET_LIST,                      RCP_PARAM_MEDIA_PRESET_IMPORT_TO_CAMERA        },
    {RCP_PARAM_MEDIA_PRESET_LIST,                      RCP_PARAM_MEDIA_PRESET_IMPORT_ALL_TO_CAMERA    },
    {RCP_PARAM_CAMERA_LOOK_LIST,                       RCP_PARAM_CAMERA_LOOK_APPLY                    },
    {RCP_PARAM_CAMERA_LOOK_LIST,                       RCP_PARAM_CAMERA_LOOK_EXPORT_TO_MEDIA          },
    {RCP_PARAM_CAMERA_LOOK_LIST,                       RCP_PARAM_CAMERA_LOOK_EXPORT_ALL_TO_MEDIA      },
    {RCP_PARAM_CAMERA_LOOK_LIST,                       RCP_PARAM_CAMERA_LOOK_DELETE                   },
    {RCP_PARAM_MEDIA_LOOK_LIST,                        RCP_PARAM_MEDIA_LOOK_IMPORT_TO_CAMERA          },
    {RCP_PARAM_MEDIA_LOOK_LIST,                        RCP_PARAM_MEDIA_LOOK_IMPORT_ALL_TO_CAMERA      },
    {RCP_PARAM_CAMERA_OVERLAY_LIST,                    RCP_PARAM_CAMERA_OVERLAY_DELETE                },
    {RCP_PARAM_CAMERA_OVERLAY_LIST,                    RCP_PARAM_CAMERA_OVERLAY_EXPORT_TO_MEDIA       },
    {RCP_PARAM_CAMERA_OVERLAY_LIST,                    RCP_PARAM_CAMERA_OVERLAY_EXPORT_ALL_TO_MEDIA   },
    {RCP_PARAM_MEDIA_OVERLAY_LIST,                     RCP_PARAM_MEDIA_OVERLAY_IMPORT_TO_CAMERA       },
    {RCP_PARAM_MEDIA_OVERLAY_LIST,                     RCP_PARAM_MEDIA_OVERLAY_IMPORT_ALL_TO_CAMERA   },
    {RCP_PARAM_REDMOTE_DISCOVERED_LIST,                RCP_PARAM_REDMOTE_PAIR                         },
    {RCP_PARAM_REDMOTE_PAIRED_LIST,                    RCP_PARAM_REDMOTE_UNPAIR                       },
    {RCP_PARAM_CAMERA_LUT_LIST,                        RCP_PARAM_CAMERA_LUT_EXPORT_TO_MEDIA           },
    {RCP_PARAM_CAMERA_LUT_LIST,                        RCP_PARAM_CAMERA_LUT_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_CAMERA_LUT_LIST,                        RCP_PARAM_CAMERA_LUT_DELETE                    },
    {RCP_PARAM_MEDIA_LUT_LIST,                         RCP_PARAM_MEDIA_LUT_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_LUT_LIST,                         RCP_PARAM_MEDIA_LUT_IMPORT_ALL_TO_CAMERA       },
    {RCP_PARAM_CAMERA_CAL_LIST,                        RCP_PARAM_CAMERA_CAL_APPLY                     },
    {RCP_PARAM_CAMERA_CAL_LIST,                        RCP_PARAM_CAMERA_CAL_EXPORT_TO_MEDIA           },
    {RCP_PARAM_CAMERA_CAL_LIST,                        RCP_PARAM_CAMERA_CAL_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_CAMERA_CAL_LIST,                        RCP_PARAM_CAMERA_CAL_DELETE                    },
    {RCP_PARAM_MEDIA_CAL_LIST,                         RCP_PARAM_MEDIA_CAL_APPLY                      },
    {RCP_PARAM_MEDIA_CAL_LIST,                         RCP_PARAM_MEDIA_CAL_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_CAL_LIST,                         RCP_PARAM_MEDIA_CAL_IMPORT_ALL_TO_CAMERA       },
    {RCP_PARAM_WIFI_SCAN_RESULTS,                      RCP_PARAM_WIFI_SCAN_SELECT                     },
    {RCP_PARAM_CAMERA_CDL_LIST,                        RCP_PARAM_CAMERA_CDL_APPLY                     },
    {RCP_PARAM_CAMERA_CDL_LIST,                        RCP_PARAM_CAMERA_CDL_EXPORT_TO_MEDIA           },
    {RCP_PARAM_CAMERA_CDL_LIST,                        RCP_PARAM_CAMERA_CDL_EXPORT_ALL_TO_MEDIA       },
    {RCP_PARAM_CAMERA_CDL_LIST,                        RCP_PARAM_CAMERA_CDL_CREATE                    },
    {RCP_PARAM_CAMERA_CDL_LIST,                        RCP_PARAM_CAMERA_CDL_DELETE                    },
    {RCP_PARAM_MEDIA_CDL_LIST,                         RCP_PARAM_MEDIA_CDL_IMPORT_TO_CAMERA           },
    {RCP_PARAM_MEDIA_CDL_LIST,                         RCP_PARAM_MEDIA_CDL_IMPORT_ALL_TO_CAMERA       },

    POWER_IN_CUR_LIST_TO_GET_STATUS_DEPENEDENCIES,
    POWER_OUT_CUR_LIST_TO_GET_STATUS_DEPENEDENCIES
};
/* *INDENT-ON* */

static void _rcp_create_exposure_display_list(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_t id_incoming)
{
    if (con && rcp_get_is_supported(con, id, NULL))
    {
        int valid = 1;

        const rcp_param_state_t * const display_mode_state = &con->param_state[RCP_PARAM_SHUTTER_DISPLAY_MODE];

        if (!display_mode_state->val_valid)
        {
            (void) _rcp_get(con, RCP_PARAM_SHUTTER_DISPLAY_MODE);
            valid = 0;
        }

        if (valid)
        {
            if (id == id_incoming)
            {
                switch ((shutter_display_t) display_mode_state->val.int_val)
                {
                    case SHUTTER_TIME:
                        (void) _rcp_get_list(con, RCP_PARAM_EXPOSURE_INTEGRATION_TIME);
                        break;

                    case SHUTTER_ANGLE:
                        (void) _rcp_get_list(con, RCP_PARAM_EXPOSURE_ANGLE);
                        break;
                }
            }
            else
            {
                switch ((shutter_display_t) display_mode_state->val.int_val)
                {
                    case SHUTTER_TIME:
                        if (id_incoming == RCP_PARAM_EXPOSURE_INTEGRATION_TIME)
                        {
                            _rcp_send_current_list(con, id_incoming, id);
                        }
                        break;

                    case SHUTTER_ANGLE:
                        if (id_incoming == RCP_PARAM_EXPOSURE_ANGLE)
                        {
                            _rcp_send_current_list(con, id_incoming, id);
                        }
                        break;
                }
            }
        }
    }
}

static void _rcp_set_int_exposure_display(rcp_camera_connection_t * con, rcp_param_t id, int32_t val)
{
    if (con && rcp_get_is_supported(con, id, NULL))
    {
        int valid = 1;

        const rcp_param_state_t * const display_mode_state = &con->param_state[RCP_PARAM_SHUTTER_DISPLAY_MODE];

        if (!display_mode_state->val_valid)
        {
            _rcp_log_warning(con, "cannot set exposure display value, shutter display mode not known.\n");
            (void) _rcp_get(con, RCP_PARAM_SHUTTER_DISPLAY_MODE);
            valid = 0;
        }

        if (valid)
        {
            switch ((shutter_display_t) display_mode_state->val.int_val)
            {
                case SHUTTER_TIME:
                    (void) _rcp_set_int(con, RCP_PARAM_EXPOSURE_INTEGRATION_TIME, val);
                    break;

                case SHUTTER_ANGLE:
                    (void) _rcp_set_int(con, RCP_PARAM_EXPOSURE_ANGLE, val);
                    break;
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_get_dependencies(rcp_camera_connection_t * con, rcp_param_t id)
{
    size_t ii;

    for (ii = 0; ii < sizeof(rcp_dependency_table) / sizeof(rcp_dependency_table[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table[ii];

        if (id == dep->source)
        {
            if (dep->target == RCP_PARAM_AUDIO_VU_DATA)
            {
                /* There is no GET for audio vu data, so instead call
                 * the process packet function with a dummy packet.
                 * This will cause the user callback to be called. */
                _rcp_process_audio_vu_packet(con, NULL, id);
            }
            else
            {
                if (rcp_get_is_supported(con, dep->target, NULL))
                {
                    (void) _rcp_get(con, dep->target);
                }
            }
        }
    }

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_to_get_list) / sizeof(rcp_dependency_table_cur_to_get_list[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_to_get_list[ii];

        if (id == dep->source)
        {
            if (rcp_get_is_supported(con, dep->target, NULL))
            {
                (void) _rcp_get_list(con, dep->target);
            }
        }
    }

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_to_get_status) / sizeof(rcp_dependency_table_cur_to_get_status[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_to_get_status[ii];

        if (id == dep->source)
        {
            (void) _rcp_get_status(con, dep->target);
        }
    }

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_to_create_edit_info) / sizeof(rcp_dependency_table_cur_to_create_edit_info[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_to_create_edit_info[ii];

        if (id == dep->source)
        {
            const rcp_param_def_t * const def = &_rcp_param_def[dep->target];
            if (def->create_edit_info_fp)
            {
                def->create_edit_info_fp(con, dep->target);

                if (rcp_get_is_supported(con, dep->target, NULL))
                {
                    (void) _rcp_get(con, dep->target);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_create_list(rcp_camera_connection_t * con, rcp_param_t id)
{
    size_t ii;

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_list_to_create_list) / sizeof(rcp_dependency_table_cur_list_to_create_list[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_list_to_create_list[ii];

        if (id == dep->source)
        {
            const rcp_param_def_t * const def = &_rcp_param_def[dep->target];

            if (def->create_list_fp)
            {
                def->create_list_fp(con, dep->target, id);
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_get(rcp_camera_connection_t * con, rcp_param_t id)
{
    size_t ii;

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_list_to_get) / sizeof(rcp_dependency_table_cur_list_to_get[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_list_to_get[ii];

        if (id == dep->source)
        {
            if (rcp_get_is_supported(con, dep->target, NULL))
            {
                (void) _rcp_get(con, dep->target);
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_get_dependencies_cur_list_to_get_status(rcp_camera_connection_t * con, rcp_param_t id)
{
    size_t ii;

    for (ii = 0; ii < sizeof(rcp_dependency_table_cur_list_to_get_status) / sizeof(rcp_dependency_table_cur_list_to_get_status[0]); ii++)
    {
        const rcp_dependency_t * const dep = &rcp_dependency_table_cur_list_to_get_status[ii];

        if (id == dep->source)
        {
            (void) _rcp_get_status(con, dep->target);
        }
    }
}

static void _rcp_create_iso_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const iso_state = &con->param_state[RCP_PARAM_ISO];
            const rcp_param_state_t * const iso_pull_state = &con->param_state[RCP_PARAM_MM_ISO_PULL];
            const rcp_param_state_t * const nd_state = &con->param_state[RCP_PARAM_ND_VAL];
            const rcp_param_state_t * const sensor_gain_state = &con->param_state[RCP_PARAM_SENSOR_SENSITIVITY];
            int mm_iso_pull;
            int nd;

            if (rcp_get_is_supported(con, RCP_PARAM_MM_ISO_PULL, NULL))
            {
                mm_iso_pull = iso_pull_state->val.int_val;
            }
            else
            {
                mm_iso_pull = 0;
            }

            if (rcp_get_is_supported(con, RCP_PARAM_ND_VAL, NULL))
            {
                nd = nd_state->val.int_val;
            }
            else
            {
                nd = 0;
            }

            decorated_string_create_iso(buf, buf_size, DECORATED_STRING_LEN_NORMAL, iso_state->val.int_val, mm_iso_pull, nd, _rcp_get_hw_cap(con, HW_CAP_SENSOR_SENSITIVITY), sensor_gain_state->val.int_val);
            decorated_string_create_iso(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, iso_state->val.int_val, mm_iso_pull, nd, _rcp_get_hw_cap(con, HW_CAP_SENSOR_SENSITIVITY), sensor_gain_state->val.int_val);

            if (iso_pull_state->val.int_val)
            {
                if (status)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                }
            }
        }
    }
}

static void _rcp_create_playback_metadata_iso_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const iso_state = &con->param_state[RCP_PARAM_PLAYBACK_METADATA_ISO];
            const rcp_param_state_t * const sensor_gain_state = &con->param_state[RCP_PARAM_SENSOR_SENSITIVITY];

            decorated_string_create_iso(buf, buf_size, DECORATED_STRING_LEN_NORMAL, iso_state->val.int_val, 0, 0, _rcp_get_hw_cap(con, HW_CAP_SENSOR_SENSITIVITY), sensor_gain_state->val.int_val);
            decorated_string_create_iso(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, iso_state->val.int_val, 0, 0, _rcp_get_hw_cap(con, HW_CAP_SENSOR_SENSITIVITY), sensor_gain_state->val.int_val);
        }
    }
}

static void _rcp_create_redcode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];

            decorated_string_create_redcode(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_redcode(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            if (status)
            {
                if (((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_NOT_IN_PLAYBACK))
                {
                    if (state->target_val_valid)
                    {
                        if (state->val.int_val != state->target_val.int_val)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                    }
                    else
                    {
                        /* get the current target value */
                        if (!state->get_target_pending)
                        {
                            const rcp_param_def_t * const def = &_rcp_param_def[id];
                            _rcp_create_get_message(con, RCP2_CMD_GET, def->get_target_msg);
                            state->get_target_pending = 1;
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_file_format_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];

            decorated_string_create_file_format(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_file_format(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            if (status)
            {
                if (((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK))
                {
                    if (state->target_val_valid)
                    {
                        if (state->val.int_val != state->target_val.int_val)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                    }
                    else
                    {
                        /* get the current target value */
                        if (!state->get_target_pending)
                        {
                            const rcp_param_def_t * const def = &_rcp_param_def[id];
                            _rcp_create_get_message(con, RCP2_CMD_GET, def->get_target_msg);
                            state->get_target_pending = 1;
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_nd_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const nd_state = &con->param_state[RCP_PARAM_ND_VAL];
            const rcp_param_state_t * const mm_nd_mode = &con->param_state[RCP_PARAM_MM_ND_MODE];

            if (nd_state->val_valid)
            {
                const int nd_val = nd_state->val.int_val;

                if (nd_val == 0)
                {
                    strlcpy(buf, "", buf_size);
                    strlcpy(buf_abbr, "", buf_abbr_size);
                }
                else
                {
                    motion_mount_display_mode_t display_mode;
                    char mode_str[C_LIST_MAX_STRING_LEN] = {0};

                    /* earlier camera firmware didn't have the display mode, if
                     * we have it use it, otherwise default to nd mode. */
                    if (rcp_get_is_supported(con, RCP_PARAM_MM_ND_MODE, NULL))
                    {
                        display_mode = (motion_mount_display_mode_t) mm_nd_mode->val.int_val;
                    }
                    else
                    {
                        display_mode = MOTION_MOUNT_DISPLAY_ND;
                    }

                    if (!_rcp_get_string_from_list(con, RCP_PARAM_MM_MODE, mode_str, sizeof(mode_str)))
                    {
                        (void) _rcp_get_list(con, RCP_PARAM_MM_MODE);
                        snprintf(mode_str, sizeof(mode_str), "---");
                    }

                    switch (display_mode)
                    {
                        case MOTION_MOUNT_DISPLAY_ND:
                            snprintf(buf, buf_size, "Fraction: 1/%.2f (%s)", pow(2, (float) nd_val / 100.0), mode_str);
                            snprintf(buf_abbr, buf_abbr_size, "1/%.2f", pow(2, (float) nd_val / 100.0));
                            break;

                        case MOTION_MOUNT_DISPLAY_OD:
                            snprintf(buf, buf_size, "Density: %.2f (%s)", ((float) nd_val * 0.30103) / 100.0, mode_str);
                            snprintf(buf_abbr, buf_abbr_size, "%.2f", ((float) nd_val * 0.30103) / 100.0);
                            break;

                        case MOTION_MOUNT_DISPLAY_FSTOP:
                            snprintf(buf, buf_size, "Stops: %.2f (%s)", (float) nd_val / 100.0, mode_str);
                            snprintf(buf_abbr, buf_abbr_size, "%.2f", (float) nd_val / 100.0);
                            break;
                    }

                    if (status)
                    {
                        if (nd_val > 400)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_sensor_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const sensor_state = &con->param_state[RCP_PARAM_SENSOR_FRAME_RATE];
            const rcp_param_state_t * const project_state = &con->param_state[RCP_PARAM_PROJECT_FRAME_RATE];

            if (sensor_state->val_valid)
            {
                decorated_string_create_fps_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, sensor_state->val.int_val);
                decorated_string_create_fps_label(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, sensor_state->val.int_val);
            }

            if (status)
            {
                if (sensor_state->val.int_val != project_state->val.int_val)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                }
            }
        }
    }
}

static void _rcp_create_project_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_fps_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_fps_label(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_qt_encode_fps_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const sensor_state = &con->param_state[RCP_PARAM_SENSOR_FRAME_RATE];

            decorated_string_create_fps_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_fps_label(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            if (status)
            {
                if (state->val.int_val != sensor_state->val.int_val)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                }
            }
        }
    }
}

static void _rcp_create_aperture_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const aperture_control_state = &con->param_state[RCP_PARAM_APERTURE_CONTROL];
            const rcp_param_state_t * const ae_mode = &con->param_state[RCP_PARAM_AE_MODE];
            const rcp_param_state_t * const ae_lockout_aperture = &con->param_state[RCP_PARAM_AE_LOCK_APERTURE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
            const playback_state_t playback_mode = (playback_state_t) playback_state->val.int_val;

            if (state->val_valid)
            {
                int32_t ae_control = 0;
                const rcp_param_def_t * const def = &_rcp_param_def[id];

                if (playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK)
                {
                    if (rcp_get_is_supported(con, RCP_PARAM_AE_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_AE_LOCK_APERTURE, NULL))
                    {
                        if ((ae_mode_t) ae_mode->val.int_val != AE_MODE_OFF)
                        {
                            if (!ae_lockout_aperture->val.int_val)
                            {
                                ae_control = 1;
                            }
                        }
                    }
                }

                decorated_string_create_aperture(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val, ae_control);
                decorated_string_create_aperture(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val, ae_control);

                if (
                    status &&
                    _rcp_version_in_range(con, &def->target_version_range) &&
                    state->val.int_val > 0
                   )
                {
                    /* If the aperture is controllable and the target
                     * aperture doesn't match the current value, and we
                     * are not in playback mode, mark it as warning */
                    if (aperture_control_state->val.int_val)
                    {
                        if (state->target_val_valid)
                        {
                            char target_buf[RCP_API_DISPLAY_STR_SIZE];

                            decorated_string_create_aperture(target_buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->target_val.int_val, ae_control);

                            if ((playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK) && (strcmp(target_buf, buf) != 0))
                            {
                                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                            }
                        }
                        else
                        {
                            /* get the current target value */
                            if (!state->get_target_pending)
                            {
                                _rcp_create_get_message(con, RCP2_CMD_GET, def->get_target_msg);
                                state->get_target_pending = 1;
                            }
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_integration_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_EXPOSURE_INTEGRATION_TIME];

            const rcp_param_state_t * const frame_processing_mode_state = &con->param_state[RCP_PARAM_FRAME_PROCESSING_MODE];
            const rcp_param_state_t * const frame_processing_num_state = &con->param_state[RCP_PARAM_FRAME_PROCESSING_NUM];
            const rcp_param_state_t * const mm_mode_state = &con->param_state[RCP_PARAM_MM_MODE];
            const rcp_param_state_t * const mm_color_state = &con->param_state[RCP_PARAM_MM_SHUTTER_COLOR];
            const rcp_param_state_t * const mm_int_time = &con->param_state[RCP_PARAM_MM_INTEGRATION_TIME];
            const rcp_param_state_t * const ae_mode = &con->param_state[RCP_PARAM_AE_MODE];
            const rcp_param_state_t * const ae_lockout_exposure = &con->param_state[RCP_PARAM_AE_LOCK_EXPOSURE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];

            if (state->val_valid)
            {
                const playback_state_t playback_mode = (playback_state_t) playback_state->val.int_val;
                frame_processing_t frame_processing_mode = FRAME_PROCESSING_OFF;
                int32_t frame_processing_num = 0;
                int32_t int_time = state->val.int_val;
                int32_t ae_control = 0;

                if (playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK)
                {
                    frame_processing_mode = (frame_processing_t) frame_processing_mode_state->val.int_val;
                    frame_processing_num = frame_processing_num_state->val.int_val;

                    if (rcp_get_is_supported(con, RCP_PARAM_MM_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_MM_INTEGRATION_TIME, NULL))
                    {
                        if (mm_mode_state->val.int_val != MOTION_MOUNT_SHUTTER_MODE_ND_ONLY)
                        {
                            int_time = mm_int_time->val.int_val / 100;
                        }
                    }

                    if (rcp_get_is_supported(con, RCP_PARAM_AE_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_AE_LOCK_EXPOSURE, NULL))
                    {
                        if ((ae_mode_t) ae_mode->val.int_val != AE_MODE_OFF)
                        {
                            if (!ae_lockout_exposure->val.int_val)
                            {
                                ae_control = 1;
                            }
                        }
                    }
                }

                decorated_string_create_int_time_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, 0, int_time, 0, frame_processing_mode, frame_processing_num, ae_control);
                decorated_string_create_int_time_label(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, 0, int_time, 0, frame_processing_mode, frame_processing_num, ae_control);

                if (status)
                {
                    if (playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK)
                    {
                        if (state->val.int_val != state->target_val.int_val)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }

                        if (rcp_get_is_supported(con, RCP_PARAM_MM_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_MM_SHUTTER_COLOR, NULL))
                        {
                            if (mm_mode_state->val.int_val != MOTION_MOUNT_SHUTTER_MODE_ND_ONLY)
                            {
                                if (mm_color_state->val.int_val)
                                {
                                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                                }
                                else
                                {
                                    *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_cal_integration_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                const int int_time = state->val.int_val;
                decorated_string_create_int_time_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, 0, int_time, 0, FRAME_PROCESSING_OFF, 1, 0);

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_color_temp_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const tint_state = &con->param_state[id == RCP_PARAM_COLOR_TEMPERATURE ? RCP_PARAM_TINT : RCP_PARAM_PLAYBACK_METADATA_TINT];

            if (state->val_valid)
            {
                const int tint = tint_state->val.int_val;
                const int rounded_whole_tint = (tint + ((tint < 0) ? -500 : 500)) / 1000;

                char color_temp[20];
                char color_temp_abbr[20];
                decorated_string_create_color_temperature(color_temp, sizeof(color_temp), DECORATED_STRING_LEN_NORMAL, state->val.int_val);
                decorated_string_create_color_temperature(color_temp_abbr, sizeof(color_temp_abbr), DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

                if (rounded_whole_tint == 0)
                {
                    snprintf(buf, buf_size, "%s", color_temp);
                    snprintf(buf_abbr, buf_abbr_size, "%s", color_temp_abbr);
                }
                else
                {
                    snprintf(buf, buf_size, "%s %+d", color_temp, rounded_whole_tint);
                    snprintf(buf_abbr, buf_abbr_size, "%s %+d", color_temp_abbr, rounded_whole_tint);
                }
            }
        }
    }
}

static void _rcp_create_fixed_point_3_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create(buf, buf_size, state->val.int_val, 1000, 3, "", "");
            decorated_string_create(buf_abbr, buf_abbr_size, state->val.int_val, 1000, 1, "", "");
        }
    }
}

static void _rcp_create_timecode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_STATE];
            const rcp_param_state_t * const drop_frame_display_mode = &con->param_state[RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE];

            const int32_t packet_timecode = state->val.int_val;
            const int32_t hr = (packet_timecode >> 24) & 0xFF;
            const int32_t min = (packet_timecode >> 16) & 0xFF;
            const int32_t sec = (packet_timecode >> 8) & 0xFF;

            /* Timecode format */
            switch (drop_frame_display_mode->val.int_val)
            {
                case TC_DISPLAY_DROP_FRAME:
                    snprintf(buf, buf_size, "%02d:%02d:%02d;--", hr, min, sec);
                    snprintf(buf_abbr, buf_abbr_size, "%02d:%02d:%02d", hr, min, sec);
                    break;

                case TC_DISPLAY_NON_DROP_FRAME:
                default:
                    snprintf(buf, buf_size, "%02d:%02d:%02d:--", hr, min, sec);
                    snprintf(buf_abbr, buf_abbr_size, "%02d:%02d:%02d", hr, min, sec);
                    break;
            }

            if (status)
            {
                switch (record_mode_state->val.int_val)
                {
                    case RECORD_STATE_NOT_RECORDING:
                        *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        break;

                    case RECORD_STATE_RECORDING:
                        *status = RCP_PARAM_DISPLAY_STATUS_RECORDING;
                        break;

                    case RECORD_STATE_FINALIZING:
                    case RECORD_STATE_PRE_RECORDING:
                    case RECORD_STATE_ENCODING:
                        *status = RCP_PARAM_DISPLAY_STATUS_FINALIZING;
                        break;
                }
            }
        }
    }
}

static void _rcp_create_focus_dist_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const focus_dist_near_state = &con->param_state[RCP_PARAM_FOCUS_DIST_NEAR];
            const rcp_param_state_t * const focus_dist_far_state = &con->param_state[RCP_PARAM_FOCUS_DIST_FAR];
            const rcp_param_state_t * const display_mode_state = &con->param_state[RCP_PARAM_FOCUS_DIST_DISPLAY_MODE];

            const focus_distance_mode_t display_mode = (focus_distance_mode_t) display_mode_state->val.int_val;
            const int32_t near_val = focus_dist_near_state->val.int_val;
            const int32_t far_val = focus_dist_far_state->val.int_val;

            decorated_string_create_focus_dist(buf, buf_size, DECORATED_STRING_LEN_NORMAL, display_mode, near_val, far_val);
            decorated_string_create_focus_dist(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, display_mode, near_val, far_val);
        }
    }
}

static void _rcp_create_focal_length_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_focal_length(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_focal_length(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_angle_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const mm_mode_state = &con->param_state[RCP_PARAM_MM_MODE];
            const rcp_param_state_t * const mm_color_state = &con->param_state[RCP_PARAM_MM_SHUTTER_COLOR];
            const rcp_param_state_t * const mm_angle = &con->param_state[RCP_PARAM_MM_SHUTTER_ANGLE];
            const rcp_param_state_t * const ae_mode = &con->param_state[RCP_PARAM_AE_MODE];
            const rcp_param_state_t * const ae_lockout_exposure = &con->param_state[RCP_PARAM_AE_LOCK_EXPOSURE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];

            const playback_state_t playback_mode = (playback_state_t) playback_state->val.int_val;

            int32_t angle = state->val.int_val;
            int32_t ae_control = 0;

            if (playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK)
            {
                if (rcp_get_is_supported(con, RCP_PARAM_MM_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_MM_SHUTTER_ANGLE, NULL))
                {
                    if (mm_mode_state->val.int_val != MOTION_MOUNT_SHUTTER_MODE_ND_ONLY)
                    {
                        angle = mm_angle->val.int_val * 100;
                    }
                }

                if (rcp_get_is_supported(con, RCP_PARAM_AE_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_AE_LOCK_EXPOSURE, NULL))
                {
                    if ((ae_mode_t) ae_mode->val.int_val != AE_MODE_OFF)
                    {
                        if (!ae_lockout_exposure->val.int_val)
                        {
                            ae_control = 1;
                        }
                    }
                }
            }

            decorated_string_create_int_time_label(buf, buf_size, DECORATED_STRING_LEN_NORMAL, 1, 0, angle, FRAME_PROCESSING_OFF, 0, ae_control);
            decorated_string_create_int_time_label(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, 1, 0, angle, FRAME_PROCESSING_OFF, 0, ae_control);

            if (status)
            {
                if (playback_mode == PLAYBACK_STATE_NOT_IN_PLAYBACK)
                {
                    if (state->val.int_val != state->target_val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                    }

                    if (rcp_get_is_supported(con, RCP_PARAM_MM_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_MM_SHUTTER_COLOR, NULL))
                    {
                        if (mm_mode_state->val.int_val != MOTION_MOUNT_SHUTTER_MODE_ND_ONLY)
                        {
                            if (mm_color_state->val.int_val)
                            {
                                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                            }
                            else
                            {
                                *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                            }
                        }
                    }
                }
            }
        }
    }
}

static void _rcp_create_gamma_space_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_red_gamma(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_red_gamma(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_color_space_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_red_color(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_red_color(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_output_transform_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_output_transform(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_output_transform(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_core_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const level_1_state = &con->param_state[RCP_PARAM_CORE_TEMP_WARNING_1];
            const rcp_param_state_t * const level_2_state = &con->param_state[RCP_PARAM_CORE_TEMP_WARNING_2];
            const rcp_param_state_t * const level_3_state = &con->param_state[RCP_PARAM_CORE_TEMP_WARNING_3];

            decorated_string_create_temperature(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_temperature(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            if (
                rcp_get_is_supported(con, RCP_PARAM_CORE_TEMP_WARNING_1, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_CORE_TEMP_WARNING_2, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_CORE_TEMP_WARNING_3, NULL)
               )
            {
                if (status)
                {
                    if (state->val.int_val >= level_3_state->val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                    }
                    else if (state->val.int_val >= level_2_state->val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_WARNING2;
                    }
                    else if (state->val.int_val >= level_1_state->val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                    }
                    else
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                    }
                }
            }
        }
    }
}

static void _rcp_create_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_temperature(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_temperature(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_fanspeed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_fan_speed(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_fan_speed(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _rcp_create_media_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const media_val_state = &con->param_state[RCP_PARAM_MEDIA_VAL];
            const rcp_param_state_t * const media_time_state = &con->param_state[RCP_PARAM_MEDIA_TIME_REMAINING];
            const rcp_param_state_t * const media_display_state = &con->param_state[RCP_PARAM_MEDIA_DISPLAY_MODE];
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];

            decorated_string_color_t string_color;

            if (rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL))
            {
                if ((primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_EXTERNAL)
                {
                    strlcpy(buf, "EXT", buf_size);
                    strlcpy(buf_abbr, "EXT", buf_abbr_size);
                    string_color = DECORATED_STRING_COLOR_WARNING;
                }
                else
                {
                    decorated_string_create_media(buf, buf_size, DECORATED_STRING_LEN_NORMAL, &string_color, (record_mode_t) record_mode_state->val.int_val, (media_display_t) media_display_state->val.int_val, media_val_state->val.int_val, media_time_state->val.int_val);
                    decorated_string_create_media(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, &string_color, (record_mode_t) record_mode_state->val.int_val, (media_display_t) media_display_state->val.int_val, media_val_state->val.int_val, media_time_state->val.int_val);
                }
            }
            else
            {
                decorated_string_create_media(buf, buf_size, DECORATED_STRING_LEN_NORMAL, &string_color, (record_mode_t) record_mode_state->val.int_val, (media_display_t) media_display_state->val.int_val, media_val_state->val.int_val, media_time_state->val.int_val);
                decorated_string_create_media(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, &string_color, (record_mode_t) record_mode_state->val.int_val, (media_display_t) media_display_state->val.int_val, media_val_state->val.int_val, media_time_state->val.int_val);
            }

            if (status)
            {
                switch (string_color)
                {
                    case DECORATED_STRING_COLOR_OK:
                        *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        break;

                    case DECORATED_STRING_COLOR_WARNING:
                        *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        break;

                    case DECORATED_STRING_COLOR_ERROR:
                        *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        break;

                    case DECORATED_STRING_COLOR_DISABLED:
                        *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        break;
                }
            }
        }
    }
}

static void _rcp_create_media_percent_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val.int_val == -1)
            {
                snprintf(buf, buf_size, "N/A");
            }
            else
            {
                snprintf(buf, buf_size, "%d%%", state->val.int_val);
            }
            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_media_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val.int_val == -1)
            {
                snprintf(buf, buf_size, "Unknown");
            }
            else
            {
                snprintf(buf, buf_size, "%d:%02d", state->val.int_val / 60, state->val.int_val % 60);
            }
            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_power_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    /*
     * Before there were indexed power in parameters the generated string relied
     * on RCP_PARAM_POWER_VAL which could contain either voltage or percentage.
     * This worked when only the voltage or percentage was used at any given
     * time. In order to access both voltage and percentage for the current
     * power source we now reference the indexed parameters.
     */
    if (_rcp_has_feature(con, RCP_FEATURE_INDEXED_POWER_IN))
    {
        _rcp_create_power_display_string_indexed_power_in(con, id, buf, buf_size, buf_abbr, buf_abbr_size, status);
    }
    else
    {
        _rcp_create_power_display_string_non_indexed_power_in(con, id, buf, buf_size, buf_abbr, buf_abbr_size, status);
    }
}

static void _rcp_create_power_display_string_indexed_power_in(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const power_display_state = &con->param_state[RCP_PARAM_POWER_DISPLAY_MODE];
            const rcp_param_state_t * const power_current_source_index = &con->param_state[RCP_PARAM_POWER_CURRENT_SOURCE_INDEX];

            const rcp_param_state_t * const power_current_source_voltage = &con->param_state[RCP_PARAM_POWER_IN_VOLTAGE_0 + power_current_source_index->val.int_val];
            const rcp_param_state_t * const power_current_source_runtime = &con->param_state[RCP_PARAM_POWER_IN_RUNTIME_0 + power_current_source_index->val.int_val];
            const rcp_param_state_t * const power_current_source_percent = &con->param_state[RCP_PARAM_POWER_IN_PERCENT_0 + power_current_source_index->val.int_val];

            int32_t runtime = BATTERY_INVALID_VALUE;
            int32_t percent = BATTERY_INVALID_VALUE;

            if (power_current_source_runtime->val_valid)
            {
                runtime = power_current_source_runtime->val.int_val;
            }

            if (power_current_source_percent->val_valid)
            {
                percent = power_current_source_percent->val.int_val;
            }

            decorated_string_create_power2(buf, buf_size, DECORATED_STRING_LEN_NORMAL, (battery_display_mode_t) power_display_state->val.int_val, power_current_source_voltage->val.int_val, runtime, percent);
            decorated_string_create_power2(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, (battery_display_mode_t) power_display_state->val.int_val, power_current_source_voltage->val.int_val, runtime, percent);

            _rcp_indexed_power_in_status(con, status, power_current_source_index->val.int_val, POWER_IN_ALL);
        }
    }
}

static void _rcp_create_power_display_string_non_indexed_power_in(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const power_val_state = &con->param_state[RCP_PARAM_POWER_VAL];
            const rcp_param_state_t * const power_time_remaining_state = &con->param_state[RCP_PARAM_POWER_TIME_REMAINING];
            const rcp_param_state_t * const power_display_state = &con->param_state[RCP_PARAM_POWER_DISPLAY_MODE];

            uint8_t voltage_above_threshold = 0;
            uint8_t voltage_below_threshold = 0;
            uint8_t low_time_remaining = 0;

            decorated_string_create_power(buf, buf_size, DECORATED_STRING_LEN_NORMAL, (battery_display_mode_t) power_display_state->val.int_val, power_val_state->val.int_val, power_time_remaining_state->val.int_val);
            decorated_string_create_power(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, (battery_display_mode_t) power_display_state->val.int_val, power_val_state->val.int_val, power_time_remaining_state->val.int_val);

            /* The voltage is higher than the max threshold */
            if (power_val_state->val.int_val > 17000)
            {
                voltage_above_threshold = 1;
            }

            /*
             * The voltage is lower than the min set or hardcoded min threshold
             */
            if (power_val_state->val.int_val < 10500)
            {
                voltage_below_threshold = 1;
            }

            /*
             * The runtime is lower than the min threshold
             */
            if (power_time_remaining_state->val.int_val != BATTERY_INVALID_VALUE)
            {
                if (power_time_remaining_state->val.int_val < BATTERY_RUNTIME_WARNING_MINUTES)
                {
                    low_time_remaining = 1;
                }
            }

            /* Any voltage or runtime error will result in a status error */
            if (voltage_above_threshold || voltage_below_threshold || low_time_remaining)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
            else
            {
                *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
            }
        }
    }
}

static void _rcp_create_media_display_label_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const media_label_state = &con->param_state[RCP_PARAM_MEDIA_LABEL];
            const rcp_param_state_t * const rec_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];

            if (rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL))
            {
                if ((primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_EXTERNAL)
                {
                    strlcpy(buf, "EXT", buf_size);
                }
                else if ((primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_NETWORK)
                {
                    strlcpy(buf, "STR", buf_size);
                }
                else
                {
                    strlcpy(buf, media_label_state->val.str_val, buf_size);
                }
            }
            else
            {
                if ((record_mode_t) rec_mode_state->val.int_val == RECORD_MODE_EXTERNAL)
                {
                    strlcpy(buf, "EXT", buf_size);
                }
                else if ((record_mode_t) rec_mode_state->val.int_val == RECORD_MODE_STREAM)
                {
                    strlcpy(buf, "STR", buf_size);
                }
                else
                {
                    strlcpy(buf, media_label_state->val.str_val, buf_size);
                }
            }

            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_exposure_display_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const display_mode_state = &con->param_state[RCP_PARAM_SHUTTER_DISPLAY_MODE];
            const rcp_param_def_t * const int_time_def = &_rcp_param_def[RCP_PARAM_EXPOSURE_INTEGRATION_TIME];
            const rcp_param_def_t * const angle_def = &_rcp_param_def[RCP_PARAM_EXPOSURE_ANGLE];

            switch ((shutter_display_t) display_mode_state->val.int_val)
            {
                case SHUTTER_TIME:
                    if (int_time_def->create_string_fp)
                    {
                        int_time_def->create_string_fp(con, RCP_PARAM_EXPOSURE_INTEGRATION_TIME, buf, buf_size, buf_abbr, buf_abbr_size, status);
                    }
                    break;

                case SHUTTER_ANGLE:
                    if (angle_def->create_string_fp)
                    {
                        angle_def->create_string_fp(con, RCP_PARAM_EXPOSURE_ANGLE, buf, buf_size, buf_abbr, buf_abbr_size, status);
                    }
                    break;
            }
        }
    }
}

static void _rcp_create_gyro_angle_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create_gyro_angle(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_gyro_angle(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);
        }
    }
}

static void _calibration_status_temperature_string(const uint32_t state_val, char * buf, size_t buf_size, rcp_param_status_t * status)
{
    const cal_status_t temp_status = (cal_status_t) (state_val & 0xffff);

    switch (temp_status)
    {
        case CAL_STATUS_MINUS_LEVEL_3:
            strlcpy(buf, "T-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
            break;

        case CAL_STATUS_MINUS_LEVEL_2:
            strlcpy(buf, "T-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING2;
            }
            break;

        case CAL_STATUS_MINUS_LEVEL_1:
            strlcpy(buf, "T-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
            }
            break;

        case CAL_STATUS_OK:
            strlcpy(buf, "T", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_1:
            strlcpy(buf, "T+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_2:
            strlcpy(buf, "T+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING2;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_3:
            strlcpy(buf, "T+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
            break;

        default:
            strlcpy(buf, "---", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
            break;
    }
}

static void _calibration_status_exposure_string(const uint32_t state_val, char * buf, size_t buf_size, rcp_param_status_t * status)
{
    const cal_status_t exposure_status = (cal_status_t) (state_val >> 16);

    switch (exposure_status)
    {
        case CAL_STATUS_MINUS_LEVEL_3:
            strlcpy(buf, "E-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
            break;

        case CAL_STATUS_MINUS_LEVEL_2:
            strlcpy(buf, "E-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING2;
            }
            break;

        case CAL_STATUS_MINUS_LEVEL_1:
            strlcpy(buf, "E-", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
            }
            break;

        case CAL_STATUS_OK:
            strlcpy(buf, "E", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_1:
            strlcpy(buf, "E+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_2:
            strlcpy(buf, "E+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_WARNING2;
            }
            break;

        case CAL_STATUS_PLUS_LEVEL_3:
            strlcpy(buf, "E+", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
            break;

        default:
            strlcpy(buf, "---", buf_size);
            if (status)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
            break;
    }
}

static void _rcp_create_calibration_status_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            char temp[5];
            char exposure[5];

            _calibration_status_temperature_string(state->val.uint_val, temp, 5, status);
            _calibration_status_exposure_string(state->val.uint_val, exposure, 5, status);

            strlcpy(buf, "CAL:", buf_size);
            strlcpy(buf_abbr, "", buf_abbr_size);

            strlcat(buf, temp, buf_size);
            strlcat(buf_abbr, temp, buf_abbr_size);

            strlcat(buf, "/", buf_size);
            strlcat(buf_abbr, "/", buf_abbr_size);

            strlcat(buf, exposure, buf_size);
            strlcat(buf_abbr, exposure, buf_abbr_size);
        }
    }
}

static void _rcp_create_calibration_status_temperature_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_CALIBRATION_STATUS];

            if (state->val_valid)
            {
                _calibration_status_temperature_string(state->val.uint_val, buf, buf_size, status);
                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_calibration_status_exposure_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_CALIBRATION_STATUS];

            if (state->val_valid)
            {
                _calibration_status_exposure_string(state->val.uint_val, buf, buf_size, status);
                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_int_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            snprintf(buf, buf_size, "%d", state->val.int_val);
            snprintf(buf_abbr, buf_abbr_size, "%d", state->val.int_val);
        }
    }
}

static void _rcp_create_clip_name_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const clip_status_state = &con->param_state[RCP_PARAM_CLIP_NAME_STATUS];

            strlcpy(buf, state->val.str_val, buf_size);
            strlcpy(buf_abbr, state->val.str_val, buf_abbr_size);

            if (status)
            {
                if (rcp_get_is_supported(con, RCP_PARAM_CLIP_NAME_STATUS, NULL))
                {
                    if (clip_status_state->val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                    }
                }
            }
        }
    }
}

static void _rcp_create_format_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const format_name_state = &con->param_state[RCP_PARAM_RECORD_FORMAT_NAME];

            strlcpy(buf, format_name_state->val.str_val, buf_size);
            strlcpy(buf_abbr, format_name_state->val.str_val, buf_abbr_size);
        }
    }
}

static void _rcp_create_ipaddress_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                if (state->val.uint_val == 0)
                {
                    snprintf(buf, buf_size, "N/A");
                }
                else
                {
                    uint8_t octet[4];
                    octet[0] = ((state->val.uint_val) & 0xff000000) >> 24;
                    octet[1] = ((state->val.uint_val) & 0x00ff0000) >> 16;
                    octet[2] = ((state->val.uint_val) & 0x0000ff00) >> 8;
                    octet[3] = ((state->val.uint_val) & 0x000000ff);

                    snprintf(buf, buf_size, "%d.%d.%d.%d", octet[0], octet[1], octet[2], octet[3]);
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_timecode_offset_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                const uint8_t seconds = state->val.int_val % 60;
                const uint8_t minutes = (state->val.int_val / 60) % 60;
                const uint8_t hours = (state->val.int_val / 3600) % 24;

                snprintf(buf, buf_size, "%02d:%02d:%02d:00", hours, minutes, seconds);
                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_hdr_mode_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case HDR_MODE_OFF:
                        strlcpy(buf, "HDRx", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case HDR_MODE_HDRX:
                        strlcpy(buf, "HDRx", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_hdr_mode_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_HDR_MODE];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case HDR_MODE_OFF:
                        strlcpy(buf, "Off", buf_size);
                        break;

                    case HDR_MODE_HDRX:
                        strlcpy(buf, "HDRx", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_timecode_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case TC_SYNC_STATE_NOT_PRESENT:
                        strlcpy(buf, "TC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case TC_SYNC_STATE_PRESENT_NOT_USED:
                        strlcpy(buf, "TC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case TC_SYNC_STATE_PRESENT_USED:
                        strlcpy(buf, "TC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_timecode_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const tc_source_state = &con->param_state[RCP_PARAM_TIMECODE_SOURCE];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case TC_SYNC_STATE_NOT_PRESENT:
                        if ((tc_source_t) tc_source_state->val.int_val == TC_SOURCE_USER)
                        {
                            strlcpy(buf, "N/A", buf_size);
                        }
                        else
                        {
                            strlcpy(buf, "No Signal", buf_size);
                        }
                        break;

                    case TC_SYNC_STATE_PRESENT_NOT_USED:
                        strlcpy(buf, "Signal Not Used", buf_size);
                        break;

                    case TC_SYNC_STATE_PRESENT_USED:
                        strlcpy(buf, "Jamming", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_magnify_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case MAGNIFY_MODE_OFF:
                        strlcpy(buf, "1:1", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case MAGNIFY_MODE_ON:
                        strlcpy(buf, "1:1", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_false_color_mode_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case FALSE_COLOR_MODE_NONE:
                        strlcpy(buf, "OFF", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case FALSE_COLOR_MODE_EXPOSURE:
                        strlcpy(buf, "E&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    case FALSE_COLOR_MODE_VIDEO:
                        strlcpy(buf, "V&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    case FALSE_COLOR_MODE_FOCUS:
                        strlcpy(buf, "F&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    case FALSE_COLOR_MODE_EDGE:
                        strlcpy(buf, "F&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    case FALSE_COLOR_MODE_GIO_SCOPE:
                        strlcpy(buf, "G&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                     case FALSE_COLOR_MODE_PEAKING:
                        strlcpy(buf, "P&redcheck;", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_gige_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case GIGE_STATUS_DISABLED:
                        strlcpy(buf, "LAN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case GIGE_STATUS_ERROR:
                        strlcpy(buf, "LAN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case GIGE_STATUS_OK:
                        strlcpy(buf, "LAN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    case GIGE_STATUS_WARNING:
                        strlcpy(buf, "LAN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_gige_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const gige_dhcp_state = &con->param_state[RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE];
            const rcp_param_state_t * const gige_ip_address_state = &con->param_state[RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case GIGE_STATUS_DISABLED:
                        strlcpy(buf, "Not Connected", buf_size);
                        break;

                    case GIGE_STATUS_ERROR:
                        strlcpy(buf, "Error", buf_size);
                        break;

                    case GIGE_STATUS_OK:
                        /* GIGE_STATUS_OK indicates a cable is
                         * connected to the ethernet. */
                        if (gige_dhcp_state->val.int_val)
                        {
                            /* If DHCP is enabled, there are three
                             * states we can be in:
                             * 1. An IP address of 0.0.0.0 which
                             * indicates we are attempting to get an IP
                             * address from the DHCP server
                             * 2. An IP address of 169.254.x.x which
                             * means we didn't get an IP address from
                             * teh DHCP serve and we self assigned an
                             * IP address (see
                             * https://en.wikipedia.org/wiki/Link-local_address)
                             * 3. Any other valid IP address which
                             * means we got an address from the DHCP
                             * server.
                             * */
                            if (gige_ip_address_state->val.uint_val == 0)
                            {
                                strlcpy(buf, "Obtaining IP Address...", buf_size);
                            }
                            else
                            {
                                uint8_t octet[2];
                                octet[0] = ((gige_ip_address_state->val.uint_val) & 0xff000000) >> 24;
                                octet[1] = ((gige_ip_address_state->val.uint_val) & 0x00ff0000) >> 16;
                                if (octet[0] == 169 && octet[1] == 254)
                                {
                                    /*  */
                                    strlcpy(buf, "Connected (Auto IP)", buf_size);
                                }
                                else
                                {
                                    strlcpy(buf, "Connected (DHCP)", buf_size);
                                }
                            }
                        }
                        else
                        {
                            strlcpy(buf, "Connected (Static IP)", buf_size);
                        }
                        break;

                    case GIGE_STATUS_WARNING:
                        strlcpy(buf, "Warning", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_rig_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case METADATA_STATUS_DISABLED:
                        strlcpy(buf, "RIG", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case METADATA_STATUS_ENABLED_INVALID:
                        strlcpy(buf, "RIG", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case METADATA_STATUS_ENABLED_VALID:
                        strlcpy(buf, "RIG", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_rig_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case METADATA_STATUS_DISABLED:
                        strlcpy(buf, "Disabled", buf_size);
                        break;

                    case METADATA_STATUS_ENABLED_INVALID:
                        strlcpy(buf, "Invalid Data", buf_size);
                        break;

                    case METADATA_STATUS_ENABLED_VALID:
                        strlcpy(buf, "Valid Data", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_sync_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case SYNC_STATE_NONE:
                        strlcpy(buf, "SYNC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case SYNC_STATE_NO_LOCK:
                        strlcpy(buf, "SYNC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case SYNC_STATE_GENLOCK:
                        strlcpy(buf, "SYNC", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_sync_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case SYNC_STATE_NONE:
                        strlcpy(buf, "N/A", buf_size);
                        break;

                    case SYNC_STATE_NO_LOCK:
                        strlcpy(buf, "Not Locked", buf_size);
                        break;

                    case SYNC_STATE_GENLOCK:
                        strlcpy(buf, "Locked", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_genlock_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case GENLOCK_STATE_NONE:
                        strlcpy(buf, "GEN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case GENLOCK_STATE_PRESENT:
                        strlcpy(buf, "GEN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case GENLOCK_STATE_LOCKED:
                        strlcpy(buf, "GEN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    case GENLOCK_STATE_CROSSLOCKED:
                        strlcpy(buf, "GEN", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_genlock_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case GENLOCK_STATE_NONE:
                        strlcpy(buf, "No Signal", buf_size);
                        break;

                    case GENLOCK_STATE_PRESENT:
                        strlcpy(buf, "Not Locked", buf_size);
                        break;

                    case GENLOCK_STATE_LOCKED:
                        strlcpy(buf, "Locked", buf_size);
                        break;

                    case GENLOCK_STATE_CROSSLOCKED:
                        strlcpy(buf, "Cross Locked", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_wifi_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case WL_STATUS_OFFLINE:
                        strlcpy(buf, "WIFI", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case WL_STATUS_ERROR:
                        strlcpy(buf, "WIFI", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                        }
                        break;

                    case WL_STATUS_CONNECTED:
                        strlcpy(buf, "WIFI", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    case WL_STATUS_SEARCHING:
                    case WL_STATUS_LOST:
                    case WL_STATUS_CONNECTING:
                        strlcpy(buf, "WIFI", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_wifi_state_detailed_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            char * ssid = NULL;
            wl_mode_t mode = WL_MODE_DISABLED;

            if (
                rcp_get_is_supported(con, RCP_PARAM_WIFI_MODE, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_WIFI_AD_HOC_SSID, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_WIFI_INFRASTRUCTURE_SSID, NULL)
               )
            {
                const rcp_param_state_t * const mode_state = &con->param_state[RCP_PARAM_WIFI_MODE];
                const rcp_param_state_t * const ad_hoc_ssid_state = &con->param_state[RCP_PARAM_WIFI_AD_HOC_SSID];
                const rcp_param_state_t * const infra_ssid_state = &con->param_state[RCP_PARAM_WIFI_INFRASTRUCTURE_SSID];
                mode = (wl_mode_t) mode_state->val.int_val;

                if (mode == WL_MODE_AD_HOC)
                {
                    ssid = ad_hoc_ssid_state->val.str_val;
                }
                else if (mode == WL_MODE_INFRASTRUCTURE)
                {
                    ssid = infra_ssid_state->val.str_val;
                }
            }

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case WL_STATUS_OFFLINE:
                        strlcpy(buf, "Disabled", buf_size);
                        break;

                    case WL_STATUS_ERROR:
                        strlcpy(buf, "Error", buf_size);
                        break;

                    case WL_STATUS_CONNECTED:
                        if (mode == WL_MODE_AD_HOC)
                        {
                            if (ssid)
                            {
                                snprintf(buf, buf_size, "SSID: %s", ssid);
                            }
                            else
                            {
                                snprintf(buf, buf_size, "SSID: N/A");
                            }
                        }
                        else
                        {
                            if (ssid)
                            {
                                snprintf(buf, buf_size, "Connected: %s", ssid);
                            }
                            else
                            {
                                strlcpy(buf, "Connected", buf_size);
                            }
                        }
                        break;

                    case WL_STATUS_SEARCHING:
                        strlcpy(buf, "Searching...", buf_size);
                        break;

                    case WL_STATUS_LOST:
                        strlcpy(buf, "Lost", buf_size);
                        break;

                    case WL_STATUS_CONNECTING:
                        if (mode == WL_MODE_AD_HOC)
                        {
                            strlcpy(buf, "Initializing...", buf_size);
                        }
                        else
                        {
                            if (ssid)
                            {
                                snprintf(buf, buf_size, "Connecting to %s...", ssid);
                            }
                            else
                            {
                                strlcpy(buf, "Connecting...", buf_size);
                            }
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_fiz_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (id)
                {
                    case RCP_PARAM_FOCUS_STATE:
                        strlcpy(buf, "F", buf_size);
                        break;

                    case RCP_PARAM_IRIS_STATE:
                        strlcpy(buf, "I", buf_size);
                        break;

                    case RCP_PARAM_ZOOM_STATE:
                        strlcpy(buf, "Z", buf_size);
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);

                if (status)
                {
                    switch (state->val.int_val)
                    {
                        case MC_MOTOR_STATUS_UNCONNECTED:
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                            break;

                        case MC_MOTOR_STATUS_ERROR:
                            *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                            break;

                        case MC_MOTOR_STATUS_IDLE:
                        case MC_MOTOR_STATUS_MOVING:
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                            break;

                        case MC_MOTOR_STATUS_HOMING:
                            *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                            break;

                        default:
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                            break;
                    }
                }
            }
        }
    }
}

static void _rcp_create_fiz_state_string_detailed(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                switch (state->val.int_val)
                {
                    case MC_MOTOR_STATUS_UNCONNECTED:
                        strlcpy(buf, "Unconnected", buf_size);
                        break;

                    case MC_MOTOR_STATUS_ERROR:
                        strlcpy(buf, "Error", buf_size);
                        break;

                    case MC_MOTOR_STATUS_IDLE:
                    case MC_MOTOR_STATUS_MOVING:
                        strlcpy(buf, "OK", buf_size);
                        break;

                    case MC_MOTOR_STATUS_HOMING:
                        strlcpy(buf, "Homing", buf_size);
                        break;

                    default:
                        strlcpy(buf, "Unknown", buf_size);
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_redmote_state_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                const redmote_connected_state_t rm_state = (redmote_connected_state_t) state->val.int_val;

                switch (rm_state)
                {
                    case REDMOTE_CONNECTED_STATE_NOT_CONNECTED:
                        strlcpy(buf, "RM", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;

                    case REDMOTE_CONNECTED_STATE_CONNECTED:
                        strlcpy(buf, "RM", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                        }
                        break;

                    default:
                        strlcpy(buf, "---", buf_size);
                        if (status)
                        {
                            *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                        }
                        break;
                }

                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_date_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                const time_t time_val = (time_t) state->val.int_val;
                const struct tm * const tm_val = localtime(&time_val);
                (void) strftime(buf, buf_size, "%c", tm_val);
                (void) strftime(buf_abbr, buf_abbr_size, "%Y-%m-%d %H:%M:%S", tm_val);
            }
        }
    }
}

static void _rcp_create_clips_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                snprintf(buf, buf_size, "%d clip%s", state->val.int_val, (state->val.int_val == 1) ? "" : "s");
                snprintf(buf_abbr, buf_abbr_size, "%d", state->val.int_val);
            }
        }
    }
}

static void _rcp_create_metadata_date_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    /* date string: YYYYMMDD */

    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (strlen(state->val.str_val) == 8)
            {
                snprintf(buf, buf_size, "%.4s-%.2s-%.2s", state->val.str_val, &(state->val.str_val[4]), &(state->val.str_val[6]));
                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_metadata_time_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    /* time string: HHMMSS */

    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (strlen(state->val.str_val) == 6)
            {
                snprintf(buf, buf_size, "%.2s:%.2s:%.2s", state->val.str_val, &(state->val.str_val[2]), &(state->val.str_val[4]));
                strlcpy(buf_abbr, buf, buf_abbr_size);
            }
        }
    }
}

static void _rcp_create_runtime_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->val_valid)
            {
                const int seconds = state->val.int_val;

                const unsigned int minutes = (seconds / 60) % 60;
                const unsigned int frac = minutes / 6;
                const unsigned int hours = (seconds / 60) / 60;
                snprintf(buf, buf_size, "%d.%d Hours", hours, frac);
                snprintf(buf_abbr, buf_abbr_size, "%d.%d", hours, frac);
            }
        }
    }
}

static void _rcp_create_hdr_factor_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const hdr_mode_state = &con->param_state[RCP_PARAM_HDR_MODE];

            if ((hdr_mode_t) hdr_mode_state->val.int_val == HDR_MODE_OFF)
            {
                /* The HDR factor doesn't make any sense if HDR is off */
                snprintf(buf, buf_size, "N/A");
            }
            else
            {
                if (!_rcp_get_string_from_list(con, id, buf, buf_size))
                {
                    (void) _rcp_get_list(con, id);
                    snprintf(buf, buf_size, "---");
                }
            }

            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_media_size_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const uint32_t MiBs = state->val.uint_val;

            if (MiBs >= 1048576U)
            {
                snprintf(buf, buf_size, "%.1f TiB", MiBs / 1048576.0);
            }
            else if (MiBs >= 1024U)
            {
                snprintf(buf, buf_size, "%.1f GiB", MiBs / 1024.0);
            }
            else
            {
                snprintf(buf, buf_size, "%u MiB", MiBs);
            }

            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_wifi_rssi_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            const int dBm = state->val.int_val;
            int quality = 0;
            if (dBm <= -100)
            {
                quality = 0;
            }
            else if (dBm >= -50)
            {
                quality = 100;
            }
            else
            {
                quality = 2 * (dBm + 100);
            }

            snprintf(buf, buf_size, "%ddBm (%d%%)", dBm, quality);
            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_power_out_status_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * enable_state = NULL;
            rcp_param_t enable_id = RCP_PARAM_COUNT;

            switch (id)
            {
                case RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_BAT_AUX_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_REAR_AUX_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE;
                    break;

                case RCP_PARAM_POWER_OUT_TIMECODE_STATUS:
                    enable_id = RCP_PARAM_POWER_OUT_TIMECODE_ENABLE;
                    break;

                default:
                    if (id >= RCP_PARAM_POWER_OUT_STATUS_0 && id <= RCP_PARAM_POWER_OUT_STATUS_LAST)
                    {
                        enable_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_ENABLE_0 + (id - RCP_PARAM_POWER_OUT_STATUS_0));
                    }
                    else
                    {
                        return;
                    }
                    break;
            }

            enable_state = &con->param_state[enable_id];

            if (!rcp_get_is_supported(con, enable_id, NULL) || enable_state->val.int_val)
            {
                if (state->val.int_val)
                {
                    strlcpy(buf, "OK", buf_size);
                    if (status)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_GOOD;
                    }
                }
                else
                {
                    strlcpy(buf, "FAULT", buf_size);
                    if (status)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                    }
                }
            }
            else
            {
                strlcpy(buf, "---", buf_size);
                if (status)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
                }
            }

            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_create_power_in_out_current_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            decorated_string_create(buf, buf_size, state->val.int_val, 1000, 1, "", "A");
            strlcpy(buf_abbr, buf, buf_abbr_size);
        }
    }
}

static void _rcp_get_video_codec_string(video_codec_t video_codec, int mxf_compression_id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size)
{
    switch (video_codec)
    {
        case VIDEO_CODEC_PRORES_4444:
            strlcpy(buf, "4444", buf_size);
            strlcpy(buf_abbr, "4444", buf_abbr_size);
            break;

        case VIDEO_CODEC_PRORES_4444XQ:
            strlcpy(buf, "4444 XQ", buf_size);
            strlcpy(buf_abbr, "4444 XQ", buf_abbr_size);
            break;

        case VIDEO_CODEC_PRORES_422HQ:
            strlcpy(buf, "422 HQ", buf_size);
            strlcpy(buf_abbr, "422 HQ", buf_abbr_size);
            break;

        case VIDEO_CODEC_PRORES_422:
            strlcpy(buf, "422", buf_size);
            strlcpy(buf_abbr, "422", buf_abbr_size);
            break;

        case VIDEO_CODEC_PRORES_422LT:
            strlcpy(buf, "422 LT", buf_size);
            strlcpy(buf_abbr, "422 LT", buf_abbr_size);
            break;

        case VIDEO_CODEC_DNX_444:
        case VIDEO_CODEC_DNX_HQX:
        case VIDEO_CODEC_DNX_HQ:
        case VIDEO_CODEC_DNX_SQ:
        case VIDEO_CODEC_DNX_LB:
        {
            char family[30];
            char family_abbr[30];

            char compression_id[30];
            char compression_id_abbr[30];

            _rcp_get_mxf_compression_id_family_string(mxf_compression_id, family, sizeof(family), family_abbr, sizeof(family_abbr));
            _rcp_get_mxf_compression_id_string(mxf_compression_id, compression_id, sizeof(compression_id), compression_id_abbr, sizeof(compression_id_abbr));

            snprintf(buf, buf_size, "%s %s", family, compression_id);
            snprintf(buf_abbr, buf_abbr_size, "%s %s", family_abbr, compression_id_abbr);
        }
        break;

        default:
            /* we should only get here if we add a
             * new codec type and need to create a
             * new string */
            strlcpy(buf, "Unknown", buf_size);
            strlcpy(buf_abbr, "Unknown", buf_abbr_size);
            break;
    }
}

static void _rcp_create_quality_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const redcode_state = &con->param_state[RCP_PARAM_REDCODE];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
            const rcp_param_state_t * const video_codec_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_CODEC];
            const rcp_param_state_t * const video_mxf_codec_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_MXF_CODEC];
            const rcp_param_state_t * const video_mxf_codec_compression_id_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];
            int color_based_on_redcode = 1;

            if (
                rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL) &&
                (primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_EXTERNAL
               )
            {
                color_based_on_redcode = 0;
                strlcpy(buf, "N/A", buf_size);
                strlcpy(buf_abbr, "N/A", buf_abbr_size);
            }
            else if (
                     rcp_get_is_supported(con, RCP_PARAM_RECORD_FILE_FORMAT, NULL) &&
                     rcp_get_is_supported(con, RCP_PARAM_RECORD_VIDEO_CODEC, NULL)
                    )
            {
                switch ((file_format_t) file_format_state->val.int_val)
                {
                    case FILE_FORMAT_REDCODE_RAW:
                        decorated_string_create_redcode(buf, buf_size, DECORATED_STRING_LEN_NORMAL, redcode_state->val.int_val);
                        decorated_string_create_redcode(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, redcode_state->val.int_val);
                        break;

                    case FILE_FORMAT_QUICKTIME:
                        color_based_on_redcode = 0;
                        _rcp_get_video_codec_string((video_codec_t) video_codec_state->val.int_val, video_mxf_codec_compression_id_state->val.int_val, buf, buf_size, buf_abbr, buf_abbr_size);
                        break;

                    case FILE_FORMAT_MXF:
                        color_based_on_redcode = 0;
                        _rcp_get_video_codec_string((video_codec_t) video_mxf_codec_state->val.int_val, video_mxf_codec_compression_id_state->val.int_val, buf, buf_size, buf_abbr, buf_abbr_size);
                        break;

                    case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                    {
                        char redcode_str[10];
                        char redcode_abbr_str[10];
                        char codec_str[30];
                        char codec_abbr_str[30];
                        _rcp_get_video_codec_string((video_codec_t) video_codec_state->val.int_val, video_mxf_codec_compression_id_state->val.int_val, codec_str, sizeof(codec_str), codec_abbr_str, sizeof(codec_abbr_str));
                        decorated_string_create_redcode(redcode_str, sizeof(redcode_str), DECORATED_STRING_LEN_NORMAL, redcode_state->val.int_val);
                        decorated_string_create_redcode(redcode_abbr_str, sizeof(redcode_abbr_str), DECORATED_STRING_LEN_ABBREVIATED, redcode_state->val.int_val);
                        snprintf(buf, buf_size, "%s/%s", redcode_str, codec_str);
                        snprintf(buf_abbr, buf_abbr_size, "%s/%s", redcode_abbr_str, codec_abbr_str);
                        break;
                    }

                    case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                    {
                        char redcode_str[10];
                        char redcode_abbr_str[10];
                        char codec_str[30];
                        char codec_abbr_str[30];
                        _rcp_get_video_codec_string((video_codec_t) video_mxf_codec_state->val.int_val, video_mxf_codec_compression_id_state->val.int_val, codec_str, sizeof(codec_str), codec_abbr_str, sizeof(codec_abbr_str));
                        decorated_string_create_redcode(redcode_str, sizeof(redcode_str), DECORATED_STRING_LEN_NORMAL, redcode_state->val.int_val);
                        decorated_string_create_redcode(redcode_abbr_str, sizeof(redcode_abbr_str), DECORATED_STRING_LEN_ABBREVIATED, redcode_state->val.int_val);
                        snprintf(buf, buf_size, "%s/%s", redcode_str, codec_abbr_str);
                        snprintf(buf_abbr, buf_abbr_size, "%s/%s", redcode_abbr_str, codec_abbr_str);
                        break;
                    }

                    default:
                        break;
                }
            }
            else
            {
                decorated_string_create_redcode(buf, buf_size, DECORATED_STRING_LEN_NORMAL, redcode_state->val.int_val);
                decorated_string_create_redcode(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, redcode_state->val.int_val);
            }

            if (status)
            {
                if (
                    color_based_on_redcode &&
                    ((playback_state_t) playback_state->val.int_val == PLAYBACK_STATE_NOT_IN_PLAYBACK) &&
                    (redcode_state->val.int_val != redcode_state->target_val.int_val)
                   )
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                }
            }
        }
    }
}

static void _rcp_create_dropped_frames_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const r3d_dropped_frames_state = &con->param_state[RCP_PARAM_R3D_DROPPED_FRAMES];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];
            const rcp_param_state_t * const qt_dropped_frames_state = &con->param_state[RCP_PARAM_QT_DROPPED_FRAMES];
            const rcp_param_state_t * const mxf_dropped_frames_state = &con->param_state[RCP_PARAM_MXF_DROPPED_FRAMES];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_DROPPED_FRAMES];

            int total_dropped_frames = 0;

            if (rcp_get_is_supported(con, RCP_PARAM_RECORD_FILE_FORMAT, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_QT_DROPPED_FRAMES, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_MXF_DROPPED_FRAMES, NULL))
            {
                switch ((file_format_t) file_format_state->val.int_val)
                {
                    case FILE_FORMAT_REDCODE_RAW:
                        total_dropped_frames = r3d_dropped_frames_state->val.int_val;
                        break;

                    case FILE_FORMAT_QUICKTIME:
                        total_dropped_frames = qt_dropped_frames_state->val.int_val;
                        break;

                    case FILE_FORMAT_MXF:
                        total_dropped_frames = mxf_dropped_frames_state->val.int_val;
                        break;

                    case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                        total_dropped_frames = r3d_dropped_frames_state->val.int_val + qt_dropped_frames_state->val.int_val;
                        break;

                    case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                        total_dropped_frames = r3d_dropped_frames_state->val.int_val + mxf_dropped_frames_state->val.int_val;
                        break;

                    default:
                        break;
                }
            }
            else
            {
                total_dropped_frames = r3d_dropped_frames_state->val.int_val;
            }

            state->val.int_val = total_dropped_frames;
            state->val_valid = 1;
        }
    }
}

static void _rcp_create_prores_dimension_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const width = &con->param_state[RCP_PARAM_PRORES_WIDTH];
            const rcp_param_state_t * const height = &con->param_state[RCP_PARAM_PRORES_HEIGHT];

            snprintf(buf, buf_size, "%dx%d", width->val.int_val, height->val.int_val);
            snprintf(buf_abbr, buf_abbr_size, "%dx%d", width->val.int_val, height->val.int_val);
        }
    }
}

static void _rcp_create_mxf_dimension_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const width = &con->param_state[RCP_PARAM_MXF_WIDTH];
            const rcp_param_state_t * const height = &con->param_state[RCP_PARAM_MXF_HEIGHT];

            snprintf(buf, buf_size, "%dx%d", width->val.int_val, height->val.int_val);
            snprintf(buf_abbr, buf_abbr_size, "%dx%d", width->val.int_val, height->val.int_val);
        }
    }
}

static void _rcp_get_mxf_compression_id_family_string(int id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size)
{
    switch (id)
    {
        case 1235: /* VC3_HQX_1080p_COMPRESSION_ID */
        case 1237: /* VC3_SQ_1080p_COMPRESSION_ID */
        case 1238: /* VC3_HQ_1080p_COMPRESSION_ID */
        case 1253: /* VC3_LB_1080p_COMPRESSION_ID */
        case 1256: /* VC3_444_1080p_COMPRESSION_ID */
            strlcpy(buf, "DNxHD", buf_size);
            strlcpy(buf_abbr, "HD", buf_abbr_size);
            break;

        case 1270: /* VC3_444_COMPRESSION_ID */
        case 1271: /* VC3_HQX_COMPRESSION_ID */
        case 1272: /* VC3_HQ_COMPRESSION_ID */
        case 1273: /* VC3_SQ_COMPRESSION_ID */
        case 1274: /* VC3_LB_COMPRESSION_ID */
            strlcpy(buf, "DNxHR", buf_size);
            strlcpy(buf_abbr, "HR", buf_abbr_size);
            break;

        default:
            strlcpy(buf, "Unknown", buf_size);
            strlcpy(buf_abbr, "Unknown", buf_abbr_size);
            break;
    }
}

static void _rcp_get_mxf_compression_id_string(int id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size)
{
    switch (id)
    {
        case 1256: /* VC3_444_1080p_COMPRESSION_ID */
        case 1270: /* VC3_444_COMPRESSION_ID */
            strlcpy(buf, "444", buf_size);
            strlcpy(buf_abbr, "444", buf_abbr_size);
            break;

        case 1235: /* VC3_HQX_1080p_COMPRESSION_ID */
        case 1271: /* VC3_HQX_COMPRESSION_ID */
            strlcpy(buf, "HQX", buf_size);
            strlcpy(buf_abbr, "HQX", buf_abbr_size);
            break;

        case 1238: /* VC3_HQ_1080p_COMPRESSION_ID */
        case 1272: /* VC3_HQ_COMPRESSION_ID */
            strlcpy(buf, "HQ", buf_size);
            strlcpy(buf_abbr, "HQ", buf_abbr_size);
            break;

        case 1237: /* VC3_SQ_1080p_COMPRESSION_ID */
        case 1273: /* VC3_SQ_COMPRESSION_ID */
            strlcpy(buf, "SQ", buf_size);
            strlcpy(buf_abbr, "SQ", buf_abbr_size);
            break;

        case 1253: /* VC3_LB_1080p_COMPRESSION_ID */
        case 1274: /* VC3_LB_COMPRESSION_ID */
            strlcpy(buf, "LB", buf_size);
            strlcpy(buf_abbr, "LB", buf_abbr_size);
            break;

        default:
            strlcpy(buf, "Unknown", buf_size);
            strlcpy(buf_abbr, "Unknown", buf_abbr_size);
            break;
    }
}

static void _rcp_create_mxf_compression_id_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const compression_id_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID];

            char family[30];
            char family_abbr[30];

            char compression_id[30];
            char compression_id_abbr[30];

            _rcp_get_mxf_compression_id_family_string(compression_id_state->val.int_val, family, sizeof(family), family_abbr, sizeof(family_abbr));
            _rcp_get_mxf_compression_id_string(compression_id_state->val.int_val, compression_id, sizeof(compression_id), compression_id_abbr, sizeof(compression_id_abbr));

            snprintf(buf, buf_size, "%s %s", family, compression_id);
            snprintf(buf_abbr, buf_abbr_size, "%s %s", family_abbr, compression_id_abbr);
        }
    }
}

static void _rcp_create_sensor_physical_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const width = &con->param_state[RCP_PARAM_SENSOR_WIDTH_PHY];
            const rcp_param_state_t * const height = &con->param_state[RCP_PARAM_SENSOR_HEIGHT_PHY];

            _rcp_get_format_dimensions_string(buf, buf_size, width->val.int_val, height->val.int_val, 2, 1000.0, "um", 0);
            _rcp_get_format_dimensions_string(buf_abbr, buf_abbr_size, width->val.int_val, height->val.int_val, 2, 1000.0, "um", 1);
        }
    }
}

static void _rcp_create_format_physical_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * width = NULL;
            const rcp_param_state_t * height = NULL;

            if (id == RCP_PARAM_FORMAT_DIMENSIONS_PHY)
            {
                width = &con->param_state[RCP_PARAM_FORMAT_WIDTH_PHY];
                height = &con->param_state[RCP_PARAM_FORMAT_HEIGHT_PHY];
            }
            else if (id == RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PHY)
            {
                width = &con->param_state[RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY];
                height = &con->param_state[RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY];
            }

            if (width && height)
            {
                _rcp_get_format_dimensions_string(buf, buf_size, width->val.int_val / 1000, height->val.int_val / 1000, 1, 1000.0, "mm", 0);
                _rcp_get_format_dimensions_string(buf_abbr, buf_abbr_size, width->val.int_val / 1000, height->val.int_val / 1000, 1, 1000.0, "mm", 1);
            }
        }
    }
}

static void _rcp_create_format_pixel_dimensions_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * width = NULL;
            const rcp_param_state_t * height = NULL;

            if (id == RCP_PARAM_FORMAT_DIMENSIONS_PIXELS)
            {
                width = &con->param_state[RCP_PARAM_FORMAT_WIDTH_PIXELS];
                height = &con->param_state[RCP_PARAM_FORMAT_HEIGHT_PIXELS];
            }
            else if (id == RCP_PARAM_SHADOW_FORMAT_DIMENSIONS_PIXELS)
            {
                width = &con->param_state[RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS];
                height = &con->param_state[RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS];
            }

            if (width && height)
            {
                snprintf(buf, buf_size, "%d x %d", width->val.int_val, height->val.int_val);
                snprintf(buf_abbr, buf_abbr_size, "%dx%d", width->val.int_val, height->val.int_val);
            }
        }
    }
}

static void _rcp_create_list_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];

            if (state->list_val_valid && state->list_val)
            {
                if (_rcp_get_string_from_list_by_value(con, id, state->val.int_val, buf, buf_size))
                {
                    strlcpy(buf_abbr, buf, buf_abbr_size);
                }
            }
            else
            {
                (void) _rcp_get_list(con, id);
            }

            if (status)
            {
                if (state->target_val_valid && (state->val.int_val != state->target_val.int_val))
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_WARNING;
                }
            }
        }
    }
}

static void _rcp_create_fixed_point_5_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->val_valid)
        {
            decorated_string_create(buf, buf_size, state->val.int_val, 100000, 5, "", "");
            decorated_string_create(buf_abbr, buf_abbr_size, state->val.int_val, 100000, 1, "", "");
        }
    }
}

static void _rcp_create_power_in_voltage_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            uint32_t index = id - RCP_PARAM_POWER_IN_VOLTAGE_0;

            decorated_string_create_power_voltage(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_power_voltage(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            _rcp_indexed_power_in_status(con, status, index, POWER_IN_VOLTAGE);
        }
    }
}

static void _rcp_create_power_in_percent_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            uint32_t index = id - RCP_PARAM_POWER_IN_PERCENT_0;

            decorated_string_create_power_percent(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_power_percent(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            _rcp_indexed_power_in_status(con, status, index, POWER_IN_PERCENT);
        }
    }
}

static void _rcp_create_power_in_runtime_string(rcp_camera_connection_t * con, rcp_param_t id, char * buf, size_t buf_size, char * buf_abbr, size_t buf_abbr_size, rcp_param_status_t * status)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const state = &con->param_state[id];
            uint32_t index = id - RCP_PARAM_POWER_IN_RUNTIME_0;

            decorated_string_create_power_runtime(buf, buf_size, DECORATED_STRING_LEN_NORMAL, state->val.int_val);
            decorated_string_create_power_runtime(buf_abbr, buf_abbr_size, DECORATED_STRING_LEN_ABBREVIATED, state->val.int_val);

            _rcp_indexed_power_in_status(con, status, index, POWER_IN_TIME_REMAINING);
        }
    }
}

static void _rcp_indexed_power_in_status_voltage(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index)
{
    if (con)
    {
        const rcp_param_state_t * const power_in_voltage = &con->param_state[RCP_PARAM_POWER_IN_VOLTAGE_0 + index];
        const rcp_param_state_t * const power_in_source_type = &con->param_state[RCP_PARAM_POWER_IN_TYPE_0 + index];
        const rcp_param_state_t * const power_in_voltage_below_threshold = &con->param_state[RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0 + index];

        uint32_t max_threshold = 17000;

        if (status)
        {
            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;

            if (rcp_get_is_supported(con, RCP_PARAM_POWER_IN_TYPE_0, NULL))
            {
                if (power_in_source_type->val.int_val == POWER_IN_TYPE_DC_WIDE_VOLTAGE)
                {
                    max_threshold = 32000;
                }
            }

            /* The voltage is higher than the max threshold */
            if (power_in_voltage->val.int_val > max_threshold)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }

            /*
             * The voltage is lower than the hardcoded min threshold. Performing
             * this check first assumes the hardcoded min threshold is always
             * less than the set threshold
             */
            if (power_in_voltage->val.int_val < 10500)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }

            /*
             * The voltage is lower than the user set min threshold
             */
            if (rcp_get_is_supported(con, RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0, NULL))
            {
                if (power_in_voltage_below_threshold->val.int_val)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                }
            }
            else if (rcp_get_is_supported(con, RCP_PARAM_VOLTAGE_BELOW_THRESHOLD, NULL))
            {
                /* RCP_PARAM_VOLTAGE_BELOW_THRESHOLD was introduced in 6.60 and then deprecated in 6.61 for a more
                 * general solution.  This code is here for backwards compatibility when connecting to cameras with
                 * parameter set version 6.60
                 */
                const rcp_param_state_t * const power_current_source_index = &con->param_state[RCP_PARAM_POWER_CURRENT_SOURCE_INDEX];
                if (index == power_current_source_index->val.int_val)
                {
                    const rcp_param_state_t * const power_voltage_below_threshold = &con->param_state[RCP_PARAM_VOLTAGE_BELOW_THRESHOLD];

                    if (power_voltage_below_threshold->val.int_val)
                    {
                        *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                    }
                }
            }
        }
    }
}

static void _rcp_indexed_power_in_status_percent(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index)
{
    if (con)
    {
        const rcp_param_state_t * const power_current_source_percent = &con->param_state[RCP_PARAM_POWER_IN_PERCENT_0 + index];

        if (status)
        {
            const int32_t percent = power_current_source_percent->val.int_val;
            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;

            /*
             * Only check the percent value if the camera sent us a value
             * and the value it sent us was valid
             */
            if (power_current_source_percent->val_valid && percent != BATTERY_INVALID_VALUE)
            {
                if (percent < 5)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                }
            }
            else
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
        }
    }
}

static void _rcp_indexed_power_in_status_time_remaining(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index)
{
    if (con)
    {
        const rcp_param_state_t * const power_current_source_runtime = &con->param_state[RCP_PARAM_POWER_IN_RUNTIME_0 + index];

        if (status)
        {
            const int32_t time_remaining = power_current_source_runtime->val.int_val;
            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;

            /*
             * Only check the time remaining value if the camera sent us a value
             * and the value it sent us was valid
             */
            if (power_current_source_runtime->val_valid && time_remaining != BATTERY_INVALID_VALUE)
            {
                /* There is low time remaining */
                if (power_current_source_runtime->val.int_val < BATTERY_RUNTIME_WARNING_MINUTES)
                {
                    *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
                }
            }
            else
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
        }
    }
}

static void _rcp_indexed_power_in_status(rcp_camera_connection_t * con, rcp_param_status_t * status, uint32_t index, power_in_display_t power_in_display)
{
    if (con)
    {
        rcp_param_status_t voltage_status = RCP_PARAM_DISPLAY_STATUS_ERROR;
        rcp_param_status_t time_remaining_status = RCP_PARAM_DISPLAY_STATUS_ERROR;
        rcp_param_status_t percent_status = RCP_PARAM_DISPLAY_STATUS_ERROR;

        _rcp_indexed_power_in_status_voltage(con, &voltage_status, index);
        _rcp_indexed_power_in_status_percent(con, &percent_status, index);
        _rcp_indexed_power_in_status_time_remaining(con, &time_remaining_status, index);

        if (status)
        {
            *status = RCP_PARAM_DISPLAY_STATUS_GOOD;

            /*
             * When checking the status of a specific power in display type
             * (voltage, time remaining, or percentage for the power in dialog) it
             * is possible for the status to be disabled
             */
            if (power_in_display == POWER_IN_VOLTAGE && voltage_status == RCP_PARAM_DISPLAY_STATUS_DISABLED)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
            else if (power_in_display == POWER_IN_TIME_REMAINING && time_remaining_status == RCP_PARAM_DISPLAY_STATUS_DISABLED)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
            else if (power_in_display == POWER_IN_PERCENT && percent_status == RCP_PARAM_DISPLAY_STATUS_DISABLED)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_DISABLED;
            }
            /*
             * When checking the status of all power in display types (for the
             * bottom bar) any error should cause the status to be an error
             */
            else if (voltage_status == RCP_PARAM_DISPLAY_STATUS_ERROR || time_remaining_status == RCP_PARAM_DISPLAY_STATUS_ERROR || percent_status == RCP_PARAM_DISPLAY_STATUS_ERROR)
            {
                *status = RCP_PARAM_DISPLAY_STATUS_ERROR;
            }
        }
    }
}

static void _rcp_create_status_aperture(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_APERTURE];
            const rcp_param_state_t * const aperture_control_state = &con->param_state[RCP_PARAM_APERTURE_CONTROL];
            const rcp_param_state_t * const ae_mode = &con->param_state[RCP_PARAM_AE_MODE];
            const rcp_param_state_t * const ae_lockout_aperture = &con->param_state[RCP_PARAM_AE_LOCK_APERTURE];

            if (aperture_control_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            if (rcp_get_is_supported(con, RCP_PARAM_AE_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_AE_LOCK_APERTURE, NULL))
            {
                if (!ae_lockout_aperture->val.int_val)
                {
                    switch ((ae_mode_t) ae_mode->val.int_val)
                    {
                        case AE_MODE_OFF:
                        case AE_MODE_SINGLESHOT:
                            break;

                        default:
                        case AE_MODE_CONTINUOUS_PREVIEW:
                        case AE_MODE_CONTINUOUS_RECORD:
                            state->is_enabled = 0;
                    }
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_exposure_display(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const ae_mode = &con->param_state[RCP_PARAM_AE_MODE];
            const rcp_param_state_t * const ae_lockout_exposure = &con->param_state[RCP_PARAM_AE_LOCK_EXPOSURE];
            const rcp_param_state_t * const record_state = &con->param_state[RCP_PARAM_RECORD_STATE_BASE];
            const rcp_param_state_t * const record_hdr_state = &con->param_state[RCP_PARAM_RECORD_HDR_MODE];

            state->is_enabled = 1;

            /* Disable exposure if AE is in control of it */
            if (rcp_get_is_supported(con, RCP_PARAM_AE_MODE, NULL) && rcp_get_is_supported(con, RCP_PARAM_AE_LOCK_EXPOSURE, NULL))
            {
                if (!ae_lockout_exposure->val.int_val)
                {
                    switch ((ae_mode_t) ae_mode->val.int_val)
                    {
                        case AE_MODE_OFF:
                        case AE_MODE_SINGLESHOT:
                            break;

                        default:
                        case AE_MODE_CONTINUOUS_PREVIEW:
                        case AE_MODE_CONTINUOUS_RECORD:
                            state->is_enabled = 0;
                    }
                }
            }

            /* Disable exposure if HDR is enabled and we are recording */
            if (
                record_state->val_valid &&
                (record_state->val.int_val == RECORD_STATE_RECORDING || record_state->val.int_val == RECORD_STATE_ENCODING) &&
                record_hdr_state->val_valid &&
                record_hdr_state->val.int_val == HDR_MODE_HDRX
               )
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_focus(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const focus_control_state = &con->param_state[RCP_PARAM_FOCUS_CONTROL];
            const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (focus_control_state->val.int_val)
            {
                switch ((af_mode_t) af_mode_state->val.int_val)
                {
                    case AF_MODE_MANUAL:
                    case AF_MODE_CONFIRM:
                    case AF_MODE_RACK:
                        state->is_enabled = 1;
                        break;

                    case AF_MODE_PRIORITY:
                    case AF_MODE_FAST:
                    case AF_MODE_CONTINUOUS:
                    case AF_MODE_TOUCH_TRACK:
                    default:
                        state->is_enabled = 0;
                        break;
                }
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_fan_record_speed(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const fan_mode_state = &con->param_state[RCP_PARAM_FAN_MODE];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_FAN_REC_SPEED];

            switch (fan_mode_state->val.int_val)
            {
                case FAN_MODE_MANUAL:
                case FAN_MODE_AUTO:
                    state->is_enabled = 1;
                    break;

                case FAN_MODE_CONTROL_LOOP:
                case FAN_MODE_LOW_NOISE_PREVIEW_RECORD:
                case FAN_MODE_ADAPTIVE_PREVIEW_LOW_NOISE_RECORD:
                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_fan_preview_speed(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const fan_mode_state = &con->param_state[RCP_PARAM_FAN_MODE];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_FAN_PREVIEW_SPEED];

            switch (fan_mode_state->val.int_val)
            {
                case FAN_MODE_MANUAL:
                    state->is_enabled = 1;
                    break;

                case FAN_MODE_ADAPTIVE_PREVIEW_LOW_NOISE_RECORD:
                case FAN_MODE_AUTO:
                case FAN_MODE_CONTROL_LOOP:
                case FAN_MODE_LOW_NOISE_PREVIEW_RECORD:
                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_fan_delay(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const fan_mode_state = &con->param_state[RCP_PARAM_FAN_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            switch (fan_mode_state->val.int_val)
            {
                case FAN_MODE_MANUAL:
                case FAN_MODE_AUTO:
                case FAN_MODE_ADAPTIVE_PREVIEW_LOW_NOISE_RECORD:
                    state->is_enabled = 1;
                    break;

                case FAN_MODE_CONTROL_LOOP:
                case FAN_MODE_LOW_NOISE_PREVIEW_RECORD:
                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_fan_target_temperature(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const fan_mode_state = &con->param_state[RCP_PARAM_FAN_MODE];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_FAN_TARGET_TEMPERATURE];

            switch (fan_mode_state->val.int_val)
            {
                case FAN_MODE_CONTROL_LOOP:
                case FAN_MODE_ADAPTIVE_PREVIEW_LOW_NOISE_RECORD:
                    state->is_enabled = 1;
                    break;

                case FAN_MODE_MANUAL:
                case FAN_MODE_AUTO:
                case FAN_MODE_LOW_NOISE_PREVIEW_RECORD:
                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_color_space(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            if (rcp_get_is_supported(con, RCP_PARAM_VIDEO_SOURCE, NULL))
            {
                const rcp_param_state_t * const video_source_state = &con->param_state[RCP_PARAM_VIDEO_SOURCE];

                switch (video_source_state->val.int_val)
                {
                    case VIDEO_SOURCE_ACESCC_ACESAP1:
                    case VIDEO_SOURCE_LOG3G10_DRAGONCOLOR:
                    case VIDEO_SOURCE_LOG3G10_DRAGONCOLOR2:
                    case VIDEO_SOURCE_LOG3G10_REC709:
                    case VIDEO_SOURCE_LOG3G10_REC2020:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR2:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR3:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR4:
                    case VIDEO_SOURCE_LOG3G10_RWGRGB:
                    case VIDEO_SOURCE_GRADED:
                    case VIDEO_SOURCE_SPLIT_CURVE_RLF:
                    case VIDEO_SOURCE_SPLIT_CURVE_LOG3G12:
                        state->is_enabled = 1;
                        break;

                    default:
                        state->is_enabled = 0;
                        break;
                }
            }
            else
            {
                /* This logic is used for older firmware */
                const rcp_param_state_t * const aces_state = &con->param_state[RCP_PARAM_ACES_PROXY];

                if (aces_state->val.int_val)
                {
                    state->is_enabled = 0;
                }
                else
                {
                    state->is_enabled = 1;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_gamma_space(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            if (rcp_get_is_supported(con, RCP_PARAM_VIDEO_SOURCE, NULL))
            {
                const rcp_param_state_t * const video_source_state = &con->param_state[RCP_PARAM_VIDEO_SOURCE];

                switch (video_source_state->val.int_val)
                {
                    case VIDEO_SOURCE_ACESCC_ACESAP1:
                    case VIDEO_SOURCE_LOG3G10_DRAGONCOLOR:
                    case VIDEO_SOURCE_LOG3G10_DRAGONCOLOR2:
                    case VIDEO_SOURCE_LOG3G10_REC709:
                    case VIDEO_SOURCE_LOG3G10_REC2020:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR2:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR3:
                    case VIDEO_SOURCE_LOG3G10_REDCOLOR4:
                    case VIDEO_SOURCE_LOG3G10_RWGRGB:
                    case VIDEO_SOURCE_GRADED:
                    case VIDEO_SOURCE_SPLIT_CURVE_RLF:
                    case VIDEO_SOURCE_SPLIT_CURVE_LOG3G12:
                    case VIDEO_SOURCE_ACES_AND_SPLIT_CURVE:
                    case VIDEO_SOURCE_DEPRECATED_1:
                        state->is_enabled = 1;
                        break;

                    default:
                        state->is_enabled = 0;
                        break;
                }
            }
            else
            {
                /* This logic is used for older firmware */
                const rcp_param_state_t * const aces_state = &con->param_state[RCP_PARAM_ACES_PROXY];
                const rcp_param_state_t * const split_curve_state = &con->param_state[RCP_PARAM_MONITOR_SPLIT_CURVE];

                if (aces_state->val.int_val && !split_curve_state->val.int_val)
                {
                    state->is_enabled = 0;
                }
                else
                {
                    state->is_enabled = 1;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static int _rcp_monitor_is_enabled(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t enable_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * enable_state = NULL;

            switch (_rcp_get_monitor(id))
            {
                case MONITOR_BRAIN_HDSDI:
                    enable_id = RCP_PARAM_MONITOR_ENABLE_HDSDI;
                    break;

                case MONITOR_REAR_HDSDI_1:
                    enable_id = RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1;
                    break;

                case MONITOR_REAR_HDSDI_2:
                    enable_id = RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2;
                    break;

                default:
                    /* only the HDSDI monitors can be disabled */
                    return 1;
            }

            enable_state = &con->param_state[enable_id];
            return enable_state->val.int_val;
        }
    }

    return 1;
}

static monitor_t _rcp_get_monitor(rcp_param_t rcp_param)
{
    switch (rcp_param)
    {
        case RCP_PARAM_MONITOR_MODE_LCD:
        case RCP_PARAM_MONITOR_OVERLAY_LCD:
        case RCP_PARAM_MONITOR_FREQ_LCD:
        case RCP_PARAM_MONITOR_TOOLS_LCD:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_LCD:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD:
        case RCP_PARAM_MONITOR_DOCK_MENUS_LCD:
        case RCP_PARAM_MONITOR_BRIGHTNESS_LCD:
        case RCP_PARAM_MONITOR_CURVE_LCD:
        case RCP_PARAM_DISPLAY_PRESET_LCD:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_LCD:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD:
        case RCP_PARAM_MONITOR_FEED_LCD:
        case RCP_PARAM_MONITOR_LUT_LCD:
            return MONITOR_BRAIN_LCD;

        case RCP_PARAM_MONITOR_MODE_HDMI:
        case RCP_PARAM_MONITOR_OVERLAY_HDMI:
        case RCP_PARAM_MONITOR_RESOLUTION_HDMI:
        case RCP_PARAM_MONITOR_FREQ_HDMI:
        case RCP_PARAM_MONITOR_TOOLS_HDMI:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI:
        case RCP_PARAM_MONITOR_DOCK_MENUS_HDMI:
        case RCP_PARAM_MONITOR_CURVE_HDMI:
        case RCP_PARAM_DISPLAY_PRESET_HDMI:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI:
        case RCP_PARAM_MONITOR_FEED_HDMI:
        case RCP_PARAM_MONITOR_LUT_HDMI:
            return MONITOR_BRAIN_HDMI;

        case RCP_PARAM_MONITOR_MODE_HDSDI:
        case RCP_PARAM_MONITOR_OVERLAY_HDSDI:
        case RCP_PARAM_MONITOR_FREQ_HDSDI:
        case RCP_PARAM_MONITOR_RESOLUTION_HDSDI:
        case RCP_PARAM_MONITOR_TOOLS_HDSDI:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI:
        case RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI:
        case RCP_PARAM_MONITOR_ENABLE_HDSDI:
        case RCP_PARAM_MONITOR_CURVE_HDSDI:
        case RCP_PARAM_DISPLAY_PRESET_HDSDI:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI:
        case RCP_PARAM_MONITOR_FEED_HDSDI:
        case RCP_PARAM_MONITOR_LUT_HDSDI:
            return MONITOR_BRAIN_HDSDI;

        case RCP_PARAM_MONITOR_MODE_EVF:
        case RCP_PARAM_MONITOR_OVERLAY_EVF:
        case RCP_PARAM_MONITOR_FREQ_EVF:
        case RCP_PARAM_MONITOR_TOOLS_EVF:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_EVF:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF:
        case RCP_PARAM_MONITOR_DOCK_MENUS_EVF:
        case RCP_PARAM_MONITOR_BRIGHTNESS_EVF:
        case RCP_PARAM_MONITOR_CURVE_EVF:
        case RCP_PARAM_DISPLAY_PRESET_EVF:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF:
        case RCP_PARAM_MONITOR_FEED_EVF:
        case RCP_PARAM_MONITOR_LUT_EVF:
            return MONITOR_BRAIN_EVF;

        case RCP_PARAM_MONITOR_MODE_REAR_LCD:
        case RCP_PARAM_MONITOR_OVERLAY_REAR_LCD:
        case RCP_PARAM_MONITOR_FREQ_REAR_LCD:
        case RCP_PARAM_MONITOR_TOOLS_REAR_LCD:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD:
        case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD:
        case RCP_PARAM_MONITOR_BRIGHTNESS_REAR_LCD:
        case RCP_PARAM_MONITOR_CURVE_REAR_LCD:
        case RCP_PARAM_DISPLAY_PRESET_REAR_LCD:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD:
        case RCP_PARAM_MONITOR_FEED_REAR_LCD:
        case RCP_PARAM_MONITOR_LUT_REAR_LCD:
            return MONITOR_REAR_LCD;

        case RCP_PARAM_MONITOR_MODE_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1:
        case RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_FEED_REAR_HDSDI1:
        case RCP_PARAM_MONITOR_LUT_REAR_HDSDI1:
            return MONITOR_REAR_HDSDI_1;

        case RCP_PARAM_MONITOR_MODE_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2:
        case RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_FEED_REAR_HDSDI2:
        case RCP_PARAM_MONITOR_LUT_REAR_HDSDI2:
            return MONITOR_REAR_HDSDI_2;

        case RCP_PARAM_MONITOR_MODE_REAR_EVF:
        case RCP_PARAM_MONITOR_OVERLAY_REAR_EVF:
        case RCP_PARAM_MONITOR_FREQ_REAR_EVF:
        case RCP_PARAM_MONITOR_TOOLS_REAR_EVF:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF:
        case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF:
        case RCP_PARAM_MONITOR_BRIGHTNESS_REAR_EVF:
        case RCP_PARAM_MONITOR_CURVE_REAR_EVF:
        case RCP_PARAM_DISPLAY_PRESET_REAR_EVF:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF:
        case RCP_PARAM_MONITOR_FEED_REAR_EVF:
        case RCP_PARAM_MONITOR_LUT_REAR_EVF:
            return MONITOR_REAR_EVF;

        case RCP_PARAM_MONITOR_MODE_LCD3:
        case RCP_PARAM_MONITOR_OVERLAY_LCD3:
        case RCP_PARAM_MONITOR_FREQ_LCD3:
        case RCP_PARAM_MONITOR_TOOLS_LCD3:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3:
        case RCP_PARAM_MONITOR_DOCK_MENUS_LCD3:
        case RCP_PARAM_MONITOR_BRIGHTNESS_LCD3:
        case RCP_PARAM_MONITOR_CURVE_LCD3:
        case RCP_PARAM_DISPLAY_PRESET_LCD3:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3:
        case RCP_PARAM_MONITOR_FEED_LCD3:
        case RCP_PARAM_MONITOR_LUT_BRAIN_LCD3:
            return MONITOR_BRAIN_LCD3;

        case RCP_PARAM_MONITOR_MODE_EVF3:
        case RCP_PARAM_MONITOR_OVERLAY_EVF3:
        case RCP_PARAM_MONITOR_FREQ_EVF3:
        case RCP_PARAM_MONITOR_TOOLS_EVF3:
        case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3:
        case RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3:
        case RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3:
        case RCP_PARAM_MONITOR_DOCK_MENUS_EVF3:
        case RCP_PARAM_MONITOR_BRIGHTNESS_EVF3:
        case RCP_PARAM_MONITOR_CURVE_EVF3:
        case RCP_PARAM_DISPLAY_PRESET_EVF3:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3:
        case RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3:
        case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3:
        case RCP_PARAM_MONITOR_FEED_EVF3:
        case RCP_PARAM_MONITOR_LUT_BRAIN_EVF3:
            return MONITOR_BRAIN_EVF3;

        case RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1:
            return MONITOR_REAR_UHDSDI_1;

        case RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2:
            return MONITOR_REAR_UHDSDI_2;

        default:
            return MONITOR_COUNT;
    }
}

static int _rcp_monitor_is_enhanced_af(const rcp_camera_connection_t * con, rcp_param_t rcp_param)
{
    if (con)
    {
        const rcp_param_state_t * const enhanced_af_state = &con->param_state[RCP_PARAM_AF_ENHANCED_ENABLE];
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_AF_ENHANCED_MONITOR];

        if (enhanced_af_state->val.int_val == 1)
        {
            if (state->val.int_val == _rcp_get_monitor(rcp_param))
            {
                return 1;
            }
        }
    }

    return 0;
}

static void _rcp_create_status_monitor_overlay(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (_rcp_get_monitor(id))
            {
                case MONITOR_BRAIN_LCD:
                    mode_id = RCP_PARAM_MONITOR_MODE_LCD;
                    break;

                case MONITOR_BRAIN_HDMI:
                    mode_id = RCP_PARAM_MONITOR_MODE_HDMI;
                    break;

                case MONITOR_BRAIN_HDSDI:
                    mode_id = RCP_PARAM_MONITOR_MODE_HDSDI;
                    break;

                case MONITOR_BRAIN_EVF:
                    mode_id = RCP_PARAM_MONITOR_MODE_EVF;
                    break;

                case MONITOR_REAR_LCD:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_LCD;
                    break;

                case MONITOR_REAR_HDSDI_1:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_HDSDI1;
                    break;

                case MONITOR_REAR_HDSDI_2:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_HDSDI2;
                    break;

                case MONITOR_REAR_EVF:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_EVF;
                    break;

                case MONITOR_BRAIN_LCD3:
                    mode_id = RCP_PARAM_MONITOR_MODE_LCD3;
                    break;

                case MONITOR_BRAIN_EVF3:
                    mode_id = RCP_PARAM_MONITOR_MODE_EVF3;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if ((monitor_mode_t) mode_state->val.int_val == MONITOR_MODE_OVERLAY)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            if (!_rcp_monitor_is_enabled(con, id))
            {
                state->is_enabled = 0;
            }

            if (_rcp_monitor_is_enhanced_af(con, id))
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_video_flip(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            state->is_enabled = 1;

            /* If an LCD/EVF supports native flip/mirroring, disable
             * video flip  */
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_LCD && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_EVF && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3 && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3 && con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3].val.int_val)
            {
                state->is_enabled = 0;
            }

            /* If an HDSDI monitor is disabled, disable video flip */
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI && !con->param_state[RCP_PARAM_MONITOR_ENABLE_HDSDI].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1 && !con->param_state[RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1].val.int_val)
            {
                state->is_enabled = 0;
            }
            if (id == RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2 && !con->param_state[RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2].val.int_val)
            {
                state->is_enabled = 0;
            }

            /* If the camera has multi feeds, we will display the video
             * flip setting, since each feed can be properly
             * flip/mirrored. */
            if (_rcp_get_hw_cap(con, HW_CAP_MULTI_MONITOR_FEEDS))
            {
                state->is_enabled = 0;
            }

            if (_rcp_monitor_is_enhanced_af(con, id))
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_monitor_enable(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            state->is_enabled = _rcp_monitor_is_enabled(con, id);

            if (_rcp_monitor_is_enhanced_af(con, id))
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_monitor_curve(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            int split_curve_enabled = 0;
            rcp_param_state_t * const state = &con->param_state[id];

            if (rcp_get_is_supported(con, RCP_PARAM_MONITOR_SPLIT_CURVE, NULL))
            {
                const rcp_param_state_t * const split_curve_state = &con->param_state[RCP_PARAM_MONITOR_SPLIT_CURVE];
                if (split_curve_state->val.int_val)
                {
                    split_curve_enabled = 1;
                }
            }
            else
            {
                if (_rcp_version_greater_or_equal_to(con, 6, 50))
                {
                    /* as of 6.50, split curve is always enabled */
                    split_curve_enabled = 1;
                }
            }

            state->is_enabled = split_curve_enabled;

            if (_rcp_monitor_is_enabled(con, id) == 0)
            {
                state->is_enabled = 0;
            }

            if (_rcp_monitor_is_enhanced_af(con, id))
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_metadata_curve(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            int split_curve_enabled = 0;
            rcp_param_state_t * const state = &con->param_state[id];

            if (rcp_get_is_supported(con, RCP_PARAM_MONITOR_SPLIT_CURVE, NULL))
            {
                const rcp_param_state_t * const split_curve_state = &con->param_state[RCP_PARAM_MONITOR_SPLIT_CURVE];
                if (split_curve_state->val.int_val)
                {
                    split_curve_enabled = 1;
                }
            }
            else
            {
                if (_rcp_version_greater_or_equal_to(con, 6, 50))
                {
                    /* as of 6.50, split curve is always enabled */
                    split_curve_enabled = 1;
                }
            }

            state->is_enabled = split_curve_enabled;
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_set_timecode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const tc_source_state = &con->param_state[RCP_PARAM_TIMECODE_SOURCE];
            rcp_param_state_t * const state = &con->param_state[id];

            if ((tc_source_t) tc_source_state->val.int_val == TC_SOURCE_USER)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_guide_normal_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_FRAME_GUIDE_SCALE:
                case RCP_PARAM_FRAME_GUIDE_X_OFFSET:
                case RCP_PARAM_FRAME_GUIDE_Y_OFFSET:
                    mode_id = RCP_PARAM_FRAME_GUIDE_MODE;
                    break;

                case RCP_PARAM_ACTION_GUIDE_SCALE:
                case RCP_PARAM_ACTION_GUIDE_X_OFFSET:
                case RCP_PARAM_ACTION_GUIDE_Y_OFFSET:
                case RCP_PARAM_ACTION_GUIDE_RELATIVE:
                    mode_id = RCP_PARAM_ACTION_GUIDE_MODE;
                    break;

                case RCP_PARAM_TITLE_GUIDE_SCALE:
                case RCP_PARAM_TITLE_GUIDE_X_OFFSET:
                case RCP_PARAM_TITLE_GUIDE_Y_OFFSET:
                case RCP_PARAM_TITLE_GUIDE_RELATIVE:
                    mode_id = RCP_PARAM_TITLE_GUIDE_MODE;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if (
                ((guide_aspect_ratio_t) mode_state->val.int_val != GUIDE_ASPECT_RATIO_ABSOLUTE) &&
                ((guide_aspect_ratio_t) mode_state->val.int_val != GUIDE_ASPECT_RATIO_OFF)
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_guide_user_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_FRAME_GUIDE_USER_AR_NUM:
                    mode_id = RCP_PARAM_FRAME_GUIDE_MODE;
                    break;

                case RCP_PARAM_ACTION_GUIDE_USER_AR_NUM:
                    mode_id = RCP_PARAM_ACTION_GUIDE_MODE;
                    break;

                case RCP_PARAM_TITLE_GUIDE_USER_AR_NUM:
                    mode_id = RCP_PARAM_TITLE_GUIDE_MODE;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if ((guide_aspect_ratio_t) mode_state->val.int_val == GUIDE_ASPECT_RATIO_USER)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_guide_abs_aspect_ratio(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_FRAME_GUIDE_ABS_X_OFFSET:
                case RCP_PARAM_FRAME_GUIDE_ABS_Y_OFFSET:
                case RCP_PARAM_FRAME_GUIDE_ABS_W:
                case RCP_PARAM_FRAME_GUIDE_ABS_H:
                    mode_id = RCP_PARAM_FRAME_GUIDE_MODE;
                    break;

                case RCP_PARAM_ACTION_GUIDE_ABS_X_OFFSET:
                case RCP_PARAM_ACTION_GUIDE_ABS_Y_OFFSET:
                case RCP_PARAM_ACTION_GUIDE_ABS_W:
                case RCP_PARAM_ACTION_GUIDE_ABS_H:
                    mode_id = RCP_PARAM_ACTION_GUIDE_MODE;
                    break;

                case RCP_PARAM_TITLE_GUIDE_ABS_X_OFFSET:
                case RCP_PARAM_TITLE_GUIDE_ABS_Y_OFFSET:
                case RCP_PARAM_TITLE_GUIDE_ABS_W:
                case RCP_PARAM_TITLE_GUIDE_ABS_H:
                    mode_id = RCP_PARAM_TITLE_GUIDE_MODE;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if ((guide_aspect_ratio_t) mode_state->val.int_val == GUIDE_ASPECT_RATIO_ABSOLUTE)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_guide_line_attributes(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_FRAME_GUIDE_LINE_STYLE:
                case RCP_PARAM_FRAME_GUIDE_COLOR:
                case RCP_PARAM_FRAME_GUIDE_OPACITY:
                    mode_id = RCP_PARAM_FRAME_GUIDE_MODE;
                    break;

                case RCP_PARAM_ACTION_GUIDE_LINE_STYLE:
                case RCP_PARAM_ACTION_GUIDE_COLOR:
                case RCP_PARAM_ACTION_GUIDE_OPACITY:
                    mode_id = RCP_PARAM_ACTION_GUIDE_MODE;
                    break;

                case RCP_PARAM_TITLE_GUIDE_LINE_STYLE:
                case RCP_PARAM_TITLE_GUIDE_COLOR:
                case RCP_PARAM_TITLE_GUIDE_OPACITY:
                case RCP_PARAM_TITLE_GUIDE_RELATIVE:
                    mode_id = RCP_PARAM_TITLE_GUIDE_MODE;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if ((guide_aspect_ratio_t) mode_state->val.int_val != GUIDE_ASPECT_RATIO_OFF)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_enhanced_af(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            /* Enhanced auto focus was removed in 6.50, so two separate implementations are used to maintain backwards compatibility */
            if (_rcp_version_greater_or_equal_to(con, 6, 50))
            {
                if (id == RCP_PARAM_AF_ENHANCED_MONITOR)
                {
                    state->is_enabled = 0;
                }
                else if (id == RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE)
                {
                    const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];
                    const af_mode_t af_mode = (af_mode_t)af_mode_state->val.int_val;

                    state->is_enabled = (af_mode == AF_MODE_CONFIRM ? 1 : 0);
                }
            }
            else
            {
                const rcp_param_state_t * const enhanced_af_state = &con->param_state[RCP_PARAM_AF_ENHANCED_ENABLE];
                state->is_enabled = (enhanced_af_state->val.int_val == 1 ? 1 : 0);
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ae_mode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const mm_mode = &con->param_state[RCP_PARAM_MM_MODE];
            rcp_param_state_t * const state = &con->param_state[id];
            motion_mount_shutter_mode_t mode;

            /* earlier camera firmware didn't have the mm mode, if
             * we have it use it, otherwise default to nd mode. */
            if (rcp_get_is_supported(con, RCP_PARAM_MM_MODE, NULL))
            {
                mode = (motion_mount_shutter_mode_t) mm_mode->val.int_val;
            }
            else
            {
                mode = MOTION_MOUNT_SHUTTER_MODE_ND_ONLY;
            }

            if (mode == MOTION_MOUNT_SHUTTER_MODE_ND_ONLY)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ae(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const ae_mode_state = &con->param_state[RCP_PARAM_AE_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            if ((ae_mode_t) ae_mode_state->val.int_val != AE_MODE_OFF)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_beeps(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const beep_enable_state = &con->param_state[RCP_PARAM_BEEP_ENABLE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (beep_enable_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_frame_processing(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const frame_processing_state = &con->param_state[RCP_PARAM_FRAME_PROCESSING_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            if ((frame_processing_t) frame_processing_state->val.int_val != FRAME_PROCESSING_OFF)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_gige_addresses(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const gige_dhcp_state = &con->param_state[RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (gige_dhcp_state->val.int_val)
            {
                state->is_enabled = 0;
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_audio_48v(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_AUDIO_CH1_48V_POWER:
                    mode_id = RCP_PARAM_AUDIO_CH1_48V_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH2_48V_POWER:
                    mode_id = RCP_PARAM_AUDIO_CH2_48V_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH3_48V_POWER:
                    mode_id = RCP_PARAM_AUDIO_CH3_48V_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH4_48V_POWER:
                    mode_id = RCP_PARAM_AUDIO_CH4_48V_PRESENT;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if (mode_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_audio_limiter(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_AUDIO_CH1_LIMITER:
                    mode_id = RCP_PARAM_AUDIO_CH1_LIMITER_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH2_LIMITER:
                    mode_id = RCP_PARAM_AUDIO_CH2_LIMITER_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH3_LIMITER:
                    mode_id = RCP_PARAM_AUDIO_CH3_LIMITER_PRESENT;
                    break;

                case RCP_PARAM_AUDIO_CH4_LIMITER:
                    mode_id = RCP_PARAM_AUDIO_CH4_LIMITER_PRESENT;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];

            if (mode_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_slate_take_shot(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const slate_scene_state = &con->param_state[RCP_PARAM_SLATE_SCENE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (slate_scene_state->val.str_val[0])
            {
                /* the take number is only valid if we have a scene name */
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_record_limit_enable(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];
            rcp_param_state_t * const state = &con->param_state[id];

            state->is_enabled = 1;

            switch ((record_mode_t) record_mode_state->val.int_val)
            {
                case RECORD_MODE_CONTINUOUS:
                case RECORD_MODE_TIMELAPSE:
                case RECORD_MODE_FRAME_TRIGGER:
                case RECORD_MODE_RAMP:
                case RECORD_MODE_BURST:
                case RECORD_MODE_MULTI_SHOT:
                case RECORD_MODE_MOTION_PLUS_STILLS:
                case RECORD_MODE_PREVIEW_OVERDRIVE:
                    break;

                default:
                    state->is_enabled = 0;
                    break;
            }

            switch ((primary_storage_t) primary_storage_state->val.int_val)
            {
                case PRIMARY_STORAGE_LOCAL:
                    break;

                case PRIMARY_STORAGE_NETWORK:
                case PRIMARY_STORAGE_EXTERNAL:
                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_record_limit_frames(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];
            const rcp_param_state_t * const limit_enable_state = &con->param_state[RCP_PARAM_RECORD_LIMIT_ENABLE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (limit_enable_state->val.int_val)
            {
                state->is_enabled = 1;

                switch ((record_mode_t) record_mode_state->val.int_val)
                {
                    case RECORD_MODE_CONTINUOUS:
                    case RECORD_MODE_TIMELAPSE:
                    case RECORD_MODE_FRAME_TRIGGER:
                    case RECORD_MODE_RAMP:
                    case RECORD_MODE_BURST:
                    case RECORD_MODE_MULTI_SHOT:
                    case RECORD_MODE_MOTION_PLUS_STILLS:
                    case RECORD_MODE_PREVIEW_OVERDRIVE:
                        break;

                    default:
                        state->is_enabled = 0;
                        break;
                }

                switch ((primary_storage_t) primary_storage_state->val.int_val)
                {
                    case PRIMARY_STORAGE_LOCAL:
                        break;

                    case PRIMARY_STORAGE_NETWORK:
                    case PRIMARY_STORAGE_EXTERNAL:
                    default:
                        state->is_enabled = 0;
                        break;
                }
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_record_timer_settings(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            switch ((record_mode_t) record_mode_state->val.int_val)
            {
                case RECORD_MODE_TIMELAPSE:
                    state->is_enabled = 1;
                    break;

                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_record_prepost_settings(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            switch ((record_mode_t) record_mode_state->val.int_val)
            {
                case RECORD_MODE_FRAME_TRIGGER:
                case RECORD_MODE_BURST:
                    state->is_enabled = 1;
                    break;

                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_record_ramp_settings(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            switch ((record_mode_t) record_mode_state->val.int_val)
            {
                case RECORD_MODE_RAMP:
                    state->is_enabled = 1;
                    break;

                default:
                    state->is_enabled = 0;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_zebra(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * enable_state = NULL;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];
            int enabled = 0;
            int correct_mode = 0;
            zebra_mode_t required_mode = ZEBRA_MODE_COUNT;

            switch (id)
            {
                case RCP_PARAM_ZEBRA_1_MODE:
                case RCP_PARAM_ZEBRA_1_IRE_LOW:
                case RCP_PARAM_ZEBRA_1_IRE_HIGH:
                case RCP_PARAM_ZEBRA_1_STOPS_LOW:
                case RCP_PARAM_ZEBRA_1_STOPS_HIGH:
                case RCP_PARAM_ZEBRA_1_PATTERN:
                case RCP_PARAM_ZEBRA_1_COLOR:
                    enable_state = &con->param_state[RCP_PARAM_ZEBRA_1_ENABLE];
                    break;

                case RCP_PARAM_ZEBRA_2_MODE:
                case RCP_PARAM_ZEBRA_2_IRE_LOW:
                case RCP_PARAM_ZEBRA_2_IRE_HIGH:
                case RCP_PARAM_ZEBRA_2_STOPS_LOW:
                case RCP_PARAM_ZEBRA_2_STOPS_HIGH:
                case RCP_PARAM_ZEBRA_2_PATTERN:
                case RCP_PARAM_ZEBRA_2_COLOR:
                    enable_state = &con->param_state[RCP_PARAM_ZEBRA_2_ENABLE];
                    break;

                default:
                    /* we shouldn't get here */
                    return;
            }

            if (enable_state->val.int_val)
            {
                enabled = 1;
            }

            switch (id)
            {
                case RCP_PARAM_ZEBRA_1_IRE_LOW:
                case RCP_PARAM_ZEBRA_1_IRE_HIGH:
                    required_mode = ZEBRA_MODE_VIDEO;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_1_MODE];
                    break;

                case RCP_PARAM_ZEBRA_1_STOPS_LOW:
                case RCP_PARAM_ZEBRA_1_STOPS_HIGH:
                    required_mode = ZEBRA_MODE_RAW;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_1_MODE];
                    break;

                case RCP_PARAM_ZEBRA_2_IRE_LOW:
                case RCP_PARAM_ZEBRA_2_IRE_HIGH:
                    required_mode = ZEBRA_MODE_VIDEO;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_2_MODE];
                    break;

                case RCP_PARAM_ZEBRA_2_STOPS_LOW:
                case RCP_PARAM_ZEBRA_2_STOPS_HIGH:
                    required_mode = ZEBRA_MODE_RAW;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_2_MODE];
                    break;

                case RCP_PARAM_ZEBRA_1_PATTERN:
                case RCP_PARAM_ZEBRA_1_COLOR:
                    required_mode = ZEBRA_MODE_RAW;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_1_MODE];
                    break;

                case RCP_PARAM_ZEBRA_2_PATTERN:
                case RCP_PARAM_ZEBRA_2_COLOR:
                    required_mode = ZEBRA_MODE_RAW;
                    mode_state = &con->param_state[RCP_PARAM_ZEBRA_2_MODE];
                    break;

                default:
                    /* we shouldn't get here */
                    break;
            }

            if (mode_state)
            {
                if ((zebra_mode_t) mode_state->val.int_val == required_mode)
                {
                    correct_mode = 1;
                }
            }
            else
            {
                /* we will only get here for RCP_PARAM_ZEBRA_1/2_MODE.
                 * force correct_mode to true for these entries. */
                correct_mode = 1;
            }

            if (enabled && correct_mode)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_hdr(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const hdr_mode_state = &con->param_state[RCP_PARAM_HDR_MODE];

            if ((hdr_mode_t) hdr_mode_state->val.int_val != HDR_MODE_OFF)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_hdr_mode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            const rcp_param_state_t * const test_pattern_state = &con->param_state[RCP_PARAM_TEST_PATTERN];               /* 5.0 */
            const rcp_param_state_t * const sync_state = &con->param_state[RCP_PARAM_SENSOR_SYNC_MODE];                   /* 6.0 */
            const rcp_param_state_t * const record_state = &con->param_state[RCP_PARAM_RECORD_MODE];                      /* 5.0 */
            const rcp_param_state_t * const mm_mode_state = &con->param_state[RCP_PARAM_MM_MODE];                         /* 5.0 */
            const rcp_param_state_t * const frame_processing_state = &con->param_state[RCP_PARAM_FRAME_PROCESSING_MODE];  /* 5.0 */
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];         /* 6.1 */

            const monitor_test_pattern_t monitor_test_pattern = (monitor_test_pattern_t) test_pattern_state->val.int_val;
            sync_mode_t sync_mode = SYNC_MODE_OFF;
            const record_mode_t record_mode = (record_mode_t) record_state->val.int_val;
            const motion_mount_shutter_mode_t motion_mount_shutter_mode = (motion_mount_shutter_mode_t) mm_mode_state->val.int_val;
            const frame_processing_t frame_processing = (frame_processing_t) frame_processing_state->val.int_val;
            primary_storage_t primary_storage = PRIMARY_STORAGE_LOCAL;

            if (rcp_get_is_supported(con, RCP_PARAM_SENSOR_SYNC_MODE, NULL))
            {
                sync_mode = (sync_mode_t) sync_state->val.int_val;
            }

            if (rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL))
            {
                primary_storage = (primary_storage_t) primary_storage_state->val.int_val;
            }

            state->is_enabled = 1;

            if (
                (monitor_test_pattern != MONITOR_TEST_PATTERN_NONE) ||
                (frame_processing != FRAME_PROCESSING_OFF) ||
                (sync_mode != SYNC_MODE_OFF) ||
                (record_mode == RECORD_MODE_RAMP) ||
                (motion_mount_shutter_mode != MOTION_MOUNT_SHUTTER_MODE_ND_ONLY) ||
                (primary_storage == PRIMARY_STORAGE_NETWORK)
               )
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_target_id(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const target_state = &con->param_state[RCP_PARAM_TARGET];

            if ((rcp_target_t) target_state->val.int_val == RCP_TARGET_CUSTOM)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ch12_gain(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const source_state = &con->param_state[RCP_PARAM_AUDIO_CH12_SOURCE];

            if ((audio_channel_source_t) source_state->val.int_val == AUDIO_CHANNEL_SOURCE_NONE)
            {
                state->is_enabled = 0;
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ch34_gain(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const source_state = &con->param_state[RCP_PARAM_AUDIO_CH34_SOURCE];

            if ((audio_channel_source_t) source_state->val.int_val == AUDIO_CHANNEL_SOURCE_NONE)
            {
                state->is_enabled = 0;
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ch1_vol(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const mute_state = &con->param_state[RCP_PARAM_AUDIO_CH1_MUTE];

            if (mute_state->val.int_val)
            {
                state->is_enabled = 0;
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ch2_vol(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const mute_state = &con->param_state[RCP_PARAM_AUDIO_CH2_MUTE];

            if (mute_state->val.int_val)
            {
                state->is_enabled = 0;
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_flip_mirror(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_LCD)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD].val.int_val;
            }
            else if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF].val.int_val;
            }
            else if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD].val.int_val;
            }
            else if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF].val.int_val;
            }
            else if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3].val.int_val;
            }
            else if (id == RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3)
            {
                state->is_enabled = con->param_state[RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3].val.int_val;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ui_flip_mirror(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_t mode_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * mode_state = NULL;
            rcp_param_t flip_mirror_supported_id = RCP_PARAM_COUNT;
            const rcp_param_state_t * flip_mirror_supported_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            switch (id)
            {
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD:
                    mode_id = RCP_PARAM_MONITOR_MODE_LCD;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD;
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF:
                    mode_id = RCP_PARAM_MONITOR_MODE_EVF;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF;
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_LCD;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD;
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF:
                    mode_id = RCP_PARAM_MONITOR_MODE_REAR_EVF;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF;
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3:
                    mode_id = RCP_PARAM_MONITOR_MODE_LCD3;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3;
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3:
                    mode_id = RCP_PARAM_MONITOR_MODE_EVF3;
                    flip_mirror_supported_id = RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3;
                    break;

                default:
                    return;
            }

            mode_state = &con->param_state[mode_id];
            flip_mirror_supported_state = &con->param_state[flip_mirror_supported_id];

            /* default to enabled, disable based on other conditions */
            state->is_enabled = 1;

            if ((monitor_mode_t) mode_state->val.int_val != MONITOR_MODE_OVERLAY)
            {
                state->is_enabled = 0;
            }

            if (flip_mirror_supported_state->val.int_val)
            {
                state->is_enabled = 0;
            }

            if (_rcp_monitor_is_enhanced_af(con, id))
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_attached(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_MEDIA_IS_ATTACHED, NULL))
            {
                if (!media_attached_state->val.int_val)
                {
                    state->is_enabled = 0;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_present(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];
            const rcp_param_state_t * const media_present_state = &con->param_state[RCP_PARAM_MEDIA_IS_PRESENT];

            if (rcp_get_is_supported(con, RCP_PARAM_MEDIA_IS_PRESENT, NULL))
            {
                /* If the camera supports RCP_PARAM_MEDIA_IS_PRESENT we
                 * will use it as it directly tells us if the media is
                 * present. */
                if (media_present_state->val.int_val)
                {
                    state->is_enabled = 1;
                }
                else
                {
                    state->is_enabled = 0;
                }
            }
            else if (rcp_get_is_supported(con, RCP_PARAM_MEDIA_IS_ATTACHED, NULL))
            {
                /* If the camera doesn't support RCP_PARAM_MEDIA_IS_PRESENT,
                 * but does support RCP_PARAM_MEDIA_IS_ATTACHED, we
                 * will use it instead.  Note, this causes a slight
                 * problem in older cameras because it won't allow us
                 * to format media that has been inserted into the
                 * camera, but not formatted. (this is why we addrd
                 * RCP_PARAM_MEDIA_IS_PRESENT). */
                if (media_attached_state->val.int_val)
                {
                    state->is_enabled = 1;
                }
                else
                {
                    state->is_enabled = 0;
                }
            }
            else
            {
                /* If the camera firmware doesn't support either
                 * RCP_PARAM_MEDIA_IS_PRESENT or
                 * RCP_PARAM_MEDIA_IS_ATTACHED we will just assume it
                 * is attached. */
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_gio_scope(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const false_color_mode_state = &con->param_state[RCP_PARAM_FALSE_COLOR_MODE];

            state->is_enabled = 0;

            if ((false_color_mode_t) false_color_mode_state->val.int_val == FALSE_COLOR_MODE_GIO_SCOPE)
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_af_zone(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];

            switch ((af_mode_t) af_mode_state->val.int_val)
            {
                case AF_MODE_MANUAL:
                case AF_MODE_RACK:
                default:
                    state->is_enabled = 0;
                    break;

                case AF_MODE_CONFIRM:
                case AF_MODE_FAST:
                case AF_MODE_PRIORITY:
                case AF_MODE_CONTINUOUS:
                case AF_MODE_TOUCH_TRACK:
                    state->is_enabled = 1;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_af_size(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];
            const rcp_param_state_t * const af_zone_state = &con->param_state[RCP_PARAM_AF_ZONE];

            switch ((af_mode_t) af_mode_state->val.int_val)
            {
                case AF_MODE_MANUAL:
                default:
                    state->is_enabled = 0;
                    break;

                case AF_MODE_CONFIRM:
                case AF_MODE_FAST:
                case AF_MODE_PRIORITY:
                case AF_MODE_CONTINUOUS:
                case AF_MODE_TOUCH_TRACK:
                case AF_MODE_RACK:
                    if ((af_focuszone_t) af_zone_state->val.int_val == AF_FOCUSZONE_SPOT)
                    {
                        state->is_enabled = 1;
                    }
                    else
                    {
                        state->is_enabled = 0;
                    }
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_af_window_move(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];

            switch ((af_mode_t) af_mode_state->val.int_val)
            {
                case AF_MODE_MANUAL:
                default:
                    state->is_enabled = 0;
                    break;

                case AF_MODE_CONFIRM:
                case AF_MODE_FAST:
                case AF_MODE_PRIORITY:
                case AF_MODE_CONTINUOUS:
                case AF_MODE_TOUCH_TRACK:
                case AF_MODE_RACK:
                    state->is_enabled = 1;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_rack(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const af_mode_state = &con->param_state[RCP_PARAM_AF_MODE];

            switch ((af_mode_t) af_mode_state->val.int_val)
            {
                case AF_MODE_MANUAL:
                case AF_MODE_FAST:
                case AF_MODE_CONFIRM:
                case AF_MODE_PRIORITY:
                case AF_MODE_CONTINUOUS:
                case AF_MODE_TOUCH_TRACK:
                default:
                    state->is_enabled = 0;
                    break;

                case AF_MODE_RACK:
                    state->is_enabled = 1;
                    break;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_presets(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_preset_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_PRESET_LIST);

            if (camera_preset_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_presets_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_preset_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_PRESET_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_preset_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_presets_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_preset_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_PRESET_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_preset_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_looks(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_look_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_LOOK_LIST);

            if (camera_look_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_looks_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_look_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_LOOK_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_look_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_looks_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_look_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_LOOK_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_look_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_overlays(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_overlay_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_OVERLAY_LIST);

            if (camera_overlay_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_overlays_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_overlay_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_OVERLAY_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_overlay_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_overlays_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_overlay_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_OVERLAY_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_overlay_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_luts(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_lut_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_LUT_LIST);

            if (camera_lut_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_luts_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_lut_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_LUT_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_lut_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_luts_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_lut_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_LUT_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_lut_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_cal_files(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_cal_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_CAL_LIST);

            if (camera_cal_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_cal_files_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_cal_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_CAL_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_cal_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_cal_files_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_cal_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_CAL_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_cal_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_discovered_redmotes(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t redmote_discovered_list_length = _rcp_get_size_of_list(con, RCP_PARAM_REDMOTE_DISCOVERED_LIST);

            if (redmote_discovered_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_paired_redmotes(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t redmote_paired_list_length = _rcp_get_size_of_list(con, RCP_PARAM_REDMOTE_PAIRED_LIST);

            if (redmote_paired_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_color_temp(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const state = &con->param_state[id];

        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            state->is_enabled = 1;

            /* If the color temperature is reporting back 0, that means
             * this is a black and white camera or clip.  Disable color
             * temperature control.*/
            if (state->val.int_val == 0)
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
        else if (id == RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE)
        {
            /* This parameter's status depends on its own value, but this
             * parameter is disabled in preview, so we may not be able to
             * get its value. As a result, we need to call
             * _rcp_send_current_status here.*/
            state->is_enabled = 0;
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_video_codec(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];

            switch ((file_format_t) file_format_state->val.int_val)
            {
                default:
                case FILE_FORMAT_REDCODE_RAW:
                case FILE_FORMAT_MXF:
                case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                    state->is_enabled = 0;
                    break;

                case FILE_FORMAT_QUICKTIME:
                case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                    state->is_enabled = 1;
                    break;
            }
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_video_mxf_codec(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];

            switch ((file_format_t) file_format_state->val.int_val)
            {
                default:
                case FILE_FORMAT_REDCODE_RAW:
                case FILE_FORMAT_QUICKTIME:
                case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                    state->is_enabled = 0;
                    break;

                case FILE_FORMAT_MXF:
                case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                    state->is_enabled = 1;
                    break;
            }
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_video_codec_any(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];

            switch ((file_format_t) file_format_state->val.int_val)
            {
                default:
                case FILE_FORMAT_REDCODE_RAW:
                    state->is_enabled = 0;
                    break;

                case FILE_FORMAT_QUICKTIME:
                case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                case FILE_FORMAT_MXF:
                case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                    state->is_enabled = 1;
                    break;
            }
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_voltage_threshold(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const enable_voltage_threshold = &con->param_state[RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD];

            state->is_enabled = enable_voltage_threshold->val.int_val;

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_voltage_threshold_dc_in(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const enable_voltage_threshold_dc_in = &con->param_state[RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN];

            state->is_enabled = enable_voltage_threshold_dc_in->val.int_val;

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_redcode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_RECORD_FILE_FORMAT, NULL))
            {
                switch ((file_format_t) file_format_state->val.int_val)
                {
                    default:
                    case FILE_FORMAT_REDCODE_RAW:
                    case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                    case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                        state->is_enabled = 1;
                        break;

                    case FILE_FORMAT_QUICKTIME:
                    case FILE_FORMAT_MXF:
                        state->is_enabled = 0;
                        break;
                }
            }

            /* primary storage overrides file format */
            if (rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL))
            {
                switch ((primary_storage_t) primary_storage_state->val.int_val)
                {
                    case PRIMARY_STORAGE_LOCAL:
                    case PRIMARY_STORAGE_NETWORK:
                    default:
                        break;

                    case PRIMARY_STORAGE_EXTERNAL:
                        state->is_enabled = 0;
                        break;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_remote_control_panel(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const enable_state = &con->param_state[RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE];

            state->is_enabled = enable_state->val.int_val;
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_ad_hoc(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode = &con->param_state[RCP_PARAM_WIFI_MODE];

            if (wifi_mode->val.int_val == WL_MODE_AD_HOC)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode = &con->param_state[RCP_PARAM_WIFI_MODE];

            if (wifi_mode->val.int_val == WL_MODE_INFRASTRUCTURE)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_ad_hoc_pw(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode = &con->param_state[RCP_PARAM_WIFI_MODE];
            const rcp_param_state_t * const encryption_type = &con->param_state[RCP_PARAM_WIFI_AD_HOC_ENCRYPTION];

            if (
                wifi_mode->val.int_val == WL_MODE_AD_HOC &&
                (
                 encryption_type->val.int_val == WL_ENCRYPTION_WPA ||
                 encryption_type->val.int_val == WL_ENCRYPTION_WPA2 ||
                 encryption_type->val.int_val == WL_ENCRYPTION_WEP
                )
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra_pw(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        int enabled = 0;

        rcp_param_state_t * const state = &con->param_state[id];
        const rcp_param_state_t * const wifi_mode = &con->param_state[RCP_PARAM_WIFI_MODE];

        if (!wifi_mode->val_valid && rcp_get_is_supported(con, RCP_PARAM_WIFI_MODE, NULL))
        {
            (void) _rcp_get(con, RCP_PARAM_WIFI_MODE);
            return;
        }

        if (wifi_mode->val.int_val == WL_MODE_INFRASTRUCTURE)
        {
            const rcp_param_state_t * const encryption_type = &con->param_state[RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION];

            if (!encryption_type->val_valid)
            {
                if (rcp_get_is_supported(con, RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION, NULL))
                {
                    (void) _rcp_get(con, RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION);
                }
            }
            else
            {
                if (
                    encryption_type->val.int_val == WL_ENCRYPTION_WPA ||
                    encryption_type->val.int_val == WL_ENCRYPTION_WPA2 ||
                    encryption_type->val.int_val == WL_ENCRYPTION_WEP
                   )
                {
                    enabled = 1;
                }
            }
        }

        state->is_enabled = enabled;
        state->is_enabled_valid = 1;
        _rcp_send_current_status(con, id);
    }
}

static void _rcp_create_status_wifi_infra_connected(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode_state = &con->param_state[RCP_PARAM_WIFI_MODE];
            const rcp_param_state_t * const wifi_state_state = &con->param_state[RCP_PARAM_WIFI_STATE];

            if (
                wifi_mode_state->val.int_val == WL_MODE_INFRASTRUCTURE &&
                wifi_state_state->val.int_val == WL_STATUS_CONNECTED
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra_connect(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode_state = &con->param_state[RCP_PARAM_WIFI_MODE];
            const rcp_param_state_t * const wifi_state_state = &con->param_state[RCP_PARAM_WIFI_STATE];
            const rcp_param_state_t * const encryption_state = &con->param_state[RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION];
            const rcp_param_state_t * const pw_state = &con->param_state[RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE];

            state->is_enabled = 0;

            if (wifi_mode_state->val.int_val == WL_MODE_INFRASTRUCTURE)
            {
                if (encryption_state->val.int_val == WL_ENCRYPTION_NONE)
                {
                    /* there is no encryption, it is ok to connect */
                    state->is_enabled = 1;
                }
                else
                {
                    /* there is some form of encryption, a password is
                     * required */
                    if (strlen(pw_state->val.str_val) > 0)
                    {
                        state->is_enabled = 1;
                    }
                }

                /* if we are connected, or connecting, don't enable the
                 * connect button*/
                if (
                    wifi_state_state->val.int_val == WL_STATUS_CONNECTING ||
                    wifi_state_state->val.int_val == WL_STATUS_CONNECTED
                   )
                {
                    state->is_enabled = 0;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra_scan(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode_state = &con->param_state[RCP_PARAM_WIFI_MODE];
            const rcp_param_state_t * const wifi_state_state = &con->param_state[RCP_PARAM_WIFI_STATE];

            if (
                wifi_mode_state->val.int_val == WL_MODE_INFRASTRUCTURE &&
                wifi_state_state->val.int_val != WL_STATUS_SEARCHING
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra_select(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const wifi_mode_state = &con->param_state[RCP_PARAM_WIFI_MODE];
            const size_t wifi_scan_results_list_length = _rcp_get_size_of_list(con, RCP_PARAM_WIFI_SCAN_RESULTS);

            if (
                wifi_mode_state->val.int_val == WL_MODE_INFRASTRUCTURE &&
                wifi_scan_results_list_length > 0
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_wifi_infra_addresses(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const wifi_dhcp_state = &con->param_state[RCP_PARAM_WIFI_DHCP_ENABLE];
            const rcp_param_state_t * const wifi_mode = &con->param_state[RCP_PARAM_WIFI_MODE];
            rcp_param_state_t * const state = &con->param_state[id];

            if (
                wifi_dhcp_state->val.int_val == 0 &&
                wifi_mode->val.int_val == WL_MODE_INFRASTRUCTURE
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_power_out_reset(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * enable_state = NULL;
            const rcp_param_state_t * status_state = NULL;
            rcp_param_t enable_id = RCP_PARAM_COUNT;
            rcp_param_t status_id = RCP_PARAM_COUNT;

            switch (id)
            {
                case RCP_PARAM_POWER_OUT_PRO_IO_GPIO_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_PRO_IO_PWR_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_BAT_AUX_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_BAT_AUX_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_JETPACK_USB_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_REAR_AUX_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_REAR_AUX_STATUS;
                    break;

                case RCP_PARAM_POWER_OUT_TIMECODE_RESET:
                    enable_id = RCP_PARAM_POWER_OUT_TIMECODE_ENABLE;
                    status_id = RCP_PARAM_POWER_OUT_TIMECODE_STATUS;
                    break;

                default:
                    if (id >= RCP_PARAM_POWER_OUT_RESET_0 && id <= RCP_PARAM_POWER_OUT_RESET_LAST)
                    {
                        enable_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_ENABLE_0 + (id - RCP_PARAM_POWER_OUT_RESET_0));
                        status_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_STATUS_0 + (id - RCP_PARAM_POWER_OUT_RESET_0));
                    }
                    else
                    {
                        return;
                    }
                    break;
            }

            enable_state = &con->param_state[enable_id];
            status_state = &con->param_state[status_id];

            /* The reset button should only be enabled if the power out
             * is enabled (or not controllable) and the current state
             * is a fault. */
            if ((!rcp_get_is_supported(con, enable_id, NULL) || enable_state->val.int_val) && !status_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_power_out_current(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * enable_state = NULL;
            const rcp_param_state_t * status_state = NULL;
            rcp_param_t enable_id = RCP_PARAM_COUNT;
            rcp_param_t status_id = RCP_PARAM_COUNT;

            if (id >= RCP_PARAM_POWER_OUT_CURRENT_0 && id <= RCP_PARAM_POWER_OUT_CURRENT_LAST)
            {
                enable_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_ENABLE_0 + (id - RCP_PARAM_POWER_OUT_CURRENT_0));
                status_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_STATUS_0 + (id - RCP_PARAM_POWER_OUT_CURRENT_0));
            }
            else
            {
                return;
            }

            enable_state = &con->param_state[enable_id];
            status_state = &con->param_state[status_id];

            /* The current should only be enabled if the power out
             * is enabled (or not controllable) and the current state
             * is not a fault. */
            if ((!rcp_get_is_supported(con, enable_id, NULL) || enable_state->val.int_val) && status_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_power_out_status(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * enable_state = NULL;
            rcp_param_t enable_id = RCP_PARAM_COUNT;

            if (id >= RCP_PARAM_POWER_OUT_STATUS_0 && id <= RCP_PARAM_POWER_OUT_STATUS_LAST)
            {
                enable_id = (rcp_param_t) (RCP_PARAM_POWER_OUT_ENABLE_0 + (id - RCP_PARAM_POWER_OUT_STATUS_0));
            }
            else
            {
                return;
            }

            enable_state = &con->param_state[enable_id];

            /* The status should only be enabled if the power out
             * is enabled (or not controllable). */
            if (!rcp_get_is_supported(con, enable_id, NULL) || enable_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_third_pary_olpf(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const olpf_type_state = &con->param_state[RCP_PARAM_OLPF_TYPE];

            if (olpf_type_state->val.int_val == 0x100) /* OLPF_TYPE_THIRD_PARTY */
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_audio_channel_mode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * sourceState;
            rcp_param_t sourceStateID;

            if (id == RCP_PARAM_AUDIO_CH1_MODE_STATUS || id == RCP_PARAM_AUDIO_CH2_MODE_STATUS)
            {
                sourceStateID = RCP_PARAM_AUDIO_CH12_SOURCE;
            }
            else if (id == RCP_PARAM_AUDIO_CH3_MODE_STATUS || id == RCP_PARAM_AUDIO_CH4_MODE_STATUS)
            {
                sourceStateID = RCP_PARAM_AUDIO_CH34_SOURCE;
            }
            else
            {
                _rcp_log_warning(con, "Invalid parameter ID %d used in audio channel status callback\n", (int) id);
                return;
            }

            sourceState = &con->param_state[sourceStateID];

            if ((audio_channel_source_t) sourceState->val.int_val == AUDIO_CHANNEL_SOURCE_PRO_IO_ANALOG12)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_bwf_enable(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const record_mode_state = &con->param_state[RCP_PARAM_RECORD_MODE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];
            const rcp_param_state_t * const varispeed_mode_state = &con->param_state[RCP_PARAM_VARISPEED_MODE];
            const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];

            const int continuousRecord = ((record_mode_t) record_mode_state->val.int_val == RECORD_MODE_CONTINUOUS);
            const int localStorage = ((primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_LOCAL);
            const int varispeedMode = varispeed_mode_state->val.int_val;
            const int recordingR3D = (file_format_state->val.int_val == FILE_FORMAT_REDCODE_RAW || file_format_state->val.int_val == FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME || file_format_state->val.int_val == FILE_FORMAT_REDCODE_RAW_PLUS_MXF);

            rcp_param_state_t * const state = &con->param_state[id];

            if (continuousRecord && localStorage && varispeedMode && recordingR3D)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_tc_channel(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const timecode_source_state = &con->param_state[RCP_PARAM_TIMECODE_SOURCE];
            const tc_source_t timecode_source = (tc_source_t) timecode_source_state->val.int_val;
            rcp_param_state_t * const state = &con->param_state[id];

            state->is_enabled = (timecode_source == TC_SOURCE_INTERNAL) ? 1 : 0;
            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_cdls(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_cdl_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_CDL_LIST);

            if (camera_cdl_list_length > 0)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_camera_cdls_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t camera_cdl_list_length = _rcp_get_size_of_list(con, RCP_PARAM_CAMERA_CDL_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (camera_cdl_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_media_cdls_media(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const size_t media_cdl_list_length = _rcp_get_size_of_list(con, RCP_PARAM_MEDIA_CDL_LIST);
            const rcp_param_state_t * const media_attached_state = &con->param_state[RCP_PARAM_MEDIA_IS_ATTACHED];

            if (media_cdl_list_length > 0 && media_attached_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_side_ui_auto_home_timeout(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * auto_home_state = NULL;

            switch (id)
            {
                case RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT:
                    auto_home_state = &con->param_state[RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT];
                    break;

                case RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT:
                    auto_home_state = &con->param_state[RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT];
                    break;

                default:
                    return;
            }

            if ((side_ui_auto_home_t) auto_home_state->val.int_val == SIDE_UI_AUTO_HOME_ON_TIMEOUT)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_uhd_monitor(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            const rcp_param_state_t * const mode_uhdsdi1_state = &con->param_state[RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1];
            const rcp_param_state_t * const mode_uhdsdi2_state = &con->param_state[RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2];
            rcp_param_state_t * const state = &con->param_state[id];

            if (
                (monitor_mode_t) mode_uhdsdi1_state->val.int_val == MONITOR_MODE_UHD ||
                (monitor_mode_t) mode_uhdsdi2_state->val.int_val == MONITOR_MODE_UHD
               )
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_power_in_present(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_def_t * const def = &_rcp_param_def[id];
            const rcp_param_state_t * const present_state = &con->param_state[(rcp_param_t) ((int) RCP_PARAM_POWER_IN_PRESENT_0 + def->index)];

            if (present_state->val.int_val)
            {
                state->is_enabled = 1;
            }
            else
            {
                state->is_enabled = 0;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_pre_record(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];

            if (rcp_get_is_supported(con, RCP_PARAM_RECORD_FILE_FORMAT, NULL))
            {
                const rcp_param_state_t * const file_format_state = &con->param_state[RCP_PARAM_RECORD_FILE_FORMAT];

                switch ((file_format_t) file_format_state->val.int_val)
                {
                    case FILE_FORMAT_REDCODE_RAW:
                        state->is_enabled = 1;
                        break;

                    case FILE_FORMAT_QUICKTIME:
                    case FILE_FORMAT_REDCODE_RAW_PLUS_QUICKTIME:
                    case FILE_FORMAT_MXF:
                    case FILE_FORMAT_REDCODE_RAW_PLUS_MXF:
                    default:
                        state->is_enabled = 0;
                        break;
                }
            }
            else
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_not_external_record(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL))
            {
                switch ((primary_storage_t) primary_storage_state->val.int_val)
                {
                    case PRIMARY_STORAGE_LOCAL:
                    case PRIMARY_STORAGE_NETWORK:
                    default:
                        break;

                    case PRIMARY_STORAGE_EXTERNAL:
                        state->is_enabled = 0;
                        break;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_ipp2_output_options(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const image_pipeline_mode_state = &con->param_state[RCP_PARAM_IMAGE_PIPELINE_MODE];

            state->is_enabled = 0;

            if (rcp_get_is_supported(con, RCP_PARAM_IMAGE_PIPELINE_MODE, NULL))
            {
                switch ((image_pipeline_mode_t) image_pipeline_mode_state->val.int_val)
                {
                    case IMAGE_PIPELINE_MODE_IPP2:
                        state->is_enabled = 1;
                        break;

                    default:
                        break;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_lookaround(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const lookaround_available_state = &con->param_state[RCP_PARAM_LOOKAROUND_AVAILABLE];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_LOOKAROUND_AVAILABLE, NULL))
            {
                state->is_enabled = lookaround_available_state->val.int_val;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_drop_frame_display_mode(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const project_state = &con->param_state[RCP_PARAM_PROJECT_FRAME_RATE];

            state->is_enabled = 0;

            if (project_state->val.int_val == 30000 || project_state->val.int_val == 60000)
            {
                state->is_enabled = 1;
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_output_color_space(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const image_pipeline_mode_state = &con->param_state[RCP_PARAM_IMAGE_PIPELINE_MODE];
            const rcp_param_state_t * const output_transform_state = &con->param_state[RCP_PARAM_OUTPUT_TRANSFORM];

            state->is_enabled = 0;

            if (rcp_get_is_supported(con, RCP_PARAM_IMAGE_PIPELINE_MODE, NULL))
            {
                if ((image_pipeline_mode_t) image_pipeline_mode_state->val.int_val == IMAGE_PIPELINE_MODE_IPP2)
                {
                    if ((output_transform_t) output_transform_state->val.int_val != OUTPUT_TRANSFORM_IPP2A)
                    {
                        state->is_enabled = 1;
                    }
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_cdl(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const cdl_enable = &con->param_state[RCP_PARAM_CDL_ENABLE];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_CDL_ENABLE, NULL))
            {
                if (cdl_enable->val.int_val == 0)
                {
                    state->is_enabled = 0;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

static void _rcp_create_status_lut_feed_1(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_status_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * const lut_enable = &con->param_state[RCP_PARAM_LUT_FEED_1_ENABLE];

            state->is_enabled = 1;

            if (rcp_get_is_supported(con, RCP_PARAM_LUT_FEED_1_ENABLE, NULL))
            {
                if (lut_enable->val.int_val == 0)
                {
                    state->is_enabled = 0;
                }
            }

            state->is_enabled_valid = 1;
            _rcp_send_current_status(con, id);
        }
    }
}

RCP_API_PRIVATE int _rcp_get_indexed_parameter_info(rcp_camera_connection_t * con, rcp_param_t list_param, int idx, c_list_entry_t * e)
{
    int entry_valid = 0;

    if (rcp_get_is_supported(con, list_param, NULL))
    {
        const rcp_param_state_t * const list_state = &con->param_state[list_param];

        if (list_state->list_val && list_state->list_val_valid)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);
            if (C_LIST_SUCCESS == c_list_import_from_string(c_list, list_state->list_val))
            {
                if (C_LIST_SUCCESS == c_list_get_entry(c_list, idx, e))
                {
                    entry_valid = 1;
                }
            }
            if (C_LIST_SUCCESS != c_list_delete(c_list))
            {
                _rcp_log_error(con, "could not delete c_list\n");
            }
        }
    }

    return entry_valid;
}

RCP_API_PRIVATE void _rcp_clear_cache_val(rcp_camera_connection_t * con, rcp_param_t param)
{
    if (con && param < RCP_PARAM_COUNT)
    {
        con->param_state[param].val_valid = 0;
        con->param_state[param].target_val_valid = 0;
        con->param_state[param].get_pending = 0;
        con->param_state[param].get_target_pending = 0;
    }
}

RCP_API_PRIVATE void _rcp_clear_cache_list(rcp_camera_connection_t * con, rcp_param_t param)
{
    if (con && param < RCP_PARAM_COUNT)
    {
        con->param_state[param].list_val_valid = 0;
        con->param_state[param].list_current_val_valid = 0;
        con->param_state[param].get_list_pending = 0;
    }
}

static void _rcp_create_label_power_in(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            c_list_entry_t e;
            if (_rcp_get_indexed_parameter_info(con, def->index_list_id, def->index, &e))
            {
                const char * suffix = NULL;
                size_t len = 0;

                if (id >= RCP_PARAM_POWER_IN_PERCENT_0 && id <= RCP_PARAM_POWER_IN_PERCENT_LAST)
                {
                    suffix = "Percent";
                }
                else if (id >= RCP_PARAM_POWER_IN_RUNTIME_0 && id <= RCP_PARAM_POWER_IN_RUNTIME_LAST)
                {
                    suffix = "Runtime";
                }
                else if (id >= RCP_PARAM_POWER_IN_VOLTAGE_0 && id <= RCP_PARAM_POWER_IN_VOLTAGE_LAST)
                {
                    suffix = "Voltage";
                }
                else if (id >= RCP_PARAM_POWER_IN_CURRENT_0 && id <= RCP_PARAM_POWER_IN_CURRENT_LAST)
                {
                    suffix = "Current";
                }
                else if (id >= RCP_PARAM_POWER_IN_PRESENT_0 && id <= RCP_PARAM_POWER_IN_PRESENT_LAST)
                {
                    suffix = "Present";
                }
                else if (id >= RCP_PARAM_POWER_IN_TYPE_0 && id <= RCP_PARAM_POWER_IN_TYPE_LAST)
                {
                    suffix = "Type";
                }
                else
                {
                    return;
                }

                len = strlen(e.str) + 2 + strlen(suffix) + 1;

                param->generated_label = RCP_MALLOC(char *, len);
                if (param->generated_label)
                {
                    snprintf(param->generated_label, len, "%s: %s", e.str, suffix);
                }
            }
        }
    }
}

static void _rcp_create_label_power_out(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            c_list_entry_t e;
            if (_rcp_get_indexed_parameter_info(con, def->index_list_id, def->index, &e))
            {
                const char * suffix = NULL;
                size_t len = 0;

                if (id >= RCP_PARAM_POWER_OUT_ENABLE_0 && id <= RCP_PARAM_POWER_OUT_ENABLE_LAST)
                {
                    suffix = "Enable";
                }
                else if (id >= RCP_PARAM_POWER_OUT_STATUS_0 && id <= RCP_PARAM_POWER_OUT_STATUS_LAST)
                {
                    suffix = "Status";
                }
                else if (id >= RCP_PARAM_POWER_OUT_RESET_0 && id <= RCP_PARAM_POWER_OUT_RESET_LAST)
                {
                    suffix = "Reset";
                }
                else if (id >= RCP_PARAM_POWER_OUT_CURRENT_0 && id <= RCP_PARAM_POWER_OUT_CURRENT_LAST)
                {
                    suffix = "Current";
                }
                else
                {
                    return;
                }

                len = strlen(e.str) + 2 + strlen(suffix) + 1;

                param->generated_label = RCP_MALLOC(char *, len);
                if (param->generated_label)
                {
                    snprintf(param->generated_label, len, "%s: %s", e.str, suffix);
                }
            }
        }
    }
}

static int _rcp_get_monitor_list_entry(rcp_camera_connection_t * con, monitor_t monitor_id, c_list_entry_t * e)
{
    int entry_valid = 0;

    if (rcp_get_is_supported(con, RCP_PARAM_MONITOR_LIST, NULL))
    {
        const rcp_param_state_t * const list_state = &con->param_state[RCP_PARAM_MONITOR_LIST];

        if (list_state->list_val && list_state->list_val_valid)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);
            if (C_LIST_SUCCESS == c_list_import_from_string(c_list, list_state->list_val))
            {
                if (C_LIST_SUCCESS == c_list_find_num(c_list, (c_list_num_t) monitor_id, e, C_LIST_FIND_EXACT))
                {
                    entry_valid = 1;
                }
            }
            if (C_LIST_SUCCESS != c_list_delete(c_list))
            {
                _rcp_log_error(con, "could not delete c_list\n");
            }
        }
    }

    return entry_valid;
}

static void _rcp_get_format_dimensions_string(char * buf, size_t buf_size, int width, int height, int sigfigs, float divider, const char * suffix, int abbr)
{
    if (buf)
    {
        const int p = (int) pow(10.0, sigfigs);
        int ivalue, i, sigfigCount;
        char widthBuf[256];
        char heightBuf[256];
        float fvalue;

        fvalue = roundf((width / divider) * p) / p; /* width rounded to sigfigs decimal places */
        ivalue = (int) (fvalue * (int) pow(10.0, sigfigs));
        sigfigCount = 0;

        for (i = 0; i < sigfigs; i++)
        {
            if ((ivalue % (int) pow(10.0, i + 1)) != 0)
            {
                sigfigCount++;
            }
        }

        snprintf(widthBuf, sizeof(widthBuf), "%.*f%s", sigfigCount, fvalue, (suffix ? suffix : ""));

        fvalue = roundf((height / divider) * p) / p; /* height rounded to sigfigs decimal places */
        ivalue = (int) (fvalue * (int) pow(10.0, sigfigs));
        sigfigCount = 0;

        for (i = 0; i < sigfigs; i++)
        {
            if ((ivalue % (int) pow(10.0, i + 1)) != 0)
            {
                sigfigCount++;
            }
        }

        snprintf(heightBuf, sizeof(heightBuf), "%.*f%s", sigfigCount, fvalue, (suffix ? suffix : ""));

        snprintf(buf, buf_size, (abbr ? "%sx%s" : "%s x %s"), widthBuf, heightBuf);
    }
}

static void _rcp_create_label_monitor(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            const char * suffix = NULL;
            const char * default_monitor_name = NULL;
            const char * monitor_name = NULL;
            size_t len = 0;
            const monitor_t monitor_id = _rcp_get_monitor(id);
            c_list_entry_t e;

            switch (id)
            {
                case RCP_PARAM_MONITOR_MODE_LCD:
                case RCP_PARAM_MONITOR_MODE_HDMI:
                case RCP_PARAM_MONITOR_MODE_HDSDI:
                case RCP_PARAM_MONITOR_MODE_EVF:
                case RCP_PARAM_MONITOR_MODE_REAR_LCD:
                case RCP_PARAM_MONITOR_MODE_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_MODE_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_MODE_REAR_EVF:
                case RCP_PARAM_MONITOR_MODE_LCD3:
                case RCP_PARAM_MONITOR_MODE_EVF3:
                case RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1:
                case RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2:
                    suffix = "Mode";
                    break;

                case RCP_PARAM_MONITOR_OVERLAY_LCD:
                case RCP_PARAM_MONITOR_OVERLAY_HDMI:
                case RCP_PARAM_MONITOR_OVERLAY_HDSDI:
                case RCP_PARAM_MONITOR_OVERLAY_EVF:
                case RCP_PARAM_MONITOR_OVERLAY_REAR_LCD:
                case RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_OVERLAY_REAR_EVF:
                case RCP_PARAM_MONITOR_OVERLAY_LCD3:
                case RCP_PARAM_MONITOR_OVERLAY_EVF3:
                    suffix = "Overlay";
                    break;

                case RCP_PARAM_MONITOR_RESOLUTION_HDMI:
                case RCP_PARAM_MONITOR_RESOLUTION_HDSDI:
                case RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2:
                    suffix = "Resolution";
                    break;

                case RCP_PARAM_MONITOR_FREQ_LCD:
                case RCP_PARAM_MONITOR_FREQ_HDMI:
                case RCP_PARAM_MONITOR_FREQ_HDSDI:
                case RCP_PARAM_MONITOR_FREQ_EVF:
                case RCP_PARAM_MONITOR_FREQ_REAR_LCD:
                case RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_FREQ_REAR_EVF:
                case RCP_PARAM_MONITOR_FREQ_LCD3:
                case RCP_PARAM_MONITOR_FREQ_EVF3:
                    suffix = "Frequency";
                    break;

                case RCP_PARAM_MONITOR_TOOLS_LCD:
                case RCP_PARAM_MONITOR_TOOLS_HDMI:
                case RCP_PARAM_MONITOR_TOOLS_HDSDI:
                case RCP_PARAM_MONITOR_TOOLS_EVF:
                case RCP_PARAM_MONITOR_TOOLS_REAR_LCD:
                case RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_TOOLS_REAR_EVF:
                case RCP_PARAM_MONITOR_TOOLS_LCD3:
                case RCP_PARAM_MONITOR_TOOLS_EVF3:
                    suffix = "Tools";
                    break;

                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3:
                case RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3:
                    suffix = "UI Flip/Mirror";
                    break;

                case RCP_PARAM_MONITOR_VIDEO_FLIP_LCD:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_EVF:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3:
                case RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3:
                    suffix = "Video Flip";
                    break;

                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3:
                case RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3:
                    suffix = "Framed Overlay";
                    break;

                case RCP_PARAM_MONITOR_DOCK_MENUS_LCD:
                case RCP_PARAM_MONITOR_DOCK_MENUS_HDMI:
                case RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI:
                case RCP_PARAM_MONITOR_DOCK_MENUS_EVF:
                case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD:
                case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF:
                case RCP_PARAM_MONITOR_DOCK_MENUS_LCD3:
                case RCP_PARAM_MONITOR_DOCK_MENUS_EVF3:
                    suffix = "Auto Hide Menus";
                    break;

                case RCP_PARAM_MONITOR_BRIGHTNESS_LCD:
                case RCP_PARAM_MONITOR_BRIGHTNESS_EVF:
                case RCP_PARAM_MONITOR_BRIGHTNESS_REAR_LCD:
                case RCP_PARAM_MONITOR_BRIGHTNESS_REAR_EVF:
                case RCP_PARAM_MONITOR_BRIGHTNESS_LCD3:
                case RCP_PARAM_MONITOR_BRIGHTNESS_EVF3:
                    suffix = "Brightness";
                    break;

                case RCP_PARAM_MONITOR_ENABLE_HDSDI:
                case RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2:
                    suffix = "Enable";
                    break;

                case RCP_PARAM_MONITOR_CURVE_LCD:
                case RCP_PARAM_MONITOR_CURVE_HDMI:
                case RCP_PARAM_MONITOR_CURVE_HDSDI:
                case RCP_PARAM_MONITOR_CURVE_EVF:
                case RCP_PARAM_MONITOR_CURVE_REAR_LCD:
                case RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_CURVE_REAR_EVF:
                case RCP_PARAM_MONITOR_CURVE_LCD3:
                case RCP_PARAM_MONITOR_CURVE_EVF3:
                    suffix = "Curve";
                    break;

                case RCP_PARAM_DISPLAY_PRESET_LCD:
                case RCP_PARAM_DISPLAY_PRESET_HDMI:
                case RCP_PARAM_DISPLAY_PRESET_HDSDI:
                case RCP_PARAM_DISPLAY_PRESET_EVF:
                case RCP_PARAM_DISPLAY_PRESET_REAR_LCD:
                case RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1:
                case RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2:
                case RCP_PARAM_DISPLAY_PRESET_REAR_EVF:
                case RCP_PARAM_DISPLAY_PRESET_LCD3:
                case RCP_PARAM_DISPLAY_PRESET_EVF3:
                    suffix = "Display Preset";
                    break;

                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3:
                    suffix = "Flip/Mirror Supported";
                    break;

                case RCP_PARAM_MONITOR_FLIP_MIRROR_LCD:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3:
                case RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3:
                    suffix = "Flip/Mirror";
                    break;

                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3:
                case RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3:
                    suffix = "Allow Return Feed";
                    break;

                case RCP_PARAM_MONITOR_FEED_LCD:
                case RCP_PARAM_MONITOR_FEED_HDMI:
                case RCP_PARAM_MONITOR_FEED_HDSDI:
                case RCP_PARAM_MONITOR_FEED_EVF:
                case RCP_PARAM_MONITOR_FEED_REAR_LCD:
                case RCP_PARAM_MONITOR_FEED_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_FEED_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_FEED_REAR_EVF:
                case RCP_PARAM_MONITOR_FEED_LCD3:
                case RCP_PARAM_MONITOR_FEED_EVF3:
                    suffix = "Look";
                    break;

                case RCP_PARAM_MONITOR_LUT_LCD:
                case RCP_PARAM_MONITOR_LUT_EVF:
                case RCP_PARAM_MONITOR_LUT_HDMI:
                case RCP_PARAM_MONITOR_LUT_HDSDI:
                case RCP_PARAM_MONITOR_LUT_REAR_LCD:
                case RCP_PARAM_MONITOR_LUT_REAR_EVF:
                case RCP_PARAM_MONITOR_LUT_REAR_HDSDI1:
                case RCP_PARAM_MONITOR_LUT_REAR_HDSDI2:
                case RCP_PARAM_MONITOR_LUT_BRAIN_LCD3:
                case RCP_PARAM_MONITOR_LUT_BRAIN_EVF3:
                    suffix = "LUT";
                    break;

                default:
                    return;
            }

            switch (monitor_id)
            {
                case MONITOR_BRAIN_LCD:
                    default_monitor_name = "LCD 1";
                    break;

                case MONITOR_BRAIN_HDMI:
                    default_monitor_name = "HDMI";
                    break;

                case MONITOR_BRAIN_HDSDI:
                    default_monitor_name = "HDSDI 1";
                    break;

                case MONITOR_BRAIN_EVF:
                    default_monitor_name = "EVF 1";
                    break;

                case MONITOR_REAR_LCD:
                    default_monitor_name = "LCD 2";
                    break;

                case MONITOR_REAR_HDSDI_1:
                    default_monitor_name = "HDSDI 2";
                    break;

                case MONITOR_REAR_HDSDI_2:
                    default_monitor_name = "HDSDI 3";
                    break;

                case MONITOR_REAR_EVF:
                    default_monitor_name = "EVF 2";
                    break;

                case MONITOR_BRAIN_LCD3:
                    default_monitor_name = "LCD 3";
                    break;

                case MONITOR_BRAIN_EVF3:
                    default_monitor_name = "EVF 3";
                    break;

                case MONITOR_REAR_UHDSDI_1:
                    default_monitor_name = "UHDSDI 1";
                    break;

                case MONITOR_REAR_UHDSDI_2:
                    default_monitor_name = "UHDSDI 2";
                    break;

                default:
                    return;
            }

            if (_rcp_get_monitor_list_entry(con, monitor_id, &e))
            {
                monitor_name = e.str;
            }
            else if (!_rcp_has_feature(con, RCP_FEATURE_DYNAMIC_MONITOR_LABELS))
            {
                monitor_name = default_monitor_name;
            }
            else
            {
                return;
            }

            len = strlen(monitor_name) + 2 + strlen(suffix) + 1;

            param->generated_label = RCP_MALLOC(char *, len);
            if (param->generated_label)
            {
                snprintf(param->generated_label, len, "%s: %s", monitor_name, suffix);
            }
        }
    }
}

static size_t str_common_prefix_len(const char * s1, const char * s2)
{
    size_t common_prefix_len = 0;
    size_t cur_len = 0;

    if (!s1 || !s2)
        return 0;

    while (*s1 && (*s1 == *s2))
    {
        cur_len++;

        if (*s1 == ' ')
        {
            common_prefix_len = cur_len;
        }

        s1++;
        s2++;
    }

    return common_prefix_len;
}

static size_t str_common_suffix_len(const char * s1, const char * s2)
{
    size_t common_suffix_len = 0;
    size_t cur_len = 0;
    size_t s1_len = 0;
    size_t s2_len = 0;

    if (!s1 || !s2)
        return 0;

    s1_len = strlen(s1);
    s2_len = strlen(s2);

    if (s1_len == 0 || s2_len == 0)
        return 0;

    s1 += s1_len - 1;
    s2 += s2_len - 1;

    while (common_suffix_len < s1_len && common_suffix_len < s2_len && (*s1 == *s2))
    {
        cur_len++;
        if (*s1 == ' ')
        {
            common_suffix_len = cur_len;
        }

        s1--;
        s2--;
    }

    return common_suffix_len;
}

static void _rcp_create_label_monitor_mux(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            char lcd_name[RCP_API_DISPLAY_STR_SIZE];
            char evf_name[RCP_API_DISPLAY_STR_SIZE];
            char hdmi_name[RCP_API_DISPLAY_STR_SIZE];
            c_list_entry_t e;
            size_t len;
            size_t prefix_len = 0;
            size_t suffix_len = 0;
            char * combo = NULL;

            if (_rcp_get_monitor_list_entry(con, MONITOR_REAR_LCD, &e))
            {
                strlcpy(lcd_name, e.str, sizeof(lcd_name));
            }
            else if (!_rcp_has_feature(con, RCP_FEATURE_DYNAMIC_MONITOR_LABELS))
            {
                strlcpy(lcd_name, "LCD", sizeof(lcd_name));
            }
            else
            {
                return;
            }

            if (_rcp_get_monitor_list_entry(con, MONITOR_REAR_EVF, &e))
            {
                strlcpy(evf_name, e.str, sizeof(evf_name));
            }
            else if (!_rcp_has_feature(con, RCP_FEATURE_DYNAMIC_MONITOR_LABELS))
            {
                strlcpy(evf_name, "EVF", sizeof(evf_name));
            }
            else
            {
                return;
            }

            if (_rcp_get_monitor_list_entry(con, MONITOR_BRAIN_HDMI, &e))
            {
                strlcpy(hdmi_name, e.str, sizeof(hdmi_name));
            }
            else if (!_rcp_has_feature(con, RCP_FEATURE_DYNAMIC_MONITOR_LABELS))
            {
                strlcpy(hdmi_name, "HDMI", sizeof(hdmi_name));
            }
            else
            {
                return;
            }

            prefix_len = str_common_prefix_len(lcd_name, evf_name);
            suffix_len = str_common_suffix_len(lcd_name, evf_name);

            if (prefix_len || suffix_len)
            {
                if (prefix_len > suffix_len)
                {
                    char * const prefix = RCP_MALLOC(char *, prefix_len + 1);
                    const size_t combo_len = strlen(lcd_name) + strlen(evf_name) - prefix_len + 2;

                    strncpy(prefix, lcd_name, prefix_len);
                    prefix[prefix_len] = 0;

                    combo = RCP_MALLOC(char *, combo_len);
                    snprintf(combo, combo_len, "%s%s/%s", prefix, lcd_name + prefix_len, evf_name + prefix_len);

                    rcp_free(prefix);
                }
                else
                {
                    char * const suffix = RCP_MALLOC(char *, suffix_len + 1);
                    const size_t combo_len = strlen(lcd_name) + strlen(evf_name) - suffix_len + 2;

                    strcpy(suffix, lcd_name + strlen(lcd_name) - suffix_len);

                    combo = RCP_MALLOC(char *, combo_len);
                    snprintf(combo, combo_len, "%.*s/%.*s%s", (int) (strlen(lcd_name) - suffix_len), lcd_name, (int) (strlen(evf_name) - suffix_len), evf_name, suffix);

                    rcp_free(suffix);
                }
            }
            else
            {
                const size_t combo_len = strlen(lcd_name) + strlen(evf_name) + 2;
                combo = RCP_MALLOC(char *, combo_len);
                snprintf(combo, combo_len, "%s/%s", lcd_name, evf_name);
            }

            len = strlen(combo) + 3 + strlen(hdmi_name) + 7 + 1;

            param->generated_label = RCP_MALLOC(char *, len);
            if (param->generated_label)
            {
                snprintf(param->generated_label, len, "%s / %s Select", combo, hdmi_name);
            }

            rcp_free(combo);
        }
    }
}

static void _rcp_create_label_side_ui(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            const char * name = NULL;
            const char * suffix = NULL;
            size_t len = 0;

            switch (id)
            {
                case RCP_PARAM_MONITOR_BRIGHTNESS_SIDE_UI:
                    suffix = "Brightness";
                    break;

                default:
                    return;
            }

            if (rcp_get_is_supported(con, RCP_PARAM_SIDE_UI_NAME, NULL))
            {
                const rcp_param_state_t * const side_ui_name = &con->param_state[RCP_PARAM_SIDE_UI_NAME];
                name = side_ui_name->val.str_val;
            }

            if (!name)
            {
                name = "Side UI";
            }

            len = strlen(name) + 2 + strlen(suffix) + 1;

            param->generated_label = RCP_MALLOC(char *, len);
            if (param->generated_label)
            {
                snprintf(param->generated_label, len, "%s: %s", name, suffix);
            }
        }
    }
}

static void _rcp_create_label_lut_feed_1(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            if (_rcp_version_greater_or_equal_to(con, 6, 50))
            {
                param->generated_label = _rcp_strdup("Output Transform: 3D LUT");
            }
            else
            {
                param->generated_label = _rcp_strdup("Look B: LUT");
            }
        }
    }
}

static void _rcp_create_label_gamma_space(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            if (_rcp_version_greater_or_equal_to(con, 6, 50))
            {
                param->generated_label = _rcp_strdup("Gamma Curve");
            }
            else
            {
                param->generated_label = _rcp_strdup("Graded Gamma Curve");
            }
        }
    }
}

static void _rcp_create_label_r3d_metadata_curve(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        rcp_param_state_t * const param = &con->param_state[id];

        if (!param->generated_label)
        {
            if (_rcp_version_greater_or_equal_to(con, 6, 50))
            {
                param->generated_label = _rcp_strdup("Gamma Curve");
            }
            else
            {
                param->generated_label = _rcp_strdup("R3D Metadata Curve");
            }
        }
    }
}

static void _rcp_create_hdr_mode_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const record_hdr_state = &con->param_state[RCP_PARAM_RECORD_HDR_MODE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
            const rcp_param_state_t * const playback_num_hdr_state = &con->param_state[RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_HDR_MODE];

            const playback_state_t playback_mode = (playback_state_t) playback_state->val.int_val;
            const hdr_mode_t record_hdr_mode = (hdr_mode_t) record_hdr_state->val.int_val;
            const int32_t num_playback_hdr_tracks = playback_num_hdr_state->val.int_val;
            hdr_mode_t hdr_mode = HDR_MODE_OFF;

            if (playback_mode == PLAYBACK_STATE_IN_PLAYBACK)
            {
                if (num_playback_hdr_tracks > 1)
                {
                    hdr_mode = HDR_MODE_HDRX;
                }
            }
            else
            {
                hdr_mode = record_hdr_mode;
            }

            state->val_valid = 1;
            state->val.int_val = hdr_mode;
        }
    }
}

static void _rcp_create_record_state_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const record_state_base = &con->param_state[RCP_PARAM_RECORD_STATE_BASE];
            const rcp_param_state_t * const tethered_server_state = &con->param_state[RCP_PARAM_TETHERED_SERVER_STATE];
            const rcp_param_state_t * const primary_storage_state = &con->param_state[RCP_PARAM_PRIMARY_STORAGE];
            rcp_param_state_t * const state = &con->param_state[RCP_PARAM_RECORD_STATE];

            if (
                rcp_get_is_supported(con, RCP_PARAM_TETHERED_SERVER_STATE, NULL) &&
                rcp_get_is_supported(con, RCP_PARAM_PRIMARY_STORAGE, NULL) &&
                ((record_state_t) record_state_base->val.int_val == RECORD_STATE_RECORDING) &&
                ((primary_storage_t) primary_storage_state->val.int_val == PRIMARY_STORAGE_NETWORK) &&
                ((tethered_server_state_t) tethered_server_state->val.int_val == TETHERED_SERVER_STATE_NOT_RECORDING)
               )
            {
                state->val.int_val = RECORD_STATE_ENCODING;
            }
            else
            {
                state->val.int_val = record_state_base->val.int_val;
            }

            state->val_valid = 1;
        }
    }
}

static void _rcp_create_exposure_display_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const display_mode_state = &con->param_state[RCP_PARAM_SHUTTER_DISPLAY_MODE];
            const rcp_param_state_t * const int_time_state = &con->param_state[RCP_PARAM_EXPOSURE_INTEGRATION_TIME];
            const rcp_param_state_t * const angle_state = &con->param_state[RCP_PARAM_EXPOSURE_ANGLE];
            rcp_param_state_t * const state = &con->param_state[id];

            switch ((shutter_display_t) display_mode_state->val.int_val)
            {
                case SHUTTER_TIME:
                    state->val.int_val = int_time_state->val.int_val;
                    state->val_valid = int_time_state->val_valid;
                    break;

                case SHUTTER_ANGLE:
                    state->val.int_val = angle_state->val.int_val;
                    state->val_valid = angle_state->val_valid;
                    break;
            }
        }
    }
}

static void _rcp_create_metadata_date_time_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const date_state = &con->param_state[RCP_PARAM_PLAYBACK_CLIP_DATE];
            const rcp_param_state_t * const time_state = &con->param_state[RCP_PARAM_PLAYBACK_CLIP_TIME];
            rcp_param_state_t * const state = &con->param_state[id];
            struct tm tm_val = {0};

            /* date string: YYYYMMDD
             * time string: HHMMSS */

            if (strlen(time_state->val.str_val) == 6)
            {
                tm_val.tm_hour = (time_state->val.str_val[0] - '0') * 10;
                tm_val.tm_hour += (time_state->val.str_val[1] - '0');

                tm_val.tm_min = (time_state->val.str_val[2] - '0') * 10;
                tm_val.tm_min += (time_state->val.str_val[3] - '0');

                tm_val.tm_sec = (time_state->val.str_val[4] - '0') * 10;
                tm_val.tm_sec += (time_state->val.str_val[5] - '0');
            }

            if (strlen(date_state->val.str_val) == 8)
            {
                tm_val.tm_year = (date_state->val.str_val[0] - '0') * 1000;
                tm_val.tm_year += (date_state->val.str_val[1] - '0') * 100;
                tm_val.tm_year += (date_state->val.str_val[2] - '0') * 10;
                tm_val.tm_year += (date_state->val.str_val[3] - '0');
                tm_val.tm_year -= 1900;

                tm_val.tm_mon = (date_state->val.str_val[4] - '0') * 10;
                tm_val.tm_mon += (date_state->val.str_val[5] - '0');
                tm_val.tm_mon -= 1;

                tm_val.tm_mday = (date_state->val.str_val[6] - '0') * 10;
                tm_val.tm_mday += (date_state->val.str_val[7] - '0');
            }

            state->val.int_val = (int) mktime(&tm_val);
            state->val_valid = 1;
        }
    }
}

static void _rcp_create_min_record_codec_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        /* This logic used to be hard-coded, but is now provided by the camera */
        if (_rcp_has_feature(con, RCP_FEATURE_MIN_CODEC_FROM_CAMERA))
        {
            /* The parameters table doesn't show the get message for this
             * parameter, because if it did then this callback would never be
             * called for older firmware. Note: if we add a min version for the
             * get message we can clean this up a little bit.
             */
            rcp_param_state_t * const state = &con->param_state[id];
            if (!state->val_valid && !state->get_pending)
            {
                /* send get messages */
                _rcp_create_get_message(con, RCP2_CMD_GET, RCP_MIVCODEC_MSG_INT);
                state->get_pending = 1;
            }
        }
        else
        {
            if (_rcp_check_parameter_dependencies(con, id))
            {
                const rcp_param_state_t * const codec_res_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION];
                rcp_param_state_t * const state = &con->param_state[id];

                switch (codec_res_state->val.int_val)
                {
                    case CODEC_RESOLUTION_4K:
                    default:
                        state->val.int_val = (int) VIDEO_CODEC_PRORES_422HQ;
                        break;

                    case CODEC_RESOLUTION_2K:
                        state->val.int_val = (int) VIDEO_CODEC_PRORES_4444;
                        break;
                }

                state->val_valid = 1;
            }
        }
    }
}

static void _rcp_create_min_record_mxf_codec_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        /* This logic used to be hard-coded, but is now provided by the camera */
        if (_rcp_has_feature(con, RCP_FEATURE_MIN_CODEC_FROM_CAMERA))
        {
            /* The parameters table doesn't show the get message for this
             * parameter, because if it did then this callback would never be
             * called for older firmware. Note: if we add a min version for the
             * get message we can clean this up a little bit.
             */
            rcp_param_state_t * const state = &con->param_state[id];
            if (!state->val_valid && !state->get_pending)
            {
                /* send get messages */
                _rcp_create_get_message(con, RCP2_CMD_GET, RCP_MVMCODEC_MSG_INT);
                state->get_pending = 1;
            }
        }
        else
        {
            if (_rcp_check_parameter_dependencies(con, id))
            {
                const rcp_param_state_t * const codec_res_state = &con->param_state[RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION];
                rcp_param_state_t * const state = &con->param_state[id];

                switch (codec_res_state->val.int_val)
                {
                    case CODEC_RESOLUTION_4K:
                    default:
                        state->val.int_val = (int) VIDEO_CODEC_DNX_HQX;
                        break;

                    case CODEC_RESOLUTION_2K:
                        state->val.int_val = (int) VIDEO_CODEC_DNX_444;
                        break;
                }

                state->val_valid = 1;
            }
        }
    }
}

static void _rcp_create_format_phy_width_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const sensor_width_state = &con->param_state[RCP_PARAM_SENSOR_WIDTH_PHY];
            const rcp_param_state_t * format_width_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            if (id == RCP_PARAM_FORMAT_WIDTH_PHY)
            {
                format_width_state = &con->param_state[RCP_PARAM_FORMAT_WIDTH_PIXELS];
            }
            else if (id == RCP_PARAM_SHADOW_FORMAT_WIDTH_PHY)
            {
                format_width_state = &con->param_state[RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS];
            }

            if (format_width_state)
            {
                state->val.int_val = sensor_width_state->val.int_val * format_width_state->val.int_val;
                state->val_valid = 1;
            }
            else
            {
                state->val_valid = 0;
            }
        }
    }
}

static void _rcp_create_format_phy_height_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            const rcp_param_state_t * const sensor_height_state = &con->param_state[RCP_PARAM_SENSOR_HEIGHT_PHY];
            const rcp_param_state_t * format_height_state = NULL;
            rcp_param_state_t * const state = &con->param_state[id];

            if (id == RCP_PARAM_FORMAT_HEIGHT_PHY)
            {
                format_height_state = &con->param_state[RCP_PARAM_FORMAT_HEIGHT_PIXELS];
            }
            else if (id == RCP_PARAM_SHADOW_FORMAT_HEIGHT_PHY)
            {
                format_height_state = &con->param_state[RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS];
            }

            if (format_height_state)
            {
                state->val.int_val = sensor_height_state->val.int_val * format_height_state->val.int_val;
                state->val_valid = 1;
            }
            else
            {
                state->val_valid = 0;
            }
        }
    }
}

static void _rcp_create_edit_info_pw(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (_rcp_check_parameter_dependencies(con, id))
        {
            rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_state_t * encryption_type = NULL;

            switch (id)
            {
                case RCP_PARAM_WIFI_AD_HOC_PASSPHRASE:
                    encryption_type = &con->param_state[RCP_PARAM_WIFI_AD_HOC_ENCRYPTION];
                    break;

                case RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE:
                    encryption_type = &con->param_state[RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION];
                    break;

                default:
                    return;
            }

            switch (encryption_type->val.int_val)
            {
                case WL_ENCRYPTION_WEP:
                    state->edit_info = (void *) &_rcp_edit_info_wep_pw;
                    break;

                case WL_ENCRYPTION_WPA:
                case WL_ENCRYPTION_WPA2:
                    state->edit_info = (void *) &_rcp_edit_info_wpa_pw;
                    break;

                default:
                    state->edit_info = NULL;
                    break;
            }
        }
    }
}

/* Parameter Properties */
const char * rcp_get_name(const rcp_camera_connection_t * con, rcp_param_t id)
{
#ifdef RCP_API_ENABLE_STR_TO_ENUM
    if (id < RCP_PARAM_COUNT)
    {
        return _rcp_param_def[id].enum_name;
    }
#endif

    return NULL;
}

const char * rcp_get_label(rcp_camera_connection_t * con, rcp_param_t id)
{
#ifdef RCP_API_ENABLE_LABELS
    if (id < RCP_PARAM_COUNT)
    {
        if (_rcp_param_def[id].create_label_fp)
        {
            if (con)
            {
                _rcp_param_def[id].create_label_fp(con, id);
                return con->param_state[id].generated_label;
            }
            else
            {
                return NULL;
            }
        }
        else
        {
            return _rcp_param_def[id].label;
        }
    }
#endif

    return NULL;
}

rcp_param_t rcp_get_id(const rcp_camera_connection_t * con, const char * name)
{
#ifdef RCP_API_ENABLE_STR_TO_ENUM
    if (name)
    {
        if (name)
        {
            size_t prefix_offset = 0;
            size_t id = 0;
            const char * const rcp_param_prefix = "RCP_PARAM_";

            /* If the name we are looking for doesn't start with the
             * RCP_PARAM_ prefix skip that part of the enum_name when
             * searching for a match.
             * The prefix is sometimes ommitted to reduce the size of
             * the RCP messages that contain stringified RCP parameter
             * names. */
            if (strncmp(name, rcp_param_prefix, strlen(rcp_param_prefix)) != 0)
            {
                prefix_offset = strlen(rcp_param_prefix);
            }

            for (id = 0; id < (size_t) RCP_PARAM_COUNT; id++)
            {
                if (strcmp(_rcp_param_def[id].enum_name + prefix_offset, name) == 0)
                {
                    return (rcp_param_t) id;
                }
            }
        }
    }
#endif

    return RCP_PARAM_COUNT;
}

int rcp_get_update_list_only_on_close(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        return properties.update_list_only_on_close;
    }
    else
    {
        return 0;
    }
}

int rcp_get_is_supported(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_properties_t * properties)
{
    if (properties)
    {
        memset(properties, 0, sizeof(rcp_param_properties_t));
    }

    if (con && id < RCP_PARAM_COUNT)
    {
        int supported = 0;
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        const rcp_param_state_t * const state = &con->param_state[id];

        /* in order to even determine if a parameter is supported or
         * not we need to first get the following parameter.
         * Therefore, always let these through. */
        if (id == RCP_PARAM_CAMERA_INFO || id == RCP_PARAM_RCP_VERSION || id == RCP_PARAM_RCP_PARAMETER_SET_VERSION)
        {
            supported = 1;
        }
        else if (_rcp_version_in_range(con, &def->rcp_param_version_range))
        {
            supported = 1;
        }

        if (properties)
        {
            if (supported)
            {
                properties->name = def->enum_name;
                properties->label = rcp_get_label(con, id);
                if (def->get_msg || def->get_target_msg || def->create_string_fp || def->create_int_fp)
                {
                    properties->has_get = 1;
                }
                if (def->get_list_msg || def->create_list_fp)
                {
                    properties->has_get_list = 1;
                }
                if (def->get_periodic_msg)
                {
                    properties->has_get_periodic = 1;
                }
                properties->has_get_status = 1;
                if (
                    ((def->current_type == RCP_TYPE_STR) && def->cur_msg) ||
                    def->get_list_msg ||
                    def->create_list_fp ||
                    def->create_string_fp ||
                    def->default_edit_info ||
                    def->create_edit_info_fp
                   )
                {
                    properties->has_display_str = 1;
                }

                if (_rcp_version_in_range(con, &def->set_version_range))
                {
                    if (def->set_msg || def->set_target_msg)
                    {
                        switch (def->set_type)
                        {
                            case RCP_TYPE_NULL:
                                properties->has_send = 1;
                                break;

                            case RCP_TYPE_INT:
                                properties->has_set_int = 1;
                                properties->has_set_int_relative = 1;
                                break;

                            case RCP_TYPE_UINT:
                                properties->has_set_uint = 1;
                                properties->has_set_uint_relative = 1;
                                break;

                            case RCP_TYPE_STR:
                                properties->has_set_str = 1;
                                break;

                            default:
                                break;
                        }

                        if (def->get_list_msg || def->create_list_fp)
                        {
                            properties->has_set_list_relative = 1;
                        }
                    }
                    else if (def->set_int_fp)
                    {
                        properties->has_set_int = 1;
                        if (def->get_list_msg || def->create_list_fp)
                        {
                            properties->has_set_list_relative = 1;
                        }
                    }
                }

                if (def->set_list_msg)
                {
                    properties->has_set_list = 1;
                }

                if (state->edit_info)
                {
                    /* all edit_info types have the major and minor
                     * version as the first two parameters so it
                     * doesn't matter which type we cast it to */
                    const rcp_cur_int_edit_info_t * const edit_info = (rcp_cur_int_edit_info_t *) state->edit_info;
                    if (_rcp_version_in_range(con, &edit_info->version_range))
                    {
                        properties->has_edit_info = 1;
                    }
                }
                else if (def->create_edit_info_fp)
                {
                    properties->has_edit_info = 1;
                }

                properties->update_list_only_on_close = def->update_list_only_on_close;

                _rcp_handle_has_list_exceptions(con, id, properties);
            }
        }

        if (state->is_hw_supported_valid && !state->is_hw_supported)
        {
            supported = 0;
        }

        if (state->is_color_science_supported_valid && !state->is_color_science_supported)
        {
            supported = 0;
        }

        if (def->is_indexed && def->index_list_id != RCP_PARAM_COUNT)
        {
            c_list_entry_t e;
            if (_rcp_get_indexed_parameter_info(con, def->index_list_id, def->index, &e))
            {
                if ((e.num & def->index_list_mask) != def->index_list_mask)
                {
                    supported = 0;
                }
            }
            else
            {
                supported = 0;
            }
        }

        return supported;
    }

    return 0;
}

static void _rcp_handle_has_list_exceptions(const rcp_camera_connection_t * con, rcp_param_t id, rcp_param_properties_t * properties)
{
    if (con && properties)
    {
        if (con->parameter_set_version_major < 6)
        {
            /* in RCP parameter set version 6.0 list support was added
             * for the following parameters.  That is, list support was
             * not present in < 6.0. */
            switch (id)
            {
                case RCP_PARAM_FOCUS_DIST_DISPLAY_MODE:
                case RCP_PARAM_FRAME_PROCESSING_NUM:
                case RCP_PARAM_HDR_MONITOR_TRACK:
                case RCP_PARAM_MEDIA_DISPLAY_MODE:
                case RCP_PARAM_MM_ISO_PULL:
                case RCP_PARAM_POWER_DISPLAY_MODE:
                case RCP_PARAM_RECORD_MODE:
                case RCP_PARAM_SHUTTER_DISPLAY_MODE:
                case RCP_PARAM_SLATE_CAMERA_ID:
                case RCP_PARAM_SLATE_CAMERA_POS:
                case RCP_PARAM_TEST_PATTERN:
                case RCP_PARAM_ZEBRA_1_IRE_HIGH:
                case RCP_PARAM_ZEBRA_1_IRE_LOW:
                case RCP_PARAM_ZEBRA_2_IRE_HIGH:
                case RCP_PARAM_ZEBRA_2_IRE_LOW:
                    properties->has_get_list = 0;
                    properties->has_set_list = 0;
                    break;

                default:
                    break;
            }
        }
    }
}

RCP_API_PRIVATE int _rcp_check_parameter_dependencies(rcp_camera_connection_t * con, rcp_param_t id)
{
    int valid = 1;

    if (con && rcp_get_is_supported(con, id, NULL))
    {
        size_t ii;

        for (ii = 0; ii < sizeof(rcp_dependency_table) / sizeof(rcp_dependency_table[0]); ii++)
        {
            const rcp_dependency_t * const dep = &rcp_dependency_table[ii];

            if (id == dep->target)
            {
                const rcp_param_state_t * const state = &con->param_state[dep->source];

                if (!state->val_valid && rcp_get_is_supported(con, dep->source, NULL))
                {
                    (void) _rcp_get(con, dep->source);
                    valid = 0;
                }
            }
        }

        for (ii = 0; ii < sizeof(rcp_dependency_table_cur_list_to_get) / sizeof(rcp_dependency_table_cur_list_to_get[0]); ii++)
        {
            const rcp_dependency_t * const dep = &rcp_dependency_table_cur_list_to_get[ii];

            if (id == dep->target)
            {
                const rcp_param_state_t * const state = &con->param_state[dep->source];

                if (!state->list_val_valid && rcp_get_is_supported(con, dep->source, NULL))
                {
                    (void) _rcp_get_list(con, dep->source);
                    valid = 0;
                }
            }
        }
    }

    return valid;
}

static int _rcp_check_parameter_status_dependencies(rcp_camera_connection_t * con, rcp_param_t id)
{
    int valid = 1;

    if (con && rcp_get_is_supported(con, id, NULL))
    {
        size_t ii;

        for (ii = 0; ii < sizeof(rcp_dependency_table_cur_to_get_status) / sizeof(rcp_dependency_table_cur_to_get_status[0]); ii++)
        {
            const rcp_dependency_t * const dep = &rcp_dependency_table_cur_to_get_status[ii];

            if (id == dep->target)
            {
                const rcp_param_state_t * const state = &con->param_state[dep->source];

                if (!state->val_valid && rcp_get_is_supported(con, dep->source, NULL))
                {
                    (void) _rcp_get(con, dep->source);
                    valid = 0;
                }
            }
        }

        for (ii = 0; ii < sizeof(rcp_dependency_table_cur_list_to_get_status) / sizeof(rcp_dependency_table_cur_list_to_get_status[0]); ii++)
        {
            const rcp_dependency_t * const dep = &rcp_dependency_table_cur_list_to_get_status[ii];

            if (id == dep->target)
            {
                const rcp_param_state_t * const state = &con->param_state[dep->source];

                if (!state->list_val_valid && rcp_get_is_supported(con, dep->source, NULL))
                {
                    (void) _rcp_get_list(con, dep->source);
                    valid = 0;
                }
            }
        }
    }

    return valid;
}

RCP_API_PRIVATE void _rcp_parameters_handle_record_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_record)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_test_pattern_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_test_pattern)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_magnify_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_magnify)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_playback_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_raw_playback || !def->enabled_in_baked_playback || !def->enabled_in_preview)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_playback_file_format_state_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_raw_playback || !def->enabled_in_baked_playback)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_raw_mode_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_raw)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_video_source_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            if (rcp_get_is_supported(con, (rcp_param_t) ii, NULL))
            {
                const rcp_param_def_t * const def = &_rcp_param_def[ii];

                if (!def->enabled_in_aces)
                {
                    _rcp_send_current_status(con, (rcp_param_t) ii);
                }
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_parameters_handle_color_science_changed(rcp_camera_connection_t * con)
{
    if (con)
    {
        int ii;
        for (ii = 0; ii < (int) RCP_PARAM_COUNT; ii++)
        {
            const rcp_param_def_t * const def = &_rcp_param_def[ii];
            rcp_param_state_t * const state = &con->param_state[ii];

            if (def->color_science != COLOR_SCIENCE_COUNT)
            {
                state->is_color_science_supported_valid = 1;
                state->is_color_science_supported = def->color_science == con->last_color_science;
                _rcp_send_current_status(con, (rcp_param_t) ii);
            }
        }
    }
}

static int _rcp_get_string_from_list(const rcp_camera_connection_t * con, rcp_param_t id, char * dest, size_t dest_size)
{
    int res = 0;
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->list_val_valid && state->list_val)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

            if (c_list)
            {
                if (C_LIST_SUCCESS == c_list_import_from_string(c_list, state->list_val))
                {
                    c_list_entry_t entry;

                    if (C_LIST_SUCCESS == c_list_get_current_entry(c_list, &entry))
                    {
                        strlcpy(dest, entry.str, dest_size);
                        res = 1;
                    }
                }

                (void) c_list_delete(c_list);
            }
        }
    }

    return res;
}

static int _rcp_get_string_from_list_by_value(const rcp_camera_connection_t * con, rcp_param_t id, int value, char * dest, size_t dest_size)
{
    int res = 0;
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->list_val_valid && state->list_val)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

            if (c_list)
            {
                if (C_LIST_SUCCESS == c_list_import_from_string(c_list, state->list_val))
                {
                    size_t ii;
                    const size_t len = c_list_get_length(c_list);

                    for (ii = 0; ii < len; ii++)
                    {
                        c_list_entry_t entry;

                        if (C_LIST_SUCCESS == c_list_get_entry(c_list, ii, &entry))
                        {
                            if (entry.num == value)
                            {
                                strlcpy(dest, entry.str, dest_size);
                                res = 1;
                            }
                        }
                    }
                }

                (void) c_list_delete(c_list);
            }
        }
    }

    return res;
}

static size_t _rcp_get_size_of_list(const rcp_camera_connection_t * con, rcp_param_t id)
{
    size_t res = 0;
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (state->list_val_valid && state->list_val)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

            if (c_list)
            {
                if (C_LIST_SUCCESS == c_list_import_from_string(c_list, state->list_val))
                {
                    res = c_list_get_length(c_list);
                }

                (void) c_list_delete(c_list);
            }
        }
    }

    return res;
}
/********** End file: rcp_api_parameters.c **************************************/

/********** Begin file: rcp_api_process_data.c **********************************/
/* #include "rcp_api_process_data.h" */

/* #include "rcp_api_audio_vu.h" */
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_client_id.h" */
/* #include "rcp_api_clip_list.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_hist.h" */
/* #include "rcp_api_key_mapping.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_parameters_hash_table.h" */
/* #include "rcp_api_send_current.h" */
/* #include "rcp_api_state.h" */
/* #include "rcp_api_hw_cap.h" */
/* #include "rcp_api_user.h" */

#include <string.h>
#include <stdio.h>
/* #include "decorated_string/decorated_string.h" */
/* #include "rcp_parser/rcp_parser2.h" */
/* #include "rcp_parser/rcp_parameter_types_public.h" */
/* #include "stringl/stringl.h" */
/* #include "clist/c_list.h" */

static void _rcp_process_packet_current(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
static void _rcp_process_packet_current_default(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
static void _rcp_process_packet_current_target(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
static void _rcp_process_packet_current_list(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
static void _rcp_process_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);
static void _rcp_process_tag_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id);
static void _rcp_process_camera_info_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet);

static int _rcp_decorated_string_version(const rcp_camera_connection_t * con);
static void _rcp_handle_record_state(rcp_camera_connection_t * con);
static void _rcp_handle_test_pattern(rcp_camera_connection_t * con);
static void _rcp_handle_magnify_state(rcp_camera_connection_t * con);
static void _rcp_handle_playback_state(rcp_camera_connection_t * con);
static void _rcp_handle_playback_file_format_state(rcp_camera_connection_t * con);
static void _rcp_handle_raw_mode(rcp_camera_connection_t * con);
static void _rcp_handle_video_source(rcp_camera_connection_t * con);
static void _rcp_handle_output_transform(rcp_camera_connection_t * con);
static void _rcp_handle_color_science(rcp_camera_connection_t * con);

static void _rcp_process_packet_current(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];
        int value_index = 0;

        if (def->is_indexed)
        {
            if (packet->argv[0] && (def->index == atoi(packet->argv[0])))
            {
                /* correct index */
                value_index = 1;
            }
            else
            {
                /* not the correct index */
                return;
            }
        }

        if (state->get_pending)
        {
            state->get_pending = 0;
        }

        /* generic handling */
        switch (def->current_type)
        {
            case RCP_TYPE_INT:
                if (packet->argv[value_index])
                {
                    state->val.int_val = atoi(packet->argv[value_index]);
                    state->val_valid = 1;
                    _rcp_send_current_int(con, id, 0);
                }
                break;

            case RCP_TYPE_UINT:
                if (packet->argv[value_index])
                {
                    state->val.uint_val = (unsigned int) strtoul(packet->argv[value_index], NULL, 10);
                    state->val_valid = 1;
                    _rcp_send_current_uint(con, id, 0);
                }
                break;

            case RCP_TYPE_HIST:
                _rcp_process_hist_packet(con, packet, id);
                break;

            case RCP_TYPE_AUDIOVU:
                _rcp_process_audio_vu_packet(con, packet, id);
                break;

            case RCP_TYPE_HW_CAP:
                _rcp_process_hw_cap_packet(con, packet, id);
                break;

            case RCP_TYPE_STR:
            {
                const size_t len = strlen(packet->argv[value_index]) + 50; /* to allow room for expansion of special chars */

                if (state->val.str_val)
                {
                    rcp_free(state->val.str_val);
                }
                state->val.str_val = RCP_MALLOC(char *, len);
                if (state->val.str_val)
                {
                    if (_rcp_decorated_string_version(con) == 1)
                    {
                        decorated_string_1_to_2(packet->argv[value_index], state->val.str_val, len);
                    }
                    else
                    {
                        strlcpy(state->val.str_val, packet->argv[value_index], len);
                    }
                }
                state->val_valid = 1;

                _rcp_send_current_str(con, id);
                break;
            }

            case RCP_TYPE_TAG:
                _rcp_process_tag_packet(con, packet, id);
                break;

            case RCP_TYPE_CAM_INFO:
                _rcp_process_camera_info_packet(con, packet);
                break;

            default:
                if (id == RCP_PARAM_SHUTDOWN)
                {
                    state->val.int_val = 1;
                    state->val_valid = 1;
                    _rcp_send_current_int(con, id, 0);
                }
                break;
        }

        /* special handling */

        /* send target get requests based on source RCP parameter */
        _rcp_get_dependencies(con, id);

        switch (id)
        {
#ifdef RCP_API_ENABLE_CLIP_LIST
            case RCP_PARAM_MEDIA_CLIP_COUNT:
                _rcp_handle_media_clip_count(con, id);
                break;

            case RCP_PARAM_MEDIA_CLIP_EXT_INFO:
                _rcp_handle_media_clip_ext_info(con, packet);
                break;

            case RCP_PARAM_MEDIA_LABEL:
                _rcp_handle_media_label(con, id);
                break;
#endif

            case RCP_PARAM_RECORD_STATE_BASE:
                _rcp_handle_record_state(con);
                break;

            case RCP_PARAM_TEST_PATTERN:
                _rcp_handle_test_pattern(con);
                break;

            case RCP_PARAM_MAGNIFY_STATE:
                _rcp_handle_magnify_state(con);
                break;

            case RCP_PARAM_PLAYBACK_STATE:
                _rcp_handle_playback_state(con);
                break;

            case RCP_PARAM_PLAYBACK_FILE_FORMAT:
                _rcp_handle_playback_file_format_state(con);
                break;

            case RCP_PARAM_RAW_MODE:
                _rcp_handle_raw_mode(con);
                break;

            case RCP_PARAM_VIDEO_SOURCE:
                _rcp_handle_video_source(con);
                break;

            case RCP_PARAM_OUTPUT_TRANSFORM:
                _rcp_handle_output_transform(con);
                break;

            case RCP_PARAM_COLOR_SCIENCE:
                _rcp_handle_color_science(con);
                break;

            default:
                break;
        }
    }
}

static void _rcp_process_packet_current_default(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        state->default_val_valid = 0;

        if (packet->argc >= 1 && packet->argv[0])
        {
            state->default_val_valid = atoi(packet->argv[0]);
        }

        switch (def->current_type)
        {
            case RCP_TYPE_INT:
                if (state->default_val_valid && packet->argv[1])
                {
                    state->default_val.int_val = atoi(packet->argv[1]);
                }
                else
                {
                    state->default_val.int_val = 0;
                }
                _rcp_send_current_default_int(con, id);
                break;

            case RCP_TYPE_UINT:
                if (state->default_val_valid && packet->argv[1])
                {
                    state->val.uint_val = (unsigned int) strtoul(packet->argv[1], NULL, 10);
                }
                else
                {
                    state->val.uint_val = 0;
                }
                _rcp_send_current_default_uint(con, id);
                break;

            default:
                break;
        }
    }
}

void _rcp_handle_record_state(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_RECORD_STATE_BASE];

        if (state->val_valid)
        {
            /* instead of just checking: con->last_record_state !=
             * state->val.int_val will see if it actually changed
             * record state or not.  This will reduce the overhead when
             * changing between encode, record, and finalize */

            if (
                ((con->last_record_state == RECORD_STATE_NOT_RECORDING) && ((record_state_t) state->val.int_val != RECORD_STATE_NOT_RECORDING)) ||
                ((con->last_record_state != RECORD_STATE_NOT_RECORDING) && ((record_state_t) state->val.int_val == RECORD_STATE_NOT_RECORDING))
               )
            {
                con->last_record_state = (record_state_t) state->val.int_val;
                _rcp_parameters_handle_record_state_changed(con);
#ifdef RCP_API_ENABLE_CLIP_LIST
                _rcp_clip_list_handle_record_state_changed(con);
#endif
            }
        }
    }
}

void _rcp_handle_test_pattern(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_TEST_PATTERN];

        if (state->val_valid)
        {
            if (con->last_test_pattern != (monitor_test_pattern_t) state->val.int_val)
            {
                con->last_test_pattern = (monitor_test_pattern_t) state->val.int_val;
                _rcp_parameters_handle_test_pattern_changed(con);
            }
        }
    }
}

void _rcp_handle_magnify_state(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_MAGNIFY_STATE];

        if (state->val_valid)
        {
            if (con->last_magnify_state != (magnify_mode_t) state->val.int_val)
            {
                con->last_magnify_state = (magnify_mode_t) state->val.int_val;
                _rcp_parameters_handle_magnify_state_changed(con);
            }
        }
    }
}

void _rcp_handle_playback_state(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];

        if (state->val_valid)
        {
            if (con->last_playback_state != (playback_state_t) state->val.int_val)
            {
                con->last_playback_state = (playback_state_t) state->val.int_val;
                _rcp_parameters_handle_playback_state_changed(con);
#ifdef RCP_API_ENABLE_MENU
                _rcp_menu_handle_playback_state_changed(con);
#endif
            }
        }
    }
}

void _rcp_handle_playback_file_format_state(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_PLAYBACK_FILE_FORMAT];

        if (state->val_valid)
        {
            if (con->last_playback_file_format_type != (file_format_type_t) state->val.int_val)
            {
                con->last_playback_file_format_type = (file_format_type_t) state->val.int_val;
                _rcp_parameters_handle_playback_file_format_state_changed(con);
            }
        }
    }
}

static void _rcp_handle_raw_mode(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_RAW_MODE];

        if (state->val_valid)
        {
            if (con->last_raw_mode != (raw_mode_t) state->val.int_val)
            {
                con->last_raw_mode = (raw_mode_t) state->val.int_val;
                _rcp_parameters_handle_raw_mode_changed(con);
            }
        }
    }
}

static void _rcp_handle_video_source(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_VIDEO_SOURCE];
        if (state->val_valid)
        {
            if (con->last_video_source != (video_source_t) state->val.int_val)
            {
                con->last_video_source = (video_source_t) state->val.int_val;
                _rcp_parameters_handle_video_source_changed(con);
            }
        }
    }
}

static void _rcp_handle_output_transform(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const output_transform_state = &con->param_state[RCP_PARAM_OUTPUT_TRANSFORM];
        if (output_transform_state->val_valid)
        {
            if (con->last_output_transform != (output_transform_t) output_transform_state->val.int_val)
            {
                con->last_output_transform = (output_transform_t) output_transform_state->val.int_val;
                _rcp_parameters_handle_video_source_changed(con);
            }
        }
    }
}

static void _rcp_handle_color_science(rcp_camera_connection_t * con)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[RCP_PARAM_COLOR_SCIENCE];

        if (state->val_valid)
        {
            if (con->last_color_science != (color_science_t) state->val.int_val)
            {
                con->last_color_science = (color_science_t) state->val.int_val;
                _rcp_parameters_handle_color_science_changed(con);
            }
        }
    }
}

static void _rcp_process_packet_current_target(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (state->get_target_pending)
        {
            state->get_target_pending = 0;
        }

        /* generic handling */
        switch (def->current_type)
        {
            case RCP_TYPE_INT:
                if (packet->argv[0])
                {
                    state->target_val.int_val = atoi(packet->argv[0]);
                    state->target_val_valid = 1;
                    _rcp_send_current_int(con, id, 1);
                }
                break;

            case RCP_TYPE_UINT:
                if (packet->argv[0])
                {
                    state->target_val.uint_val = (unsigned int) strtoul(packet->argv[0], NULL, 10);
                    state->target_val_valid = 1;
                    _rcp_send_current_uint(con, id, 1);
                }
                break;

            default:
                break;
        }

        /* special handling */

        /* send target get requests based on source RCP parameter */
        _rcp_get_dependencies(con, id);
    }
}

static void _rcp_process_packet_current_list(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        rcp_param_state_t * const state = &con->param_state[id];
        const size_t len = strlen(packet->argv[0]) + 1;

        if (state->get_list_pending)
        {
            state->get_list_pending = 0;
        }

        if (state->list_val)
        {
            rcp_free(state->list_val);
        }
        state->list_val_valid = 0;
        state->list_current_val_valid = 0;

        state->list_val = RCP_MALLOC(char *, len);
        if (state->list_val)
        {
            if (_rcp_decorated_string_version(con) == 1)
            {
                /* we need to convert old decorated strings for each
                 * entry in the list.  we can't decode the entire string
                 * using decorated_string_1_to_2 because the old decorated
                 * strings use both \ and | which are both used in the
                 * clist stringify syntax. */
                c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);
                if (c_list)
                {
                    size_t ii;
                    size_t total_len = 20; /* to make room for overhead (type, current, some separaters, null, etc) */
                    if (C_LIST_SUCCESS == c_list_import_from_string(c_list, packet->argv[0]))
                    {
                        const size_t list_len = c_list_get_length(c_list);
                        for (ii = 0; ii < list_len; ii++)
                        {
                            c_list_entry_t e;
                            if (C_LIST_SUCCESS == c_list_get_entry(c_list, ii, &e))
                            {
                                char buf[C_LIST_MAX_STRING_LEN];
                                decorated_string_1_to_2(e.str, buf, sizeof(buf));
                                total_len += strlen(buf);
                                total_len += 12; /* to make room for int and two separators  */
                                strlcpy(e.str, buf, sizeof(e.str));
                                if (C_LIST_SUCCESS != c_list_set_entry(c_list, ii, &e))
                                {
                                    _rcp_log_error(con, "c_list_set_entry failed\n");
                                }
                            }
                        }

                        /* reallocate based on new size */
                        rcp_free(state->list_val);
                        state->list_val = RCP_MALLOC(char *, total_len);
                        if (state->list_val)
                        {
                            if (C_LIST_SUCCESS == c_list_export_to_string(c_list, state->list_val, total_len))
                            {
                                state->list_val_valid = 1;
                            }
                            else
                            {
                                _rcp_log_error(con, "c_list_export_to_string failed\n");
                            }
                        }
                    }
                    else
                    {
                        _rcp_log_error(con, "c_list_import_from_string failed\n");
                    }

                    if (C_LIST_SUCCESS != c_list_delete(c_list))
                    {
                        _rcp_log_error(con, "c_list_delete failed\n");
                    }
                }
            }
            else
            {
                strlcpy(state->list_val, packet->argv[0], len);
                state->list_val_valid = 1;
                /* note: we don't set list_current_val_valid to true,
                 * since we don't know what the current value is.  we
                 * would need to convert the stringified list into a
                 * list a get the current value out.  It's not worth
                 * doing that here since we don't always need to know
                 * the current value in the list. */
            }
        }

        _rcp_send_current_list(con, id, id);

        _rcp_get_dependencies_cur_list_to_get(con, id);
        _rcp_get_dependencies_cur_list_to_get_status(con, id);
        _rcp_get_dependencies_cur_list_to_create_list(con, id);
    }
}

static void _rcp_process_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        size_t id;

        const char cmd = *packet->pCmd;

        int current_found = 0;
        int target_found = 0;
        size_t start_index = 0;

        if (packet->pParam)
        {
            const cur_msg_to_param_id_t * cur = NULL;

            /* Notification, Menu Tree, and file transfer messages
             * aren't added to the parameter list table since they
             * aren't intended to be used directly.  Check for them and
             * handle here.
             * */
#ifdef RCP_API_ENABLE_NOTIFICATIONS
            if (strcmp(packet->pParam, RCP_NOTIFY_MSG_NOTIFICATION_PTR) == 0)
            {
                _rcp_process_packet_notification(con, packet);
                return;
            }
#endif

#ifdef RCP_API_ENABLE_MENU
            if (strcmp(packet->pParam, RCP_MENUTREE_MSG_MENU_TREE_CHILDREN) == 0)
            {
                _rcp_menu_handle_node_list(con, packet->argv[0]);
                return;
            }

            if (strcmp(packet->pParam, RCP_MENUST_MSG_RCP_API_MENU_NODE_ENABLE) == 0)
            {
                const rcp_menu_node_id_t menu_node_id_t = (rcp_menu_node_id_t) atoi(packet->argv[0]);
                const int is_enabed = atoi(packet->argv[1]);
                const int is_supported = (packet->argc >= 3) ? atoi(packet->argv[2]) : 1;
                _rcp_menu_handle_node_status(con, menu_node_id_t, is_enabed, is_supported);
                return;
            }
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
            if (strcmp(packet->pParam, RCP_RFTPSTOR_MSG_RFTP_STORE) == 0)
            {
                _rcp_rftp_handle_store(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPRETR_MSG_RFTP_RETRIEVE) == 0)
            {
                _rcp_rftp_handle_retrieve(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPLIST_MSG_RFTP_LIST) == 0)
            {
                _rcp_rftp_handle_list(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPDATA_MSG_RFTP_DATA) == 0)
            {
                _rcp_rftp_handle_data(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPABOR_MSG_RFTP_ABORT) == 0)
            {
                _rcp_rftp_handle_abort(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPDELE_MSG_RFTP_DELETE) == 0)
            {
                _rcp_rftp_handle_delete(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RFTPPAUS_MSG_RFTP_PAUSE_STATE) == 0)
            {
                _rcp_rftp_handle_pause(con, packet);
                return;
            }
#endif

            if (strcmp(packet->pParam, RCP_USER_MSG_USER_DATA) == 0)
            {
                _rcp_process_user_packet(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_USRMDREG_MSG_USER_METADATA_REGISTER) == 0)
            {
                _rcp_process_user_metadata_reg_packet(con, packet);
                return;
            }

            if (strcmp(packet->pParam, RCP_RCPPING_MSG_STR_PTR) == 0)
            {
                _rcp_client_id_ping(con, packet);
                return;
            }

            if (strcmp(packet->pParam, "WHO") == 0)
            {
                /* Ignore */
                return;
            }

            if (strcmp(packet->pParam, RCP_USERKEY_MSG_KEY_MAPPING) == 0)
            {
                _rcp_process_key_mapping_packet(con, packet);
                return;
            }

            /* normal current messages are handled here. */
            cur = _rcp_get_id_from_cur_msg(packet->pParam, (unsigned int) strlen(packet->pParam));
            if (cur)
            {
                start_index = (size_t) cur->id;
            }
            else
            {
                _rcp_log_debug(con, "current message %s not found in hash table\n", packet->pParam);
            }
        }

        /* Iterate over the list of parameters and find the entries
         * that match the incoming current packet. Then call the
         * appropriate sub-type process packet function. Since we
         * optimize the search by aborting once we find all matches,
         * we need to ensure that entries with matching rcp current
         * messages are sequential in the list. */
        for (id = start_index; id < (size_t) RCP_PARAM_COUNT; id++)
        {
            const rcp_param_def_t * const def = &_rcp_param_def[id];
            int current_last_found = 0;
            int target_last_found = 0;

            if (cmd == RCP2_CMD_CURRENT)
            {
                if (def->cur_msg && packet->pParam)
                {
                    if (strcmp(def->cur_msg, packet->pParam) == 0)
                    {
                        _rcp_process_packet_current(con, packet, (rcp_param_t) id);
                        current_found = 1;
                    }
                    else
                    {
                        current_last_found = 1;
                    }
                }
                if (def->cur_target_msg && packet->pParam)
                {
                    if (strcmp(def->cur_target_msg, packet->pParam) == 0)
                    {
                        _rcp_process_packet_current_target(con, packet, (rcp_param_t) id);
                        target_found = 1;
                    }
                    else
                    {
                        target_last_found = 1;
                    }
                }

                if ((current_found && current_last_found) || (target_found && target_last_found))
                {
                    break;
                }
            }
            else if (cmd == RCP2_CMD_CURRENT_LIST)
            {
                if (def->cur_list_msg && packet->pParam)
                {
                    if (strcmp(def->cur_list_msg, packet->pParam) == 0)
                    {
                        _rcp_process_packet_current_list(con, packet, (rcp_param_t) id);
                        current_found = 1;
                    }
                    else
                    {
                        current_last_found = 1;
                    }
                }

                if (current_found && current_last_found)
                {
                    break;
                }
            }
            else if (cmd == RCP2_CMD_CURRENT_DEFAULT)
            {
                if (def->cur_msg && packet->pParam)
                {
                    if (strcmp(def->cur_msg, packet->pParam) == 0)
                    {
                        _rcp_process_packet_current_default(con, packet, (rcp_param_t) id);
                        current_found = 1;
                    }
                    else
                    {
                        current_last_found = 1;
                    }
                }
                if (def->cur_target_msg && packet->pParam)
                {
                    if (strcmp(def->cur_target_msg, packet->pParam) == 0)
                    {
                        _rcp_process_packet_current_default(con, packet, (rcp_param_t) id);
                        target_found = 1;
                    }
                    else
                    {
                        target_last_found = 1;
                    }
                }

                if ((current_found && current_last_found) || (target_found && target_last_found))
                {
                    break;
                }
            }
        }
    }
}

static void _rcp_process_tag_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet, rcp_param_t id)
{
    if (con && packet)
    {
        if (packet->argc == 3)
        {
            rcp_cur_tag_info_cb_data_t data;

            data.con = con;
            data.id = id;
            data.tag_info.frame = strtoull(packet->argv[0], NULL, 10);
            strlcpy(data.tag_info.tod_timecode, packet->argv[1], sizeof(data.tag_info.tod_timecode));
            data.tag_info.type = (tag_info_tag_type_t) atoi(packet->argv[2]);

            _rcp_cur_tag_cb(con, &data);
        }
    }
}

static int _rcp_decorated_string_version(const rcp_camera_connection_t * con)
{
    if (!con)
    {
        return 0;
    }

    if (con->parameter_set_version_major == 5)
    {
        return 1;
    }
    else
    {
        return 2;
    }
}

static void _rcp_process_camera_info_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        if (packet->argc < 3)
        {
            _rcp_log_error(con, "invalid number of arguments in camera info packet\n");
        }
        else
        {
            rcp_cam_info_t cam_info;
            /* copy data from RCP packet into camera info structure. */
            strlcpy(cam_info.id, packet->pSource, sizeof(cam_info.id));
            strlcpy(cam_info.pin, packet->argv[0], sizeof(cam_info.pin));
            strlcpy(cam_info.type, packet->argv[1], sizeof(cam_info.type));
            strlcpy(cam_info.version, packet->argv[2], sizeof(cam_info.version));

            /* argv[3] is deprecated - it used to be the ip address,
             * which is now provided by the client */

            if (packet->argc > 4)
            {
                cam_info.rcp_interface = (rcp_interface_t) atoi(packet->argv[4]);
            }
            else
            {
                cam_info.rcp_interface = RCP_INTERFACE_UNKNOWN;
            }

            if (packet->argc > 5)
            {
                cam_info.rcp_interface_enabled = atoi(packet->argv[5]);
                cam_info.rcp_interface_enabled_valid = 1;
            }
            else
            {
                /* we don't know if the interface is enabled or not;
                 * the camera firmware is too old to tell us. */
                cam_info.rcp_interface_enabled = 0;
                cam_info.rcp_interface_enabled_valid = 0;
            }

            _rcp_cur_camera_info_cb(con, &cam_info);
        }
    }
}

void rcp_process_data(rcp_camera_connection_t * con, const char * data, size_t len)
{
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);

    if (con)
    {
#ifdef RCP_API_ENABLE_STATS
        con->stats.rx_bytes += len;
#endif

        while (len--)
        {
            const int res = RCP_get_and_parse_packet(&con->parser_state, *data++);

            switch (res)
            {
                case RCP2_PARSER_OK:
#ifdef RCP_API_ENABLE_STATS
                    con->stats.rx_packets++;
#endif
                    _rcp_process_packet(con, &con->parser_state.parsed);
                    break;

                case RCP2_PARSER_INCOMPLETE_PACKET:
                    /* this is not an error, just an incomplete RCP
                     * packet, continue on. */
                    break;

                default:
                    _rcp_log_error(con, "RCP parser error: %d\n", res);
                    break;
            }
        }
    }

    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
}
/********** End file: rcp_api_process_data.c ************************************/

/********** Begin file: rcp_api_rftp.c ******************************************/
/* #include "rcp_api_rftp.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_utils.h" */
/* #include "rcp_api_uuid.h" */

/* #include "base64/base64.h" */
/* #include "rcp_parser/rcp_parser2.h" */
/* #include "rcp_parser/rcp_parameter_types_public.h" */
#include <stdio.h>
#ifdef _MSC_VER
#define atoll _atoi64
#define PRId64 "I64d"
#else
#include <inttypes.h>
#endif
#include <string.h>

#define RFTP_WINDOW_SIZE 4

static int64_t _rftp_get_max_fragment_size(const rcp_camera_connection_t * con);
#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_stor(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed);
static void _rcp_send_rftp_retr(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path, int64_t max_fragment_size, int compression_allowed, int is_tethered);
static void _rcp_send_rftp_retr_ack(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, rftp_error_t error);
static void _rcp_send_rftp_data_ack(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, rftp_error_t error, int64_t fragment_num);
static void _rcp_send_rftp_abor(rcp_camera_connection_t * con, const rcp_uuid_t * uuid);
static void _rcp_send_rftp_dele(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path);
static void _rcp_get_rftp_list(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path);
static void _rcp_rftp_update_status(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer);
#endif
static int _rcp_rftp_send_data_fragment(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer);
static rftp_error_t _rcp_rftp_send_data_fragment_packet(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, int64_t fragment_num, const uint8_t * data, int64_t fragment_size);
static void _rcp_rftp_error(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error);
static void _rcp_rftp_cleanup(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer);

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_stor(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, int fragment_size, rcp_uuid_t * uuid);
static rcp_error_t _rcp_rftp_retr(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, int is_tethered, rcp_uuid_t * uuid);
static rcp_error_t _rcp_rftp_retr_ack(rcp_camera_connection_t * con, const rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error);
static rcp_error_t _rcp_rftp_data_ack(rcp_camera_connection_t * con, const rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error, int64_t fragment_num);
static rcp_error_t _rcp_rftp_abor(rcp_camera_connection_t * con, rcp_uuid_t * uuid);
static rcp_error_t _rcp_rftp_dele(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid);
static rcp_error_t _rcp_rftp_list(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid);
static rcp_error_t _rcp_rftp_retrieve_file(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, int is_tethered, rcp_uuid_t * uuid);
#endif

static rcp_rftp_transfer_t * _rcp_rftp_get_transfer_request(const rcp_camera_connection_t * con, const char * uuid);
#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_rftp_transfer_t * _rcp_rftp_create_transfer_request(rcp_camera_connection_t * con);
static void _rcp_rftp_free_data(const rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer);
#endif
static void _rcp_rftp_free_transfer(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer);

static int64_t _rftp_get_max_fragment_size(const rcp_camera_connection_t * con)
{
    int64_t max_size = 0;

    if (con)
    {
        max_size = RCP_FILE_TRANSFER_MAX_FRAGMENT_SIZE;
    }

    return max_size;
}

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_stor(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed)
{
    if (con && uuid && path)
    {
        char uncompressed_len_str[RCP_STR_LEN_FOR_INT64];
        char compressed_len_str[RCP_STR_LEN_FOR_INT64];
        char file_is_compressed_str[RCP_STR_LEN_FOR_INT32];

        snprintf(uncompressed_len_str, sizeof(uncompressed_len_str), "%" PRId64, uncompressed_len);
        snprintf(compressed_len_str, sizeof(compressed_len_str), "%" PRId64, compressed_len);
        snprintf(file_is_compressed_str, sizeof(file_is_compressed_str), "%d", file_is_compressed);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPSTOR_MSG_RFTP_STORE, 5, uuid->str, path, uncompressed_len_str, compressed_len_str, file_is_compressed_str))
        {
            _rcp_log_error(con, "cannot create rftp stor packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_retr(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path, int64_t max_fragment_size, int compression_allowed, int is_tethered)
{
    if (con && uuid && path)
    {
        char size_str[RCP_STR_LEN_FOR_INT64];
        char compress_str[RCP_STR_LEN_FOR_INT32];

        snprintf(size_str, sizeof(size_str), "%" PRId64, max_fragment_size);
        snprintf(compress_str, sizeof(compress_str), "%d", compression_allowed);

        if (is_tethered)
        {
            char tether_str[RCP_STR_LEN_FOR_INT32];
            snprintf(tether_str, sizeof(tether_str), "%d", is_tethered);

            if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPRETR_MSG_RFTP_RETRIEVE, 5, uuid->str, path, size_str, compress_str, tether_str))
            {
                _rcp_log_error(con, "cannot create rftp retr packet\n");
            }
        }
        else
        {
            if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPRETR_MSG_RFTP_RETRIEVE, 4, uuid->str, path, size_str, compress_str))
            {
                _rcp_log_error(con, "cannot create rftp retr packet\n");
            }
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_retr_ack(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, rftp_error_t error)
{
    if (con && uuid)
    {
        char error_str[RCP_STR_LEN_FOR_INT32];
        snprintf(error_str, sizeof(error_str), "%d", error);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_CURRENT, RCP_RFTPRETR_MSG_RFTP_RETRIEVE, 2, uuid->str, error_str))
        {
            _rcp_log_error(con, "cannot create rftp retr ack packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_data_ack(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, rftp_error_t error, int64_t fragment_num)
{
    if (con && uuid)
    {
        char error_str[RCP_STR_LEN_FOR_INT32];
        char fragment_str[RCP_STR_LEN_FOR_INT64];

        snprintf(error_str, sizeof(error_str), "%d", error);
        snprintf(fragment_str, sizeof(fragment_str), "%" PRId64, fragment_num);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_CURRENT, RCP_RFTPDATA_MSG_RFTP_DATA, 3, uuid->str, error_str, fragment_str))
        {
            _rcp_log_error(con, "cannot create rftp data ack packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_abor(rcp_camera_connection_t * con, const rcp_uuid_t * uuid)
{
    if (con && uuid)
    {
        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPABOR_MSG_RFTP_ABORT, 2, uuid->str, "1"))
        {
            _rcp_log_error(con, "cannot create rftp abor packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_send_rftp_dele(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path)
{
    if (con && uuid && path)
    {
        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPDELE_MSG_RFTP_DELETE, 2, uuid->str, path))
        {
            _rcp_log_error(con, "cannot create rftp dele packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_get_rftp_list(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, const char * path)
{
    if (con && uuid && path)
    {
        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_GET, RCP_RFTPLIST_MSG_RFTP_LIST, 2, uuid->str, path))
        {
            _rcp_log_error(con, "cannot create rftp list packet\n");
        }
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_stor(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, int fragment_size, rcp_uuid_t * uuid)
{
    if (con)
    {
        rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_create_transfer_request(con);
        if (!rcp_rftp_transfer)
        {
            return RCP_ERROR_INTERNAL;
        }

        if (_rcp_create_uuid(&rcp_rftp_transfer->rftp_uuid))
        {
            rcp_rftp_transfer->rftp_type = RFTP_TYPE_STORE;
            rcp_rftp_transfer->rftp_data_size = (file_is_compressed ? compressed_len : uncompressed_len);
            rcp_rftp_transfer->rftp_data = data;
            rcp_rftp_transfer->rftp_data_cur = data;
            rcp_rftp_transfer->rftp_data_is_compressed = file_is_compressed;
            rcp_rftp_transfer->rftp_last_percent_sent = -1;
            rcp_rftp_transfer->is_paused = 0;

            rcp_rftp_transfer->rftp_last_ack = -1;
            rcp_rftp_transfer->rftp_num_fragments = -1;
            rcp_rftp_transfer->rftp_cur_fragment = 0;
            rcp_rftp_transfer->rftp_max_fragment_size = fragment_size;

            _rcp_send_rftp_stor(con, &rcp_rftp_transfer->rftp_uuid, path, uncompressed_len, compressed_len, file_is_compressed);
            rcp_rftp_transfer->rftp_state = RCP_RFTP_STATE_STOR_INIT_WAIT_FOR_ACK;

            if (uuid)
            {
                *uuid = rcp_rftp_transfer->rftp_uuid;
            }

            return RCP_SUCCESS;
        }
        else
        {
            rcp_free(rcp_rftp_transfer);
            return RCP_ERROR_INTERNAL;
        }
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_retr(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, int is_tethered, rcp_uuid_t * uuid)
{
    if (con)
    {
        rcp_rftp_transfer_t * rcp_rftp_transfer;

        if (is_tethered)
        {
            const rcp_rftp_transfer_t * cur = con->rftp_transfer;

            while (cur)
            {
                if (cur->rftp_is_tethered && !cur->rftp_tethering_is_complete)
                {
                    /* Only one tethered RFTP transfer is allowed at a time */
                    return RCP_ERROR_TETHERED_RFTP_TRANSFER_IN_PROGRESS;
                }

                cur = cur->next;
            }
        }

        rcp_rftp_transfer = _rcp_rftp_create_transfer_request(con);
        if (!rcp_rftp_transfer)
        {
            return RCP_ERROR_INTERNAL;
        }

        if (_rcp_create_uuid(&rcp_rftp_transfer->rftp_uuid))
        {
            rcp_rftp_transfer->rftp_type = RFTP_TYPE_RETRIEVE;
            rcp_rftp_transfer->rftp_last_percent_sent = -1;

            rcp_rftp_transfer->rftp_bytes_read = 0;
            rcp_rftp_transfer->rftp_max_file_size = max_file_size;
            rcp_rftp_transfer->rftp_is_tethered = is_tethered;
            rcp_rftp_transfer->rftp_tethering_is_complete = 0;
            memset(rcp_rftp_transfer->rftp_md5sum, 0, sizeof(rcp_rftp_transfer->rftp_md5sum));

            _rcp_send_rftp_retr(con, &rcp_rftp_transfer->rftp_uuid, path, _rftp_get_max_fragment_size(con), compression_allowed, is_tethered);
            rcp_rftp_transfer->rftp_state = RCP_RFTP_STATE_RETR_INIT_WAIT_FOR_ACK;

            if (uuid)
            {
                *uuid = rcp_rftp_transfer->rftp_uuid;
            }

            return RCP_SUCCESS;
        }
        else
        {
            rcp_free(rcp_rftp_transfer);
            return RCP_ERROR_INTERNAL;
        }
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_retr_ack(rcp_camera_connection_t * con, const rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error)
{
    if (con)
    {
        _rcp_send_rftp_retr_ack(con, &rcp_rftp_transfer->rftp_uuid, error);
        return RCP_SUCCESS;
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_data_ack(rcp_camera_connection_t * con, const rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error, int64_t fragment_num)
{
    if (con)
    {
        _rcp_send_rftp_data_ack(con, &rcp_rftp_transfer->rftp_uuid, error, fragment_num);
        return RCP_SUCCESS;
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_abor(rcp_camera_connection_t * con, rcp_uuid_t * uuid)
{
    if (con && uuid)
    {
        const rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid->str);
        if (rcp_rftp_transfer)
        {
            _rcp_send_rftp_abor(con, &rcp_rftp_transfer->rftp_uuid);
        }
        else
        {
            /* not for our transfer; ignore */
            _rcp_log_error(con, "ABORT: uuid \"%s\" is not a valid transfer\n", uuid->str);
        }

        return RCP_SUCCESS;
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_dele(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid)
{
    if (con)
    {
        rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_create_transfer_request(con);
        if (!rcp_rftp_transfer)
        {
            return RCP_ERROR_INTERNAL;
        }

        if (_rcp_create_uuid(&rcp_rftp_transfer->rftp_uuid))
        {
            rcp_rftp_transfer->rftp_type = RFTP_TYPE_DELETE;

            _rcp_send_rftp_dele(con, &rcp_rftp_transfer->rftp_uuid, path);

            if (uuid)
            {
                *uuid = rcp_rftp_transfer->rftp_uuid;
            }

            return RCP_SUCCESS;
        }
        else
        {
            rcp_free(rcp_rftp_transfer);
            return RCP_ERROR_INTERNAL;
        }
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_list(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid)
{
    if (con)
    {
        rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_create_transfer_request(con);
        if (!rcp_rftp_transfer)
        {
            return RCP_ERROR_INTERNAL;
        }

        if (_rcp_create_uuid(&rcp_rftp_transfer->rftp_uuid))
        {
            rcp_rftp_transfer->rftp_type = RFTP_TYPE_LIST;

            _rcp_get_rftp_list(con, &rcp_rftp_transfer->rftp_uuid, path);

            if (uuid)
            {
                *uuid = rcp_rftp_transfer->rftp_uuid;
            }

            return RCP_SUCCESS;
        }
        else
        {
            rcp_free(rcp_rftp_transfer);
            return RCP_ERROR_INTERNAL;
        }
    }
    else
    {
        return RCP_ERROR_INTERNAL;
    }
}
#endif

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_error_t _rcp_rftp_retrieve_file(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, int is_tethered, rcp_uuid_t * uuid)
{
    if (con)
    {
        if (rcp_rftp_is_supported(con) && (!is_tethered || rcp_rftp_tethered_is_supported(con)))
        {
            rcp_error_t err = RCP_SUCCESS;
            rcp_mutex_lock(RCP_MUTEX_CONNECTION);
            err = _rcp_rftp_retr(con, path, max_file_size, compression_allowed, is_tethered, uuid);
            rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
            return err;
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }

    return RCP_ERROR_BAD_PARAM;
}
#endif

RCP_API_PRIVATE void _rcp_rftp_handle_store(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        /* RFTPSTOR CURRENT Message:
         * #$SOURCE:C:RFTPSTOR:[BASE_64_ENCODED_UUID]:[rftp_error_t]:[MAX_FRAGMENT_SIZE]: */
        if (packet->argc == 3)
        {
            const char * const uuid = packet->argv[0];
            const rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);
            int64_t max_fragment_size_base64 = atoll(packet->argv[2]);

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                if (rcp_rftp_transfer->rftp_state == RCP_RFTP_STATE_STOR_INIT_WAIT_FOR_ACK)
                {
                    if (rftp_error == RFTP_SUCCESS)
                    {
                        const int64_t max_size = _rftp_get_max_fragment_size(con);

                        if (rcp_rftp_transfer->rftp_max_fragment_size > 0 && rcp_rftp_transfer->rftp_max_fragment_size < max_fragment_size_base64)
                        {
                            max_fragment_size_base64 = rcp_rftp_transfer->rftp_max_fragment_size;
                        }

                        if (max_fragment_size_base64 > max_size)
                        {
                            max_fragment_size_base64 = max_size;
                        }

                        rcp_rftp_transfer->rftp_max_fragment_size = (max_fragment_size_base64 / 4) * 3; /* convert from base64 size */
                        rcp_rftp_transfer->rftp_num_fragments = ((rcp_rftp_transfer->rftp_data_size) + rcp_rftp_transfer->rftp_max_fragment_size - 1) / rcp_rftp_transfer->rftp_max_fragment_size;

                        rcp_rftp_transfer->rftp_start_timestamp = rcp_timestamp();

                        while (_rcp_rftp_send_data_fragment(con, rcp_rftp_transfer))
                            ;
                    }
                    else
                    {
                        _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                    }
                }
                else
                {
                    _rcp_log_error(con, "STORE: invalid state\n");
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "STORE: uuid \"%s\" is not a valid transfer\n", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
}

RCP_API_PRIVATE void _rcp_rftp_handle_retrieve(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && packet)
    {
        /* RFTPRETR CURRENT Message:
         * #$SOURCE:C:RFTPRETR:[BASE_64_ENCODED_UUID]:[rftp_error_t]:[UNCOMPRESSED_FILE_SIZE]:[COMPRESSED_FILE_SIZE]:[FILE_IS_COMPRESSED]:[MD5SUM]: */
        if (packet->argc >= 5)
        {
            const char * const uuid = packet->argv[0];
            rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                if (rcp_rftp_transfer->rftp_state == RCP_RFTP_STATE_RETR_INIT_WAIT_FOR_ACK)
                {
                    if (rftp_error == RFTP_SUCCESS)
                    {
                        const int64_t uncompressed_file_size = atoll(packet->argv[2]);
                        const int64_t compressed_file_size = atoll(packet->argv[3]);
                        const int file_is_compressed = atoi(packet->argv[4]);
                        const int64_t file_size = (file_is_compressed ? compressed_file_size : uncompressed_file_size);

                        if (rcp_rftp_transfer->rftp_max_file_size != 0 && file_size > rcp_rftp_transfer->rftp_max_file_size)
                        {
                            rftp_error = RFTP_ERROR_NOT_ENOUGH_SPACE;
                            rcp_rftp_transfer->rftp_max_file_size = 0;
                            _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                        }
                        else
                        {
                            rcp_rftp_transfer->rftp_data = (rcp_rftp_transfer->rftp_is_tethered ? NULL : RCP_MALLOC(uint8_t *, file_size));

                            if (rcp_rftp_transfer->rftp_data || rcp_rftp_transfer->rftp_is_tethered)
                            {
                                rcp_rftp_transfer->rftp_state = RCP_RFTP_STATE_RETR_ACK_WAIT_FOR_DATA;
                                rcp_rftp_transfer->rftp_data_size = file_size;
                                rcp_rftp_transfer->rftp_data_cur = rcp_rftp_transfer->rftp_data;
                                rcp_rftp_transfer->rftp_data_is_compressed = file_is_compressed;
                                rcp_rftp_transfer->rftp_start_timestamp = rcp_timestamp();
                                rcp_rftp_transfer->rftp_bytes_read = 0;

                                if (packet->argc >= 6)
                                {
                                    snprintf(rcp_rftp_transfer->rftp_md5sum, sizeof(rcp_rftp_transfer->rftp_md5sum), "%s", packet->argv[5]);
                                }
                                else
                                {
                                    memset(rcp_rftp_transfer->rftp_md5sum, 0, sizeof(rcp_rftp_transfer->rftp_md5sum));
                                }
                            }
                            else
                            {
                                rftp_error = RFTP_ERROR_INTERNAL;
                                rcp_rftp_transfer->rftp_max_file_size = 0;
                                _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                            }
                        }

                        if (_rcp_rftp_retr_ack(con, rcp_rftp_transfer, rftp_error) != RCP_SUCCESS)
                        {
                            _rcp_log_error(con, "unable to send retrieve ack\n");
                        }
                    }
                    else
                    {
                        _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                    }
                }
                else
                {
                    _rcp_log_error(con, "RETRIEVE: invalid state\n");
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "RETRIEVE: uuid \"%s\" is not a valid transfer\n", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
#endif
}

RCP_API_PRIVATE void _rcp_rftp_handle_list(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && packet)
    {
        /* RFTPLIST CURRENT Message:
         * #$SOURCE:C:RFTPLIST:[BASE_64_ENCODED_UUID]:[rftp_error_t]:[DIRECTORY_LISTING_CLIST]: */
        if (packet->argc == 3)
        {
            const char * const uuid = packet->argv[0];
            const rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                if (rftp_error != RFTP_SUCCESS)
                {
                    _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                }
                else
                {
                    if (con->rftp_status_cb)
                    {
                        rcp_cur_rftp_status_cb_data_t data = {0};

                        data.con = con;
                        data.uuid = rcp_rftp_transfer->rftp_uuid;
                        data.error = rftp_error;
                        data.rftp_type = rcp_rftp_transfer->rftp_type;
                        data.data = NULL;
                        data.data_size = 0;
                        data.is_compressed = 0;
                        data.percent_complete = 0;
                        data.directory_list_string = packet->argv[2];
                        data.is_paused = 0;

                        con->rftp_status_cb(&data, con->rftp_status_cb_user_data);
                    }

                    _rcp_rftp_free_transfer(con, rcp_rftp_transfer);
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "LIST: uuid \"%s\" is not a valid transfer\n", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
#endif
}

RCP_API_PRIVATE void _rcp_rftp_handle_data(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && packet)
    {
        if (*(packet->pCmd) == RCP2_CMD_SET) /* Retrieve */
        {
            /* RFTPDATA SET Message:
             * #$SOURCE:S:RFTPDATA:[BASE_64_ENCODED_UUID]:[FRAGMENT_NUMBER]:[BASE_64_ENCODED_DATA]: */
            if (packet->argc == 3)
            {
                const char * const uuid = packet->argv[0];
                const int64_t fragment_num = atoll(packet->argv[1]);
                const char * const data = packet->argv[2];

                rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);
                if (rcp_rftp_transfer)
                {
                    if (rcp_rftp_transfer->rftp_state == RCP_RFTP_STATE_RETR_ACK_WAIT_FOR_DATA)
                    {
                        const size_t buf_size = ((strlen(data) / 4) * 3) * sizeof(unsigned char);
                        const size_t length = base64_decode(data, rcp_rftp_transfer->rftp_data_cur, buf_size);
                        rftp_error_t rftp_error = RFTP_SUCCESS;

                        if (length == (size_t) -1)
                        {
                            rftp_error = RFTP_ERROR_INTERNAL;
                            _rcp_log_error(con, "an error occurred base64 decoding \"%s\"\n", data);
                            _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                        }
                        else
                        {
                            rcp_rftp_transfer->rftp_data_cur += length;
                            rcp_rftp_transfer->rftp_bytes_read += length;

                            if (rcp_rftp_transfer->rftp_bytes_read == rcp_rftp_transfer->rftp_data_size)
                            {
                                rftp_error = RFTP_TRANSFER_COMPLETE;
                            }

                            if (_rcp_rftp_data_ack(con, rcp_rftp_transfer, rftp_error, fragment_num) != RCP_SUCCESS)
                            {
                                _rcp_log_error(con, "an error occurred acking fragment %" PRId64 "\n", fragment_num);
                            }

                            _rcp_rftp_update_status(con, rcp_rftp_transfer);
                        }
                    }
                    else
                    {
                        _rcp_log_error(con, "DATA: invalid state\n");
                    }
                }
                else
                {
                    /* not for our transfer; ignore */
                    _rcp_log_error(con, "DATA SET: uuid \"%s\" is not a valid transfer\n", uuid);
                }
            }
            else
            {
                _rcp_log_error(con, "incorrect number of arguments\n");
            }
        }
        else if (*(packet->pCmd) == RCP2_CMD_CURRENT) /* Store or Tethered Retrieve */
        {
            /* RFTPDATA CURRENT Message:
             * #$SOURCE:C:RFTPDATA:[BASE_64_ENCODED_UUID]:[rftp_error_t]:[FRAGMENT_NUMBER]: */
            if (packet->argc == 3)
            {
                const char * const uuid = packet->argv[0];
                const rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);
                const int64_t acked_fragment = atoll(packet->argv[2]);

                rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

                if (rcp_rftp_transfer)
                {
                    if (rcp_rftp_transfer->rftp_state == RCP_RFTP_STATE_STOR_SEND_DATA_WAIT_FOR_ACK)
                    {
                        if (rftp_error == RFTP_SUCCESS || rftp_error == RFTP_TRANSFER_COMPLETE)
                        {
                            rcp_rftp_transfer->rftp_last_ack = acked_fragment;

                            if (rcp_rftp_transfer->rftp_last_ack == rcp_rftp_transfer->rftp_num_fragments - 1)
                            {
                                /* transfer is complete! */
                            }
                            else
                            {
                                while (_rcp_rftp_send_data_fragment(con, rcp_rftp_transfer))
                                    ;
                            }

                            _rcp_rftp_update_status(con, rcp_rftp_transfer);
                        }
                        else
                        {
                            _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                        }
                    }
                    else if (rcp_rftp_transfer->rftp_state == RCP_RFTP_STATE_RETR_ACK_WAIT_FOR_DATA && rcp_rftp_transfer->rftp_is_tethered)
                    {
                        if (rftp_error == RFTP_TRANSFER_COMPLETE || rftp_error == RFTP_SUCCESS)
                        {
                            rcp_rftp_transfer->rftp_tethering_is_complete = (rftp_error == RFTP_TRANSFER_COMPLETE) ? 1 : 0;
                            _rcp_rftp_update_status(con, rcp_rftp_transfer);
                        }
                        else
                        {
                            /* RFTP_SUCCESS is still considered an error status in this case. Error statuses or RFTP_TRANSFER_COMPLETE are the only valid statuses for a tethered transfer. */
                            _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                        }
                    }
                    else
                    {
                        _rcp_log_error(con, "DATA: invalid state\n");
                    }
                }
                else
                {
                    /* not for our transfer; ignore */
                    _rcp_log_debug(con, "DATA CURRENT: uuid \"%s\" is not a valid transfer\n", uuid);
                }
            }
            else
            {
                _rcp_log_error(con, "incorrect number of arguments\n");
            }
        }
    }
#endif
}

RCP_API_PRIVATE void _rcp_rftp_handle_abort(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        /* RFTPABOR CURRENT Message:
         * #$SOURCE:C:RFTPABOR:[BASE_64_ENCODED_UUID]:[rftp_error_t]: */
        if (packet->argc == 2)
        {
            const char * const uuid = packet->argv[0];
            const rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);
            const int success = (rftp_error == RFTP_SUCCESS) ? 1 : 0;

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                if (rcp_rftp_transfer->rftp_type == RFTP_TYPE_STORE)
                {
                    rcp_rftp_transfer->rftp_type = RFTP_TYPE_ABORT_STORE;
                }
                else if (rcp_rftp_transfer->rftp_type == RFTP_TYPE_RETRIEVE)
                {
                    rcp_rftp_transfer->rftp_type = RFTP_TYPE_ABORT_RETRIEVE;

                    if (success)
                    {
                        rcp_rftp_transfer->rftp_tethering_is_complete = 1;
                    }
                }

                if (success)
                {
                    _rcp_rftp_cleanup(con, rcp_rftp_transfer);
                }
                else
                {
                    _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "ABORT: uuid \"%s\" is not a valid transfer\n", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
}

RCP_API_PRIVATE void _rcp_rftp_handle_delete(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && packet)
    {
        /* RFTPDELE CURRENT Message:
         * #$SOURCE:C:RFTPDELE:[BASE_64_ENCODED_UUID]:[rftp_error_t]: */
        if (packet->argc == 2)
        {
            const char * const uuid = packet->argv[0];
            const rftp_error_t rftp_error = (rftp_error_t) atoi(packet->argv[1]);

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                if (rftp_error != RFTP_SUCCESS)
                {
                    _rcp_rftp_error(con, rcp_rftp_transfer, rftp_error);
                }
                else
                {
                    if (con->rftp_status_cb)
                    {
                        rcp_cur_rftp_status_cb_data_t data = {0};

                        data.con = con;
                        data.uuid = rcp_rftp_transfer->rftp_uuid;
                        data.error = rftp_error;
                        data.rftp_type = rcp_rftp_transfer->rftp_type;
                        data.data = NULL;
                        data.data_size = 0;
                        data.is_compressed = 0;
                        data.percent_complete = 0;
                        data.directory_list_string = NULL;
                        data.is_paused = rcp_rftp_transfer->is_paused;

                        con->rftp_status_cb(&data, con->rftp_status_cb_user_data);
                    }

                    _rcp_rftp_free_transfer(con, rcp_rftp_transfer);
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "DELETE: uuid \"%s\" is not valid a transfer\n", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
#endif
}

RCP_API_PRIVATE void _rcp_rftp_handle_pause(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && packet)
    {
        /* RFTPPAUS CURRENT Message:
        * #$SOURCE:C:RFTPPAUS:[BASE_64_ENCODED_UUID]:[IS_PAUSED]: */
        if (packet->argc == 2)
        {
            const char * const uuid = packet->argv[0];
            const int is_paused = atoi(packet->argv[1]);

            rcp_rftp_transfer_t * const rcp_rftp_transfer = _rcp_rftp_get_transfer_request(con, uuid);

            if (rcp_rftp_transfer)
            {
                rcp_rftp_transfer->is_paused = is_paused;

                if (con->rftp_status_cb)
                {
                    rcp_cur_rftp_status_cb_data_t data = {0};

                    data.con = con;
                    data.uuid = rcp_rftp_transfer->rftp_uuid;
                    data.error = RFTP_SUCCESS;
                    data.rftp_type = rcp_rftp_transfer->rftp_type;
                    data.data = NULL;
                    data.data_size = 0;
                    data.is_compressed = 0;
                    data.percent_complete = 0;
                    data.directory_list_string = NULL;
                    data.md5sum = NULL;
                    data.is_paused = rcp_rftp_transfer->is_paused = is_paused;

                    con->rftp_status_cb(&data, con->rftp_status_cb_user_data);
                }
            }
            else
            {
                /* not for our transfer; ignore */
                _rcp_log_error(con, "%s: uuid \"%s\" is not valid a transfer\n", is_paused ? "PAUSE" : "RESUME", uuid);
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect number of arguments\n");
        }
    }
#endif
}

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_rftp_free_data(const rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer)
{
    if (con && rcp_rftp_transfer)
    {
        if (rcp_rftp_transfer->rftp_data && (rcp_rftp_transfer->rftp_type == RFTP_TYPE_RETRIEVE || rcp_rftp_transfer->rftp_type == RFTP_TYPE_ABORT_RETRIEVE))
        {
            rcp_free(rcp_rftp_transfer->rftp_data);
        }

        rcp_rftp_transfer->rftp_data = NULL;
        rcp_rftp_transfer->rftp_data_cur = NULL;
    }
}
#endif

static void _rcp_rftp_free_transfer(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (!con || !rcp_rftp_transfer)
    {
        return;
    }
    else
    {
        _rcp_rftp_free_data(con, rcp_rftp_transfer);

#if 0
        _rcp_log_debug(con, "freeing transfer %s\n", rcp_rftp_transfer->rftp_uuid.str);
#endif

        if (con->rftp_transfer)
        {
            if (con->rftp_transfer == rcp_rftp_transfer)
            {
                /* remove head of linked list */
                con->rftp_transfer = rcp_rftp_transfer->next;
                rcp_free(rcp_rftp_transfer);
            }
            else
            {
                /* find transfer in linked list and remove it */
                rcp_rftp_transfer_t * rcp_rftp_transfer_last = con->rftp_transfer;
                rcp_rftp_transfer_t * rcp_rftp_transfer_cur = con->rftp_transfer->next;
                while (rcp_rftp_transfer_cur)
                {
                    if (rcp_rftp_transfer_cur == rcp_rftp_transfer)
                    {
                        rcp_rftp_transfer_last->next = rcp_rftp_transfer_cur->next;
                        rcp_free(rcp_rftp_transfer);
                        break;
                    }

                    rcp_rftp_transfer_last = rcp_rftp_transfer_cur;
                    rcp_rftp_transfer_cur = rcp_rftp_transfer_cur->next;
                }
            }
        }
    }
#endif
}

RCP_API_PRIVATE void _rcp_rftp_free_all_data(rcp_camera_connection_t * con)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con)
    {
        rcp_rftp_transfer_t * rcp_rftp_transfer = con->rftp_transfer;
        while (rcp_rftp_transfer)
        {
            rcp_rftp_transfer_t * const last = rcp_rftp_transfer;
            _rcp_rftp_free_data(con, rcp_rftp_transfer);
            rcp_rftp_transfer = rcp_rftp_transfer->next;
            rcp_free(last);
        }

        con->rftp_transfer = NULL;
    }
#endif
}

static rftp_error_t _rcp_rftp_send_data_fragment_packet(rcp_camera_connection_t * con, const rcp_uuid_t * uuid, int64_t fragment_num, const uint8_t * data, int64_t fragment_size)
{
    /* RFTPDATA SET Message:
     * #$SOURCE:S:RFTPDATA:[BASE_64_ENCODED_UUID]:[FRAGMENT_NUMBER]:[BASE_64_ENCODED_DATA]: */

    if (con && uuid && data)
    {
        char fragment_num_str[RCP_STR_LEN_FOR_INT64];
        char * data_base64;
        const int64_t data_base64_len = (((fragment_size + 2) / 3) * 4) + 1;

        data_base64 = RCP_MALLOC(char *, data_base64_len);
        if (!data_base64)
        {
            _rcp_log_error(con, "cannot allocate memory for base64 data\n");
            return RFTP_ERROR_INTERNAL;
        }

        if (!base64_encode(data, fragment_size, data_base64, data_base64_len))
        {
            _rcp_log_error(con, "cannot base64 encode data\n");
            return RFTP_ERROR_INTERNAL;
        }

        snprintf(fragment_num_str, sizeof(fragment_num_str), "%" PRId64, fragment_num);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_RFTPDATA_MSG_RFTP_DATA, 3, uuid->str, fragment_num_str, data_base64))
        {
            _rcp_log_error(con, "cannot create rftp data fragment packet\n");
        }

        rcp_free(data_base64);
    }

    return RFTP_SUCCESS;
}

static int _rcp_rftp_send_data_fragment(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer)
{
    if (con)
    {
        if (
            (rcp_rftp_transfer->rftp_cur_fragment < rcp_rftp_transfer->rftp_num_fragments) &&
            (rcp_rftp_transfer->rftp_cur_fragment <= rcp_rftp_transfer->rftp_last_ack + RFTP_WINDOW_SIZE)
           )
        {
            int64_t data_len_to_send = rcp_rftp_transfer->rftp_data_size - (rcp_rftp_transfer->rftp_cur_fragment * rcp_rftp_transfer->rftp_max_fragment_size);
            if (data_len_to_send > rcp_rftp_transfer->rftp_max_fragment_size)
            {
                data_len_to_send = rcp_rftp_transfer->rftp_max_fragment_size;
            }

            if (RFTP_SUCCESS == _rcp_rftp_send_data_fragment_packet(con, &rcp_rftp_transfer->rftp_uuid, rcp_rftp_transfer->rftp_cur_fragment, rcp_rftp_transfer->rftp_data_cur, data_len_to_send))
            {
                rcp_rftp_transfer->rftp_state = RCP_RFTP_STATE_STOR_SEND_DATA_WAIT_FOR_ACK;
                rcp_rftp_transfer->rftp_data_cur += data_len_to_send;
                rcp_rftp_transfer->rftp_cur_fragment++;
            }
            else
            {
                _rcp_rftp_error(con, rcp_rftp_transfer, RFTP_ERROR_INTERNAL);
            }

            return 1;
        }
    }

    return 0;
}

rcp_error_t rcp_rftp_send_file(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, rcp_uuid_t * uuid)
{
    return rcp_rftp_send_file_v2(con, path, data, uncompressed_len, compressed_len, file_is_compressed, 0, uuid);
}

rcp_error_t rcp_rftp_send_file_v2(rcp_camera_connection_t * con, const char * path, uint8_t * data, int64_t uncompressed_len, int64_t compressed_len, int file_is_compressed, int fragment_size, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con)
    {
        if (rcp_rftp_is_supported(con))
        {
            rcp_error_t err = RCP_SUCCESS;
            rcp_mutex_lock(RCP_MUTEX_CONNECTION);
            err = _rcp_rftp_stor(con, path, data, uncompressed_len, compressed_len, file_is_compressed, fragment_size, uuid);
            rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
            return err;
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_rftp_retrieve_file(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    return _rcp_rftp_retrieve_file(con, path, max_file_size, compression_allowed, 0, uuid);
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_rftp_retrieve_file_tethered(rcp_camera_connection_t * con, const char * path, int64_t max_file_size, int compression_allowed, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    return _rcp_rftp_retrieve_file(con, path, max_file_size, compression_allowed, 1, uuid);
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_rftp_abort_transfer(rcp_camera_connection_t * con, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con && uuid)
    {
        if (rcp_rftp_is_supported(con))
        {
            rcp_error_t err = RCP_SUCCESS;
            rcp_mutex_lock(RCP_MUTEX_CONNECTION);
            err = _rcp_rftp_abor(con, uuid);
            rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
            return err;
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_rftp_delete_file(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con)
    {
        if (rcp_rftp_is_supported(con))
        {
            rcp_error_t err = RCP_SUCCESS;
            rcp_mutex_lock(RCP_MUTEX_CONNECTION);
            err = _rcp_rftp_dele(con, path, uuid);
            rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
            return err;
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
#else
    return RCP_SUCCESS;
#endif
}

rcp_error_t rcp_rftp_directory_listing(rcp_camera_connection_t * con, const char * path, rcp_uuid_t * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (con)
    {
        if (rcp_rftp_is_supported(con))
        {
            rcp_error_t err = RCP_SUCCESS;
            rcp_mutex_lock(RCP_MUTEX_CONNECTION);
            err = _rcp_rftp_list(con, path, uuid);
            rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
            return err;
        }
        else
        {
            return RCP_ERROR_NOT_SUPPORTED;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
#else
    return RCP_SUCCESS;
#endif
}

static void _rcp_rftp_error(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer, rftp_error_t error)
{
    if (con)
    {
        switch (error)
        {
            case RFTP_ERROR_FILE_NOT_FOUND:
                _rcp_log_error(con, "File not found.\n");
                break;

            case RFTP_ERROR_FILE_EXISTS:
                _rcp_log_error(con, "File already exists.\n");
                break;

            case RFTP_ERROR_NO_READ_PERMISSION:
                _rcp_log_error(con, "File does not have read permission.\n");
                break;

            case RFTP_ERROR_NO_WRITE_PERMISSION:
                _rcp_log_error(con, "%s does not have write permission.\n", (rcp_rftp_transfer->rftp_type == RFTP_TYPE_STORE) ? "Directory" : "File");
                break;

            case RFTP_ERROR_INVALID_PATH:
                _rcp_log_error(con, "Invalid file path specified.\n");
                break;

            case RFTP_ERROR_NOT_ENOUGH_SPACE:
                _rcp_log_error(con, "Not enough space.\n");
                break;

            case RFTP_ERROR_UNABLE_TO_CREATE_FILE:
                _rcp_log_error(con, "Unable to create file.\n");
                break;

            case RFTP_ERROR_INTERNAL:
                _rcp_log_error(con, "An error occurred.\n");
                break;

            default:
                break;
        }

        if (con->rftp_status_cb)
        {
            rcp_cur_rftp_status_cb_data_t data = {0};

            data.con = con;
            data.uuid = rcp_rftp_transfer->rftp_uuid;
            data.error = error;
            data.rftp_type = rcp_rftp_transfer->rftp_type;
            data.percent_complete = 0;
            data.directory_list_string = NULL;
            data.is_compressed = rcp_rftp_transfer->rftp_data_is_compressed;
            data.is_paused = rcp_rftp_transfer->is_paused;

            if (data.rftp_type == RFTP_TYPE_STORE || data.rftp_type == RFTP_TYPE_ABORT_STORE)
            {
                /* for store transfers, the application is responsible for freeing data */
                data.data = rcp_rftp_transfer->rftp_data;
                data.data_size = rcp_rftp_transfer->rftp_data_size;
            }

            con->rftp_status_cb(&data, con->rftp_status_cb_user_data);
        }

        _rcp_rftp_free_transfer(con, rcp_rftp_transfer);
    }
}

static void _rcp_rftp_cleanup(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer)
{
    _rcp_rftp_error(con, rcp_rftp_transfer, RFTP_SUCCESS);
}

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static void _rcp_rftp_update_status(rcp_camera_connection_t * con, rcp_rftp_transfer_t * rcp_rftp_transfer)
{
    if (con)
    {
        int32_t percent_complete = 0;
        int issue_callback = 0;

        if (rcp_rftp_transfer->rftp_type == RFTP_TYPE_STORE)
        {
            if (rcp_rftp_transfer->rftp_last_ack > -1)
            {
                if (rcp_rftp_transfer->rftp_num_fragments == 1)
                {
                    percent_complete = 100;
                }
                else
                {
                    percent_complete = (int32_t) ((100 * rcp_rftp_transfer->rftp_last_ack) / (rcp_rftp_transfer->rftp_num_fragments - 1));

                    /* don't send 100% complete until we are actually
                     * 100% complete. */
                    if (
                        (percent_complete == 100) &&
                        (rcp_rftp_transfer->rftp_last_ack != rcp_rftp_transfer->rftp_num_fragments - 1)
                       )
                    {
                        percent_complete = 99;
                    }
                }

                if (rcp_rftp_transfer->rftp_last_percent_sent != percent_complete)
                {
                    rcp_rftp_transfer->rftp_last_percent_sent = percent_complete;
                    issue_callback = 1;
                }
            }
        }
        else if (rcp_rftp_transfer->rftp_type == RFTP_TYPE_RETRIEVE)
        {
            if (rcp_rftp_transfer->rftp_is_tethered)
            {
                /* For a tethered retrieve, _rcp_rftp_update_status is only called once the transfer is initiated and once the transfer is complete */
                percent_complete = (rcp_rftp_transfer->rftp_tethering_is_complete ? 100 : 0);
                issue_callback = 1;
            }
            else if (rcp_rftp_transfer->rftp_bytes_read < rcp_rftp_transfer->rftp_data_size)
            {
                percent_complete = (int32_t) ((100 * rcp_rftp_transfer->rftp_bytes_read) / rcp_rftp_transfer->rftp_data_size);

                /* don't send 100% complete until we are actually
                 * 100% complete. */
                if (percent_complete == 100)
                {
                    percent_complete = 99;
                }
            }
            else if (rcp_rftp_transfer->rftp_bytes_read == rcp_rftp_transfer->rftp_data_size)
            {
                percent_complete = 100;
            }

            if (rcp_rftp_transfer->rftp_last_percent_sent != percent_complete)
            {
                rcp_rftp_transfer->rftp_last_percent_sent = percent_complete;
                issue_callback = 1;
            }
        }

        if (issue_callback && con->rftp_status_cb)
        {
            rcp_cur_rftp_status_cb_data_t data = {0};

            data.con = con;
            data.uuid = rcp_rftp_transfer->rftp_uuid;
            data.error = (percent_complete == 100) ? RFTP_TRANSFER_COMPLETE : RFTP_SUCCESS;
            data.rftp_type = rcp_rftp_transfer->rftp_type;
            data.percent_complete = percent_complete;
            data.directory_list_string = NULL;
            data.is_compressed = rcp_rftp_transfer->rftp_data_is_compressed;
            data.md5sum = rcp_rftp_transfer->rftp_md5sum;
            data.is_paused = rcp_rftp_transfer->is_paused;

            if (
                (rcp_rftp_transfer->rftp_type == RFTP_TYPE_STORE) ||
                (rcp_rftp_transfer->rftp_type == RFTP_TYPE_RETRIEVE && data.error == RFTP_TRANSFER_COMPLETE)
               )
            {
                data.data = rcp_rftp_transfer->rftp_data;
                data.data_size = rcp_rftp_transfer->rftp_data_size;
            }

            con->rftp_status_cb(&data, con->rftp_status_cb_user_data);
        }

        if (percent_complete == 100)
        {
            const uint32_t cur_timestamp = rcp_timestamp();
            uint32_t time_elapsed = cur_timestamp - rcp_rftp_transfer->rftp_start_timestamp;

            if (time_elapsed == 0)
            {
                time_elapsed = 1;
            }

            _rcp_log_debug(con, "bytes %s: %" PRId64 ", time: %dms, bytes/s: %" PRId64 "\n", (rcp_rftp_transfer->rftp_type == RFTP_TYPE_STORE) ? "sent" : "received", rcp_rftp_transfer->rftp_data_size, time_elapsed, (int64_t) ((rcp_rftp_transfer->rftp_data_size * 1000.0) / time_elapsed));
            _rcp_rftp_free_transfer(con, rcp_rftp_transfer);
        }
    }
}
#endif

int rcp_rftp_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_RFTP);
}

int rcp_rftp_tethered_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_RFTP_TETHERED);
}

#ifdef RCP_API_ENABLE_FILE_TRANSFER
static rcp_rftp_transfer_t * _rcp_rftp_create_transfer_request(rcp_camera_connection_t * con)
{
    if (!con)
    {
        return NULL;
    }
    else
    {
        rcp_rftp_transfer_t * const rcp_rftp_transfer = RCP_MALLOC(rcp_rftp_transfer_t *, sizeof(rcp_rftp_transfer_t));
        if (!rcp_rftp_transfer)
        {
            return NULL;
        }

        memset(rcp_rftp_transfer, 0, sizeof(rcp_rftp_transfer_t));
        rcp_rftp_transfer->rftp_type = RFTP_TYPE_NONE;
        rcp_rftp_transfer->rftp_state = RCP_RFTP_STATE_IDLE;
        rcp_rftp_transfer->rftp_data_size = 0;
        rcp_rftp_transfer->rftp_data = NULL;
        rcp_rftp_transfer->rftp_data_cur = NULL;
        rcp_rftp_transfer->rftp_data_is_compressed = 0;
        rcp_rftp_transfer->rftp_last_percent_sent = -1;
        rcp_rftp_transfer->rftp_start_timestamp = 0;
        rcp_rftp_transfer->is_paused = 0;
        rcp_rftp_transfer->rftp_last_ack = -1;
        rcp_rftp_transfer->rftp_cur_fragment = 0;
        rcp_rftp_transfer->rftp_max_fragment_size = 0;
        rcp_rftp_transfer->rftp_num_fragments = -1;
        rcp_rftp_transfer->rftp_bytes_read = 0;
        rcp_rftp_transfer->rftp_max_file_size = 0;
        rcp_rftp_transfer->rftp_is_tethered = 0;
        rcp_rftp_transfer->rftp_tethering_is_complete = 0;
        memset(rcp_rftp_transfer->rftp_md5sum, 0, sizeof(rcp_rftp_transfer->rftp_md5sum));

        if (!con->rftp_transfer)
        {
            con->rftp_transfer = rcp_rftp_transfer;
        }
        else
        {
            rcp_rftp_transfer_t * last_rcp_rftp_transfer = con->rftp_transfer;
            while (last_rcp_rftp_transfer->next)
            {
                last_rcp_rftp_transfer = last_rcp_rftp_transfer->next;
            }

            last_rcp_rftp_transfer->next = rcp_rftp_transfer;
        }

        return rcp_rftp_transfer;
    }
}
#endif

static rcp_rftp_transfer_t * _rcp_rftp_get_transfer_request(const rcp_camera_connection_t * con, const char * uuid)
{
#ifdef RCP_API_ENABLE_FILE_TRANSFER
    if (!con)
    {
        return NULL;
    }
    else
    {
        rcp_rftp_transfer_t * rcp_rftp_transfer = con->rftp_transfer;
        while (rcp_rftp_transfer)
        {
            if (strcmp(uuid, rcp_rftp_transfer->rftp_uuid.str) == 0)
            {
                return rcp_rftp_transfer;
            }

            rcp_rftp_transfer = rcp_rftp_transfer->next;
        }

        return NULL;
    }
#else
    return NULL;
#endif
}
/********** End file: rcp_api_rftp.c ********************************************/

/********** Begin file: rcp_api_send.c ******************************************/
/* #include "rcp_api_send.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>

static rcp_error_t _rcp_send(rcp_camera_connection_t * con, rcp_param_t id);

rcp_error_t rcp_send(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "send: %s\n", rcp_get_name(con, id));
    err = _rcp_send(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

static rcp_error_t _rcp_send(rcp_camera_connection_t * con, rcp_param_t id)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        if (!properties.has_send)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }
        else
        {
            const rcp_param_def_t * const def = &_rcp_param_def[id];

            if (def->is_indexed)
            {
                char index_str[RCP_STR_LEN_FOR_INT32];
                snprintf(index_str, sizeof(index_str), "%d", def->index);
                return _rcp_create_and_send_packet(con, RCP2_CMD_SET, def->set_msg, 1, index_str);
            }
            else
            {
                return _rcp_create_and_send_packet(con, RCP2_CMD_SET, def->set_msg, 0);
            }
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}
/********** End file: rcp_api_send.c ********************************************/

/********** Begin file: rcp_api_send_current.c **********************************/
/* #include "rcp_api_send_current.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_set_int.h" */
/* #include "rcp_api_set_list.h" */
/* #include "rcp_api_set_uint.h" */
/* #include "rcp_api_state.h" */
/* #include "rcp_api_utils.h" */

#include <string.h>
#include <stdint.h>
/* #include "decorated_string/decorated_string.h" */
/* #include "clist/c_list.h" */
/* #include "stringl/stringl.h" */

static void _rcp_update_list_val_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val);
static void _rcp_update_list_val_str(rcp_camera_connection_t * con, rcp_param_t id, const char * str);

RCP_API_PRIVATE void _rcp_send_current_int(rcp_camera_connection_t * con, rcp_param_t id, int target_val_updated)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];
        char str[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_abbr[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_abbr_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
        int str_valid = 0;
        rcp_param_status_t display_status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
        rcp_cur_int_cb_data_t data;

        if (state->list_val_valid)
        {
            if (def->set_target_msg && _rcp_version_in_range(con, &def->target_version_range))
            {
                if (target_val_updated)
                {
                    if (state->target_val_valid)
                    {
                        _rcp_update_list_val_int(con, id, state->target_val.int_val);
                    }
                    else
                    {
                        _rcp_log_debug(con, "cannot update list with current value\n");
                    }
                }
            }
            else
            {
                _rcp_update_list_val_int(con, id, state->val.int_val);
            }
        }

        if (def->create_string_fp)
        {
            if (_rcp_check_parameter_dependencies(con, id))
            {
                def->create_string_fp(con, id, str, sizeof(str), str_abbr, sizeof(str_abbr), &display_status);
                decorated_string_decode(str, str_decoded, sizeof(str_decoded));
                decorated_string_decode(str_abbr, str_abbr_decoded, sizeof(str_abbr_decoded));
                str_valid = state->val_valid;
            }
        }
        else
        {
            if (def->create_edit_info_fp)
            {
                def->create_edit_info_fp(con, id);
            }

            if (state->edit_info)
            {
                const rcp_cur_int_edit_info_t * const edit_info = ((rcp_cur_int_edit_info_t *) state->edit_info);
                if (_rcp_version_in_range(con, &edit_info->version_range))
                {
                    decorated_string_create(str, sizeof(str), state->val.int_val, edit_info->divider, edit_info->digits, edit_info->prefix, edit_info->suffix);
                    strlcpy(str_abbr, str, sizeof(str_abbr));
                    decorated_string_decode(str, str_decoded, sizeof(str_decoded));
                    decorated_string_decode(str_abbr, str_abbr_decoded, sizeof(str_abbr_decoded));
                    str_valid = state->val_valid;
                }
            }
        }

        data.con = con;
        data.id = id;
        data.cur_val = state->val.int_val;
        data.cur_val_valid = state->val_valid;
        data.target_val = state->target_val.int_val;
        data.target_val_valid = state->target_val_valid;
        data.display_str = str;
        data.display_str_decoded = str_decoded;
        data.display_str_abbr = str_abbr;
        data.display_str_abbr_decoded = str_abbr_decoded;
        data.display_str_valid = str_valid;
        data.display_str_status = display_status;
        data.display_str_in_list = def->cur_msg && def->cur_list_msg && !def->create_string_fp && !state->edit_info;

        if (def->create_edit_info_fp)
        {
            def->create_edit_info_fp(con, id);
        }

        if (state->edit_info)
        {
            const rcp_cur_int_edit_info_t * const edit_info = (rcp_cur_int_edit_info_t *) state->edit_info;
            if (_rcp_version_in_range(con, &edit_info->version_range))
            {
                data.edit_info_valid = 1;
                data.edit_info = *edit_info;
            }
        }
        else
        {
            data.edit_info_valid = 0;
            memset(&data.edit_info, 0, sizeof(data.edit_info));
        }

        _rcp_cur_int_cb(con, &data);

#ifdef RCP_API_ENABLE_RELATIVE
        if (state->pending_relative_offset_value != 0 || state->expected_retry_count != 0)
        {
            /* wait for two currents with the same value to
             * come in before sending out next relative set. This
             * will reduce the problem of applying relative sets to
             * state currents coming in. */

            if (state->pending_expected_relative_value.int_val != state->val.int_val)
            {
                if (!state->expected_retry_count)
                {
                    state->pending_expected_relative_value.int_val = state->val.int_val;
                    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
                }
                else
                {
                    state->expected_retry_count--;
                }
                state->val_valid = 0;
                state->target_val_valid = 0;
                (void) _rcp_get(con, id);
            }
            else
            {
                state->expected_retry_count = 0;

                if (state->pending_relative_offset_value != 0)
                {
                    if (RCP_SUCCESS != _rcp_set_int_from_relative(con, id, state->val.int_val, state->pending_relative_offset_value))
                    {
                        _rcp_log_error(con, "failed to set relative value for parameter: %s\n", rcp_get_name(con, id));
                    }
                }

                /* clear pending relative value */
                state->pending_relative_offset_value = 0;
            }
        }
#endif
    }
}

RCP_API_PRIVATE void _rcp_send_current_uint(rcp_camera_connection_t * con, rcp_param_t id, int target_val_updated)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];
        char str[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_abbr[RCP_API_DISPLAY_STR_SIZE] = {0};
        char str_abbr_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
        int str_valid = 0;
        rcp_param_status_t display_status = RCP_PARAM_DISPLAY_STATUS_NORMAL;
        rcp_cur_uint_cb_data_t data;

        if (state->list_val_valid)
        {
            if (def->set_target_msg && _rcp_version_in_range(con, &def->target_version_range))
            {
                if (target_val_updated)
                {
                    if (state->target_val_valid)
                    {
                        _rcp_update_list_val_int(con, id, (int32_t) state->target_val.uint_val);
                    }
                    else
                    {
                        _rcp_log_debug(con, "cannot update list with current value\n");
                    }
                }
            }
            else
            {
                _rcp_update_list_val_int(con, id, (int32_t) state->val.uint_val);
            }
        }

        if (def->create_string_fp)
        {
            if (_rcp_check_parameter_dependencies(con, id))
            {
                def->create_string_fp(con, id, str, sizeof(str), str_abbr, sizeof(str_abbr), &display_status);
                decorated_string_decode(str, str_decoded, sizeof(str_decoded));
                decorated_string_decode(str_abbr, str_abbr_decoded, sizeof(str_abbr_decoded));
                str_valid = state->val_valid;
            }
        }
        else
        {
            if (def->create_edit_info_fp)
            {
                def->create_edit_info_fp(con, id);
            }

            if (state->edit_info)
            {
                const rcp_cur_uint_edit_info_t * const edit_info = ((rcp_cur_uint_edit_info_t *) state->edit_info);
                if (_rcp_version_in_range(con, &edit_info->version_range))
                {
                    decorated_string_create(str, sizeof(str), state->val.int_val, edit_info->divider, edit_info->digits, edit_info->prefix, edit_info->suffix);
                    strlcpy(str_abbr, str, sizeof(str_abbr));
                    decorated_string_decode(str, str_decoded, sizeof(str_decoded));
                    decorated_string_decode(str_abbr, str_abbr_decoded, sizeof(str_abbr_decoded));
                    str_valid = state->val_valid;
                }
            }
        }

        data.con = con;
        data.id = id;
        data.cur_val = state->val.uint_val;
        data.cur_val_valid = state->val_valid;
        data.target_val = state->target_val.uint_val;
        data.target_val_valid = state->target_val_valid;
        data.display_str = str;
        data.display_str_decoded = str_decoded;
        data.display_str_abbr = str_abbr;
        data.display_str_abbr_decoded = str_abbr_decoded;
        data.display_str_valid = str_valid;
        data.display_str_status = display_status;
        data.display_str_in_list = def->cur_msg && def->cur_list_msg && !def->create_string_fp && !state->edit_info;

        if (def->create_edit_info_fp)
        {
            def->create_edit_info_fp(con, id);
        }

        if (state->edit_info)
        {
            const rcp_cur_uint_edit_info_t * const edit_info = (rcp_cur_uint_edit_info_t *) state->edit_info;
            if (_rcp_version_in_range(con, &edit_info->version_range))
            {
                data.edit_info_valid = 1;
                data.edit_info = *edit_info;
            }
        }
        else
        {
            data.edit_info_valid = 0;
            memset(&data.edit_info, 0, sizeof(data.edit_info));
        }

        _rcp_cur_uint_cb(con, &data);

#ifdef RCP_API_ENABLE_RELATIVE
        if (state->pending_relative_offset_value != 0 || state->expected_retry_count != 0)
        {
            /* wait for two currents with the same value to
             * come in before sending out next relative set. This
             * will reduce the problem of applying relative sets to
             * state currents coming in. */

            if (state->pending_expected_relative_value.uint_val != state->val.uint_val)
            {
                if (!state->expected_retry_count)
                {
                    state->pending_expected_relative_value.uint_val = state->val.uint_val;
                    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
                }
                else
                {
                    state->expected_retry_count--;
                }
                state->val_valid = 0;
                state->target_val_valid = 0;
                (void) _rcp_get(con, id);
            }
            else
            {
                state->expected_retry_count = 0;

                if (state->pending_relative_offset_value != 0)
                {
                    if (RCP_SUCCESS != _rcp_set_uint_from_relative(con, id, state->val.uint_val, state->pending_relative_offset_value))
                    {
                        _rcp_log_error(con, "failed to set relative value for parameter: %s\n", rcp_get_name(con, id));
                    }
                }

                /* clear pending relative value */
                state->pending_relative_offset_value = 0;
            }
        }
#endif
    }
}

RCP_API_PRIVATE void _rcp_send_current_list(rcp_camera_connection_t * con, rcp_param_t id, rcp_param_t send_as_id)
{
    if (con)
    {
        rcp_param_properties_t properties;
        if (rcp_get_is_supported(con, id, &properties))
        {
            const rcp_param_def_t * const def = &_rcp_param_def[id];
            rcp_param_state_t * const state = &con->param_state[id];
#ifdef RCP_API_ENABLE_RELATIVE
            rcp_param_state_t * const state_send_as = &con->param_state[send_as_id];
#endif

            rcp_cur_list_cb_data_t data;

            if (def->min_param != RCP_MIN_NONE())
            {
                const rcp_param_state_t * const min_state = &con->param_state[def->min_param];

                data.min_val = min_state->val.int_val;
                data.min_val_valid = min_state->val_valid;
            }
            else
            {
                data.min_val = 0;
                data.min_val_valid = 0;
            }

            if (def->max_param != RCP_MAX_NONE())
            {
                const rcp_param_state_t * const max_state = &con->param_state[def->max_param];

                data.max_val = max_state->val.int_val;
                data.max_val_valid = max_state->val_valid;
            }
            else
            {
                data.max_val = 0;
                data.max_val_valid = 0;
            }

            data.con = con;
            data.id = send_as_id;
            data.list_string = state->list_val;
            data.list_string_valid = state->list_val_valid;
            data.display_str_in_list = def->cur_msg && def->cur_list_msg && !def->create_string_fp && !state->edit_info;
            data.send_int = properties.has_set_int;
            data.send_uint = properties.has_set_uint;
            data.send_str = properties.has_set_str;
            data.update_list_only_on_close = properties.update_list_only_on_close;
            _rcp_cur_list_cb(con, &data);

#ifdef RCP_API_ENABLE_RELATIVE
            if (state_send_as->pending_relative_list_offset_value != 0)
            {
                /* wait for two currents with the same value to
                 * come in before sending out next relative set. This
                 * will reduce the problem of applying relative sets to
                 * state currents coming in. */
                c_list_entry_t entry;
                if (RCP_SUCCESS == _rcp_get_current_entry_from_list(con, state->list_val, &entry))
                {
                    if (properties.has_set_int && state_send_as->pending_expected_relative_value.int_val != entry.num)
                    {
                        state_send_as->pending_expected_relative_value.int_val = entry.num;
                        state->val_valid = 0;
                        (void) _rcp_get(con, id);
                    }
                    else if (properties.has_set_uint && state_send_as->pending_expected_relative_value.uint_val != (uint32_t) entry.num)
                    {
                        state_send_as->pending_expected_relative_value.uint_val = (uint32_t) entry.num;
                        state->val_valid = 0;
                        (void) _rcp_get(con, id);
                    }
                    else
                    {
                        if (RCP_SUCCESS != _rcp_set_list_from_relative(con, send_as_id, state->list_val, state_send_as->pending_relative_list_offset_value))
                        {
                            _rcp_log_error(con, "failed to set relative list value for parameter: %s\n", rcp_get_name(con, send_as_id));
                        }

                        /* clear pending relative value */
                        state_send_as->pending_relative_list_offset_value = 0;
                    }
                }
            }
#endif

#ifndef RCP_API_ENABLE_CACHING
            if (state->list_val)
            {
                rcp_free(state->list_val);
                state->list_val = NULL;
                state->list_val_valid = 0;
                state->list_current_val_valid = 0;
            }
#endif
        }
    }
}

RCP_API_PRIVATE void _rcp_send_current_str(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
#ifdef RCP_API_ENABLE_CACHING
        const
#endif
        rcp_param_state_t * const state = &con->param_state[id];

        if (state->list_val_valid)
        {
            _rcp_update_list_val_str(con, id, state->val.str_val);
        }

        if (def->create_string_fp)
        {
            _rcp_send_current_composite_string(con, id);
        }
        else
        {
            rcp_cur_str_cb_data_t data;

            data.con = con;
            data.id = id;
            data.display_str = state->val.str_val;
            data.display_str_decoded = state->val.str_val;
            data.display_str_abbr = state->val.str_val;
            data.display_str_abbr_decoded = state->val.str_val;
            data.display_str_status = RCP_PARAM_DISPLAY_STATUS_NORMAL;

            if (def->create_edit_info_fp)
            {
                def->create_edit_info_fp(con, id);
            }

            if (state->edit_info)
            {
                const rcp_cur_str_edit_info_t * const edit_info = (rcp_cur_str_edit_info_t *) state->edit_info;
                if (_rcp_version_in_range(con, &edit_info->version_range))
                {
                    data.edit_info_valid = 1;
                    data.edit_info = *edit_info;
                }
            }
            else
            {
                data.edit_info_valid = 0;
                memset(&data.edit_info, 0, sizeof(data.edit_info));
            }

            _rcp_cur_str_cb(con, &data);

#ifndef RCP_API_ENABLE_CACHING
            if (state->val.str_val)
            {
                rcp_free(state->val.str_val);
                state->val.str_val = NULL;
            }
#endif
        }
    }
}

RCP_API_PRIVATE void _rcp_send_current_composite_string(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];

        if (def->create_string_fp && con->cur_str_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_str_cb_data_t data;
            char str[RCP_API_DISPLAY_STR_SIZE] = {0};
            char str_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
            char str_abbr[RCP_API_DISPLAY_STR_SIZE] = {0};
            char str_abbr_decoded[RCP_API_DISPLAY_STR_SIZE] = {0};
            rcp_param_status_t display_status = RCP_PARAM_DISPLAY_STATUS_NORMAL;

            if (_rcp_check_parameter_dependencies(con, id))
            {
                def->create_string_fp(con, id, str, sizeof(str), str_abbr, sizeof(str_abbr), &display_status);
                decorated_string_decode(str, str_decoded, sizeof(str_decoded));
                decorated_string_decode(str_abbr, str_abbr_decoded, sizeof(str_abbr_decoded));

                data.con = con;
                data.id = id;
                data.display_str = str;
                data.display_str_decoded = str_decoded;
                data.display_str_abbr = str_abbr;
                data.display_str_abbr_decoded = str_abbr_decoded;
                data.display_str_status = display_status;
                data.edit_info_valid = 0;
                memset(&data.edit_info, 0, sizeof(data.edit_info));
                con->cur_str_cb(&data, con->cur_str_cb_user_data);
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_send_current_status(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        if (con->cur_status_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_status_cb_data_t data;
            const rcp_param_state_t * const state = &con->param_state[id];
            const rcp_param_def_t * const def = &_rcp_param_def[id];
            const rcp_param_state_t * const record_state = &con->param_state[RCP_PARAM_RECORD_STATE_BASE];
            const rcp_param_state_t * const test_pattern = &con->param_state[RCP_PARAM_TEST_PATTERN];
            const rcp_param_state_t * const magnify_state = &con->param_state[RCP_PARAM_MAGNIFY_STATE];
            const rcp_param_state_t * const playback_state = &con->param_state[RCP_PARAM_PLAYBACK_STATE];
            const rcp_param_state_t * const playback_file_format_state = &con->param_state[RCP_PARAM_PLAYBACK_FILE_FORMAT_TYPE];
            const rcp_param_state_t * const raw_mode_state = &con->param_state[RCP_PARAM_RAW_MODE];
            const rcp_param_state_t * const video_source_state = &con->param_state[RCP_PARAM_VIDEO_SOURCE];
            const rcp_param_state_t * const output_transform_state = &con->param_state[RCP_PARAM_OUTPUT_TRANSFORM];

            data.con = con;
            data.id = id;
            data.is_enabled = state->is_enabled;
            data.is_enabled_valid = state->is_enabled_valid;
            data.is_supported = rcp_get_is_supported(con, id, NULL);
            data.is_supported_valid = 1;

            if (data.is_enabled_valid == 0)
            {
                data.is_enabled = 1;
                data.is_enabled_valid = 1;
            }

            if (data.is_supported_valid && !data.is_supported)
            {
                /* If the parameter is not supported; we will mark it
                 * as disabled to simplify any client logic required. */
                data.is_enabled = 0;
            }

            if (record_state->val_valid)
            {
                if (!def->enabled_in_record && record_state->val.int_val != RECORD_STATE_NOT_RECORDING)
                {
                    data.is_enabled = 0;
                }
            }

            if (test_pattern->val_valid)
            {
                if (!def->enabled_in_test_pattern && test_pattern->val.int_val != MONITOR_TEST_PATTERN_NONE)
                {
                    data.is_enabled = 0;
                }
            }

            if (magnify_state->val_valid)
            {
                if (!def->enabled_in_magnify && magnify_state->val.int_val == MAGNIFY_MODE_ON)
                {
                    data.is_enabled = 0;
                }
            }

            if (playback_state->val_valid)
            {
                if (
                    !def->enabled_in_raw_playback &&
                    playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK &&
                    playback_file_format_state->val.int_val == FILE_FORMAT_TYPE_RAW
                   )
                {
                    data.is_enabled = 0;
                }

                if (
                    !def->enabled_in_baked_playback &&
                    playback_state->val.int_val == PLAYBACK_STATE_IN_PLAYBACK &&
                    playback_file_format_state->val.int_val == FILE_FORMAT_TYPE_BAKED
                   )
                {
                    data.is_enabled = 0;
                }

                if (
                    !def->enabled_in_preview &&
                    playback_state->val.int_val == PLAYBACK_STATE_NOT_IN_PLAYBACK
                   )
                {
                    data.is_enabled = 0;
                }
            }

            if (raw_mode_state->val_valid)
            {
                if (!def->enabled_in_raw && raw_mode_state->val.int_val == RAW_MODE_ON)
                {
                    data.is_enabled = 0;
                }
            }

            if (video_source_state->val_valid)
            {
                if (!def->enabled_in_aces && video_source_state->val.int_val == VIDEO_SOURCE_ACES)
                {
                    data.is_enabled = 0;
                }
            }

            if (output_transform_state->val_valid)
            {
                if (!def->enabled_in_aces && output_transform_state->val.int_val == OUTPUT_TRANSFORM_ACES_AP1)
                {
                    data.is_enabled = 0;
                }
            }

            con->cur_status_cb(&data, con->cur_status_cb_user_data);
        }
    }
}

static void _rcp_update_list_val_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val)
{
    if (con)
    {
        rcp_param_state_t * const state = &con->param_state[id];

        if (state)
        {
            c_list_t * c_list;

            /* If we've already updated the list with this value, don't
             * do it again. */
            if (state->list_current_val_valid && state->list_current_val == val)
            {
                /* If get_list_pending is set we should clear it and send out
                 * the list - even though the value didn't change. */
                if (state->get_list_pending)
                {
                    state->get_list_pending = 0;
                    _rcp_send_current_list(con, id, id);
                }
                return;
            }

            c_list = c_list_create(rcp_malloc, rcp_free);

            state->list_val_valid = 0;
            state->list_current_val_valid = 0;
            if (c_list)
            {
                c_list_entry_t entry;
                if (C_LIST_SUCCESS == c_list_import_from_string(c_list, state->list_val))
                {
                    if (0 == c_list_get_length(c_list))
                    {
                        /* the list is an empty list, nothing to do. */
                        state->list_val_valid = 1;
                    }
                    else
                    {
                        char export_string[RCP2_MAX_VALUE_LENGTH];

                        if (C_LIST_SUCCESS != c_list_find_num(c_list, val, &entry, C_LIST_FIND_EXACT))
                        {
                            if (id == RCP_PARAM_APERTURE)
                            {
                                if (C_LIST_SUCCESS != c_list_find_num(c_list, val, &entry, C_LIST_FIND_CLOSEST))
                                {
                                    _rcp_log_error(con, "could not find closest current value in list for %s: %d\n", rcp_get_name(con, id), val);
                                }
                            }
                            else
                            {
                                _rcp_log_warning(con, "could not find current value in list for %s: %d\n", rcp_get_name(con, id), val);
                            }
                        }

                        if (C_LIST_SUCCESS == c_list_export_to_string(c_list, export_string, sizeof(export_string)))
                        {
                            if (state->list_val)
                            {
                                rcp_free(state->list_val);
                            }

                            state->list_val = _rcp_strdup(export_string);

                            if (state->list_val)
                            {
                                state->list_val_valid = 1;
                                state->list_current_val = val;
                                state->list_current_val_valid = 1;
                            }
                        }
                        else
                        {
                            _rcp_log_error(con, "c_list_export_to_string failed\n");
                        }
                    }
                }
                else
                {
                    _rcp_log_error(con, "c_list_import_from_string failed\n");
                }

                if (C_LIST_SUCCESS != c_list_delete(c_list))
                {
                    _rcp_log_error(con, "c_list_delete failed\n");
                }
            }

            _rcp_send_current_list(con, id, id);
        }
    }
}

static void _rcp_update_list_val_str(rcp_camera_connection_t * con, rcp_param_t id, const char * str)
{
    if (con)
    {
        rcp_param_state_t * const state = &con->param_state[id];

        if (state)
        {
            c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

            state->list_val_valid = 0;
            if (c_list)
            {
                c_list_entry_t entry;
                if (C_LIST_SUCCESS == c_list_import_from_string(c_list, state->list_val))
                {
                    if (C_LIST_SUCCESS == c_list_find_str(c_list, str, &entry))
                    {
                        char export_string[RCP2_MAX_VALUE_LENGTH];
                        if (C_LIST_SUCCESS == c_list_export_to_string(c_list, export_string, sizeof(export_string)))
                        {
                            const size_t len = strlen(export_string) + 1;
                            if (state->list_val)
                            {
                                rcp_free(state->list_val);
                                state->list_val = RCP_MALLOC(char *, len);
                                if (state->list_val)
                                {
                                    strlcpy(state->list_val, export_string, len);
                                    state->list_val_valid = 1;
                                }
                            }
                        }
                        else
                        {
                            _rcp_log_error(con, "c_list_export_to_string failed\n");
                        }
                    }
                }
                else
                {
                    _rcp_log_error(con, "c_list_import_from_string failed\n");
                }

                if (C_LIST_SUCCESS != c_list_delete(c_list))
                {
                    _rcp_log_error(con, "c_list_delete failed\n");
                }
            }

            _rcp_send_current_list(con, id, id);
        }
    }
}

RCP_API_PRIVATE void _rcp_send_current_default_int(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (con->cur_default_int_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_default_int_cb_data_t data;

            data.con = con;
            data.id = id;
            data.default_val = state->default_val.int_val;
            data.default_val_valid = state->default_val_valid;

            con->cur_default_int_cb(&data, con->cur_default_int_cb_user_data);
        }
    }
}

RCP_API_PRIVATE void _rcp_send_current_default_uint(rcp_camera_connection_t * con, rcp_param_t id)
{
    if (con)
    {
        const rcp_param_state_t * const state = &con->param_state[id];

        if (con->cur_default_uint_cb && con->state == RCP_CONNECTION_STATE_CONNECTED)
        {
            rcp_cur_default_uint_cb_data_t data;

            data.con = con;
            data.id = id;
            data.default_val = state->default_val.uint_val;
            data.default_val_valid = state->default_val_valid;

            con->cur_default_uint_cb(&data, con->cur_default_uint_cb_user_data);
        }
    }
}
/********** End file: rcp_api_send_current.c ************************************/

/********** Begin file: rcp_api_set_int.c ***************************************/
/* #include "rcp_api_set_int.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_utils.h" */

#include <stdio.h>

static void _rcp_create_set_int_message_with_index(rcp_camera_connection_t * con, char cmd, const char * msg, int index, int32_t val);
#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_int_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);
#endif

rcp_error_t rcp_set_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set int: %s\n", rcp_get_name(con, id));
    err = _rcp_set_int(con, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_int(rcp_camera_connection_t * con, rcp_param_t id, int32_t val)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_int)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_type == RCP_TYPE_INT)
        {
            const char * const set_msg = def->set_msg;
            const char * const set_target_msg = def->set_target_msg;
            const char * msg = NULL;

            /* If we have a set target message we want to send a set
             * target value rather than a set value message. */
            if (set_target_msg && _rcp_version_in_range(con, &def->target_version_range))
            {
                msg = set_target_msg;
            }
            else if (set_msg)
            {
                msg = set_msg;
            }
            else
            {
                _rcp_log_error(con, "cannot set parameter: %s\n", rcp_get_name(con, id));
                return RCP_ERROR_NO_SET;
            }

            if (def->is_indexed)
            {
                _rcp_create_set_int_message_with_index(con, RCP2_CMD_SET, msg, def->index, val);
            }
            else
            {
                _rcp_create_set_int_message(con, RCP2_CMD_SET, msg, val);
            }

            /* clear cached value */
            state->val_valid = 0;
            state->target_val_valid = 0;
        }
        else if (def->set_int_fp)
        {
            def->set_int_fp(con, id, val);
        }
        else
        {
            _rcp_log_error(con, "incorrect type for parameter %s\n", rcp_get_name(con, id));
            return RCP_ERROR_SET_WRONG_TYPE;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

/* create RCP message for SET and send to camera */
RCP_API_PRIVATE void _rcp_create_set_int_message(rcp_camera_connection_t * con, char cmd, const char * msg, int32_t val)
{
    if (con)
    {
        char val_str[RCP_STR_LEN_FOR_INT32];
        snprintf(val_str, sizeof(val_str), "%d", val);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 1, val_str))
        {
            _rcp_log_error(con, "cannot create set int packet\n");
        }
    }
}

static void _rcp_create_set_int_message_with_index(rcp_camera_connection_t * con, char cmd, const char * msg, int idx, int32_t val)
{
    if (con)
    {
        char index_str[RCP_STR_LEN_FOR_INT32];
        char val_str[RCP_STR_LEN_FOR_INT32];
        snprintf(index_str, sizeof(index_str), "%d", idx);
        snprintf(val_str, sizeof(val_str), "%d", val);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 2, index_str, val_str))
        {
            _rcp_log_error(con, "cannot create set int packet\n");
        }
    }
}

rcp_error_t rcp_set_int_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
#ifdef RCP_API_ENABLE_RELATIVE
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set int relative: %s\n", rcp_get_name(con, id));
    err = _rcp_set_int_relative(con, id, offset);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}

#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_int_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_int_relative)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_relative_msg && _rcp_version_in_range(con, &def->set_relative_version_range))
        {
            _rcp_create_set_int_message(con, RCP2_CMD_SET_RELATIVE, def->set_relative_msg, offset);
        }
        else
        {
            state->pending_relative_offset_value += offset;

            if (state->pending_relative_offset_value != 0)
            {
#ifdef RCP_API_ENABLE_CACHING
                if (def->val_cacheable && state->val_valid)
                {
                    if (RCP_SUCCESS != _rcp_set_int_from_relative(con, id, state->val.int_val, state->pending_relative_offset_value))
                    {
                        _rcp_log_error(con, "failed to set relative value for parameter: %s\n", rcp_get_name(con, id));
                    }

                    /* clear pending relative value */
                    state->pending_relative_offset_value = 0;
                }
                else
#endif
                {
                    /* the value isn't cached or isn't cache-able.
                     * we have already stored the pending relative
                     * change, we will request the current value with a
                     * GET and the offset will be applied in the
                     * CURRENT handler. */
                    state->expected_retry_count = 0;
                    if (RCP_SUCCESS != _rcp_get(con, id))
                    {
                        _rcp_log_error(con, "failed to get value for %s\n", rcp_get_name(con, id));
                    }
                }
            }
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_int_from_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t val, int32_t offset)
{
    rcp_param_state_t * const state = &con->param_state[id];

    /* perform clamping to min/max value */
    if (val >= 0)
    {
        if ((INT32_MAX - val) < offset)
        {
            val = INT32_MAX;
        }
        else
        {
            val += offset;
        }
    }
    else
    {
        if (offset < (INT32_MIN - val))
        {
            val = INT32_MIN;
        }
        else
        {
            val += offset;
        }
    }

    /* set new value */
    state->pending_expected_relative_value.int_val = val;
    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
    return _rcp_set_int(con, id, val);
}
#endif
/********** End file: rcp_api_set_int.c *****************************************/

/********** Begin file: rcp_api_set_list.c **************************************/
/* #include "rcp_api_set_list.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get_list.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_set_int.h" */
/* #include "rcp_api_set_uint.h" */
/* #include "rcp_api_set_str.h" */

static rcp_error_t _rcp_set_list(rcp_camera_connection_t * con, rcp_param_t id, const char * val);
#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_list_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);
#endif

rcp_error_t rcp_set_list(rcp_camera_connection_t * con, rcp_param_t id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set list: %s\n", rcp_get_name(con, id));
    err = _rcp_set_list(con, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

static rcp_error_t _rcp_set_list(rcp_camera_connection_t * con, rcp_param_t id, const char * val)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];

        if (!properties.has_set_list)
        {
            return RCP_ERROR_NO_SET;
        }

        if (def->set_list_msg)
        {
            _rcp_create_set_str_message(con, RCP2_CMD_SET_LIST, def->set_list_msg, val);
        }
        else
        {
            _rcp_log_error(con, "cannot set list for parameter: %s\n", rcp_get_name(con, id));
            return RCP_ERROR_NO_SET;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

rcp_error_t rcp_set_list_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
#ifdef RCP_API_ENABLE_RELATIVE
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set list relative: %s\n", rcp_get_name(con, id));
    err = _rcp_set_list_relative(con, id, offset);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}

#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_list_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_list_relative)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_list_relative_msg && _rcp_version_in_range(con, &def->set_list_relative_version_range))
        {
            _rcp_create_set_int_message(con, RCP2_CMD_SET_LIST_RELATIVE, def->set_list_relative_msg, offset);
        }
        else
        {
            state->pending_relative_list_offset_value += offset;

            if (state->pending_relative_list_offset_value != 0)
            {
#ifdef RCP_API_ENABLE_CACHING
                if (def->list_cacheable && state->list_val_valid && (state->val_valid || !def->val_cacheable))
                {
                    if (RCP_SUCCESS != _rcp_set_list_from_relative(con, id, state->list_val, state->pending_relative_list_offset_value))
                    {
                        _rcp_log_error(con, "failed to set relative list value for parameter: %s\n", rcp_get_name(con, id));
                    }
                    state->pending_relative_list_offset_value = 0;
                }
                else
#endif
                {
                    /* the value isn't cached or isn't cache-able.
                     * we have already stored the pending relative
                     * change, we will request the current list with a
                     * GET_LIST and the offset will be applied in the
                     * CURRENT_LIST handler. */
                    if (RCP_SUCCESS != _rcp_get_list(con, id))
                    {
                        _rcp_log_error(con, "cannot get list for %s\n", rcp_get_name(con, id));
                    }
                }
            }
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_get_current_entry_from_list(const rcp_camera_connection_t * con, const char * list_val, c_list_entry_t * entry)
{
    c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

    if (c_list)
    {
        if (C_LIST_SUCCESS == c_list_import_from_string(c_list, list_val))
        {
            if (C_LIST_SUCCESS != c_list_get_current_entry(c_list, entry))
            {
                _rcp_log_error(con, "could not get current entry in list\n");

                if (C_LIST_SUCCESS != c_list_delete(c_list))
                {
                    _rcp_log_error(con, "c_list_delete failed\n");
                }

                return RCP_ERROR_INTERNAL;
            }
        }
        else
        {
            _rcp_log_error(con, "c_list_import_from_string failed\n");

            if (C_LIST_SUCCESS != c_list_delete(c_list))
            {
                _rcp_log_error(con, "c_list_delete failed\n");
            }

            return RCP_ERROR_INTERNAL;
        }

        if (C_LIST_SUCCESS != c_list_delete(c_list))
        {
            _rcp_log_error(con, "c_list_delete failed\n");
            return RCP_ERROR_INTERNAL;
        }
    }
    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_list_from_relative(rcp_camera_connection_t * con, rcp_param_t id, const char * list_val, int32_t offset)
{
    rcp_param_properties_t properties;

    if (con && rcp_get_is_supported(con, id, &properties))
    {
        rcp_param_state_t * const state = &con->param_state[id];

        c_list_t * const c_list = c_list_create(rcp_malloc, rcp_free);

        if (c_list)
        {
            if (C_LIST_SUCCESS == c_list_import_from_string(c_list, list_val))
            {
                int ii;
                c_list_entry_t entry;

                if (C_LIST_SUCCESS != c_list_get_current_entry(c_list, &entry))
                {
                    _rcp_log_error(con, "could not get current entry in list\n");

                    if (C_LIST_SUCCESS != c_list_delete(c_list))
                    {
                        _rcp_log_error(con, "c_list_delete failed\n");
                    }

                    return RCP_ERROR_INTERNAL;
                }

                if (offset > 0)
                {
                    for (ii = 0; ii < offset; ii++)
                    {
                        if (C_LIST_SUCCESS != c_list_find_next(c_list, &entry))
                        {
                            /* at the end of the list */
                            break;
                        }
                    }
                }
                else if (offset < 0)
                {
                    for (ii = 0; ii > offset; ii--)
                    {
                        if (C_LIST_SUCCESS != c_list_find_prev(c_list, &entry))
                        {
                            /* at the end of the list */
                            break;
                        }
                    }
                }

                if (properties.has_set_int)
                {
                    state->pending_expected_relative_value.int_val = entry.num;
                    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
                    if (RCP_SUCCESS != _rcp_set_int(con, id, entry.num))
                    {
                        _rcp_log_error(con, "could not set int list value for %s\n", rcp_get_name(con, id));
                    }
                }
                else if (properties.has_set_uint)
                {
                    state->pending_expected_relative_value.uint_val = (uint32_t) entry.num;
                    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
                    if (RCP_SUCCESS != _rcp_set_uint(con, id, (uint32_t) entry.num))
                    {
                        _rcp_log_error(con, "could not set uint list value for %s\n", rcp_get_name(con, id));
                    }
                }
                else if (properties.has_set_str)
                {
                    if (RCP_SUCCESS != _rcp_set_str(con, id, entry.str))
                    {
                        _rcp_log_error(con, "could not set str list value for %s\n", rcp_get_name(con, id));
                    }
                }
            }
            else
            {
                _rcp_log_error(con, "c_list_import_from_string failed\n");
            }

            if (C_LIST_SUCCESS != c_list_delete(c_list))
            {
                _rcp_log_error(con, "c_list_delete failed\n");
            }
        }
    }

    return RCP_SUCCESS;
}
#endif
/********** End file: rcp_api_set_list.c ****************************************/

/********** Begin file: rcp_api_set_uint.c **************************************/
/* #include "rcp_api_set_uint.h" */

#include <stdio.h>
/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */
/* #include "rcp_api_set_int.h" */
/* #include "rcp_api_utils.h" */

static void _rcp_create_set_uint_message(rcp_camera_connection_t * con, char cmd, const char * msg, uint32_t val);
#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_uint_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset);
#endif

rcp_error_t rcp_set_uint(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set int: %s\n", rcp_get_name(con, id));
    err = _rcp_set_uint(con, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_uint(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_uint)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_type == RCP_TYPE_UINT)
        {
            const char * const set_msg = def->set_msg;
            const char * const set_target_msg = def->set_target_msg;
            const char * msg = NULL;

            /* If we have a set target message we want to send a set
             * target value rather than a set value message. */
            if (set_target_msg && _rcp_version_in_range(con, &def->target_version_range))
            {
                msg = set_target_msg;
            }
            else if (set_msg)
            {
                msg = set_msg;
            }
            else
            {
                _rcp_log_error(con, "cannot set parameter: %s\n", rcp_get_name(con, id));
                return RCP_ERROR_NO_SET;
            }

            _rcp_create_set_uint_message(con, RCP2_CMD_SET, msg, val);

            /* clear cached value */
            state->val_valid = 0;
            state->target_val_valid = 0;
        }
        else
        {
            _rcp_log_error(con, "incorrect type for parameter %s\n", rcp_get_name(con, id));
            return RCP_ERROR_SET_WRONG_TYPE;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

/* create RCP message for SET and send to camera */
static void _rcp_create_set_uint_message(rcp_camera_connection_t * con, char cmd, const char * msg, uint32_t val)
{
    if (con)
    {
        char val_str[RCP_STR_LEN_FOR_UINT32];
        snprintf(val_str, sizeof(val_str), "%u", val);

        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 1, val_str))
        {
            _rcp_log_error(con, "cannot create set uint packet\n");
        }
    }
}

rcp_error_t rcp_set_uint_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
#ifdef RCP_API_ENABLE_RELATIVE
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set uint relative: %s\n", rcp_get_name(con, id));
    err = _rcp_set_uint_relative(con, id, offset);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
#else
    return RCP_SUCCESS;
#endif
}

#ifdef RCP_API_ENABLE_RELATIVE
static rcp_error_t _rcp_set_uint_relative(rcp_camera_connection_t * con, rcp_param_t id, int32_t offset)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_uint_relative)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_relative_msg && _rcp_version_in_range(con, &def->set_relative_version_range))
        {
            _rcp_create_set_int_message(con, RCP2_CMD_SET_RELATIVE, def->set_relative_msg, offset);
        }
        else
        {
            state->pending_relative_offset_value += offset;

            if (state->pending_relative_offset_value != 0)
            {
#ifdef RCP_API_ENABLE_CACHING
                if (def->val_cacheable && state->val_valid)
                {
                    if (RCP_SUCCESS != _rcp_set_uint_from_relative(con, id, state->val.uint_val, state->pending_relative_offset_value))
                    {
                        _rcp_log_error(con, "failed to set relative value for parameter: %s\n", rcp_get_name(con, id));
                    }

                    /* clear pending relative value */
                    state->pending_relative_offset_value = 0;
                }
                else
#endif
                {
                    /* the value isn't cached or isn't cache-able.
                     * we have already stored the pending relative
                     * change, we will request the current value with a
                     * GET and the offset will be applied in the
                     * CURRENT handler. */
                    state->expected_retry_count = 0;
                    if (RCP_SUCCESS != _rcp_get(con, id))
                    {
                        _rcp_log_error(con, "failed to get value for %s\n", rcp_get_name(con, id));
                    }
                }
            }
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_uint_from_relative(rcp_camera_connection_t * con, rcp_param_t id, uint32_t val, int32_t offset)
{
    rcp_param_state_t * const state = &con->param_state[id];

    /* perform clamping to min/max value */
    if (offset >= 0)
    {
        if ((UINT32_MAX - val) < (uint32_t) offset)
        {
            val = UINT32_MAX;
        }
        else
        {
            val += offset;
        }
    }
    else
    {
        if (val < (uint32_t) (0 - offset))
        {
            val = 0;
        }
        else
        {
            val += offset;
        }
    }

    /* set new value */
    state->pending_expected_relative_value.uint_val = val;
    state->expected_retry_count = RCP_EXPECTED_RETRY_COUNT;
    return _rcp_set_uint(con, id, val);
}
#endif
/********** End file: rcp_api_set_uint.c ****************************************/

/********** Begin file: rcp_api_set_str.c ***************************************/
/* #include "rcp_api_set_str.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_parameters.h" */

rcp_error_t rcp_set_str(rcp_camera_connection_t * con, rcp_param_t id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "set str: %s\n", rcp_get_name(con, id));
    err = _rcp_set_str(con, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

RCP_API_PRIVATE rcp_error_t _rcp_set_str(rcp_camera_connection_t * con, rcp_param_t id, const char * val)
{
    rcp_param_properties_t properties;
    if (con && rcp_get_is_supported(con, id, &properties))
    {
        const rcp_param_def_t * const def = &_rcp_param_def[id];
        rcp_param_state_t * const state = &con->param_state[id];

        if (!properties.has_set_str)
        {
            return RCP_ERROR_SET_WRONG_TYPE;
        }

        if (def->set_type == RCP_TYPE_STR)
        {
            const char * const set_msg = def->set_msg;

            if (set_msg)
            {
                _rcp_create_set_str_message(con, RCP2_CMD_SET, set_msg, val);

                /* clear cached value */
                state->val_valid = 0;
            }
            else
            {
                _rcp_log_error(con, "cannot set parameter: %s\n", rcp_get_name(con, id));
                return RCP_ERROR_NO_SET;
            }
        }
        else
        {
            _rcp_log_error(con, "incorrect type for parameter %s\n", rcp_get_name(con, id));
            return RCP_ERROR_SET_WRONG_TYPE;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }

    return RCP_SUCCESS;
}

/* create RCP message for SET and send to camera */
RCP_API_PRIVATE void _rcp_create_set_str_message(rcp_camera_connection_t * con, char cmd, const char * msg, const char * val)
{
    if (con)
    {
        if (RCP_SUCCESS != _rcp_create_and_send_packet(con, cmd, msg, 1, val))
        {
            _rcp_log_error(con, "cannot create set str packet\n");
        }
    }
}
/********** End file: rcp_api_set_str.c *****************************************/

/********** Begin file: rcp_api_state.c *****************************************/
/* #include "rcp_api_state.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_client_id.h" */
/* #include "rcp_api_get.h" */
/* #include "rcp_api_get_list.h" */
/* #include "rcp_api_hw_cap.h" */
/* #include "rcp_api_key_mapping.h" */
/* #include "rcp_api_log.h" */

/* #include "rcp_parser/rcp_parameter_types_public.h" */

typedef void (* state_enter_cb_t) (rcp_camera_connection_t * con);

typedef void (* state_cur_int_cb_t) (rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data);
typedef void (* state_cur_uint_cb_t) (rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data);
typedef void (* state_cur_camera_info_cb_t) (rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info);
typedef void (* state_cur_tag_cb_t) (rcp_camera_connection_t * con, const rcp_cur_tag_info_cb_data_t * data);
typedef void (* state_cur_list_cb_t) (rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
typedef void (* state_cur_str_cb_t) (rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data);

static void _rcp_state_init_enter(rcp_camera_connection_t * con);
static void _rcp_state_init_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data);
static void _rcp_state_init_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data);
static void _rcp_state_init_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info);
static void _rcp_state_init_update(rcp_camera_connection_t * con);

static void _rcp_state_get_required_params_enter(rcp_camera_connection_t * con);
static void _rcp_state_get_required_params_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data);
static void _rcp_state_get_required_params_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data);
static void _rcp_state_get_required_params_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info);
static void _rcp_state_get_required_params_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
static void _rcp_state_get_required_params_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data);
static void _rcp_state_get_required_params_update(rcp_camera_connection_t * con);

static void _rcp_state_connected_enter(rcp_camera_connection_t * con);
static void _rcp_state_connected_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data);
static void _rcp_state_connected_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data);
static void _rcp_state_connected_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info);
static void _rcp_state_connected_cur_tag_cb(rcp_camera_connection_t * con, const rcp_cur_tag_info_cb_data_t * data);
static void _rcp_state_connected_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data);
static void _rcp_state_connected_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data);

typedef struct
{
    const char * name;
    state_enter_cb_t enter;
    state_cur_int_cb_t cur_int;
    state_cur_uint_cb_t cur_uint;
    state_cur_camera_info_cb_t cur_camera_info;
    state_cur_tag_cb_t cur_tag;
    state_cur_list_cb_t cur_list;
    state_cur_str_cb_t cur_str;
} state_info_t;

static const state_info_t state_info[RCP_CONNECTION_STATE_COUNT] =
{
    /* RCP_CONNECTION_STATE_INIT */
    {
        "INIT",
        _rcp_state_init_enter,
        _rcp_state_init_cur_int_cb,
        _rcp_state_init_cur_uint_cb,
        _rcp_state_init_cur_camera_info_cb,
        NULL,
        NULL,
        NULL
    },

    /* RCP_CONNECTION_STATE_GET_REQUIRED_PARAMS */
    {
        "GET_REQUIRED_PARAMS",
        _rcp_state_get_required_params_enter,
        _rcp_state_get_required_params_cur_int_cb,
        _rcp_state_get_required_params_cur_uint_cb,
        _rcp_state_get_required_params_cur_camera_info_cb,
        NULL,
        _rcp_state_get_required_params_cur_list_cb,
        _rcp_state_get_required_params_cur_str_cb
    },

    /* RCP_CONNECTION_STATE_CONNECTED */
    {
        "CONNECTED",
        _rcp_state_connected_enter,
        _rcp_state_connected_cur_int_cb,
        _rcp_state_connected_cur_uint_cb,
        _rcp_state_connected_cur_camera_info_cb,
        _rcp_state_connected_cur_tag_cb,
        _rcp_state_connected_cur_list_cb,
        _rcp_state_connected_cur_str_cb
    },

    /* RCP_CONNECTION_STATE_ERROR_RCP_VERSION_MISMATCH */
    {
        "ERROR_RCP_VERSION_MISMATCH",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    },

    /* RCP_CONNECTION_STATE_ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH */
    {
        "ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    },

    /* RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE */
    {
        "RCP_DISABLED_ON_INTERFACE",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    },

    /* RCP_CONNECTION_STATE_COMMUNICATION_ERROR */
    {
        "COMMUNICATION_ERROR",
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    },
};

const rcp_param_t required_params[] =
{
    RCP_PARAM_RECORD_STATE_BASE,
    RCP_PARAM_TEST_PATTERN,
    RCP_PARAM_MAGNIFY_STATE,
    RCP_PARAM_PLAYBACK_STATE,
    RCP_PARAM_PLAYBACK_FILE_FORMAT,
    RCP_PARAM_RAW_MODE,
    RCP_PARAM_VIDEO_SOURCE,
    RCP_PARAM_OUTPUT_TRANSFORM,
    RCP_PARAM_COLOR_SCIENCE,
    RCP_PARAM_SIDE_UI_NAME,
    RCP_PARAM_HARDWARE_CAPABILITIES
};

const rcp_param_t required_list_params[] =
{
    RCP_PARAM_POWER_IN_LIST,
    RCP_PARAM_POWER_OUT_LIST,
    RCP_PARAM_MONITOR_LIST
};

/* set connection state.  if the state changes call the state callback
 * provided by the user */
RCP_API_PRIVATE void _rcp_set_state(rcp_camera_connection_t * con, rcp_connection_state_t new_state)
{
    if (con)
    {
        if (con->state != new_state)
        {
            con->state = new_state;
            _rcp_log_info(con, "entering state: %s\n", state_info[con->state].name);

            /* Call user's callback function to inform user of the state change */
            if (con->state_cb)
            {
                rcp_state_data_t data;

                data.con = con;
                data.state = con->state;
                data.parameter_set_version_major = con->parameter_set_version_major;
                data.parameter_set_version_minor = con->parameter_set_version_minor;
                data.parameter_set_newer = con->parameter_set_newer;
                data.parameter_set_version_valid = con->parameter_set_version_valid;
                data.cam_info = &con->cam_info;
                con->state_cb(&data, con->state_cb_user_data);
            }

            /* Call new state's enter handler */
            if (state_info[con->state].enter)
            {
                state_info[con->state].enter(con);
            }
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data)
{
    if (con)
    {
        if (state_info[con->state].cur_int)
        {
            state_info[con->state].cur_int(con, data);
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data)
{
    if (con)
    {
        if (state_info[con->state].cur_uint)
        {
            state_info[con->state].cur_uint(con, data);
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info)
{
    if (con)
    {
        if (state_info[con->state].cur_camera_info)
        {
            state_info[con->state].cur_camera_info(con, cam_info);
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_tag_cb(rcp_camera_connection_t * con, const rcp_cur_tag_info_cb_data_t * data)
{
    if (con)
    {
        if (state_info[con->state].cur_tag)
        {
            state_info[con->state].cur_tag(con, data);
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    if (con)
    {
        if (state_info[con->state].cur_list)
        {
            state_info[con->state].cur_list(con, data);
        }
    }
}

RCP_API_PRIVATE void _rcp_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data)
{
    if (con)
    {
        if (state_info[con->state].cur_str)
        {
            state_info[con->state].cur_str(con, data);
        }
    }
}

static void _rcp_state_init_enter(rcp_camera_connection_t * con)
{
    if (con)
    {
        /* start connection validation process by asking for camera info. */
        _rcp_log_info(con, "requesting camera info\n");
        (void) _rcp_get(con, RCP_PARAM_CAMERA_INFO);
        (void) _rcp_get(con, RCP_PARAM_RCP_VERSION);
        (void) _rcp_get(con, RCP_PARAM_RCP_PARAMETER_SET_VERSION);
    }
}

static void _rcp_state_init_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data)
{
    if (con && data)
    {
        if (data->cur_val_valid)
        {
            switch (data->id)
            {
                case RCP_PARAM_RCP_VERSION:
                    con->rcp_version = data->cur_val;
                    con->rcp_version_valid = 1;
                    _rcp_log_info(con, "RCP version: %d\n", con->rcp_version);
                    if (con->rcp_version != RCP2_VERSION)
                    {
                        _rcp_set_state(con, RCP_CONNECTION_STATE_ERROR_RCP_VERSION_MISMATCH);
                    }
                    else
                    {
                        _rcp_state_init_update(con);
                    }
                    break;

                default:
                    break;
            }
        }
    }
}

static void _rcp_state_init_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data)
{
    if (con && data)
    {
        if (data->cur_val_valid)
        {
            switch (data->id)
            {
                case RCP_PARAM_RCP_PARAMETER_SET_VERSION:
                    con->parameter_set_version_major = (data->cur_val & 0xffff0000) >> 16;
                    con->parameter_set_version_minor = (data->cur_val & 0x0000ffff);
                    con->parameter_set_version_valid = 1;

                    _rcp_log_info(con, "RCP parameter set version: %d.%d\n", con->parameter_set_version_major, con->parameter_set_version_minor);

                    if (con->parameter_set_version_major > RCP_PARAMETER_SET_VERSION_MAJOR)
                    {
                        _rcp_set_state(con, RCP_CONNECTION_STATE_ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH);
                    }
                    else if (con->parameter_set_version_major < RCP_PARAMETER_SET_MIN_VERSION_MAJOR)
                    {
                        _rcp_set_state(con, RCP_CONNECTION_STATE_ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH);
                    }
                    else if (
                             (con->parameter_set_version_major == RCP_PARAMETER_SET_MIN_VERSION_MAJOR) &&
                             (con->parameter_set_version_minor < RCP_PARAMETER_SET_MIN_VERSION_MINOR)
                            )
                    {
                        _rcp_set_state(con, RCP_CONNECTION_STATE_ERROR_RCP_PARAMETER_SET_VERSION_MISMATCH);
                    }
                    else
                    {
                        if (
                            (con->parameter_set_version_major == RCP_PARAMETER_SET_VERSION_MAJOR) &&
                            (con->parameter_set_version_minor > RCP_PARAMETER_SET_VERSION_MINOR)
                           )
                        {
                            _rcp_log_info(con, "camera parameter set version is newer than API; upgrade API.\n");
                            con->parameter_set_newer = 1;
                        }

                        _rcp_state_init_update(con);
                    }
                    break;

                default:
                    break;
            }
        }
    }
}

static void _rcp_state_init_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info)
{
    if (con && cam_info)
    {
        con->cam_info = *cam_info;
        con->cam_info_valid = 1;
        _rcp_state_init_update(con);
    }
}

static void _rcp_state_init_update(rcp_camera_connection_t * con)
{
    if (con && con->state == RCP_CONNECTION_STATE_INIT)
    {
        if (con->cam_info_valid && con->parameter_set_version_valid && con->rcp_version_valid)
        {
            /* if the interface is not enabled; go to an error state */

            if (con->cam_info.rcp_interface_enabled_valid && !con->cam_info.rcp_interface_enabled)
            {
                _rcp_set_state(con, RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE);
            }
            else
            {
                _rcp_set_state(con, RCP_CONNECTION_STATE_GET_REQUIRED_PARAMS);
            }
        }
    }
}

static void _rcp_state_get_required_params_enter(rcp_camera_connection_t * con)
{
    if (con)
    {
        size_t ii;

        /* set client id */
        if (_rcp_has_feature(con, RCP_FEATURE_CLIENT_ID))
        {
            _rcp_log_info(con, "setting client id\n");
            (void) _rcp_send_client_id(con);
        }

        /* clear cached values */
        _rcp_log_info(con, "clearing cached values\n");
        for (ii = 0; ii < (size_t) RCP_PARAM_COUNT; ii++)
        {
            _rcp_clear_cache_val(con, (rcp_param_t) ii);
            _rcp_clear_cache_list(con, (rcp_param_t) ii);

            con->param_state[ii].is_enabled_valid = 0;
            con->param_state[ii].is_hw_supported_valid = 0;
            con->param_state[ii].is_color_science_supported_valid = 0;
#ifdef RCP_API_ENABLE_RELATIVE
            con->param_state[ii].pending_relative_offset_value = 0;
            con->param_state[ii].pending_relative_list_offset_value = 0;
            con->param_state[ii].expected_retry_count = 0;
#endif
        }

        con->last_record_state = RECORD_STATE_COUNT;
        con->last_test_pattern = MONITOR_TEST_PATTERN_COUNT;
        con->last_magnify_state = MAGNIFY_MODE_COUNT;
        con->last_playback_state = PLAYBACK_STATE_COUNT;
        con->last_playback_file_format_type = FILE_FORMAT_TYPE_COUNT;
        con->last_raw_mode = RAW_MODE_COUNT;
        con->last_video_source = VIDEO_SOURCE_COUNT;
        con->last_output_transform= OUTPUT_TRANSFORM_COUNT;
        con->last_color_science = COLOR_SCIENCE_COUNT;

        _rcp_log_info(con, "requesting required parameters\n");
        for (ii = 0; ii < sizeof(required_params) / sizeof(required_params[0]); ii++)
        {
            if (rcp_get_is_supported(con, required_params[ii], NULL))
            {
                (void) _rcp_get(con, required_params[ii]);
            }
        }

        for (ii = 0; ii < sizeof(required_list_params) / sizeof(required_list_params[0]); ii++)
        {
            if (rcp_get_is_supported(con, required_list_params[ii], NULL))
            {
                (void) _rcp_get_list(con, required_list_params[ii]);
            }
        }

        _rcp_state_get_required_params_update(con);
    }
}

static void _rcp_state_get_required_params_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data)
{
    if (con && data)
    {
        if (data->cur_val_valid)
        {
            _rcp_state_get_required_params_update(con);
        }
    }
}

static void _rcp_state_get_required_params_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data)
{
    if (con && data)
    {
        if (data->cur_val_valid)
        {
            _rcp_state_get_required_params_update(con);
        }
    }
}

static void _rcp_state_get_required_params_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info)
{
    if (con && cam_info)
    {
        con->cam_info = *cam_info;
        con->cam_info_valid = 1;
        if (con->cam_info.rcp_interface_enabled_valid && !con->cam_info.rcp_interface_enabled)
        {
            _rcp_set_state(con, RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE);
        }
    }
}

static void _rcp_state_get_required_params_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    if (con && data)
    {
        if (data->list_string_valid)
        {
            _rcp_state_get_required_params_update(con);
        }
    }
}

static void _rcp_state_get_required_params_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data)
{
    if (con && data)
    {
        if (data->display_str)
        {
            _rcp_state_get_required_params_update(con);
        }
    }
}

static void _rcp_state_get_required_params_update(rcp_camera_connection_t * con)
{
    if (con && con->state == RCP_CONNECTION_STATE_GET_REQUIRED_PARAMS)
    {
        size_t ii;
        int have_all_required_params = 1;

        for (ii = 0; ii < sizeof(required_params) / sizeof(required_params[0]); ii++)
        {
            if (rcp_get_is_supported(con, required_params[ii], NULL))
            {
                if (!con->param_state[required_params[ii]].val_valid)
                {
                    have_all_required_params = 0;
                }
            }
        }

        for (ii = 0; ii < sizeof(required_list_params) / sizeof(required_list_params[0]); ii++)
        {
            if (rcp_get_is_supported(con, required_list_params[ii], NULL))
            {
                if (!con->param_state[required_list_params[ii]].list_val_valid)
                {
                    have_all_required_params = 0;
                }
            }
        }

        if (have_all_required_params)
        {
            _rcp_set_state(con, RCP_CONNECTION_STATE_CONNECTED);
        }
    }
}

static void _rcp_state_connected_enter(rcp_camera_connection_t * con)
{
    if (con)
    {
        /* Get the hardware capabilities */
        if (rcp_get_is_supported(con, RCP_PARAM_HARDWARE_CAPABILITIES, NULL))
        {
            _rcp_hw_cap_update_status(con);
        }
        else
        {
            _rcp_hw_cap_not_supported(con);
        }

        if (!rcp_get_is_supported(con, RCP_PARAM_COLOR_SCIENCE, NULL))
        {
            /* older cameras use FLUT */
            con->last_color_science = COLOR_SCIENCE_FLUT;
            _rcp_parameters_handle_color_science_changed(con);
        }

        /* Get the current notifications */
        _rcp_log_info(con, "requesting current notification\n");
        _rcp_create_get_message(con, RCP2_CMD_GET, RCP_NOTIFY_MSG_NOTIFICATION_PTR);
    }
}

static void _rcp_state_connected_cur_int_cb(rcp_camera_connection_t * con, const rcp_cur_int_cb_data_t * data)
{
    /* call user callback */
    if (con && con->cur_int_cb)
    {
        con->cur_int_cb(data, con->cur_int_cb_user_data);
    }
}

static void _rcp_state_connected_cur_uint_cb(rcp_camera_connection_t * con, const rcp_cur_uint_cb_data_t * data)
{
    /* call user callback */
    if (con && con->cur_uint_cb)
    {
        con->cur_uint_cb(data, con->cur_uint_cb_user_data);
    }
}

static void _rcp_state_connected_cur_camera_info_cb(rcp_camera_connection_t * con, const rcp_cam_info_t * cam_info)
{
    if (con && cam_info)
    {
        con->cam_info = *cam_info;
        con->cam_info_valid = 1;
        if (con->cam_info.rcp_interface_enabled_valid && !con->cam_info.rcp_interface_enabled)
        {
            _rcp_set_state(con, RCP_CONNECTION_STATE_RCP_DISABLED_ON_INTERFACE);
        }
    }
}

static void _rcp_state_connected_cur_tag_cb(rcp_camera_connection_t * con, const rcp_cur_tag_info_cb_data_t * data)
{
    /* call user callback */
    if (con && con->cur_tag_cb)
    {
        con->cur_tag_cb(data, con->cur_tag_cb_user_data);
    }
}

static void _rcp_state_connected_cur_list_cb(rcp_camera_connection_t * con, const rcp_cur_list_cb_data_t * data)
{
    if (data)
    {
        switch (data->id)
        {
            case RCP_PARAM_CAMERA_PRESET_LIST:
                _rcp_key_mapping_preset_list(con, data);
                break;

            case RCP_PARAM_CAMERA_LOOK_LIST:
                _rcp_key_mapping_look_list(con, data);
                break;

            case RCP_PARAM_KEY_MAPPING_ACTION_LIST:
                _rcp_key_mapping_action_list(con, data);
                break;

            case RCP_PARAM_DIALOG_LIST:
                _rcp_key_mapping_dialog_list(con, data);
                break;

            case RCP_PARAM_CAMERA_SCRIPT_LIST:
                _rcp_key_mapping_script_list(con, data);
                break;

            default:
                break;
        }
    }

    /* call user callback */
    if (con && con->cur_list_cb)
    {
        con->cur_list_cb(data, con->cur_list_cb_user_data);
    }
}

static void _rcp_state_connected_cur_str_cb(rcp_camera_connection_t * con, const rcp_cur_str_cb_data_t * data)
{
    /* call user callback */
    if (con && con->cur_str_cb)
    {
        con->cur_str_cb(data, con->cur_str_cb_user_data);
    }
}
/********** End file: rcp_api_state.c *******************************************/

/********** Begin file: rcp_api_user.c ******************************************/
/* #include "rcp_api_user.h" */

/* #include "rcp_api_camera_connection.h" */
/* #include "rcp_api_error.h" */
/* #include "rcp_api_log.h" */
/* #include "rcp_api_packet.h" */
/* #include "rcp_api_utils.h" */

/* #include "rcp_parser/rcp_parameter_types_public.h" */
#include <stdio.h>

static rcp_error_t _rcp_user_send(rcp_camera_connection_t * con, char cmd, const char * id, const char * val);
static rcp_error_t _rcp_user_metadata_register(rcp_camera_connection_t * con, const char * id, uint32_t max_len);
static rcp_error_t _rcp_user_metadata_unregister(rcp_camera_connection_t * con, const char * id);
static rcp_error_t _rcp_user_metadata_send(rcp_camera_connection_t * con, const char * id, const char * val);

/* User pass-through messages */

int rcp_user_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_USER_PASS_THROUGH);
}

RCP_API_PRIVATE void _rcp_process_user_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        rcp_handle_user_cb_data_t rcp_handle_user_cb_data = {0};

        if (packet->argc < 1)
        {
            _rcp_log_error(con, "bad user message detected, no id given\n");
            return;
        }

        rcp_handle_user_cb_data.con = con;
        rcp_handle_user_cb_data.id = packet->argv[0];
        if (packet->argc < 2)
        {
            rcp_handle_user_cb_data.value = NULL;
        }
        else
        {
            rcp_handle_user_cb_data.value = packet->argv[1];
        }

        switch (packet->pCmd[0])
        {
            case RCP2_CMD_SET:
                if (con->handle_user_set_cb)
                {
                    con->handle_user_set_cb(&rcp_handle_user_cb_data, con->handle_user_set_cb_user_data);
                }
                break;

            case RCP2_CMD_GET:
                if (con->handle_user_get_cb)
                {
                    con->handle_user_get_cb(&rcp_handle_user_cb_data, con->handle_user_get_cb_user_data);
                }
                break;

            case RCP2_CMD_CURRENT:
                if (con->handle_user_current_cb)
                {
                    con->handle_user_current_cb(&rcp_handle_user_cb_data, con->handle_user_current_cb_user_data);
                }
                break;
        }
    }
}

rcp_error_t rcp_user_send_set(rcp_camera_connection_t * con, const char * id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "user set: %s\n", id);
    err = _rcp_user_send(con, RCP2_CMD_SET, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_user_send_get(rcp_camera_connection_t * con, const char * id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "user get: %s\n", id);
    err = _rcp_user_send(con, RCP2_CMD_GET, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_user_send_current(rcp_camera_connection_t * con, const char * id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "user current: %s\n", id);
    err = _rcp_user_send(con, RCP2_CMD_CURRENT, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

static rcp_error_t _rcp_user_send(rcp_camera_connection_t * con, char cmd, const char * id, const char * val)
{
    if (con)
    {
        if (id)
        {
            if (val)
            {
                return _rcp_create_and_send_packet(con, cmd, RCP_USER_MSG_USER_DATA, 2, id, val);
            }
            else
            {
                return _rcp_create_and_send_packet(con, cmd, RCP_USER_MSG_USER_DATA, 1, id);
            }
        }
        else
        {
            return RCP_ERROR_BAD_PARAM;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}

/* User metadata messages */

int rcp_user_metadata_is_supported(const rcp_camera_connection_t * con)
{
    return _rcp_has_feature(con, RCP_FEATURE_USER_METADATA);
}

RCP_API_PRIVATE void _rcp_process_user_metadata_reg_packet(rcp_camera_connection_t * con, const tRCPParsedPacket2 * packet)
{
    if (con && packet)
    {
        rcp_handle_user_metadata_cb_data_t rcp_handle_user_metadata_cb_data = {0};

        if (packet->argc < 2)
        {
            _rcp_log_error(con, "bad user message detected\n");
            return;
        }

        rcp_handle_user_metadata_cb_data.con = con;
        rcp_handle_user_metadata_cb_data.id = packet->argv[0];
        rcp_handle_user_metadata_cb_data.max_len = atoi(packet->argv[1]);
        rcp_handle_user_metadata_cb_data.is_registered = rcp_handle_user_metadata_cb_data.max_len > 0;

        if (con->handle_user_metadata_cb)
        {
            con->handle_user_metadata_cb(&rcp_handle_user_metadata_cb_data, con->handle_user_metadata_cb_user_data);
        }
    }
}

rcp_error_t rcp_user_metadata_register(rcp_camera_connection_t * con, const char * id, uint32_t max_len)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "send user metadata: %s\n", id);
    err = _rcp_user_metadata_register(con, id, max_len);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_user_metadata_unregister(rcp_camera_connection_t * con, const char * id)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "send user metadata: %s\n", id);
    err = _rcp_user_metadata_unregister(con, id);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

rcp_error_t rcp_user_metadata_send(rcp_camera_connection_t * con, const char * id, const char * val)
{
    rcp_error_t err;
    rcp_mutex_lock(RCP_MUTEX_CONNECTION);
    _rcp_log_info(con, "send user metadata: %s\n", id);
    err = _rcp_user_metadata_send(con, id, val);
    _rcp_handle_deferred_error(con);
    rcp_mutex_unlock(RCP_MUTEX_CONNECTION);
    return err;
}

static rcp_error_t _rcp_user_metadata_register(rcp_camera_connection_t * con, const char * id, uint32_t max_len)
{
    if (con)
    {
        if (id)
        {
            char max_len_str[RCP_STR_LEN_FOR_INT32];
            snprintf(max_len_str, sizeof(max_len_str), "%u", max_len);

            return _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_USRMDREG_MSG_USER_METADATA_REGISTER, 2, id, max_len_str);
        }
        else
        {
            return RCP_ERROR_BAD_PARAM;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}

static rcp_error_t _rcp_user_metadata_unregister(rcp_camera_connection_t * con, const char * id)
{
    if (con)
    {
        if (id)
        {
            return _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_USRMDUNR_MSG_USER_METADATA_UNREGISTER, 1, id);
        }
        else
        {
            return RCP_ERROR_BAD_PARAM;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}

static rcp_error_t _rcp_user_metadata_send(rcp_camera_connection_t * con, const char * id, const char * val)
{
    if (con)
    {
        if (id && val)
        {
            return _rcp_create_and_send_packet(con, RCP2_CMD_SET, RCP_USRMDSET_MSG_USER_METADATA_SEND, 2, id, val);
        }
        else
        {
            return RCP_ERROR_BAD_PARAM;
        }
    }
    else
    {
        return RCP_ERROR_BAD_PARAM;
    }
}
/********** End file: rcp_api_user.c ********************************************/

/********** Begin file: rcp_api_utils.c *****************************************/
/* #include "rcp_api_utils.h" */

/* #include "stringl/stringl.h" */
#include <string.h>

RCP_API_PRIVATE char * _rcp_strdup(const char * src)
{
    if (src)
    {
        char * ptr = NULL;
        const size_t size = strlen(src) + 1;
        ptr = RCP_MALLOC(char *, size);
        if (ptr)
        {
            strlcpy(ptr, src, size);
        }
        return ptr;
    }
    else
    {
        return NULL;
    }
}
/********** End file: rcp_api_utils.c *******************************************/

/********** Begin file: rcp_api_uuid.c ******************************************/
/* #include "rcp_api_uuid.h" */

/* #include "base64/base64.h" */

RCP_API_PRIVATE int _rcp_create_uuid(rcp_uuid_t * uuid)
{
    if (uuid)
    {
        size_t ii;
        for (ii = 0; ii < sizeof(uuid->data) / sizeof(uuid->data[0]); ++ii)
        {
            uuid->data[ii] = rcp_rand() & 0xff;
        }

        /* mark this UUID as a version 4 UUID: generated using
         * psuedo-random numbers. */
        uuid->data[6] &= 0x0F;
        uuid->data[6] |= 0x40;
        uuid->data[8] &= 0x3F;
        uuid->data[8] |= 0x80;

        if (!base64_encode(uuid->data, sizeof(uuid->data), uuid->str, sizeof(uuid->str)))
        {
            return 0;
        }

        return 1;
    }

    return 0;
}
/********** End file: rcp_api_uuid.c ********************************************/

/********** Begin file: rcp_api_version.c ***************************************/
/* #include "rcp_api_version.h" */
/* #include "rcp_sdk_version.h" */

const char * rcp_api_get_version(void)
{
    return RCP_SDK_VERSION;
}
/********** End file: rcp_api_version.c *****************************************/

/* #include "c_list.h" */
#include <stdio.h>
#ifdef CLIST_USE_THREADX
#include "bsp/os/red/red_block_pool.h"
#endif
#ifdef CLIST_USE_LOGGER
#include "utils/diagnostic/log/log.h"
#endif
/* #include "stringl/stringl.h" */
/* #include "decorated_string/decorated_string.h" */
/* #include "rcp_parser/rcp_parser2.h" */
#include <string.h>
#include <ctype.h>

#if defined(_MSC_VER) && (_MSC_VER < 1900)
#define snprintf _snprintf
#endif

#define ESCAPE_CHAR '%'
#define SEPARATOR_CHAR '|'
#define COMPRESSED_STRING_DICTIONARY_START_CHAR '{'
#define COMPRESSED_STRING_DICTIONARY_END_CHAR '}'
#define COMPRESSED_STRING_DICTIONARY_SEPARATOR_CHAR ':'

/* Note - Make sure the table below is from longest to shortest to
 * gurantee unique matches */

#define MAX_COMPRESSED_STRINGS 25
#define MAX_UNCOMPRESSED_STRING_LENGTH 20
/* {uncompressed0:compressed0|uncompressed1:compressed1|...} */
#define MAX_DICTIONARY_STRING_LENGTH (1 + (MAX_UNCOMPRESSED_STRING_LENGTH + 1 + 1 + 1) * MAX_COMPRESSED_STRINGS + 1 + 1)

typedef struct {
    char uncompressed_string[MAX_UNCOMPRESSED_STRING_LENGTH];
    char compressed_character;
} c_list_compressed_string_dictionary_entry_t;

#define FIRST_USABLE_CHARACER_FOR_COMPRESSION '0'
#define LAST_USABLE_CHARACTER_FOR_COMPRESSION 'z'

static c_list_entry_t * _c_list_get_entry_by_index(const c_list_t * c_list, size_t idx);
static int _c_list_convert_string_token(char * pBuffer, const char * pToken, size_t maxLength, const char * characters_to_compress);
static const char _c_list_get_compressed_character(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_character_count, const char * src, size_t src_size, const unsigned char * used_characters, char * current_unused_character);
static char _c_list_create_compressed_character(const unsigned char * used_characters, char * current_unused_character);
static void _c_list_compress_string_token(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_string_count, char * pBuffer, const char * pToken, size_t maxLength, const unsigned char * used_characters, char * current_unused_character);
static size_t _c_list_get_token(const char * pBuffer, char * pToken, size_t maxLength, int remove_escape_characters);
static size_t _c_list_remove_escape_characters(const char * src, char * dest, size_t dest_length);
static c_list_error_t _c_list_import_normal_string(c_list_t * c_list, const char * str, int compress);
static c_list_error_t _c_list_import_min_max_step_string(c_list_t * c_list, const char * str);
static c_list_error_t _c_list_export_min_max_step_string(const c_list_t * c_list, char * str, size_t size);
static void _c_list_parse_compressed_string_dictionary(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_string_count, const char * str_dictionary);
static void _c_list_get_used_characters(const c_list_t * c_list, unsigned char * used_characters);
static c_list_error_t _c_list_export_normal_string(const c_list_t * c_list, char * str, size_t size, int compress);
static c_list_entry_t * _c_list_entry_create(const c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined);
static c_list_error_t _c_list_entry_delete(const c_list_t * c_list, c_list_entry_t * entry);
static c_list_error_t _c_list_entry_copy(c_list_entry_t * dest, const c_list_entry_t * src);

static c_list_entry_t * _c_list_entry_create(const c_list_t * c_list, c_list_num_t num, const char * str, user_defined_t user_defined)
{
#ifndef CLIST_USE_THREADX
    c_list_entry_t * c_list_entry = NULL;

    if (!c_list)
    {
        return NULL;
    }
    c_list_entry = (c_list_entry_t *) c_list->malloc(sizeof(c_list_entry_t));

#else
    c_list_entry_t * c_list_entry = red_block_pool_allocate(&_red_block_pool_c_list_entry_t);

    if (!c_list_entry)
    {
#ifdef CLIST_USE_LOGGER
        log_error("cList block pool full\n");
#endif
        return NULL;
    }
#endif

    c_list_entry->num = num;
    strlcpy(c_list_entry->str, str, sizeof(c_list_entry->str));
    c_list_entry->user_defined = user_defined;
    c_list_entry->next = NULL;
    c_list_entry->prev = NULL;
    return c_list_entry;
}


static c_list_entry_t * _c_list_get_entry_by_index(const c_list_t * c_list, size_t idx)
{
    c_list_entry_t * cur = NULL;
    if (!c_list)
    {
        return NULL;
    }

    cur = c_list->head;

    while (idx--)
    {
        if (cur)
        {
            cur = cur->next;
        }
        else
        {
            break;
        }
    }

    return cur;
}

static c_list_error_t _c_list_entry_copy(c_list_entry_t * dest, const c_list_entry_t * src)
{
    if (!dest || !src)
    {
        return C_LIST_PARAM_ERROR;
    }

    dest->num = src->num;
    strlcpy(dest->str, src->str, sizeof(dest->str));
    dest->user_defined = src->user_defined;

    return C_LIST_SUCCESS;
}

/* Import a list based on strings (From an RCP Command for Example)
 * String lists are used to transmit lists through the RCP protocol.
 * To pass them as RCP data the lists is put into one long parameter
 * The separator for fields inside the lists is '|'
 * The first field in a list has to be a number for the currently active
 * element in the list. After that the list number / list string pairs
 * are following. Pointers in lists are ignored.
 */

static int _c_list_convert_string_token(char * pBuffer, const char * pToken, size_t maxLength, const char * characters_to_escape)
{
    size_t ii = 0;

    if (!characters_to_escape)
    {
#ifdef CLIST_USE_LOGGER
        log_error("NULL characters to escape\n");
#endif
        return 0;
    }

    /* Loop through token we are adding */
    while (*pToken != '\0')
    {
        /* Deal with Escape Characters */
        size_t jj = 0;
        while (characters_to_escape[jj] != '\0')
        {
            if (*pToken == characters_to_escape[jj])
            {
                pBuffer[ii++] = ESCAPE_CHAR;
                break;
            }

            jj++;
        }

        /* Add character */
        pBuffer[ii++] = *pToken++;

        if (ii >= maxLength)
        {
            return 0;
        }
    }

    pBuffer[ii++] = 0;

    return 1;
}

const char _c_list_get_compressed_character(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_string_count, const char * src, size_t src_size, const unsigned char * used_characters, char * current_unused_character)
{
    size_t ii = 0;
    size_t idx;
    char tmp;

    if (!src)
    {
#ifdef CLIST_USE_LOGGER
        log_error("NULL source\n");
#endif
        return 0;
    }

    for (ii = 0; ii < *compressed_string_count; ii++)
    {
        if (strcmp(compressed_string_dictionary[ii].uncompressed_string, src) == 0)
        {
            return compressed_string_dictionary[ii].compressed_character;
        }
    }

    if (*compressed_string_count == MAX_COMPRESSED_STRINGS)
    {
        return 0;
    }

    /* Add string to the compressed dictionary */
    idx = *compressed_string_count;

    if (src_size > sizeof(compressed_string_dictionary[idx].uncompressed_string))
    {
#ifdef CLIST_USE_LOGGER
        log_error("Uncompressed string too large to store: %s\n", src);
#endif
        return 0;
    }

    tmp = _c_list_create_compressed_character(used_characters, current_unused_character);
    if (tmp)
    {
        (*compressed_string_count)++;
        strncpy(compressed_string_dictionary[idx].uncompressed_string, src, src_size);

        compressed_string_dictionary[idx].compressed_character = tmp;
    }

    return tmp;
}

char _c_list_create_compressed_character(const unsigned char * used_characters, char * current_unused_character)
{
    /* Find next available unused character */
    char compressed_character = 0;
    while (*current_unused_character <= LAST_USABLE_CHARACTER_FOR_COMPRESSION)
    {
        /* Since the dictionary separator character falls in the range
         * of compressed characters that can be used it must be skipped
         * */
        if (*current_unused_character != COMPRESSED_STRING_DICTIONARY_SEPARATOR_CHAR)
        {
            if (!used_characters[*current_unused_character - FIRST_USABLE_CHARACER_FOR_COMPRESSION])
            {
                compressed_character = *current_unused_character;
                (*current_unused_character)++;
                break;
            }
        }
        (*current_unused_character)++;
    }
    return compressed_character;
}

/* For lists that are too long attempt to compress the string by
 * generating a dictionary that will be passed with the stringified
 * list */
static void _c_list_compress_string_token(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_string_count, char * dest, const char * src, size_t dest_size, const unsigned char * used_characters, char * current_unused_character)
{
    if (dest_size == 0)
    {
        return;
    }

    while (dest_size != 1 && *src)
    {
        int string_to_compress_found = 0;
        size_t ii = 0;

        if (*src == ESCAPE_CHAR)
        {
            *dest++ = *src++;
            dest_size--;
        }
        else
        {
            for (ii = 0; ii < sizeof(c_list_strings_to_compress_1) / sizeof(c_list_strings_to_compress_1[0]); ii++)
            {
                const size_t length = strlen(c_list_strings_to_compress_1[ii]);
                if (strncmp(src, c_list_strings_to_compress_1[ii], length) == 0)
                {
                    /* Find string in dictionary or add it */
                    const char compressed_character = _c_list_get_compressed_character(compressed_string_dictionary, compressed_string_count, c_list_strings_to_compress_1[ii], length, used_characters, current_unused_character);
                    if (compressed_character)
                    {
                        *dest++ = compressed_character;
                        src += length;
                        dest_size--;
                        string_to_compress_found = 1;
                        break;
                    }
                }
            }
        }

        if (!string_to_compress_found)
        {
            *dest++ = *src++;
            dest_size--;
        }
    }

    *dest = '\0';
}

static size_t _c_list_get_token(const char * pBuffer, char * pToken, size_t maxLength, int remove_escape_characters)
{
    size_t count = 0;

    /* Check for end of list */
    if (*pBuffer == '\0')
    {
        return 0;
    }

    /* Loop through token until we hit a separator */
    while (*pBuffer != SEPARATOR_CHAR && *pBuffer != 0)
    {
        /* Deal with Escape characters */
        if (*pBuffer == ESCAPE_CHAR)
        {
            if (remove_escape_characters)
            {
                pBuffer++;
                count++;
            }
            else
            {
                *pToken++ = *pBuffer++;
                count++;

                if (count >= maxLength || *pBuffer == 0)
                {
                    return 0;
                }
            }
        }

        *pToken++ = *pBuffer++;
        count++;

        if (count >= maxLength)
        {
            return 0;
        }
    }

    /* Add string terminator to in-buffer string */
    *pToken = '\0';
    return count;
}

static size_t _c_list_remove_escape_characters(const char * src, char * dest, size_t dest_length)
{
    size_t count = 0;

    /* Check for end of list */
    if (*src == '\0')
    {
        return 0;
    }

    while (*src != 0)
    {
        /* Skip Escape characters */
        if (*src == ESCAPE_CHAR)
        {
            src++;
            count++;
        }

        *dest++ = *src++;
        count++;

        if (count >= dest_length)
        {
            return 0;
        }
    }

    /* Add string terminator to in-buffer string */
    *dest = '\0';
    return count;
}

/* Fill in table of used characters in the list.  This table is used by
 * the compressor to reduce matching strings to a single unused
 * character */
static void _c_list_get_used_characters(const c_list_t * c_list, unsigned char * used_characters)
{
    const c_list_entry_t * cur_entry;

    if (!c_list)
    {
#ifdef CLIST_USE_LOGGER
        log_error("NULL clist\n");
#endif

        return;
    }

    if (!used_characters)
    {
#ifdef CLIST_USE_LOGGER
        log_error("NULL used characters\n");
#endif

        return;
    }

    cur_entry = c_list->head;
    while (cur_entry)
    {
        const char * tmp = cur_entry->str;
        while (*tmp != '\0')
        {
            /* Make sure the character is in the range of usable
             * characters for compression */
            if (*tmp >= FIRST_USABLE_CHARACER_FOR_COMPRESSION && *tmp <= LAST_USABLE_CHARACTER_FOR_COMPRESSION)
            {
                /* Mark character as used */
                used_characters[*tmp - FIRST_USABLE_CHARACER_FOR_COMPRESSION] = 1;
            }
            tmp++;
        }

        cur_entry = cur_entry->next;
    }
}

static c_list_error_t _c_list_export_normal_string(const c_list_t * c_list, char * str, size_t size, int compress)
{
    size_t cur;
    int cur_int;
    char buff[2 * C_LIST_MAX_STRING_LEN + 1];     /* we use 2*C_LIST_MAX_STRING_LEN in case each char needs to be escaped */
    const char separator[2] = {SEPARATOR_CHAR, '\0'};
    size_t ii;
    c_list_compressed_string_dictionary_entry_t compressed_string_dictionary[MAX_COMPRESSED_STRINGS] = {0};
    const c_list_entry_t * cur_entry;
    size_t offset = 0;
    unsigned char used_characters[LAST_USABLE_CHARACTER_FOR_COMPRESSION - FIRST_USABLE_CHARACER_FOR_COMPRESSION + 1] = {0};
    char current_unused_character = FIRST_USABLE_CHARACER_FOR_COMPRESSION;

    size_t compressed_string_count = 0;

    if (!c_list || !str)
    {
        return C_LIST_PARAM_ERROR;
    }

    str[0] = 0;

    /* Add list type */
    if (compress)
    {
        snprintf(buff, sizeof(buff), "%d", C_LIST_STRING_TYPE_COMPRESSED);

        _c_list_get_used_characters(c_list, used_characters);
    }
    else
    {
        snprintf(buff, sizeof(buff), "%d", C_LIST_STRING_TYPE_NORMAL);
    }

    offset += strlcat(str + offset, buff, size - offset);
    if (size <= offset)
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    offset += strlcat(str + offset, separator, size - offset);
    if (size <= offset)
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add current index */
    if (C_LIST_SUCCESS != c_list_get_index(c_list, &cur))
    {
        cur_int = -1;
    }
    else
    {
        cur_int = (int) cur;
    }

    snprintf(buff, sizeof(buff), "%d", cur_int);
    offset += strlcat(str + offset, buff, size - offset);
    if (size <= offset)
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    offset += strlcat(str + offset, separator, size - offset);
    if (size <= offset)
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Loop through all entries */
    cur_entry = c_list->head;
    while (cur_entry)
    {
        /* Add number */
        snprintf(buff, sizeof(buff), "%d", cur_entry->num);
        offset += strlcat(str + offset, buff, size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }
        offset += strlcat(str + offset, separator, size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }

        /* Add string */
        if (compress)
        {
            char tmp[2 * C_LIST_MAX_STRING_LEN + 1] = {0};
            char tmp2[2 * C_LIST_MAX_STRING_LEN + 1] = {0};
            const char characters_to_compress_1[] = {SEPARATOR_CHAR, ESCAPE_CHAR, COMPRESSED_STRING_DICTIONARY_START_CHAR, COMPRESSED_STRING_DICTIONARY_END_CHAR, COMPRESSED_STRING_DICTIONARY_SEPARATOR_CHAR, '\0'};
            const char characters_to_compress_2[] = {SEPARATOR_CHAR, ESCAPE_CHAR, COMPRESSED_STRING_DICTIONARY_START_CHAR, '\0'};

            /* Escape characters in string compressing.
             * Uncompressed values in the dictionary must be escaped
             * in order to parse the dicationary correctly on import.
             * Escape characters are removed when uncompressing */
            if (!_c_list_convert_string_token(tmp, cur_entry->str, sizeof(tmp), characters_to_compress_1))
            {
                return C_LIST_MEM_ERROR;
            }

            /* Create dictionary and generate compressed version of the
             * stringified list */
            _c_list_compress_string_token(compressed_string_dictionary, &compressed_string_count, buff, tmp, sizeof(buff), used_characters, &current_unused_character);

            /* The uncompressed values in the dictionary should escape
             * both the characters used for the stringified clist
             * syntax (SEPARATOR_CHAR) as well as the characters in the
             * dictionary syntax (COMPRESSED_STRING_DICTIONARY_...)
             * The strings in the stringified clist should only escape
             * the characters used for the stingified clist syntax
             * (SEPARATOR_CHAR). Thus we remove the dictionary specific
             * characters here and then add clist specific  ones to
             * create the stringified list */
            _c_list_remove_escape_characters(buff, tmp2, sizeof(tmp2));

            if (!_c_list_convert_string_token(buff, tmp2, sizeof(buff), characters_to_compress_2))
            {
                return C_LIST_MEM_ERROR;
            }
        }
        else
        {
            const char characters_to_compress[] = {SEPARATOR_CHAR, ESCAPE_CHAR, '\0'};
            if (!_c_list_convert_string_token(buff, cur_entry->str, sizeof(buff), characters_to_compress))
            {
                return C_LIST_MEM_ERROR;
            }
        }

        offset += strlcat(str + offset, buff, size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }
        offset += strlcat(str + offset, separator, size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }

        cur_entry = cur_entry->next;
    }

    /* For compressed lists add dictionary */
    if (compress)
    {
        offset += strlcat(str + offset, "{", size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }

        for (ii = 0; ii < compressed_string_count; ii++)
        {
            const char dictionary_separator[] = {COMPRESSED_STRING_DICTIONARY_SEPARATOR_CHAR, '\0'};

            /* Strings in the dictionary were already escaped when they were
             * added, they should not be escaped again */
            offset += strlcat(str + offset, compressed_string_dictionary[ii].uncompressed_string, size - offset);
            if (size <= offset)
            {
                return C_LIST_BUFFER_FULL_ERROR;
            }

            offset += strlcat(str + offset, dictionary_separator, size - offset);
            if (size <= offset)
            {
                return C_LIST_BUFFER_FULL_ERROR;
            }

            /* Compressed strings in the dicationary were already
             * escaped when they were added, they should not be escaped
             * again */
            str[offset] = compressed_string_dictionary[ii].compressed_character;
            offset++;
            if (size <= offset)
            {
                return C_LIST_BUFFER_FULL_ERROR;
            }
            str[offset] = '\0';

            offset += strlcat(str + offset, separator, size - offset);
            if (size <= offset)
            {
                return C_LIST_BUFFER_FULL_ERROR;
            }
        }

        offset += strlcat(str + offset, "}", size - offset);
        if (size <= offset)
        {
            return C_LIST_BUFFER_FULL_ERROR;
        }
    }

    return C_LIST_SUCCESS;
}

static c_list_error_t _c_list_export_min_max_step_string(const c_list_t * c_list, char * str, size_t size)
{
    size_t cur;
    int cur_int;
    char buff[2 * C_LIST_MAX_STRING_LEN + 1];     /* we use 2*C_LIST_MAX_STRING_LEN in case each char needs to be escaped */
    const char separator[2] = {SEPARATOR_CHAR, 0};
    const char characters_to_compress[] = {SEPARATOR_CHAR, ESCAPE_CHAR, '\0'};

    if (!c_list || !str)
    {
        return C_LIST_PARAM_ERROR;
    }

    str[0] = 0;

    /* Add list type */
    snprintf(buff, sizeof(buff), "%d", C_LIST_STRING_TYPE_MIN_MAX_STEP);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add current index */
    if (C_LIST_SUCCESS != c_list_get_index(c_list, &cur))
    {
        cur_int = -1;
    }
    else
    {
        cur_int = (int) cur;
    }

    snprintf(buff, sizeof(buff), "%d", cur_int);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Min */
    snprintf(buff, sizeof(buff), "%d", c_list->step_options.min);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Max */
    snprintf(buff, sizeof(buff), "%d", c_list->step_options.max);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Step */
    snprintf(buff, sizeof(buff), "%d", c_list->step_options.step);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Divider */
    snprintf(buff, sizeof(buff), "%d", c_list->step_options.divider);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Precision */
    snprintf(buff, sizeof(buff), "%d", c_list->step_options.precision);
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Prefix */
    if (!_c_list_convert_string_token(buff, c_list->step_options.prefix, sizeof(buff), characters_to_compress))
    {
        return C_LIST_MEM_ERROR;
    }
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    /* Add Postfix */
    if (!_c_list_convert_string_token(buff, c_list->step_options.postfix, sizeof(buff), characters_to_compress))
    {
        return C_LIST_MEM_ERROR;
    }
    if (size <= strlcat(str, buff, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }
    if (size <= strlcat(str, separator, size))
    {
        return C_LIST_BUFFER_FULL_ERROR;
    }

    return C_LIST_SUCCESS;
}

void _c_list_parse_compressed_string_dictionary(c_list_compressed_string_dictionary_entry_t * compressed_string_dictionary, size_t * compressed_string_count, const char * str_dictionary)
{
    if (!str_dictionary)
    {
#ifdef CLIST_USE_LOGGER
        log_error("NULL compressed string dictionary\n");
#endif
        return;
    }

    while (*compressed_string_count < MAX_COMPRESSED_STRINGS)
    {
        int src_index = 0;
        int uncompressed_string_index = 0;

        /* Each token in the dictionary contains both the compressed
         * and uncompressed string separated by a colon */
        char token[MAX_UNCOMPRESSED_STRING_LENGTH + 1 + 1];

        /* Get the next token from the string.  Do not remove escape
         * characters here since they are sill needed to parse the
         * token correctly.  The escape characters will be removed when
         * decompressing for import  */
        const size_t len = _c_list_get_token(str_dictionary, token, sizeof(token), 0);
        if (len == 0)
        {
            break;
        }
        str_dictionary = str_dictionary + len + 1;

        /* Separate the uncompressed and compressed values from the
         * token */
        while (token[src_index] != '\0')
        {
            if (token[src_index] != ESCAPE_CHAR)
            {
                /* The character following the separator is the
                 * compressed character */
                if (token[src_index] == COMPRESSED_STRING_DICTIONARY_SEPARATOR_CHAR)
                {
                    compressed_string_dictionary[*compressed_string_count].uncompressed_string[uncompressed_string_index] = '\0';
                    src_index++;
                    compressed_string_dictionary[*compressed_string_count].compressed_character = token[src_index];
                    break;
                }
                else
                {
                    compressed_string_dictionary[*compressed_string_count].uncompressed_string[uncompressed_string_index++] = token[src_index++];
                }
            }
            else
            {
                compressed_string_dictionary[*compressed_string_count].uncompressed_string[uncompressed_string_index++] = token[src_index++];
                if (token[src_index] != '\0')
                {
                    compressed_string_dictionary[*compressed_string_count].uncompressed_string[uncompressed_string_index++] = token[src_index++];
                }
            }
        }

        (*compressed_string_count)++;
    }
}

static c_list_error_t _c_list_import_normal_string(c_list_t * c_list, const char * str, int compress)
{
    int idx;
    size_t len;
    char buffer1[2 * C_LIST_MAX_STRING_LEN + 1]; /* we use 2*C_LIST_MAX_STRING_LEN in case each char needs to be escaped */
    c_list_entry_t listEntry;
    c_list_error_t err;
    c_list_compressed_string_dictionary_entry_t compressed_string_dictionary[MAX_COMPRESSED_STRINGS] = {0};
    size_t compressed_string_count = 0;

    if (!c_list || !str)
    {
        return C_LIST_PARAM_ERROR;
    }

    /* Parse the compressed string dictionary */
    if (compress)
    {
        int ii = 0;
        int dictionary_start = -1;
        int dictionary_end = -1;

        /* Find the start and end of the dictionary */
        while (str[ii] != '\0')
        {
            if (str[ii] == ESCAPE_CHAR)
            {
                if (str[ii + 1] == '\0')
                {
                    break;
                }

                ii += 2;
                continue;
            }

            if (str[ii] == COMPRESSED_STRING_DICTIONARY_START_CHAR)
            {
                dictionary_start = ii + 1;
            }
            else if (dictionary_start != -1 && str[ii] == COMPRESSED_STRING_DICTIONARY_END_CHAR)
            {
                dictionary_end = ii - 2;
                break;
            }
            ii++;
        }

        /* Valid dicationary was found so parse it and fill in the
         * dictionary structure */
        if (dictionary_start > 0 && dictionary_end > 0 && dictionary_start < dictionary_end)
        {
            const size_t str_dictionary_size = dictionary_end - dictionary_start + 1;
            if (str_dictionary_size <= MAX_DICTIONARY_STRING_LENGTH)
            {
                char str_dictionary[MAX_DICTIONARY_STRING_LENGTH] = {0};
                strncpy(str_dictionary, str + dictionary_start, str_dictionary_size);
                _c_list_parse_compressed_string_dictionary(compressed_string_dictionary, &compressed_string_count, str_dictionary);
            }
            else
            {
#ifdef CLIST_USE_LOGGER
                log_error("String dictionary too large to fit in buffer\n");
#endif
                return C_LIST_BUFFER_FULL_ERROR;
            }
        }
    }

    /* Get current index */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
    {
        return C_LIST_NO_DATA_ERROR;
    }
    str = str + len + 1;
    idx = atoi(buffer1);

    for (;; )
    {
        user_defined_t user_defined;

        /* Do not attempt to uncompress the dictionary.  This assumes
         * the dictionary is at the very end of the string */
        if (*str == COMPRESSED_STRING_DICTIONARY_START_CHAR)
        {
            break;
        }

        /* Get Value */
        len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
        if (len == 0)
            break;
        str = str + len + 1;
        listEntry.num = atoi(buffer1);

        /* Get String */
        len = _c_list_get_token(str, buffer1, sizeof(buffer1), compress ? 0 : 1);
        str = str + len;
        if (*str == SEPARATOR_CHAR)
            str += 1;

        /* Expand compressed strings */
        if (compress)
        {
            size_t src_index = 0;
            int dest_index = 0;
            memset(listEntry.str, 0, sizeof(listEntry.str));

            /* Iterate over each character in the buffer and compare
             * it to each of the compressed characters in the
             * dictionary.  If a match is found copy the corresponding
             * uncompressed string otherwise copy the character itself */
            while (src_index < len)
            {
                int compressed_string_found = 0;
                size_t ii = 0;

                /* Ignore escaped characters */
                if (buffer1[src_index] == ESCAPE_CHAR)
                {
                    src_index++;
                    if (src_index < len)
                    {
                        listEntry.str[dest_index++] = buffer1[src_index++];
                    }
                    continue;
                }

                /* Attempt to find a matching compressed character */
                for (ii = 0; ii < compressed_string_count; ii++)
                {
                    /* If a match is found copy the corresponding
                     * uncompressed value.  This assumes that only one
                     * compressed string will match.  To make this
                     * generic it must be assumed that more than one
                     * compressed string can match and the longest
                     * matching string must be found (requires
                     * iterating over all of the entries) */
                    if (buffer1[src_index] == compressed_string_dictionary[ii].compressed_character)
                    {
                        /* Remove any escape characters that were added
                         * to the dictionary */
                        char tmp[MAX_UNCOMPRESSED_STRING_LENGTH] = {0};
                        _c_list_remove_escape_characters(compressed_string_dictionary[ii].uncompressed_string, tmp, sizeof(tmp));

                        strncpy(listEntry.str + dest_index, tmp, strlen(tmp));
                        dest_index += strlen(tmp);
                        src_index++;
                        compressed_string_found = 1;
                        break;
                    }
                }

                if (!compressed_string_found)
                {
                    listEntry.str[dest_index++] = buffer1[src_index++];
                }
            }
        }
        else
        {
            strlcpy(listEntry.str, buffer1, sizeof(listEntry.str));
        }

        /* Add to List */
        user_defined.ptr = NULL;
        user_defined.int32 = 0;
        listEntry.user_defined.ptr = NULL;
        err = c_list_append(c_list, listEntry.num, listEntry.str, user_defined);
        if (err != C_LIST_SUCCESS)
        {
            return err;
        }
    }

    /* Set index */
    if (idx >= 0)
    {
        err = c_list_set_index(c_list, idx);
        if (err != C_LIST_SUCCESS)
        {
            return err;
        }
    }

    return C_LIST_SUCCESS;
}

static c_list_error_t _c_list_import_min_max_step_string(c_list_t * c_list, const char * str)
{
    int idx;
    size_t len;
    char buffer1[2 * C_LIST_MAX_STRING_LEN + 1]; /* we use 2*C_LIST_MAX_STRING_LEN in case each char needs to be escaped */
    c_list_error_t err;
    int min;
    int max;
    int step;
    int divider;
    int precision;
    char prefix[C_LIST_MAX_STRING_LEN];
    char postfix[C_LIST_MAX_STRING_LEN];

    if (!c_list || !str)
    {
        return C_LIST_PARAM_ERROR;
    }

    /* Get current index */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    idx = atoi(buffer1);

    /* Get min */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    min = atoi(buffer1);

    /* Get max */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    max = atoi(buffer1);

    /* Get step */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    step = atoi(buffer1);

    /* Get divider */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    divider = atoi(buffer1);

    /* Get precision */
    len = _c_list_get_token(str, buffer1, sizeof(buffer1), 1);
    if (len == 0)
        return C_LIST_NO_DATA_ERROR;
    str = str + len + 1;
    precision = atoi(buffer1);

    /* Get prefix */
    len = _c_list_get_token(str, prefix, sizeof(prefix), 1);
    str = str + len + 1;

    /* Get postfix */
    (void) _c_list_get_token(str, postfix, sizeof(postfix), 1);

    err = c_list_fill_generic(c_list, min, max, step, divider, precision, postfix, prefix);
    if (err != C_LIST_SUCCESS)
    {
        return err;
    }

    /* Set index */
    if (idx >= 0)
    {
        err = c_list_set_index(c_list, idx);
        if (err != C_LIST_SUCCESS)
        {
            return err;
        }
    }

    return C_LIST_SUCCESS;
}

/********** End file: c_list.c **************************************************/

/********** Begin file: rcp_parser2.c *******************************************/
/* #include "rcp_parser2.h" */
#include <stdlib.h>
#include <string.h>

/* Convert two ASCII characters to number (ASCIIHEX to short) */
static unsigned char ascii2hex16b(const char * valstr);

/* Convert number to two chars */
static void hex2ascii16b(unsigned short num, char * valstr);

static int _RCP_get_and_parse_packet_ext(tRCPParsedPacketState * packetState, char nextChar, int destructive);

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
static int RCP_noBufferRoom(const tRCP * pRcpData, int increase);
static int RCP_getStringSize(const char * pBuffer);
#endif

char * RCP_copyStringChar(char * dst, const char * src, const char * end);

/* Receive Functions */
/* ----------------- */
int RCP_prepareForParsing(tRCP * pRcpData, char * pBuffer, int bufferLength)
{
    /* Setup RCP Structure */
    pRcpData->pBufferPos = pBuffer;
    pRcpData->pParserPos = pBuffer;
    pRcpData->bufferLength = bufferLength;
    pRcpData->pTargetID = 0;
    pRcpData->pSourceID = 0;

    return RCP2_PARSER_OK;
}

/* WARNING: checksum characters are not properly escaped. A sequence of
 * ':*' in a list will be */
/* misinterpreted as a checksum. Just don't do it ;-) */
int RCP_validateChecksum(const tRCP * pRcpData)
{
    unsigned char result = 0;
    unsigned char checksum;
    const char * pScanPos = (char *) (pRcpData->pBufferPos + 1);

    /*  -1 as an index is nasty but it is guaranteed that there is
     *  always a start of message marker before */
    /*  the first character in our array. saves a bunch of code.... */
    while (!((pScanPos[-1] == RCP2_MSG_SEPARATOR_SYMBOL) && (pScanPos[0] == RCP2_MSG_CKSUM_SYMBOL)))
    {
        /* End of Message? Too many characters? No way out.... */
        if (*pScanPos == RCP2_MSG_END1_SYMBOL)
            return RCP2_PARSER_NO_CHECKSUM;

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
        if (pScanPos == (char *) (pRcpData->pBufferPos + pRcpData->bufferLength))
            return RCP2_PARSER_BUFFER_END;
#endif

        result = result ^ *pScanPos;
        pScanPos++;
    }
    /* skip checksum marker */
    pScanPos++;

    /* we got our checksum... now we interpret the next two characters
     * as ASCII hex */
    checksum = ascii2hex16b(pScanPos);

    /* Validate checksum */
    if (checksum != result)
        return RCP2_PARSER_CHECKSUM_MISSMATCH;
    else
        return RCP2_PARSER_OK;
}

int RCP_validateChecksumBinary(const tRCP * pRcpData)
{
    unsigned char result = 0;
    unsigned char checksum;
    const char * pScanPos = (char *) (pRcpData->pBufferPos + 1);

    /*  skip last 4 bytes as it consists of 1 byte of checksum marker,
     *  2 bytes of checksum, and the last byte of end symbol */
    int checksumdatalen = pRcpData->bufferLength - 4;

    /* check checksum marker */
    if (RCP2_MSG_CKSUM_SYMBOL == (pRcpData->pBufferPos[checksumdatalen]))
    {
        /*  Decrease by one as Start symbol is not used for checksum
         *  calculation */
        checksumdatalen--;
        /*  calculate checksum */
        while (0 < checksumdatalen--)
        {
            result = result ^ *pScanPos;
            pScanPos++;
        }
        /* skip checksum marker */
        pScanPos++;

        /* we got our checksum... now we interpret the next two
         * characters as ASCII hex */
        checksum = ascii2hex16b(pScanPos);

        /* Validate checksum */
        if (checksum != result)
            return RCP2_PARSER_CHECKSUM_MISSMATCH;
        else
            return RCP2_PARSER_OK;
    }
    else
    {
        return RCP2_PARSER_NO_CHECKSUM;
    }
}

int RCP_parseHeader(tRCP * pRcpData, const char * pDeviceID, char * pCmd)
{
    const char * pScanPos;
    const char * pCmdToken;

    /* Validate valid Marker */
    if (*pRcpData->pParserPos != RCP2_MSG_START_SYMBOL)
        return RCP2_PARSER_NO_HEADER;

    /* If the first parameter is a target ID we set the pointer */
    pRcpData->pParserPos++;
    if (*pRcpData->pParserPos == RCP2_MSG_TARGET_SYMBOL)
        pRcpData->pTargetID = pRcpData->pParserPos + 1;

    /* Look for start of source id */
    /* TODO: we should check for end of message characters so we do not
     * loop endlessly on data... */
    while (*pRcpData->pParserPos != RCP2_MSG_SOURCE_SYMBOL)
    {
        pRcpData->pParserPos++;

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
        if (pRcpData->pParserPos == (pRcpData->pBufferPos + pRcpData->bufferLength))
            return RCP2_PARSER_BUFFER_END;
#endif
    }

    /* Replace symbol with end of string */
    *pRcpData->pParserPos = '\0';

    /* Extract Source ID */
    pRcpData->pSourceID = RCP_getNextToken(pRcpData);

    /* Extract Command */
    if (0 == (pCmdToken = RCP_getNextToken(pRcpData)))
    {
        return RCP2_PARSER_NO_COMMAND;
    }
    *pCmd = *pCmdToken;

    /* Validate Device ID */
    if (pRcpData->pTargetID)
    {
        pScanPos = pRcpData->pTargetID;
        /* Compare with Device ID */
        while (*pDeviceID != '\0')
        {
            if (*pScanPos != *pDeviceID)
                return RCP2_PARSER_WRONG_ID;
            pScanPos++;
            pDeviceID++;
        }
    }
    return RCP2_PARSER_OK;
}

char * RCP_getNextToken(tRCP * pRcpData)
{
    char * pCopyPos;
    char * pStringPos;

    /* Check for end of Token list */
    if ((*pRcpData->pParserPos == RCP2_MSG_END1_SYMBOL) || (*pRcpData->pParserPos == RCP2_MSG_CKSUM_SYMBOL))
        return 0;

    /* Skip first character as it is a separator */
    pRcpData->pParserPos++;

    /* Init Copy Position */
    pCopyPos = pRcpData->pParserPos;
    pStringPos = pRcpData->pParserPos;

    /* Loop through token until we hit a separator */
    do
    {
        /* Deal with Escape characters */
        if (*pRcpData->pParserPos == RCP2_MSG_ESCAPE_SYMBOL)
            pRcpData->pParserPos++;

        /* Copy character */
        *pCopyPos = *pRcpData->pParserPos;

        /* Advance one character */
        pRcpData->pParserPos++;
        pCopyPos++;

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
        if (pRcpData->pParserPos == (pRcpData->pBufferPos + pRcpData->bufferLength))
            return 0;
#endif
    }
    while (*pRcpData->pParserPos != RCP2_MSG_SEPARATOR_SYMBOL);

    /* Add string terminator to in-buffer string */
    *pCopyPos = '\0';
    return pStringPos;
}

/* Send Functions */
/* -------------- */

int RCP_buildHeader(tRCP * pRcpData, char * pBuffer, int bufferLength, const char * pSourceID, const char * pTargetID, char Cmd)
{
    /* Setup RCP Structure */
    pRcpData->pBufferPos = pBuffer;
    pRcpData->pParserPos = pBuffer;
    pRcpData->bufferLength = bufferLength;

    /* Fill in Header into Buffer */
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for the header */
    if (RCP_noBufferRoom(pRcpData, 10))
        return RCP2_PARSER_BUFFER_FULL;
#endif

    /* Add Header Start */
    *pRcpData->pParserPos++ = RCP2_MSG_START_SYMBOL;

    /* Add optional Target ID */
    if (pTargetID && *pTargetID)
    {
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
        /* Check if we have room for the header */
        if (RCP_noBufferRoom(pRcpData, RCP_getStringSize(pTargetID) + 1))
            return RCP2_PARSER_BUFFER_FULL;
#endif
        /* Add Target Marker */
        *pRcpData->pParserPos++ = RCP2_MSG_TARGET_SYMBOL;
        /* Add Target ID */
        pRcpData->pParserPos = RCP_copyStringChar(pRcpData->pParserPos, pTargetID, pBuffer + bufferLength);
    }

    /* Add Source Marker */
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for the header */
    if (RCP_noBufferRoom(pRcpData, RCP_getStringSize(pSourceID) + 1))
        return RCP2_PARSER_BUFFER_FULL;
#endif
    /* Add Source Marker */
    *pRcpData->pParserPos++ = RCP2_MSG_SOURCE_SYMBOL;
    /* Add Target ID */
    pRcpData->pParserPos = RCP_copyStringChar(pRcpData->pParserPos, pSourceID, pBuffer + bufferLength);

    /* Add Command */
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for the header */
    if (RCP_noBufferRoom(pRcpData, 2))
        return RCP2_PARSER_BUFFER_FULL;
#endif
    *pRcpData->pParserPos++ = RCP2_MSG_SEPARATOR_SYMBOL;
    *pRcpData->pParserPos++ = Cmd;
    *pRcpData->pParserPos++ = RCP2_MSG_SEPARATOR_SYMBOL;

    return RCP2_PARSER_OK;
}

int RCP_addToken(tRCP * pRcpData, const char * pToken)
{
    /* Loop through token we are adding */
    while (*pToken != '\0')
    {
        /* Deal with Escape Characters */
        if (
            (*pToken == RCP2_MSG_START_SYMBOL) ||
            (*pToken == RCP2_MSG_TARGET_SYMBOL) ||
            (*pToken == RCP2_MSG_SOURCE_SYMBOL) ||
            (*pToken == RCP2_MSG_SEPARATOR_SYMBOL) ||
            (*pToken == RCP2_MSG_CKSUM_SYMBOL) ||
            (*pToken == RCP2_MSG_ESCAPE_SYMBOL)
           )
        {
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
            /* Check if we have room for escape character */
            if (RCP_noBufferRoom(pRcpData, 1))
                return RCP2_PARSER_BUFFER_FULL;
#endif
            *(pRcpData->pParserPos++) = RCP2_MSG_ESCAPE_SYMBOL;
        }
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
        /* Check if we have room for character */
        if (RCP_noBufferRoom(pRcpData, 1))
            return RCP2_PARSER_BUFFER_FULL;
#endif
        /* Add character */
        *(pRcpData->pParserPos++) = *pToken;

        /* Move us forward... */
        pToken++;
    }

    /* Add Separator */
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for the header */
    if (RCP_noBufferRoom(pRcpData, 1))
        return RCP2_PARSER_BUFFER_FULL;
#endif
    *(pRcpData->pParserPos++) = RCP2_MSG_SEPARATOR_SYMBOL;

    return RCP2_PARSER_OK;
}

int RCP_addChecksum(tRCP * pRcpData)
{
    unsigned char result = 0;
    const char * pBufPos = pRcpData->pBufferPos + 1;

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for checksum */
    if (RCP_noBufferRoom(pRcpData, 3))
        return RCP2_PARSER_BUFFER_FULL;
#endif

    /* Calculate Checksum */
    while (pBufPos != pRcpData->pParserPos)
    {
        result = result ^ *pBufPos;
        pBufPos++;
    }
    /* Append Checksum marker */
    *(pRcpData->pParserPos++) = RCP2_MSG_CKSUM_SYMBOL;

    /* Append Checksum */
    hex2ascii16b(result, pRcpData->pParserPos++);

    pRcpData->pParserPos++;
    return RCP2_PARSER_OK;
}

int RCP_finalizeMessage(tRCP * pRcpData)
{
#ifdef RCP2_CHECK_BUFFER_OVERFLOW
    /* Check if we have room for termination */
    if (RCP_noBufferRoom(pRcpData, 2))
        return RCP2_PARSER_BUFFER_FULL;
#endif

    /* Append termination character */
    *(pRcpData->pParserPos++) = RCP2_MSG_END1_SYMBOL;

    /* Just to make life easier we terminate the string here... */
    *(pRcpData->pParserPos++) = '\0';

    /* Return final size */
    return (int) ((pRcpData->pParserPos - 1) - pRcpData->pBufferPos);  /* While calculating size, do not include '\0' at the end of RCP message. */
}

/* Wrapper Function */
/* ---------------- */

int RCP_buildMessage(char * pBuffer, int maxSize, const char * pSource, const char * pTarget, char cmd, const char * pParam, const char * pValue, char addChecksum)
{
    tRCP rcpBuffer;
    int returnVal;

    /* Lets create a header */
    returnVal = RCP_buildHeader(&rcpBuffer, pBuffer, maxSize, pSource, pTarget, cmd);
    if (returnVal != RCP2_PARSER_OK)
        return returnVal;

    /* Add Param */
    returnVal = RCP_addToken(&rcpBuffer, pParam);
    if (returnVal != RCP2_PARSER_OK)
        return returnVal;

    /* Add Value */
    returnVal = RCP_addToken(&rcpBuffer, pValue);
    if (returnVal != RCP2_PARSER_OK)
        return returnVal;

    /* Add Optional checksum */
    if (addChecksum)
    {
        returnVal = RCP_addChecksum(&rcpBuffer);
        if (returnVal != RCP2_PARSER_OK)
            return returnVal;
    }

    /* Finalize */
    return RCP_finalizeMessage(&rcpBuffer);
}

int RCP_parseMessage(char * pBuffer, int bufferSize, const char * myDeviceId, char * * senderID, char * pCmd, char * * pParam, char * * pValue)
{
    tRCP rcpBuffer;
    int returnVal;

    /* Prepare for Parsing */
    returnVal = RCP_prepareForParsing(&rcpBuffer, pBuffer, bufferSize);
    if (returnVal != RCP2_PARSER_OK)
        return returnVal;

    /* Validate checksum */
    returnVal = RCP_validateChecksumBinary(&rcpBuffer);
    if ((returnVal != RCP2_PARSER_NO_CHECKSUM) && (returnVal != RCP2_PARSER_OK))
        return returnVal;

    /* Parse Header */
    returnVal = RCP_parseHeader(&rcpBuffer, myDeviceId, pCmd);
    if (returnVal != RCP2_PARSER_OK)
        return returnVal;

    *senderID = rcpBuffer.pSourceID;
    /* Extract Parameter */
    if (0 == (*pParam = RCP_getNextToken(&rcpBuffer)))
    {
        *pValue = 0;
        return RCP2_PARSER_NO_PARAMETER;
    }

    /* Extract Value */
    if (0 == (*pValue = RCP_getNextToken(&rcpBuffer)))
        return RCP2_PARSER_NO_VALUE;

    return RCP2_PARSER_OK;
}

/* Helper functions */
/* ---------------- */
int RCP_getVersion(void)
{
    return (int) RCP2_VERSION;
}

static unsigned char ascii2hex16b(const char * valstr)
{
    unsigned char val;

    if (valstr[0] <= '9')
        val = valstr[0] - '0';
    else
        val = 10 + (valstr[0] - 'A');

    val *= 16;

    if (valstr[1] <= '9')
        val += valstr[1] - '0';
    else
        val += 10 + (valstr[1] - 'A');

    return val;
}

static void hex2ascii16b(unsigned short num, char * valstr)
{
    /* Append as string */
    int digit = num / 16;
    if (digit < 10)
        valstr[0] = (char) ('0' + digit);
    else
        valstr[0] = (char) ('A' + (digit - 10));

    digit = num % 16;
    if (digit < 10)
        valstr[1] = (char) ('0' + digit);
    else
        valstr[1] = (char) ('A' + (digit - 10));
}

/* Specific copy.... Copy string characters (Not terminator) */
/* up to a specific length.... */
char * RCP_copyStringChar(char * dst, const char * src, const char * end)
{
    do
    {
        *dst = *src;
        src++;
        dst++;
    }
    while ((*src != '\0') && (dst <= end));
    return dst;
}

#ifdef RCP2_CHECK_BUFFER_OVERFLOW
static int RCP_getStringSize(const char * pBuffer)
{
    int ii = 0;
    while (pBuffer[ii] != '\0')
        ii++;

    return ii;
}

static int RCP_noBufferRoom(const tRCP * pRcpData, int increase)
{
    if (((pRcpData->pParserPos - pRcpData->pBufferPos) + increase) > pRcpData->bufferLength)
        return 1;
    else
        return 0;
}
#endif

const char * RCP_get_packet(tRCPPacketState * packetState, char nextChar, int * numBytes)
{
    if (!packetState)
    {
        return 0;
    }

    if (packetState->len >= (packetState->buf_len - 2))
    {
        /*  RCP receive buffer full */
        packetState->len = packetState->buf_len - 2;
    }

    if (packetState->escaped && packetState->in_packet)
    {
        /* This character has no special meaning */
        packetState->buf[packetState->len++] = nextChar;
        packetState->escaped = 0;
        if (numBytes)
        {
            *numBytes = 0;
        }
        return 0;
    }

    if (packetState->skip_bytes && packetState->in_packet)
    {
        packetState->buf[packetState->len++] = nextChar;
        packetState->skip_bytes--;
        if (numBytes)
        {
            *numBytes = 0;
        }
        return 0;
    }

    switch (nextChar)
    {
        case RCP2_MSG_START_SYMBOL:
            packetState->len = 0;
            packetState->buf[packetState->len++] = nextChar;
            packetState->in_packet = 1;
            packetState->is_binary = 0;
            packetState->skip_bytes = 0;
            packetState->parsed.pCmd = 0;
            packetState->parsed.pTarget = 0;
            packetState->parsed.pSource = 0;
            packetState->parsed.pParam = 0;
            packetState->parsed.pArg = 0;
            packetState->parsed.pExtra = 0;
            break;

        case RCP2_MSG_END1_SYMBOL:
        case RCP2_MSG_END2_SYMBOL:
            if (packetState->in_packet)
            {
                packetState->buf[packetState->len++] = RCP2_MSG_END1_SYMBOL;
                packetState->buf[packetState->len++] = 0;
                if (numBytes)
                {
                    *numBytes = packetState->len - 1;
                }
                packetState->len = 0;
                packetState->in_packet = 0;
                return packetState->buf;
            }
            break;

        case RCP2_MSG_ESCAPE_SYMBOL:
            if (packetState->in_packet)
            {
                packetState->buf[packetState->len++] = nextChar;
                packetState->escaped = 1;
            }
            break;

        default:
            if (packetState->in_packet)
            {
                packetState->buf[packetState->len++] = nextChar;

                switch (nextChar)
                {
                    case RCP2_MSG_TARGET_SYMBOL:
                        packetState->parsed.pTarget = &(packetState->buf[packetState->len]);
                        break;

                    case RCP2_MSG_SOURCE_SYMBOL:
                        packetState->parsed.pSource = &(packetState->buf[packetState->len]);
                        break;

                    case RCP2_MSG_SEPARATOR_SYMBOL:
                        if (!packetState->parsed.pCmd)
                        {
                            packetState->parsed.pCmd = &(packetState->buf[packetState->len]);
                        }
                        else if (!packetState->parsed.pParam)
                        {
                            packetState->parsed.pParam = &(packetState->buf[packetState->len]);
                        }
                        else if (!packetState->parsed.pArg)
                        {
                            packetState->parsed.pArg = &(packetState->buf[packetState->len]);

                            if (packetState->parsed.pCmd[0] == 'S' &&
                                packetState->parsed.pParam[0] == 'B' &&
                                packetState->parsed.pParam[1] == 'I' &&
                                packetState->parsed.pParam[2] == 'N' &&
                                packetState->parsed.pParam[3] == ':')
                            {
                                /* This is a binary packet */
                                packetState->is_binary = 1;
                            }
                            break;
                        }
                        else if (!packetState->parsed.pExtra)
                        {
                            packetState->parsed.pExtra = &(packetState->buf[packetState->len]);

                            if (packetState->is_binary)
                            {
                                int digits = 0;
                                packetState->skip_bytes = 0;
                                while ((packetState->parsed.pArg[digits] >= '0') && (packetState->parsed.pArg[digits] <= '9'))
                                {
                                    packetState->skip_bytes *= 10;
                                    packetState->skip_bytes += packetState->parsed.pArg[digits] - '0';
                                    digits++;
                                }
                            }
                            break;
                        }
                        break;
                }
            }
            break;
    }
    if (numBytes)
    {
        *numBytes = 0;
    }
    return 0;
}

int RCP_strcmp(const char * s1, const char * s2)
{
    for (;; )
    {
        if (
            (!*s1 || *s1 == RCP2_MSG_SEPARATOR_SYMBOL || *s1 == RCP2_MSG_SOURCE_SYMBOL) &&
            (!*s2 || *s2 == RCP2_MSG_SEPARATOR_SYMBOL || *s2 == RCP2_MSG_SOURCE_SYMBOL)
           )
        {
            return 0;
        }

        if (*s1 == RCP2_MSG_ESCAPE_SYMBOL)
        {
            s1++;
        }

        if (*s2 == RCP2_MSG_ESCAPE_SYMBOL)
        {
            s2++;
        }

        if (*s1 != *s2)
        {
            return *(const unsigned char *) s1 - *(const unsigned char *) s2;
        }

        s1++;
        s2++;
    }
}

size_t RCP_strlcpy(char * dst, const char * src, size_t siz)
{
    size_t retval = 0;
    char * d = dst;
    const char * s = src;
    size_t n = siz;

    if (!dst)
    {
        return 0;
    }

    if (!src)
    {
        if (siz > 0)
        {
            *d = '\0';
        }

        return 0;
    }

    /* Copy as many bytes as will fit */
    if (n != 0)
    {
        while (--n != 0)
        {
            if (*s == '\0' || *s == RCP2_MSG_SEPARATOR_SYMBOL || *s == RCP2_MSG_SOURCE_SYMBOL)
            {
                *d++ = '\0';
                break;
            }

            if (*s == RCP2_MSG_ESCAPE_SYMBOL)
            {
                s++;
            }

            *d++ = *s++;
            retval++;
        }
    }

    /* Not enough room in dst, add NUL and traverse rest of src */
    if (n == 0)
    {
        if (siz != 0)
        {
            *d = '\0';      /* NUL-terminate dst */
        }
        while (*s != '\0' && *s != RCP2_MSG_SEPARATOR_SYMBOL && *s != RCP2_MSG_SOURCE_SYMBOL)
        {
            if (*s == RCP2_MSG_ESCAPE_SYMBOL)
            {
                s++;
            }

            s++;
            retval++;
        }
    }

    return retval;
}

int RCP_get_and_parse_packet(tRCPParsedPacketState * packetState, char nextChar)
{
    return _RCP_get_and_parse_packet_ext(packetState, nextChar, 1);
}

int RCP_get_and_parse_packet_non_destructive(tRCPParsedPacketState * packetState, char nextChar)
{
    return _RCP_get_and_parse_packet_ext(packetState, nextChar, 0);
}

static int _RCP_get_and_parse_packet_ext(tRCPParsedPacketState * packetState, char nextChar, int destructive)
{
    tRCPState next_state;
    int delim_start = 0;
    int delim_target = 0;
    int delim_source = 0;
    int delim_separator = 0;
    int delim_checksum = 0;
    int delim_end = 0;
    int delim = 0;
    int successful = 0;

    /* check for valid packet state pointer */
    if (!packetState)
    {
        return RCP2_PARSER_INCOMPLETE_PACKET;
    }

    /* initialize packet state the first time */
    if (!packetState->initialized)
    {
        packetState->initialized = 1;
        packetState->len = 0;
        packetState->is_escaped = 0;
        packetState->is_binary = 0;
        packetState->last_error = RCP2_PARSER_INCOMPLETE_PACKET;
        packetState->cur_state = RCP2_STATE_IDLE;
    }

    if (packetState->len >= packetState->buf_len - 2)
    {
        /* RCP receive buffer full */
        packetState->len = 0;
        packetState->last_error = RCP2_PARSER_BUFFER_FULL;
        /* we reset the length and continue parsing in this case.  This
         * packet is a lost cause but we don't want to miss the start
         * of the next packet.  We don't want to reset our parsing
         * flags since we want to retain the current state.  Just
         * notify the user that the buffer was full on move on. */
    }

    /* check for escape character */
    if (
        !packetState->is_escaped &&
        packetState->cur_state != RCP2_STATE_BIN_DATA &&
        nextChar == RCP2_MSG_ESCAPE_SYMBOL)
    {
        if (!destructive)
        {
            packetState->buf[packetState->len++] = nextChar;
        }
        packetState->checksum ^= nextChar;
        packetState->is_escaped = 1;
        return packetState->last_error;
    }

    /* check for delimiters */
    if (!packetState->is_escaped && packetState->cur_state != RCP2_STATE_BIN_DATA)
    {
        switch (nextChar)
        {
            case RCP2_MSG_START_SYMBOL:
                delim_start = 1;
                delim = 1;
                break;

            case RCP2_MSG_TARGET_SYMBOL:
                delim_target = 1;
                delim = 1;
                break;

            case RCP2_MSG_SOURCE_SYMBOL:
                delim_source = 1;
                delim = 1;
                break;

            case RCP2_MSG_SEPARATOR_SYMBOL:
                delim_separator = 1;
                delim = 1;
                break;

            case RCP2_MSG_CKSUM_SYMBOL:
                delim_checksum = 1;
                delim = 1;
                break;

            case RCP2_MSG_END1_SYMBOL:
            case RCP2_MSG_END2_SYMBOL:
                delim_end = 1;
                delim = 1;
                break;

            default:
                break;
        }
    }
    else
    {
        packetState->is_escaped = 0;
    }

    /* state handlers */
    next_state = packetState->cur_state;
    switch (packetState->cur_state)
    {
        case RCP2_STATE_IDLE:
            if (delim_start)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_START;
            }
            break;

        case RCP2_STATE_START:
            if (delim_target)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                packetState->checksum ^= nextChar;
                next_state = RCP2_STATE_TARGET;
            }
            else if (delim_source)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                packetState->checksum ^= nextChar;
                next_state = RCP2_STATE_SOURCE;
            }
            else if (delim_start)
            {
                /* stay in this state */
            }
            else
            {
                next_state = RCP2_STATE_IDLE;
            }

            break;

        case RCP2_STATE_TARGET:
            if (delim_source)
            {
                if (destructive)
                {
                    packetState->buf[packetState->len++] = 0;
                }
                else
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                packetState->checksum ^= nextChar;
                next_state = RCP2_STATE_SOURCE;
            }
            else if (delim_start)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_START;
            }
            else if (delim)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_IDLE;
            }
            else
            {
                packetState->checksum ^= nextChar;
                packetState->buf[packetState->len++] = nextChar;
            }
            break;

        case RCP2_STATE_SOURCE:
        case RCP2_STATE_CMD:
        case RCP2_STATE_PARAM:
        case RCP2_STATE_BIN_LEN:
            if (delim_separator)
            {
                if (destructive)
                {
                    packetState->buf[packetState->len++] = 0;
                }
                else
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                packetState->checksum ^= nextChar;

                /* taking advantage of the fact that these states are
                 * in the same order as in the packet */
                next_state = (tRCPState) ((int) packetState->cur_state + 1);
            }
            else if (delim_start)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_START;
            }
            else if (delim)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_IDLE;
            }
            else
            {
                packetState->checksum ^= nextChar;
                packetState->buf[packetState->len++] = nextChar;
            }
            break;

        case RCP2_STATE_ARG:
            if (delim_separator)
            {
                if (destructive)
                {
                    packetState->buf[packetState->len++] = 0;
                }
                else
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                packetState->checksum ^= nextChar;

                packetState->parsed.argc++;

                if (packetState->parsed.argc == RCP2_MAX_ARG_COUNT)
                {
                    /* This is the last allowed argument, don't try to set the next argument
                     * pointer. */
                }
                else if (packetState->parsed.argc > RCP2_MAX_ARG_COUNT)
                {
                    /* We've seen too many arguments, return an error. */
                    packetState->parsed.argc = RCP2_MAX_ARG_COUNT;
                    packetState->last_error = RCP2_PARSER_TOO_MANY_ARGS;
                }
                else
                {
                    /* Set the next argument pointer */
                    packetState->parsed.argv[packetState->parsed.argc] = &packetState->buf[packetState->len];
                }
            }
            else if (delim_start)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_START;
            }
            else if (delim_checksum)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_CHKSUM;
            }
            else if (delim_end)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_END;
            }
            else if (delim)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_IDLE;
            }
            else
            {
                packetState->checksum ^= nextChar;
                packetState->buf[packetState->len++] = nextChar;
            }
            break;

        case RCP2_STATE_BIN_DATA:
            packetState->checksum ^= nextChar;
            packetState->buf[packetState->len++] = nextChar;
            if (0 == --packetState->skip_bytes)
            {
                next_state = RCP2_STATE_BIN_DONE;
            }

            break;

        case RCP2_STATE_BIN_DONE:
            if (delim_start)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_START;
            }
            else if (delim_checksum)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_CHKSUM;
            }
            else if (delim_end)
            {
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_END;
            }
            else if (nextChar == 0)
            {
                /* this is just padding */
                if (!destructive)
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
            }
            else
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_IDLE;
            }
            break;

        case RCP2_STATE_CHKSUM:
            if (delim_end)
            {
                if (destructive)
                {
                    packetState->buf[packetState->len++] = 0;
                }
                else
                {
                    packetState->buf[packetState->len++] = nextChar;
                }
                next_state = RCP2_STATE_END;
            }
            else if (delim_start)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_START;
            }
            else if (delim)
            {
                packetState->last_error = RCP2_PARSER_MALFORMED;
                next_state = RCP2_STATE_IDLE;
            }
            else
            {
                packetState->buf[packetState->len++] = nextChar;
            }
            break;

        case RCP2_STATE_END:
            break;
    }

    /* handle state enter conditions */
    while (packetState->cur_state != next_state)
    {
        packetState->cur_state = next_state;

        /* handle enter condition */
        switch (packetState->cur_state)
        {
            case RCP2_STATE_IDLE:
                break;

            case RCP2_STATE_START:
                packetState->parsed.pTarget = 0;
                packetState->parsed.pSource = 0;
                packetState->is_binary = 0;
                packetState->checksum = 0;
                if (destructive)
                {
                    packetState->len = 0;
                }
                else
                {
                    packetState->len = 1;
                }
                packetState->parsed.argc = 0;
                packetState->parsed.pChecksum = 0;
                packetState->parsed.pParam = 0;
                packetState->parsed.pCmd = 0;
                packetState->parsed.argv[0] = 0;
                packetState->last_error = RCP2_PARSER_INCOMPLETE_PACKET;
                break;

            case RCP2_STATE_TARGET:
                packetState->parsed.pTarget = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_SOURCE:
                packetState->parsed.pSource = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_CMD:
                packetState->parsed.pCmd = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_PARAM:
                packetState->parsed.pParam = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_ARG:
                if (packetState->parsed.pCmd[0] == 'S' &&
                    (RCP_strcmp(packetState->parsed.pParam, "BIN") == 0 ||
                     RCP_strcmp(packetState->parsed.pParam, "BINDONE") == 0 ||
                     RCP_strcmp(packetState->parsed.pParam, "FUILCD") == 0))
                {
                    next_state = RCP2_STATE_BIN_LEN;
                }
                else
                {
                    packetState->parsed.argv[packetState->parsed.argc] = &packetState->buf[packetState->len];
                }
                break;

            case RCP2_STATE_BIN_LEN:
                packetState->parsed.argv[0] = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_BIN_DATA:
                packetState->skip_bytes = atoi(packetState->parsed.argv[0]);
                packetState->parsed.argv[1] = &packetState->buf[packetState->len];

                if (!packetState->skip_bytes)
                {
                    next_state = RCP2_STATE_BIN_DONE;
                }
                break;

            case RCP2_STATE_BIN_DONE:
                if (packetState->parsed.pCmd[0] == 'S' &&
                    (RCP_strcmp(packetState->parsed.pParam, "BIN") == 0 ||
                     RCP_strcmp(packetState->parsed.pParam, "FUILCD") == 0))
                {
                    packetState->parsed.argc = 2;
                }
                else                    /* BINDONE */
                {
                    packetState->parsed.argc = 1;
                }
                break;

            case RCP2_STATE_CHKSUM:
                packetState->parsed.pChecksum = &packetState->buf[packetState->len];
                break;

            case RCP2_STATE_END:
                next_state = RCP2_STATE_IDLE;

                if (packetState->parsed.pChecksum)
                {
                    if (packetState->checksum != ascii2hex16b(packetState->parsed.pChecksum))
                    {
                        packetState->last_error = RCP2_PARSER_CHECKSUM_MISSMATCH;
                        break;
                    }
                }

                if (destructive)
                {
                    if (!packetState->parsed.pCmd || !packetState->parsed.pCmd[0])
                    {
                        packetState->last_error = RCP2_PARSER_NO_COMMAND;
                        break;
                    }
                }
                else
                {
                    if (!packetState->parsed.pCmd || packetState->parsed.pCmd[0] == RCP2_MSG_SEPARATOR_SYMBOL)
                    {
                        packetState->last_error = RCP2_PARSER_NO_COMMAND;
                        break;
                    }
                }

                if (destructive)
                {
                    if (!packetState->parsed.pParam || !packetState->parsed.pParam[0])
                    {
                        packetState->last_error = RCP2_PARSER_NO_PARAMETER;
                        break;
                    }
                }
                else
                {
                    if (!packetState->parsed.pParam || packetState->parsed.pParam[0] == RCP2_MSG_SEPARATOR_SYMBOL)
                    {
                        packetState->last_error = RCP2_PARSER_NO_PARAMETER;
                        break;
                    }
                }

                if (packetState->last_error == RCP2_PARSER_INCOMPLETE_PACKET)
                {
                    /* if the only error up until now is an incomplete
                     * packet then we have successfully parsed a packet */
                    successful = 1;
                }
                break;
        }
    }

    if (successful)
    {
        return RCP2_PARSER_OK;
    }
    else
    {
        return packetState->last_error;
    }
}
/********** End file: rcp_parser2.c *********************************************/

/********** Begin file: decorated_string.c **************************************/
/* #include "decorated_string.h" */
/* #include "stringl/stringl.h" */
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
/* #include "types/rcp_types_public.h" */

#if defined(_MSC_VER) || defined(_CVI_)
#if defined(_MSC_VER) && (_MSC_VER < 1900)
#define snprintf _snprintf
#endif
#define roundf(x) (float) floor((x) + 0.5)
#ifdef _CVI_
#define powf(value, power) (float) pow(value, power)
#endif
#endif

#define FPS_DIVIDER 1001
#define INT_TIME_DIVIDER 1000

static void num_to_str(char * dest, size_t dest_size, int32_t num, int32_t divider, int32_t digits);
static void concatenate(char * dest, size_t dest_size, const char * prefix, const char * body, const char * postfix);
static void format_imperial_dist(char * str, size_t size, int32_t dist);
static void format_metric_dist(char * str, size_t size, int32_t dist, int32_t num_dec);
static const char * special_char_lut_1(char sym);
static const char * special_char_lut_2(const char * sym, size_t len, int32_t builtin);
static const char * special_char_lut_1_to_2(char sym);
static int is_word_char(char ch);

/* abbreviation list for use in decorated_string_abbreviate */
typedef struct
{
    const char * full;
    const char * abbr;
} full_abbr_pair_t;

full_abbr_pair_t full_abbr_pairs[] =
{
    {"Maximum", "Max"},
    {"maximum", "max"},
    {"Minimum", "Min"},
    {"minimum", "min"},
    {"Record", "Rec"},
    {"record", "rec"},
    {"Recording", "Rec"},
    {"recording", "rec"},
    {"Preview", "Prev"},
    {"preview", "prev"},
    {"Position", "Pos"},
    {"position", "pos"},
    {"Temperature", "Temp"},
    {"temperature", "temp"},
    {"Integration", "Int"},
    {"integration", "int"},
    {"Exposure", "Exp"},
    {"exposure", "exp"},
    {"Compensation", "Comp"},
    {"compensation", "comp"},
    {"Motion Mount", "MM"},
    {"Absolute", "Abs"},
    {"absolute", "abs"},
    {"Relative", "Rel"},
    {"relative", "rel"},
    {"Distance", "Dist"},
    {"distance", "dist"},
    {"Frequency", "Freq"},
    {"frequency", "freq"},
    {"Resolution", "Res"},
    {"resolution", "res"},
    {"External", "Ext"},
    {"external", "ext"},
    {"Camera", "Cam"},
    {"camera", "cam"},
    {"Number", "No"},
    {"number", "no"},
    {"Volume", "Vol"},
    {"volume", "vol"},
    {"Internal", "Int"},
    {"internal", "int"},
    {"Version", "Ver"},
    {"version", "ver"},
    {"Channel", "Ch"},
    {"channel", "ch"},
    {"Project", "Proj"},
    {"project", "proj"},
    {"Continuous", "Cont"},
    {"continuous", "cont"},
    {"Timecode", "TC"},
    {"timecode", "TC"},
    {"Independent", "Indep"},
    {"independent", "indep"},
    {"Space", "Sp"},
    {"space", "sp"},
    {"Firmware", "FW"},
    {"firmware", "FW"},
    {"Default", "Def"},
    {"default", "def"},
    {"Alternate", "Alt"},
    {"alternate", "alt"},
    {"Calibration", "Cal"},
    {"calibration", "cal"},
    {"Dimensions", "Dims"},
    {"dimensions", "dims"},
    {"Standard", "Std"},
    {"standard", "std"},
    {"Low Light", "LL"},
    {"low light", "ll"},
};

static const char * special_char_lut_2(const char * sym, size_t len, int32_t builtin)
{
    /* converts HTML style special chars to either ascii equivalent or
     * internal font mapping.
     *
     * &SPECIAL; where SPECIAL is one of:
     * RED:
     *   redana2        ANA 2.0 icon
     *   redana125      ANA 1.25 icon
     *   redana13       ANA 1.3 icon
     *   redana15       ANA 1.5 icon
     *   redana165      ANA 1.65 icon
     *   redana18       ANA 1.8 icon
     *   redae          AE icon
     *   rediso         subscript "ISO"
     *   redsec         subscript "sec"
     *   redkelvin      subscript "K"
     *   redformatk     subscript "K"
     *   redfps         subscript "FPS"
     *   red1over       superscript "1/"
     *   redfover       superscript "f/"
     *   redav          Av icon
     *   redcheck       check mark
     *   redsub2        subscript "2"
     *   redll          LL icon
     * Global:
     *   amp, deg, reg, copy, trade
     *
     * */
    switch (len)
    {
        /*
         * NOTE: If a special character is added below make sure to also
         * add it to the characters to compress table in c_list.c
         * */
        case 3:
            if (strncmp(sym, "amp", len) == 0)
                return builtin ? "&" : "&";
            else if (strncmp(sym, "deg", len) == 0)
                return builtin ? "\xb0" : " deg";
            else if (strncmp(sym, "reg", len) == 0)
                return builtin ? "\xae" : "(R)";
            break;

        case 4:
            if (strncmp(sym, "copy", len) == 0)
                return builtin ? "\xa9" : "(C)";
            break;

        case 5:
            if (strncmp(sym, "redae", len) == 0)
                return builtin ? "\x03" : " AE";
            else if (strncmp(sym, "redav", len) == 0)
                return builtin ? "\x0c" : " Av";
            else if (strncmp(sym, "trade", len) == 0)
                return builtin ? "\x0f" : "(TM)";
            else if (strncmp(sym, "redll", len) == 0)
                return builtin ? "\x12" : "LL";
            break;

        case 6:
            if (strncmp(sym, "redfps", len) == 0)
                return builtin ? "\x07" : " FPS";
            else if (strncmp(sym, "rediso", len) == 0)
                return builtin ? "\x04" : "ISO ";
            else if (strncmp(sym, "redsec", len) == 0)
                return builtin ? "\x05" : " sec";
            break;

        case 7:
            if (strncmp(sym, "redana2", len) == 0)
                return builtin ? "\x01" : " ANA 2";
            if (strncmp(sym, "redsub2", len) == 0)
                return builtin ? "\x10" : "2";
            break;

        case 8:
            if (strncmp(sym, "red1over", len) == 0)
                return builtin ? "\x08" : "1/";
            else if (strncmp(sym, "redana13", len) == 0)
                return builtin ? "\x02" : " ANA 1.3";
            else if (strncmp(sym, "redana15", len) == 0)
                return builtin ? "\x15" : " ANA 1.5";
            else if (strncmp(sym, "redana18", len) == 0)
                return builtin ? "\x13" : " ANA 1.8";
            else if (strncmp(sym, "redcheck", len) == 0)
                return builtin ? "\x0e" : " Check";
            else if (strncmp(sym, "redfover", len) == 0)
                return builtin ? "\x0b" : "f/";
            break;

        case 9:
            if (strncmp(sym, "redana125", len) == 0)
                return builtin ? "\x11" : " ANA 1.25";
            else if (strncmp(sym, "redana165", len) == 0)
                return builtin ? "\x14" : " ANA 1.65";
            else if (strncmp(sym, "redkelvin", len) == 0)
                return builtin ? "\x06" : "K";
            break;

        case 10:
            if (strncmp(sym, "redformatk", len) == 0)
                return builtin ? "\x06" : "K";
            break;

        default:
            break;
    }

    return NULL;
}

static const char * special_char_lut_1(char sym)
{
    switch (sym)
    {
        case '$':
            return "1/";

        case '&':
            return "f/";

        case '|':
            return " sec";

        case '{':
            return "ISO ";

        case '}':
            return "K";

        case '^':
            return " deg";

        case '~':
            return " FPS";

        case '!':
            return " ANA 2";

        case '\"':
            return " ANA 1.3";

        default:
            return NULL;
    }
}

static const char * special_char_lut_1_to_2(char sym)
{
    switch (sym)
    {
        case '$':
            return "&red1over;";

        case '&':
            return "&redfover;";

        case '|':
            return "&redsec;";

        case '{':
            return "&rediso;";

        case '}':
            return "&redformatk;";

        case '^':
            return "&deg;";

        case '~':
            return "&redfps;";

        case '!':
            return "&redana2;";

        case '\"':
            return "&redana13;";

        default:
            return NULL;
    }
}

void decorated_string_decode2(const char * src, char * dest, size_t dest_len, int32_t builtin)
{
    if (dest_len == 0)
    {
        return;
    }

    while (dest_len != 1 && *src)
    {
        if (*src == '&')
        {
            const char * end = src + 1;
            while (isalnum((int) *end))
            {
                end++;
            }
            if (*end == ';')
            {
                const char * replacement = special_char_lut_2(src + 1, (end - src) - 1, builtin);
                if (replacement)
                {
                    while (dest_len != 1 && *replacement)
                    {
                        *dest++ = *replacement++;
                        dest_len--;
                    }
                }
                src = end + 1;
            }
            else
            {
                *dest++ = *src++;
                dest_len--;
            }
        }
        else
        {
            *dest++ = *src++;
            dest_len--;
        }
    }

    *dest = '\0';
}

void decorated_string_decode(const char * src, char * dest, size_t dest_len)
{
    decorated_string_decode2(src, dest, dest_len, 0);
}

void decorated_string_decode1(const char * src, char * dest, size_t dest_len)
{
    if (dest_len == 0)
    {
        return;
    }

    while (dest_len != 1 && *src)
    {
        const char * replacement = special_char_lut_1(*src);
        if (!replacement)
        {
            *dest++ = *src++;
            dest_len--;
        }
        else
        {
            while (dest_len != 1 && *replacement)
            {
                *dest++ = *replacement++;
                dest_len--;
            }
            src++;
        }
    }

    *dest = '\0';
}

void decorated_string_1_to_2(const char * src, char * dest, size_t dest_len)
{
    if (dest_len == 0)
    {
        return;
    }

    while (dest_len != 1 && *src)
    {
        const char * replacement = special_char_lut_1_to_2(*src);
        if (!replacement)
        {
            *dest++ = *src++;
            dest_len--;
        }
        else
        {
            while (dest_len != 1 && *replacement)
            {
                *dest++ = *replacement++;
                dest_len--;
            }
            src++;
        }
    }

    *dest = '\0';
}

static void concatenate(char * dest, size_t dest_size, const char * prefix, const char * body, const char * postfix)
{
    if (prefix != NULL)
    {
        strlcpy(dest, prefix, dest_size);
    }
    else
    {
        strlcpy(dest, "", dest_size);
    }

    strlcat(dest, body, dest_size);

    if (postfix != NULL)
    {
        strlcat(dest, postfix, dest_size);
    }
}

static void num_to_str(char * dest, size_t dest_size, int32_t num, int32_t divider, int32_t digits)
{
    if (divider == 0)
    {
        snprintf(dest, dest_size, "---");
    }
    else
    {
        /* snprintf takes care of all rounding to the appropriate decimal point */
        snprintf(dest, dest_size, "%.*f", digits, (float) num / divider);
    }
}

void decorated_string_create(char * dest, size_t dest_size, int32_t num, int32_t divider, int32_t digits, const char * prefix, const char * postfix)
{
    char num_str[20];
    num_to_str(num_str, sizeof(num_str), num, divider, digits);
    concatenate(dest, dest_size, prefix, num_str, postfix);
}

void decorated_string_create_fps_label(char * dest, size_t dest_size, decorated_string_len_t len, int32_t fps)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            if (fps >= FPS_DIVIDER)
            {
                decorated_string_create(dest, dest_size, fps, FPS_DIVIDER, (fps % FPS_DIVIDER) ? 2 : 0, "", "&redfps;");
            }
            else
            {
                decorated_string_create(dest, dest_size, FPS_DIVIDER, fps, (FPS_DIVIDER % fps) ? 2 : 0, "&red1over;", "&redfps;");
            }
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            if (fps >= FPS_DIVIDER)
            {
                decorated_string_create(dest, dest_size, fps, FPS_DIVIDER, (fps % FPS_DIVIDER) ? 2 : 0, "", "");
            }
            else
            {
                decorated_string_create(dest, dest_size, FPS_DIVIDER, fps, (FPS_DIVIDER % fps) ? 2 : 0, "&red1over;", "");
            }
            break;
    }
}

void decorated_string_create_int_time_label(char * dest, size_t dest_size, decorated_string_len_t len, int32_t show_angle, int32_t int_time, int32_t int_time_angle, frame_processing_t frameproc, int32_t frame_divider, int32_t ae_control)
{
    char suffix[50];

    if (show_angle)
    {
        if (ae_control)
        {
            decorated_string_create(dest, dest_size, int_time_angle, 1000, 1, "&redae; ", "&deg;");
        }
        else
        {
            decorated_string_create(dest, dest_size, int_time_angle, 1000, 1, "", "&deg;");
        }
    }
    else
    {
        switch (len)
        {
            default:
            case DECORATED_STRING_LEN_NORMAL:
                if (frameproc == FRAME_PROCESSING_SUM)
                {
                    snprintf(suffix, sizeof(suffix), "x%d", frame_divider);
                }
                else
                {
                    suffix[0] = 0;
                }

                if (int_time > INT_TIME_DIVIDER)
                {
                    if (ae_control)
                    {
                        decorated_string_create(dest, dest_size, int_time, INT_TIME_DIVIDER, (int_time % INT_TIME_DIVIDER) ? 2 : 0, "&redae; &red1over;", "");
                    }
                    else
                    {
                        decorated_string_create(dest, dest_size, int_time, INT_TIME_DIVIDER, (int_time % INT_TIME_DIVIDER) ? 2 : 0, "&red1over;", "");
                    }
                }
                else
                {
                    int32_t digits;

                    if (int_time == 0)
                    {
                        digits = 0;
                    }
                    else
                    {
                        digits = (INT_TIME_DIVIDER % int_time) ? 2 : 0;
                    }

                    if (ae_control)
                    {
                        decorated_string_create(dest, dest_size, INT_TIME_DIVIDER, int_time, digits, "&redae; ", "&redsec;");
                    }
                    else
                    {
                        decorated_string_create(dest, dest_size, INT_TIME_DIVIDER, int_time, digits, "", "&redsec;");
                    }
                }

                strlcat(dest, suffix, dest_size);
                break;

            case DECORATED_STRING_LEN_ABBREVIATED:
                if (frameproc == FRAME_PROCESSING_SUM)
                {
                    snprintf(suffix, sizeof(suffix), "x");
                }
                else
                {
                    suffix[0] = 0;
                }

                if (int_time > INT_TIME_DIVIDER)
                {
                    if (ae_control)
                    {
                        decorated_string_create(dest, dest_size, int_time, INT_TIME_DIVIDER, (int_time % INT_TIME_DIVIDER) ? 2 : 0, "&redae; &red1over;", "");
                    }
                    else
                    {
                        decorated_string_create(dest, dest_size, int_time, INT_TIME_DIVIDER, (int_time % INT_TIME_DIVIDER) ? 2 : 0, "&red1over;", "");
                    }
                }
                else
                {
                    int32_t digits;

                    if (int_time == 0)
                    {
                        digits = 0;
                    }
                    else
                    {
                        digits = (INT_TIME_DIVIDER % int_time) ? 2 : 0;
                    }

                    if (ae_control)
                    {
                        decorated_string_create(dest, dest_size, INT_TIME_DIVIDER, int_time, digits, "&redae; ", "&redsec;");
                    }
                    else
                    {
                        decorated_string_create(dest, dest_size, INT_TIME_DIVIDER, int_time, digits, "", "&redsec;");
                    }
                }

                strlcat(dest, suffix, dest_size);
                break;
        }
    }
}

void decorated_string_create_red_gamma(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            switch (value)
            {
                case GAMMACURVE_REDLOGFILM:
                    strlcpy(dest, "REDlogFilm", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA2:
                    strlcpy(dest, "REDgamma2", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA3:
                    strlcpy(dest, "REDgamma3", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA4:
                    strlcpy(dest, "REDgamma4", dest_size);
                    break;

                case GAMMACURVE_ACESPROXY:
                    strlcpy(dest, "ACES Proxy", dest_size);
                    break;

                case GAMMACURVE_ACESCC:
                    strlcpy(dest, "ACEScc", dest_size);
                    break;

                case GAMMACURVE_LOG3G12:
                    strlcpy(dest, "Log3G12", dest_size);
                    break;

                case GAMMACURVE_BT1886:
                    strlcpy(dest, "BT-1886", dest_size);
                    break;

                case GAMMACURVE_HDR2084:
                    strlcpy(dest, "HDR-2084", dest_size);
                    break;

                case GAMMACURVE_LOG3G10:
                    strlcpy(dest, "Log3G10", dest_size);
                    break;

                default:
                    strlcpy(dest, "---", dest_size);
                    break;
            }
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            switch (value)
            {
                case GAMMACURVE_REDLOGFILM:
                    strlcpy(dest, "RLF", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA2:
                    strlcpy(dest, "RG2", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA3:
                    strlcpy(dest, "RG3", dest_size);
                    break;

                case GAMMACURVE_REDGAMMA4:
                    strlcpy(dest, "RG4", dest_size);
                    break;

                case GAMMACURVE_ACESPROXY:
                    strlcpy(dest, "ACES", dest_size);
                    break;

                case GAMMACURVE_ACESCC:
                    strlcpy(dest, "ACEScc", dest_size);
                    break;

                case GAMMACURVE_LOG3G12:
                    strlcpy(dest, "Log3G12", dest_size);
                    break;

                case GAMMACURVE_BT1886:
                    strlcpy(dest, "1886", dest_size);
                    break;

                case GAMMACURVE_HDR2084:
                    strlcpy(dest, "2084", dest_size);
                    break;

                case GAMMACURVE_LOG3G10:
                    strlcpy(dest, "Log3G10", dest_size);
                    break;

                default:
                    strlcpy(dest, "---", dest_size);
                    break;
            }
            break;
    }
}

void decorated_string_create_red_color(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            switch (value)
            {
                case COLORSPACE_REDCOLOR2:
                    strlcpy(dest, "REDcolor2", dest_size);
                    break;

                case COLORSPACE_REDCOLOR3:
                    strlcpy(dest, "REDcolor3", dest_size);
                    break;

                case COLORSPACE_REDCOLOR4:
                    strlcpy(dest, "REDcolor4", dest_size);
                    break;

                case COLORSPACE_DRAGONCOLOR:
                    strlcpy(dest, "DRAGONcolor", dest_size);
                    break;

                case COLORSPACE_DRAGONCOLOR2:
                    strlcpy(dest, "DRAGONcolor2", dest_size);
                    break;

                case COLORSPACE_ACES:
                case COLORSPACE_ACES_AP1:
                    strlcpy(dest, "ACES", dest_size);
                    break;

                case COLORSPACE_REC709:
                    strlcpy(dest, "Rec. 709", dest_size);
                    break;

                case COLORSPACE_REC2020:
                    strlcpy(dest, "Rec. 2020", dest_size);
                    break;

                case COLORSPACE_RWGRGB:
                    strlcpy(dest, "REDWideGamutRGB", dest_size);
                    break;

                default:
                    strlcpy(dest, "---", dest_size);
                    break;
            }
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            switch (value)
            {
                case COLORSPACE_REDCOLOR2:
                    strlcpy(dest, "RC2", dest_size);
                    break;

                case COLORSPACE_REDCOLOR3:
                    strlcpy(dest, "RC3", dest_size);
                    break;

                case COLORSPACE_REDCOLOR4:
                    strlcpy(dest, "RC4", dest_size);
                    break;

                case COLORSPACE_DRAGONCOLOR:
                    strlcpy(dest, "DC", dest_size);
                    break;

                case COLORSPACE_DRAGONCOLOR2:
                    strlcpy(dest, "DC2", dest_size);
                    break;

                case COLORSPACE_ACES:
                case COLORSPACE_ACES_AP1:
                    strlcpy(dest, "ACES", dest_size);
                    break;

                case COLORSPACE_REC709:
                    strlcpy(dest, "Rec709", dest_size);
                    break;

                case COLORSPACE_REC2020:
                    strlcpy(dest, "Rec2020", dest_size);
                    break;

                case COLORSPACE_RWGRGB:
                    strlcpy(dest, "RWG", dest_size);
                    break;

                default:
                    strlcpy(dest, "---", dest_size);
                    break;
            }
            break;
    }
}

typedef struct
{
    int32_t enum_entry;
    const char * normal;
    const char * abbreviated;
} string_table_t;

const string_table_t main_output_preset_string_table[MAIN_OUTPUT_PRESET_COUNT] =
{
    {MAIN_OUTPUT_PRESET_ACES_PROXY, "ACES PROXY", "ACES"},
    {MAIN_OUTPUT_PRESET_BT1886, "BT-1886", "1886"},
    {MAIN_OUTPUT_PRESET_HDR, "HDR", "HDR"},
    {MAIN_OUTPUT_PRESET_HDR2084, "HDR-2084", "2084"},
    {MAIN_OUTPUT_PRESET_HDR_400, "HDR 400 Nits", "HDR400"},
    {MAIN_OUTPUT_PRESET_HDR_1K, "HDR 1K Nits", "HDR1K"},
    {MAIN_OUTPUT_PRESET_HDR_2K, "HDR 2K Nits", "HDR2K"},
    {MAIN_OUTPUT_PRESET_HDR_4K, "HDR 4K Nits", "HDR4K"},
    {MAIN_OUTPUT_PRESET_LOG3G10, "Log3G10", "Log3G10"},
    {MAIN_OUTPUT_PRESET_REC709, "Rec. 709", "Rec709"},
    {MAIN_OUTPUT_PRESET_REDGAMMA2, "REDgamma2", "RG2"},
    {MAIN_OUTPUT_PRESET_REDGAMMA3, "REDgamma3", "RG3"},
    {MAIN_OUTPUT_PRESET_REDGAMMA4, "REDgamma4", "RG4"},
    {MAIN_OUTPUT_PRESET_REDLOGFILM, "REDlogFilm", "RLF"},
    {MAIN_OUTPUT_PRESET_SDR, "SDR", "SDR"},
    {MAIN_OUTPUT_PRESET_SDR_REC709, "SDR Rec. 709", "SDR709"},
    {MAIN_OUTPUT_PRESET_SDR_REC709_NO_KNEE, "SDR Rec709 No Knee", "SDR709NK"},
    {MAIN_OUTPUT_PRESET_USER, "Log3G10 : 3DLUT", "Log3G10:3D"},
    {MAIN_OUTPUT_PRESET_RLF_TO_3DLUT, "REDlogFilm : 3DLUT", "RLF:3D"},
    {MAIN_OUTPUT_PRESET_IPP2A, "Log3G10 : 3DLUT", "Log3G10:3D"},
};

#define MAIN_OUTPUT_PRESET_STRING_TABLE_COUNT (sizeof(main_output_preset_string_table) / sizeof(string_table_t))

void decorated_string_create_main_output_preset(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    const int32_t string_count = MAIN_OUTPUT_PRESET_STRING_TABLE_COUNT;

    if (value != main_output_preset_string_table[value].enum_entry || (value >= string_count))
    {
        strlcpy(dest, "---", dest_size);
        return;
    }

    if (DECORATED_STRING_LEN_ABBREVIATED == len)
    {
        strlcpy(dest, main_output_preset_string_table[value].abbreviated, dest_size);
    }
    else
    {
        strlcpy(dest, main_output_preset_string_table[value].normal, dest_size);
    }
}

const string_table_t display_preset_string_table[DISPLAY_PRESET_COUNT] =
{
    {DISPLAY_PRESET_ACES_PROXY, "ACES Proxy", "ACES"},
    {DISPLAY_PRESET_FLUT_BT1886, "BT-1886", "1886"},
    {DISPLAY_PRESET_FLUT_HDR2084, "HDR-2084", "2084"},
    {DISPLAY_PRESET_FLUT_LOG3G10, "Log3G10", "Log3G10"},
    {DISPLAY_PRESET_FLUT_REDGAMMA2, "REDgamma2", "RG2"},
    {DISPLAY_PRESET_FLUT_REDGAMMA3, "REDgamma3", "RG3"},
    {DISPLAY_PRESET_FLUT_REDGAMMA4, "REDgamma4", "RG4"},
    {DISPLAY_PRESET_FLUT_REDLOGFILM, "REDlogFilm", "RLF"},
    {DISPLAY_PRESET_MAIN_HDR, "HDR", "HDR"},
    {DISPLAY_PRESET_MAIN_HDR_400, "HDR 400 Nits", "HDR400"},
    {DISPLAY_PRESET_MAIN_HDR_1K, "HDR 1K Nits", "HDR1K"},
    {DISPLAY_PRESET_MAIN_HDR_2K, "HDR 2K Nits", "HDR2K"},
    {DISPLAY_PRESET_MAIN_HDR_4K, "HDR 4K Nits", "HDR4K"},
    {DISPLAY_PRESET_MAIN_SDR, "SDR", "SDR"},
    {DISPLAY_PRESET_MAIN_HLG, "HLG", "HLG"},
    {DISPLAY_PRESET_MAIN_SDR_REC709, "SDR Rec. 709", "SDR709"},
    {DISPLAY_PRESET_MAIN_SDR_REC709_NO_KNEE, "SDR Rec. 709", "SDR709NK"},
    {DISPLAY_PRESET_RWGRGB_HDR, "HDR", "HDR"},
    {DISPLAY_PRESET_RWGRGB_HDR_400, "HDR 400 Nits", "HDR400"},
    {DISPLAY_PRESET_RWGRGB_HDR_1K, "HDR 1K Nits", "HDR1K"},
    {DISPLAY_PRESET_RWGRGB_HDR_2K, "HDR 2K Nits", "HDR2K"},
    {DISPLAY_PRESET_RWGRGB_HDR_4K, "HDR 4K Nits", "HDR4K"},
    {DISPLAY_PRESET_RWGRGB_SDR, "SDR", "SDR"},
    {DISPLAY_PRESET_RWGRGB_HLG, "HLG", "HLG"},
    {DISPLAY_PRESET_RWGRGB_SDR_REC709, "SDR Rec. 709", "SDR709"},
    {DISPLAY_PRESET_RWGRGB_SDR_REC709_NO_KNEE, "SDR Rec. 709", "SDR709NK"},
    {DISPLAY_PRESET_USER, "Log3G10:3DLUT", "Log3G10:3D"},
    {DISPLAY_PRESET_RLF_TO_3DLUT, "REDlogFilm:3DLUT", "RLF:3D"}
};

#define DISPLAY_PRESET_STRING_TABLE_COUNT (sizeof(display_preset_string_table) / sizeof(string_table_t))

void decorated_string_create_display_preset(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    const int32_t string_count = DISPLAY_PRESET_STRING_TABLE_COUNT;

    if (value != display_preset_string_table[value].enum_entry || (value >= string_count))
    {
        strlcpy(dest, "---", dest_size);
        return;
    }

    if (DECORATED_STRING_LEN_ABBREVIATED == len)
    {
        strlcpy(dest, display_preset_string_table[value].abbreviated, dest_size);
    }
    else
    {
        strlcpy(dest, display_preset_string_table[value].normal, dest_size);
    }
}

const string_table_t output_transform_string_table[OUTPUT_TRANSFORM_COUNT] =
{
    {OUTPUT_TRANSFORM_ACES_AP1, "ACES AP1", "ACES"},
    {OUTPUT_TRANSFORM_DRAGONCOLOR, "DRAGONcolor", "DC"},
    {OUTPUT_TRANSFORM_DRAGONCOLOR2, "DRAGONcolor2", "DC2"},
    {OUTPUT_TRANSFORM_P3, "DCI-P3", "DCI-P3"},
    {OUTPUT_TRANSFORM_REC709, "Rec. 709", "Rec709"},
    {OUTPUT_TRANSFORM_REC2020, "Rec. 2020", "Rec2020"},
    {OUTPUT_TRANSFORM_REDCOLOR2, "REDcolor2", "RC2"},
    {OUTPUT_TRANSFORM_REDCOLOR3, "REDcolor3", "RC3"},
    {OUTPUT_TRANSFORM_REDCOLOR4, "REDcolor4", "RC4"},
    {OUTPUT_TRANSFORM_RWGRGB, "REDWideGamutRGB", "RWGRGB"},
    {OUTPUT_TRANSFORM_NONE, "NONE", "NONE"},
    {OUTPUT_TRANSFORM_CUSTOM, "CUSTOM", "CUSTOM"},    
    {OUTPUT_TRANSFORM_IPP2A, "REDWideGamutRGB", "RWGRGB"},
};

#define OUTPUT_TRANSFORM_STRING_TABLE_COUNT (sizeof(output_transform_string_table) / sizeof(string_table_t))

void decorated_string_create_output_transform(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    const int32_t string_count = OUTPUT_TRANSFORM_STRING_TABLE_COUNT;

    if (value != output_transform_string_table[value].enum_entry || (value >= string_count))
    {
        strlcpy(dest, "---", dest_size);
        return;
    }

    if (DECORATED_STRING_LEN_ABBREVIATED == len)
    {
        strlcpy(dest, output_transform_string_table[value].abbreviated, dest_size);
    }
    else
    {
        strlcpy(dest, output_transform_string_table[value].normal, dest_size);
    }
}

void decorated_string_create_iso(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value, int32_t iso_pull, int32_t nd_val, int32_t sensor_gain_supported, int32_t sensor_gain_mode)
{
    if (iso_pull)
    {
        value = (int) roundf(value / powf(2, nd_val / 100.0f));
    }

    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            if (sensor_gain_supported && sensor_gain_mode == SENSOR_SENSITIVITY_LOW_LIGHT)
            {
                decorated_string_create(dest, dest_size, value, 1, 0, "&rediso;", " &redll;");
            }
            else
            {
                decorated_string_create(dest, dest_size, value, 1, 0, "&rediso;", "");
            }
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            if (sensor_gain_supported && sensor_gain_mode == SENSOR_SENSITIVITY_LOW_LIGHT)
            {
                decorated_string_create(dest, dest_size, value, 1, 0, "", " &redll;");
            }
            else
            {
                decorated_string_create(dest, dest_size, value, 1, 0, "", "");
            }
            break;
    }
}

void decorated_string_create_redcode(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            snprintf(dest, dest_size, "%d:1", (value + 99) / 100);
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            snprintf(dest, dest_size, "%d:1", (value + 99) / 100);
            break;
    }
}

void decorated_string_create_file_format(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
        case DECORATED_STRING_LEN_ABBREVIATED:
            switch (value)
            {
                case 0:
                    strlcpy(dest, "Redcode", dest_size);
                    break;

                case 1:
                    strlcpy(dest, "QuickTime", dest_size);
                    break;
            }
    }
}

void decorated_string_create_aperture(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value, int32_t ae_control)
{
    const int base = value / 10;
    const int decimal = value % 10;

    if (value <= 0)
    {
        strlcpy(dest, "N/A", dest_size);
    }
    else if (decimal == 0)
    {
        if (ae_control)
        {
            snprintf(dest, dest_size, "&redae; &redfover;%d", base);
        }
        else
        {
            snprintf(dest, dest_size, "&redfover;%d", base);
        }
    }
    else
    {
        if (ae_control)
        {
            snprintf(dest, dest_size, "&redae; &redfover;%d.%d", base, decimal);
        }
        else
        {
            snprintf(dest, dest_size, "&redfover;%d.%d", base, decimal);
        }
    }
}

void decorated_string_create_power(char * dest, size_t dest_size, decorated_string_len_t len, battery_display_mode_t display_mode, int32_t power_level, int32_t runtime)
{
    if (power_level < 101)
    {
        /* Battery */
        if (display_mode == BATTERY_DISPLAY_MODE_PERCENT)
        {
            decorated_string_create_power_percent(dest, dest_size, len, power_level);
        }
        else if (display_mode == BATTERY_DISPLAY_MODE_TOTAL_TIME)
        {
            decorated_string_create_power_runtime(dest, dest_size, len, runtime);
        }
    }
    else
    {
        /* DC Voltage */
        decorated_string_create_power_voltage(dest, dest_size, len, power_level);
    }
}

void decorated_string_create_power2(char * dest, size_t dest_size, decorated_string_len_t len, battery_display_mode_t display_mode, int32_t voltage, int32_t runtime, int32_t percent)
{
    if (percent != BATTERY_INVALID_VALUE && runtime != BATTERY_INVALID_VALUE && display_mode == BATTERY_DISPLAY_MODE_PERCENT)
    {
        decorated_string_create_power_percent(dest, dest_size, len, percent);
    }
    else if (runtime != BATTERY_INVALID_VALUE && display_mode == BATTERY_DISPLAY_MODE_TOTAL_TIME)
    {
        decorated_string_create_power_runtime(dest, dest_size, len, runtime);
    }
    else
    {
        decorated_string_create_power_voltage(dest, dest_size, len, voltage);
    }
}

void decorated_string_create_power_voltage(char * dest, size_t dest_size, decorated_string_len_t len, int32_t voltage)
{
    if (voltage < 0)
    {
        strlcpy(dest, "N/A", dest_size);
    }
    else
    {
        int voltage_deca_volts = voltage / 100;

        snprintf(dest, dest_size, "%d.%dV", voltage_deca_volts / 10, voltage_deca_volts % 10);
    }
}

void decorated_string_create_power_percent(char * dest, size_t dest_size, decorated_string_len_t len, int32_t percent)
{
    if (percent < 0)
    {
        snprintf(dest, dest_size, "N/A");
    }
    else
    {
        snprintf(dest, dest_size, "%d%%", percent);
    }
}

void decorated_string_create_power_runtime(char * dest, size_t dest_size, decorated_string_len_t len, int32_t runtime)
{
    /*  Show batteries with capacity larger then 10 hours as Unknown. */
    if ((runtime < BATTERY_RUNTIME_MAX_MINUTES) && (runtime > 0))
    {
        snprintf(dest, dest_size, "%d:%02d", runtime / 60, runtime % 60);
    }
    else
    {
        snprintf(dest, dest_size, "N/A");
    }
}

static void format_imperial_dist(char * str, size_t size, int32_t dist)
{
    const int32_t total_inches = (int) roundf((float) dist / 2.54);
    const int32_t feet = total_inches / 12;
    const int32_t inches = total_inches % 12;

    if (dist < 0)
    {
        snprintf(str, size, "---");
    }
    else if (dist >= 0xffff)
    {
        snprintf(str, size, "inf");
    }
    else if (feet == 0)
    {
        snprintf(str, size, "%d\"", inches);
    }
    else if (inches == 0)
    {
        snprintf(str, size, "%d'", feet);
    }
    else
    {
        snprintf(str, size, "%d'%d\"", feet, inches);
    }
}

static void format_metric_dist(char * str, size_t size, int32_t dist, int32_t num_dec)
{
    if (dist < 0)
    {
        snprintf(str, size, "---");
    }
    else if (dist >= 0xffff)
    {
        snprintf(str, size, "inf");
    }
    else if (dist < 100)
    {
        snprintf(str, size, "%dcm", dist);
    }
    else
    {
        snprintf(str, size, "%.*fm", num_dec, dist / 100.0);
    }
}

void decorated_string_create_focus_dist(char * dest, size_t dest_size, decorated_string_len_t len, focus_distance_mode_t display_mode, int32_t near_dist, int32_t far_dist)
{
    char near_dist_str[20];
    char far_dist_str[20];

    if ((near_dist == far_dist && near_dist <= 0) || near_dist < 0 || far_dist < 0)
    {
        strlcpy(dest, "N/A", dest_size);
        return;
    }

    switch (display_mode)
    {
        case FOCUS_DISTANCE_MODE_METRIC:
            format_metric_dist(near_dist_str, sizeof(near_dist_str), near_dist, (len == DECORATED_STRING_LEN_NORMAL) ? 2 : 1);
            format_metric_dist(far_dist_str, sizeof(far_dist_str), far_dist, (len == DECORATED_STRING_LEN_NORMAL) ? 2 : 1);
            break;

        case FOCUS_DISTANCE_MODE_IMPERIAL:
        default:
            format_imperial_dist(near_dist_str, sizeof(near_dist_str), near_dist);
            format_imperial_dist(far_dist_str, sizeof(far_dist_str), far_dist);
            break;
    }

    if (strcmp(near_dist_str, far_dist_str) == 0)
    {
        snprintf(dest, dest_size, "%s", near_dist_str);
    }
    else
    {
        switch (len)
        {
            default:
            case DECORATED_STRING_LEN_NORMAL:
                snprintf(dest, dest_size, "%s - %s", near_dist_str, far_dist_str);
                break;

            case DECORATED_STRING_LEN_ABBREVIATED:
                snprintf(dest, dest_size, "%s-%s", near_dist_str, far_dist_str);
                break;
        }
    }
}

void decorated_string_create_focal_length(char * dest, size_t dest_size, decorated_string_len_t len, int32_t value)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            snprintf(dest, dest_size, "%dmm", (value + 50) / 100);
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            snprintf(dest, dest_size, "%d", (value + 50) / 100);
            break;
    }
}

void decorated_string_create_media(char * dest, size_t dest_size, decorated_string_len_t len, decorated_string_color_t * color, record_mode_t record_mode, media_display_t display_mode, int32_t media_level, int32_t runtime)
{
    if (record_mode == RECORD_MODE_EXTERNAL)
    {
        strlcpy(dest, "EXT", dest_size);
        if (color)
        {
            *color = DECORATED_STRING_COLOR_WARNING;
        }
    }
    else if (record_mode == RECORD_MODE_STREAM)
    {
        strlcpy(dest, "STR", dest_size);
        if (color)
        {
            *color = DECORATED_STRING_COLOR_WARNING;
        }
    }
    else
    {
        if (media_level < 0)
        {
            if (color)
            {
                *color = DECORATED_STRING_COLOR_DISABLED;
            }
            strlcpy(dest, "", dest_size);
        }
        else
        {
            switch (display_mode)
            {
                case MEDIA_DISPLAY_PERCENTAGE:
                    decorated_string_create(dest, dest_size, media_level, 1, 0, "", "%");
                    break;

                case MEDIA_DISPLAY_TIME:
                    if (runtime == -1)
                    {
                        decorated_string_create(dest, dest_size, media_level, 1, 0, "", "%");
                    }
                    else
                    {
                        snprintf(dest, dest_size, "%d:%02d", runtime / 60, runtime % 60);
                    }
                    break;
            }

            if (color)
            {
                if (media_level > 10)
                {
                    *color = DECORATED_STRING_COLOR_OK;
                }
                else if (media_level > 5)
                {
                    *color = DECORATED_STRING_COLOR_WARNING;
                }
                else
                {
                    *color = DECORATED_STRING_COLOR_ERROR;
                }
            }
        }
    }
}

void decorated_string_create_color_temperature(char * dest, size_t dest_size, decorated_string_len_t len, int32_t color_temp)
{
    if (color_temp == 0)
    {
        snprintf(dest, dest_size, "N/A");
    }
    else
    {
        switch (len)
        {
            default:
            case DECORATED_STRING_LEN_NORMAL:
                decorated_string_create(dest, dest_size, color_temp, 1, 0, "", "&redkelvin;");
                break;

            case DECORATED_STRING_LEN_ABBREVIATED:
                decorated_string_create(dest, dest_size, color_temp, 1, 0, "", "&redkelvin;");
                break;
        }
    }
}

void decorated_string_create_temperature(char * dest, size_t dest_size, decorated_string_len_t len, int32_t temp)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            decorated_string_create(dest, dest_size, temp, 1, 0, "", "&deg;C");
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            decorated_string_create(dest, dest_size, temp, 1, 0, "", "");
            break;
    }
}

void decorated_string_create_fan_speed(char * dest, size_t dest_size, decorated_string_len_t len, int32_t fan_speed)
{
    if (fan_speed == -1)
    {
        snprintf(dest, dest_size, "---");
    }
    else
    {
        switch (len)
        {
            default:
            case DECORATED_STRING_LEN_NORMAL:
                decorated_string_create(dest, dest_size, fan_speed, 1, 0, "", "%");
                break;

            case DECORATED_STRING_LEN_ABBREVIATED:
                decorated_string_create(dest, dest_size, fan_speed, 1, 0, "", "");
                break;
        }
    }
}

void decorated_string_create_gyro_angle(char * dest, size_t dest_size, decorated_string_len_t len, int32_t angle)
{
    switch (len)
    {
        default:
        case DECORATED_STRING_LEN_NORMAL:
            decorated_string_create(dest, dest_size, angle, 10000, 1, "", "&deg;");
            break;

        case DECORATED_STRING_LEN_ABBREVIATED:
            decorated_string_create(dest, dest_size, angle, 10000, 0, "", "");
            break;
    }
}

static int is_word_char(char ch)
{
    return isalnum((int) ch) || ch == '\\' || ch == '/';
}

void decorated_string_abbreviate(char * str)
{
    /* TODO: can we make this case-insensitive so the master list
     * doesn't need variations? */
    size_t ii;
    for (ii = 0; ii < sizeof(full_abbr_pairs) / sizeof(full_abbr_pairs[0]); ii++)
    {
        /* cur_pos is not declared as pointing to const char because
         * strstr is overloaded in C++ with a version that takes in
         * const char * and return const char *. */

        /*lint -esym(954, cur_pos) */
        char * cur_pos = str;
        char * find_pos;
        const size_t len_full = strlen(full_abbr_pairs[ii].full);
        const size_t len_abbr = strlen(full_abbr_pairs[ii].abbr);

        do
        {
            /* look for full form of word in the remainder of our string */
            find_pos = strstr(cur_pos, full_abbr_pairs[ii].full);

            if (find_pos)
            {
                /* we only want to find "whole words" that match the
                 * full word.  That is, it only counts if the match is
                 * surrounded by white space, punctuation, etc, or is at
                 * full extent of the string. */

                if (
                    /* first character of match is beginning of string or preceded by a space */
                    (find_pos == str || !is_word_char((*(find_pos - 1))))
                    &&
                    /* last character of match is end of string or followed by a space */
                    (*(find_pos + len_full) == 0 || !is_word_char((*(find_pos + len_full))))
                   )
                {
                    const char * copy_src = find_pos + len_full;
                    char * copy_dest = find_pos + len_abbr;

                    /* we know the abbreviation is shorter than the
                     * full word (otherwise it's not much of an
                     * abbreviation), so we can copy the abbreviation
                     * over at the current location and then copy the
                     * rest of the string. */
                    strncpy(find_pos, full_abbr_pairs[ii].abbr, len_abbr);

                    /* copy the rest of the string.  We can't just call
                     * strcpy because the buffers would be overlapping. */
                    while (*copy_src)
                    {
                        *copy_dest++ = *copy_src++;
                    }
                    *copy_dest = 0;

                    /* continue search after replaced word */
                    cur_pos = find_pos + len_abbr + 1;
                }
                else
                {
                    cur_pos++;
                }
            }
            else
            {
                cur_pos = NULL;
            }
        }
        while (cur_pos && *cur_pos);
    }
}
/********** End file: decorated_string.c ****************************************/

/********** Begin file: base64.c ************************************************/
/* #include "base64.h" */
#include <string.h>

/**
 * characters used for Base64 encoding
 */
static const char * BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/**
 * encode three bytes using base64 (RFC 3548)
 *
 * @param triple three bytes that should be encoded
 * @param result buffer of four characters where the result is stored
 */
static void _base64_encode_triple(const unsigned char triple[3], char result[4])
{
    int tripleValue;
    int ii;

    tripleValue = triple[0];
    tripleValue *= 256;
    tripleValue += triple[1];
    tripleValue *= 256;
    tripleValue += triple[2];

    for (ii = 0; ii < 4; ii++)
    {
        result[3 - ii] = BASE64_CHARS[tripleValue % 64];
        tripleValue /= 64;
    }
}

/**
 * encode an array of bytes using Base64 (RFC 3548)
 *
 * @param source the source buffer
 * @param sourcelen the length of the source buffer
 * @param target the target buffer
 * @param targetlen the length of the target buffer
 * @return 1 on success, 0 otherwise
 */
int base64_encode(const unsigned char * source, size_t sourcelen, char * target, size_t targetlen)
{
    if (!source || !target)
    {
        return 0;
    }

    /* check if the result will fit in the target buffer */
    if ((sourcelen + 2) / 3 * 4 > targetlen - 1)
    {
        return 0;
    }

    /* encode all full triples */
    while (sourcelen >= 3)
    {
        _base64_encode_triple(source, target);
        sourcelen -= 3;
        source += 3;
        target += 4;
    }

    /* encode the last one or two characters */
    if (sourcelen > 0)
    {
        unsigned char temp[3];
        memset(temp, 0, sizeof(temp));
        memcpy(temp, source, sourcelen);
        _base64_encode_triple(temp, target);
        target[3] = '=';
        if (sourcelen == 1)
        {
            target[2] = '=';
        }

        target += 4;
    }

    /* terminate the string */
    target[0] = 0;

    return 1;
}

/**
 * determine the value of a base64 encoding character
 *
 * @param base64char the character of which the value is searched
 * @return the value in case of success (0-63), -1 on failure
 */
static int _base64_char_value(char base64char)
{
    if (base64char >= 'A' && base64char <= 'Z')
    {
        return base64char - 'A';
    }
    else if (base64char >= 'a' && base64char <= 'z')
    {
        return base64char - 'a' + 26;
    }
    else if (base64char >= '0' && base64char <= '9')
    {
        return base64char - '0' + 2 * 26;
    }
    else if (base64char == '+')
    {
        return 2 * 26 + 10;
    }
    else if (base64char == '/')
    {
        return 2 * 26 + 11;
    }
    else
    {
        return -1;
    }
}

/**
 * decode a 4 char base64 encoded byte triple
 *
 * @param quadruple the 4 characters that should be decoded
 * @param result the decoded data
 * @return lenth of the result (1, 2 or 3), 0 on failure
 */
static int _base64_decode_triple(const char quadruple[4], unsigned char * result)
{
    int ii;
    int triple_value;
    int bytes_to_decode = 3;
    int only_equals_yet = 1;
    int char_value[4];

    for (ii = 0; ii < 4; ii++)
    {
        char_value[ii] = _base64_char_value(quadruple[ii]);
    }

    /* check if the characters are valid */
    for (ii = 3; ii >= 0; ii--)
    {
        if (char_value[ii] < 0)
        {
            if (only_equals_yet && quadruple[ii] == '=')
            {
                /* we will ignore this character anyway, make it something
                 * that does not break our calculations */
                char_value[ii] = 0;
                bytes_to_decode--;
                continue;
            }
            return 0;
        }
        /* after we got a real character, no other '=' are allowed anymore */
        only_equals_yet = 0;
    }

    /* if we got "====" as input, bytes_to_decode is -1 */
    if (bytes_to_decode < 0)
    {
        bytes_to_decode = 0;
    }

    /* make one big value out of the partial values */
    triple_value = char_value[0];
    triple_value *= 64;
    triple_value += char_value[1];
    triple_value *= 64;
    triple_value += char_value[2];
    triple_value *= 64;
    triple_value += char_value[3];

    /* break the big value into bytes */
    for (ii = bytes_to_decode; ii < 3; ii++)
    {
        triple_value /= 256;
    }
    for (ii = bytes_to_decode - 1; ii >= 0; ii--)
    {
        result[ii] = triple_value % 256;
        triple_value /= 256;
    }

    return bytes_to_decode;
}

/**
 * decode base64 encoded data
 *
 * @param source the encoded data (zero terminated)
 * @param target pointer to the target buffer
 * @param targetlen length of the target buffer
 * @return length of converted data on success, -1 otherwise
 */
size_t base64_decode(const char * source, unsigned char * target, size_t targetlen)
{
    char * src;
    const char * tmpptr;
    char quadruple[4];
    char tmpresult[3];
    int ii;
    size_t tmplen = 3;
    size_t converted = 0;

    if (!source || !target)
    {
        return (size_t) -1;
    }

    /* concatinate '====' to the source to handle unpadded base64 data */
    src =
#ifdef __cplusplus
    (char *)
#endif
    malloc(strlen(source) + 5);

    if (src == NULL)
    {
        return (size_t) -1;
    }
    strcpy(src, source);
    strcat(src, "====");
    tmpptr = src;

    /* convert as long as we get a full result */
    while (tmplen == 3)
    {
        /* get 4 characters to convert */
        for (ii = 0; ii < 4; ii++)
        {
            /* skip invalid characters - we won't reach the end */
            while (*tmpptr != '=' && _base64_char_value(*tmpptr) < 0)
            {
                tmpptr++;
            }

            quadruple[ii] = *tmpptr++;
        }

        /* convert the characters */
        tmplen = _base64_decode_triple(quadruple, (unsigned char *) tmpresult);

        /* check if the fit in the result buffer */
        if (targetlen < tmplen)
        {
            free(src);
            return (size_t) -1;
        }

        /* put the partial result in the result buffer */
        memcpy(target, tmpresult, tmplen);
        target += tmplen;
        targetlen -= tmplen;
        converted += tmplen;
    }

    free(src);
    return converted;
}
/********** End file: base64.c **************************************************/

/********** Begin file: strlcpy.c ***********************************************/
/*	$OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp  */

/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef HAVE_STRLCPY

#include <stdlib.h>
#include <string.h>
/* #include "stringl/stringl.h" */
#ifdef STRINGL_USE_LOGGER
#include "utils/diagnostic/log/log.h"
#endif

/*
 * Copy src to string dst of size siz.  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz == 0).
 * Returns strlen(src); if retval >= siz, truncation occurred.
 */
size_t strlcpy(char * dst, const char * src, size_t siz)
{
    size_t retval;
    char * d = dst;
    const char * s = src;
    size_t n = siz;

    if (!dst)
    {
#ifdef STRINGL_USE_LOGGER
        log_error("strlcpy called with NULL for destination\n");
#endif
        return 0;
    }

    if (!src)
    {
#ifdef STRINGL_USE_LOGGER
        log_error("strlcpy called with NULL for source\n");
#endif
        if (siz > 0)
        {
            *d = '\0';
        }

        return 0;
    }

    /* Copy as many bytes as will fit */
    if (n != 0)
    {
        while (--n != 0)
        {
            if ((*d++ = *s++) == '\0')
                break;
        }
    }

    /* Not enough room in dst, add NUL and traverse rest of src */
    if (n == 0)
    {
        if (siz != 0)
            *d = '\0';      /* NUL-terminate dst */
        while (*s++)
            ;
    }

    retval = (s - src - 1); /* count does not include NUL */

    if (retval >= siz)
    {
#ifdef STRINGL_USE_LOGGER
        log_warning("truncation occurred in strlcpy; dest size %u; source string: %s\n", siz, src);
#endif
    }

    return retval;
}

#endif
/********** End file: strlcpy.c *************************************************/

/********** Begin file: strlcat.c ***********************************************/
/*	$OpenBSD: strlcat.c,v 1.13 2005/08/08 08:05:37 espie Exp    */

/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef HAVE_STRLCAT

#include <stdlib.h>
#include <string.h>
/* #include "stringl/stringl.h" */
#ifdef STRINGL_USE_LOGGER
#include "utils/diagnostic/log/log.h"
#endif

/*
 * Appends src to string dst of size siz (unlike strncat, siz is the
 * full size of dst, not space left).  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).
 * Returns strlen(src) + MIN(siz, strlen(initial dst)).
 * If retval >= siz, truncation occurred.
 */
size_t
strlcat(char * dst, const char * src, size_t siz)
{
    size_t retval;
    char * d = dst;
    const char * s = src;
    size_t n = siz;
    size_t dlen;

    if (!dst)
    {
#ifdef STRINGL_USE_LOGGER
        log_error("strlcat called with NULL for destination\n");
#endif
        return 0;
    }

    /* Find the end of dst and adjust bytes left but don't go past end */
    while (n-- != 0 && *d != '\0')
        d++;
    dlen = d - dst;
    n = siz - dlen;

    if (!src)
    {
#ifdef STRINGL_USE_LOGGER
        log_error("strlcat called with NULL for source\n");
#endif
        return dlen;
    }

    if (n == 0)
        return dlen + strlen(s);
    while (*s != '\0')
    {
        if (n != 1)
        {
            *d++ = *s;
            n--;
        }
        s++;
    }
    *d = '\0';

    retval = (dlen + (s - src));    /* count does not include NUL */

    if (retval >= siz)
    {
#ifdef STRINGL_USE_LOGGER
        log_warning("truncation occured in strlcat; dest size %u; source string: %s\n", siz, src);
#endif
    }
    return retval;
}

#endif
/********** End file: strlcat.c *************************************************/

/********** Begin file: rcp_api_parameters_hash_table.c *************************/
#ifndef _lint
/* ANSI-C code produced by gperf version 3.0.4 */
/* Command-line: /usr/bin/gperf -Kmsg -t -T -N_rcp_get_id_from_cur_msg -LANSI-C -C -G -m 3 -S 1 /cygdrive/c/jenkins/workspace/rcp_sdk_6_6x/common/rcp_api/amalgamation_sans_hash/rcp_api_parameters_hash_table.gperf  */
/* Computed positions: -k'1-8' */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
#endif


/* #include "rcp_api.h" */
/* #include "rcp_api_config.h" */
/* #include "rcp_api_parameters_hash_table.h" */
#include <string.h>

#define TOTAL_KEYWORDS 869
#define MIN_WORD_LENGTH 3
#define MAX_WORD_LENGTH 8
#define MIN_HASH_VALUE 20
#define MAX_HASH_VALUE 5923
/* maximum key range = 5904, duplicates = 0 */

#ifdef __GNUC__
__inline
#else
#ifdef __cplusplus
inline
#endif
#endif
static unsigned int
hash (register const char *str, register unsigned int len)
{
  static const unsigned short asso_values[] =
    {
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,  256, 1087,
       894,  859, 1471,    1, 5924,    1,    3,    1, 5924, 5924,
      5924, 5924, 5924, 5924, 5924,   47,  492,    6,   87,    1,
         2,  278,  818,  644, 1002,   34,   30,    1,  101,  180,
        16, 1250,    3,    2,    7,   21,  608, 1045, 1408, 1261,
      1241,    6, 5924, 5924, 5924, 5924,    3, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924, 5924,
      5924, 5924, 5924, 5924, 5924, 5924, 5924
    };
  register int hval = len;

  switch (hval)
    {
      default:
        hval += asso_values[(unsigned char)str[7]];
      /*FALLTHROUGH*/
      case 7:
        hval += asso_values[(unsigned char)str[6]];
      /*FALLTHROUGH*/
      case 6:
        hval += asso_values[(unsigned char)str[5]];
      /*FALLTHROUGH*/
      case 5:
        hval += asso_values[(unsigned char)str[4]+1];
      /*FALLTHROUGH*/
      case 4:
        hval += asso_values[(unsigned char)str[3]+1];
      /*FALLTHROUGH*/
      case 3:
        hval += asso_values[(unsigned char)str[2]];
      /*FALLTHROUGH*/
      case 2:
        hval += asso_values[(unsigned char)str[1]];
      /*FALLTHROUGH*/
      case 1:
        hval += asso_values[(unsigned char)str[0]];
        break;
    }
  return hval;
}

static const struct rcp_current_table wordlist[] =
  {
    {"CSCR", RCP_PARAM_CAMERA_SCRIPT_LIST},
    {"MPRE", RCP_PARAM_MEDIA_PRESET_LIST},
    {"MMMODE", RCP_PARAM_MM_MODE},
    {"FSMODE", RCP_PARAM_FAN_MODE},
    {"CPRE", RCP_PARAM_CAMERA_PRESET_LIST},
    {"FRMTRES", RCP_PARAM_RECORD_FORMAT_RESOLUTION},
    {"RECTLFR", RCP_PARAM_RECORD_TIMELAPSE_FRAMES},
    {"FMTETCS", RCP_PARAM_MEDIA_FORMAT_EDGE_TC_START},
    {"MCAL", RCP_PARAM_MEDIA_CAL_LIST},
    {"PLCDDM", RCP_PARAM_MONITOR_DOCK_MENUS_REAR_LCD},
    {"PLCDRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_LCD},
    {"CCAL", RCP_PARAM_CAMERA_CAL_LIST},
    {"ACES", RCP_PARAM_ACES_PROXY},
    {"PLCDBR", RCP_PARAM_MONITOR_BRIGHTNESS_REAR_LCD},
    {"CAMSER", RCP_PARAM_CAMERA_PIN},
    {"AEMODE", RCP_PARAM_AE_MODE},
    {"AFMODE", RCP_PARAM_AF_MODE},
    {"AESELECT", RCP_PARAM_AE_SELECTION},
    {"RLCDLUT", RCP_PARAM_MONITOR_LUT_REAR_LCD},
    {"MLUT", RCP_PARAM_MEDIA_LUT_LIST},
    {"FLUT", RCP_PARAM_FLUT},
    {"CURRTEMP", RCP_PARAM_CORE_TEMP},
    {"FRMTLA", RCP_PARAM_RECORD_FORMAT_LOOKAROUND},
    {"CLUT", RCP_PARAM_CAMERA_LUT_LIST},
    {"CAMLOC", RCP_PARAM_SLATE_LOCATION},
    {"AEMETERM", RCP_PARAM_AE_METERING_MODE},
    {"CMATRR", RCP_PARAM_USER_MATRIX_RR},
    {"MASTRRC", RCP_PARAM_MASTER_REDCODE},
    {"CMATBR", RCP_PARAM_USER_MATRIX_BR},
    {"MASTRFMT", RCP_PARAM_MASTER_RECORD_FORMAT},
    {"FRMTLAST", RCP_PARAM_LOOKAROUND_AVAILABLE},
    {"APRTR", RCP_PARAM_APERTURE},
    {"PAUSE", RCP_PARAM_PLAYBACK_PAUSE},
    {"MCDL", RCP_PARAM_MEDIA_CDL_LIST},
    {"FALSEC", RCP_PARAM_FALSE_COLOR_MODE},
    {"MASTRFPS", RCP_PARAM_MASTER_SENSOR_FRAME_RATE},
    {"APRTRT", RCP_PARAM_APERTURE},
    {"CCDL", RCP_PARAM_CAMERA_CDL_LIST},
    {"PLCDTL", RCP_PARAM_MONITOR_TOOLS_REAR_LCD},
    {"RECORD", RCP_PARAM_RECORD_STATE_BASE},
    {"MLABEL", RCP_PARAM_MEDIA_LABEL},
    {"PRERECDR", RCP_PARAM_PRE_RECORD_DURATION},
    {"CALTEMP", RCP_PARAM_CURRENT_CALIBRATION_TEMPERATURE},
    {"PLABEL", RCP_PARAM_POWER_LABEL},
    {"CTRLSCRN", RCP_PARAM_MONITOR_CONTROL_SCREEN},
    {"RCPCLL", RCP_PARAM_RCP_CLIENT_LIST},
    {"FMTREELN", RCP_PARAM_MEDIA_FORMAT_REEL_NO},
    {"USECRCL", RCP_PARAM_USE_CUSTOM_REDCODE},
    {"CURSENST", RCP_PARAM_SENSOR_TEMP},
    {"PLCDM", RCP_PARAM_MONITOR_MODE_REAR_LCD},
    {"CUSTMRC", RCP_PARAM_CUSTOM_REDCODE},
    {"SMLCKREC", RCP_PARAM_SIDE_MODULE_RECORD_KEY_LOCKABLE},
    {"CUSTMFMT", RCP_PARAM_CUSTOM_RECORD_FORMAT},
    {"CALSTAT", RCP_PARAM_CALIBRATION_STATUS},
    {"PLDETECT", RCP_PARAM_PL_DETECT},
    {"CUSTMFPS", RCP_PARAM_CUSTOM_SENSOR_FRAME_RATE},
    {"RMEN", RCP_PARAM_REDMOTE_WIRELESS_ENABLE},
    {"MROLL", RCP_PARAM_CAMERA_ROLL},
    {"APERCTRL", RCP_PARAM_APERTURE_CONTROL},
    {"LNMTSERL", RCP_PARAM_LENS_META_SERIAL},
    {"RECMODE", RCP_PARAM_RECORD_MODE},
    {"TPATTERN", RCP_PARAM_TEST_PATTERN},
    {"DPLCD", RCP_PARAM_DISPLAY_PRESET_LCD},
    {"LCDM", RCP_PARAM_MONITOR_MODE_LCD},
    {"FRPRNUM", RCP_PARAM_FRAME_PROCESSING_NUM},
    {"FRPRNUMT", RCP_PARAM_FRAME_PROCESSING_NUM},
    {"ROLLOFF", RCP_PARAM_ROLL_OFF},
    {"MLOK", RCP_PARAM_MEDIA_LOOK_LIST},
    {"CLOK", RCP_PARAM_CAMERA_LOOK_LIST},
    {"POSTTC", RCP_PARAM_TIMECODE},
    {"CAMSCENE", RCP_PARAM_SLATE_SCENE},
    {"CAMMODE", RCP_PARAM_CAMERA_CAPTURE_MODE},
    {"AFRCKSPD", RCP_PARAM_AF_RACK_SPEED},
    {"F0MODE", RCP_PARAM_FRAME_GUIDE_MODE},
    {"AELOCKAP", RCP_PARAM_AE_LOCK_APERTURE},
    {"DPRLCD", RCP_PARAM_DISPLAY_PRESET_REAR_LCD},
    {"REDCODE", RCP_PARAM_REDCODE},
    {"LENSCAP", RCP_PARAM_LENS_CAPABILITIES},
    {"MTMST0", RCP_PARAM_FOCUS_STATE},
    {"RECFS", RCP_PARAM_FAN_REC_SPEED},
    {"AFRCKNPT", RCP_PARAM_AF_RACK_NUMBER_OF_POINTS},
    {"CAMERAOP", RCP_PARAM_SLATE_CAMERA_OPERATOR},
    {"CDLEN", RCP_PARAM_CDL_ENABLE},
    {"TCDMODE", RCP_PARAM_TIMECODE_DISPLAY_MODE},
    {"PORECFPS", RCP_PARAM_OVERDRIVE_FRAME_RATE},
    {"PRERECON", RCP_PARAM_PRE_RECORD_ALWAYS_TRIGGER},
    {"GESTDTR", RCP_PARAM_UI_GESTURE_DOUBLE_TAP_RIGHT_REC},
    {"CONTRST", RCP_PARAM_CONTRAST},
    {"FOCSCTRL", RCP_PARAM_FOCUS_CONTROL},
    {"PLCDF", RCP_PARAM_MONITOR_FREQ_REAR_LCD},
    {"PLCDFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_LCD},
    {"RLCDFMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_LCD},
    {"GESTDTL", RCP_PARAM_UI_GESTURE_DOUBLE_TAP_LEFT_AF},
    {"SENSNAME", RCP_PARAM_SENSOR_NAME},
    {"F0SCL", RCP_PARAM_FRAME_GUIDE_SCALE},
    {"COLTMP", RCP_PARAM_COLOR_TEMPERATURE},
    {"CMATRG", RCP_PARAM_USER_MATRIX_RG},
    {"CMATBG", RCP_PARAM_USER_MATRIX_BG},
    {"TCLTCOUT", RCP_PARAM_TIMECODE_LTC_OUT_ENABLE},
    {"COLTMPP", RCP_PARAM_COLOR_TEMPERATURE_PRESET},
    {"CAMCOLOR", RCP_PARAM_SLATE_CAMERA_COLOR},
    {"LNMTNAME", RCP_PARAM_LENS_META_NAME},
    {"DRPFRMS", RCP_PARAM_R3D_DROPPED_FRAMES},
    {"FRPRMODE", RCP_PARAM_FRAME_PROCESSING_MODE},
    {"GENSRC", RCP_PARAM_GENLOCK_SOURCE},
    {"TPATTONE", RCP_PARAM_TEST_PATTERN_TONE},
    {"LCDF", RCP_PARAM_MONITOR_FREQ_LCD},
    {"FRPRMODT", RCP_PARAM_FRAME_PROCESSING_MODE},
    {"GENLOC", RCP_PARAM_GENLOCK_STATE},
    {"SENSFPS", RCP_PARAM_SENSOR_FRAME_RATE},
    {"USECFL", RCP_PARAM_USE_CUSTOM_FORMAT},
    {"USECFRL", RCP_PARAM_USE_CUSTOM_FRAME_RATE},
    {"LNMTMANU", RCP_PARAM_LENS_META_MANUFACTURER},
    {"GENETMSK", RCP_PARAM_GIGABIT_ETHERNET_NETMASK},
    {"F0COLOR", RCP_PARAM_FRAME_GUIDE_COLOR},
    {"FANTRGTT", RCP_PARAM_FAN_TARGET_TEMPERATURE},
    {"MMNDMODE", RCP_PARAM_MM_ND_MODE},
    {"ROFFSET", RCP_PARAM_CDL_OFFSET_RED},
    {"RTRNFST", RCP_PARAM_RETURN_FEED_STATE},
    {"F0LNST", RCP_PARAM_FRAME_GUIDE_LINE_STYLE},
    {"CGCOLOR", RCP_PARAM_CENTER_GUIDE_COLOR},
    {"OLPF", RCP_PARAM_OLPF_TYPE},
    {"PLCDFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_LCD},
    {"FRMTAR", RCP_PARAM_RECORD_FORMAT_ASPECT_RATIO},
    {"RMSTATE", RCP_PARAM_REDMOTE_STATE},
    {"PROJFPS", RCP_PARAM_PROJECT_FRAME_RATE},
    {"BLCDDM", RCP_PARAM_MONITOR_DOCK_MENUS_LCD},
    {"BLCDRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD},
    {"BLCDBR", RCP_PARAM_MONITOR_BRIGHTNESS_LCD},
    {"PBCLSTTM", RCP_PARAM_PLAYBACK_CLIP_TIME},
    {"OLPFTPEM", RCP_PARAM_OLPF_THIRD_PARTY_EMULATED_TYPE},
    {"OGTSTATE", RCP_PARAM_OPEN_GATE_STATE},
    {"PBCOLTMP", RCP_PARAM_PLAYBACK_METADATA_COLOR_TEMPERATURE},
    {"BLCDLUT", RCP_PARAM_MONITOR_LUT_LCD},
    {"RTRNFEED", RCP_PARAM_RETURN_FEED},
    {"LNMTFLMN", RCP_PARAM_LENS_META_FLEN_MIN},
    {"CMATRB", RCP_PARAM_USER_MATRIX_RB},
    {"CMATBB", RCP_PARAM_USER_MATRIX_BB},
    {"RGAMMA", RCP_PARAM_LGG_GAMMA_RED},
    {"BATTRTM", RCP_PARAM_POWER_TIME_REMAINING},
    {"BLCDTL", RCP_PARAM_MONITOR_TOOLS_LCD},
    {"RMMAC", RCP_PARAM_REDMOTE_ATTACHED_MAC},
    {"APSTART", RCP_PARAM_AUTO_PRESET_STARTUP},
    {"LENSFDMD", RCP_PARAM_FOCUS_DIST_DISPLAY_MODE},
    {"AFENCONS", RCP_PARAM_AF_ENHANCED_CONFIRM_STYLE},
    {"CAMTAKE", RCP_PARAM_SLATE_TAKE},
    {"CSPACE", RCP_PARAM_COLOR_SPACE},
    {"RMPMAC", RCP_PARAM_REDMOTE_PAIRED_LIST},
    {"PBCLSTDT", RCP_PARAM_PLAYBACK_CLIP_DATE},
    {"VMCODEC", RCP_PARAM_RECORD_VIDEO_MXF_CODEC},
    {"VMCODECR", RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION},
    {"OLPFTPNM", RCP_PARAM_OLPF_THIRD_PARTY_NAME},
    {"VMCODECT", RCP_PARAM_RECORD_VIDEO_MXF_CODEC},
    {"VMCODCRT", RCP_PARAM_RECORD_VIDEO_MXF_CODEC_RESOLUTION},
    {"TCSOURCE", RCP_PARAM_TIMECODE_SOURCE},
    {"RMCH", RCP_PARAM_REDMOTE_WIRELESS_CHANNEL},
    {"RMCAMMAC", RCP_PARAM_REDMOTE_CAMERA_MAC},
    {"TETHERS", RCP_PARAM_TETHERING_SUPPORTED},
    {"FRMTANA", RCP_PARAM_RECORD_FORMAT_ANAMORPHIC},
    {"OGTMODE", RCP_PARAM_OPEN_GATE_MODE},
    {"FUIBR", RCP_PARAM_MONITOR_BRIGHTNESS_SIDE_UI},
    {"PLCDOV", RCP_PARAM_MONITOR_OVERLAY_REAR_LCD},
    {"RMDMAC", RCP_PARAM_REDMOTE_DISCOVERED_LIST},
    {"CLPOUTPT", RCP_PARAM_PLAYBACK_OUT_POINT},
    {"EVFM", RCP_PARAM_MONITOR_MODE_EVF},
    {"MEDASRNU", RCP_PARAM_MEDIA_SERIAL_NUMBER},
    {"SUNAME", RCP_PARAM_SIDE_UI_NAME},
    {"VUSRC", RCP_PARAM_AUDIO_VU_METER_SOURCE},
    {"SATURAT", RCP_PARAM_SATURATION},
    {"MEDACLPC", RCP_PARAM_MEDIA_CLIP_COUNT},
    {"CAMNAME", RCP_PARAM_CAMERA_TYPE},
    {"PEAKLVL", RCP_PARAM_PEAKING_LEVEL},
    {"GREENG", RCP_PARAM_GREEN_GAIN},
    {"CSATURAT", RCP_PARAM_CDL_SATURATION},
    {"PLCDCV", RCP_PARAM_MONITOR_CURVE_REAR_LCD},
    {"TCDFMODE", RCP_PARAM_TIMECODE_DROP_FRAME_DISPLAY_MODE},
    {"GOFFSET", RCP_PARAM_CDL_OFFSET_GREEN},
    {"GGCOLOR", RCP_PARAM_GRID_GUIDE_COLOR},
    {"DPUHD", RCP_PARAM_DISPLAY_PRESET_REAR_UHDSDI},
    {"TINT", RCP_PARAM_TINT},
    {"RECTLINT", RCP_PARAM_RECORD_TIMELAPSE_INTERVAL},
    {"FMTCAMPO", RCP_PARAM_MEDIA_FORMAT_CAMERA_POS},
    {"MOVR", RCP_PARAM_MEDIA_OVERLAY_LIST},
    {"COVR", RCP_PARAM_CAMERA_OVERLAY_LIST},
    {"FORMATST", RCP_PARAM_RECORD_FORMAT_NAME},
    {"RCTARGET", RCP_PARAM_REDCODE},
    {"FOCUS", RCP_PARAM_FOCUS_DIST},
    {"VCODEC", RCP_PARAM_RECORD_VIDEO_CODEC},
    {"FOCUSF", RCP_PARAM_FOCUS_DIST_FAR},
    {"VCODECR", RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION},
    {"BLCDFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD},
    {"MVMCODEC", RCP_PARAM_MIN_RECORD_VIDEO_MXF_CODEC},
    {"VCODECT", RCP_PARAM_RECORD_VIDEO_CODEC},
    {"DATETIME", RCP_PARAM_RTC_DATE_TIME},
    {"CGMARK", RCP_PARAM_CENTER_GUIDE_MARKER_TYPE},
    {"VCODECRT", RCP_PARAM_RECORD_VIDEO_CODEC_RESOLUTION},
    {"ISO", RCP_PARAM_ISO},
    {"MASTRINT", RCP_PARAM_MASTER_INTEGRATION_TIME},
    {"BLCDFMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD},
    {"UILOCK", RCP_PARAM_UI_LOCK_TOUCHSCREEN},
    {"MINRC", RCP_PARAM_MIN_REDCODE},
    {"SHMODE", RCP_PARAM_SHUTTER_MODE},
    {"GGAMMA", RCP_PARAM_LGG_GAMMA_GREEN},
    {"GEMAC", RCP_PARAM_GIGABIT_ETHERNET_MAC_ADDRESS},
    {"MODCAP", RCP_PARAM_MODULE_CAPABILITIES},
    {"FRMTSPH", RCP_PARAM_RECORD_FORMAT_SPHERICAL},
    {"PLCDG", RCP_PARAM_MONITOR_FEED_REAR_LCD},
    {"PRISTOR", RCP_PARAM_PRIMARY_STORAGE},
    {"GSPACE", RCP_PARAM_GAMMA_SPACE},
    {"TARGET", RCP_PARAM_TARGET},
    {"EVFF", RCP_PARAM_MONITOR_FREQ_EVF},
    {"COLORSCI", RCP_PARAM_COLOR_SCIENCE},
    {"CAMMEID", RCP_PARAM_SLATE_CAMERA_ID},
    {"REVFDM", RCP_PARAM_MONITOR_DOCK_MENUS_REAR_EVF},
    {"CAMSHOT", RCP_PARAM_SLATE_SHOT},
    {"REVFRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_EVF},
    {"CMATGR", RCP_PARAM_USER_MATRIX_GR},
    {"REVFBR", RCP_PARAM_MONITOR_BRIGHTNESS_REAR_EVF},
    {"DEVCON", RCP_PARAM_OUTPUT_TONE_MAP},
    {"MASTRISO", RCP_PARAM_MASTER_ISO},
    {"FOCUSN", RCP_PARAM_FOCUS_DIST_NEAR},
    {"CUSTMINT", RCP_PARAM_CUSTOM_INTEGRATION_TIME},
    {"REDG", RCP_PARAM_RED_GAIN},
    {"SMLCKNAV", RCP_PARAM_SIDE_MODULE_NAV_KEYS_LOCKABLE},
    {"MASTRPHS", RCP_PARAM_MASTER_SHUTTER_ANGLE},
    {"F2MODE", RCP_PARAM_TITLE_GUIDE_MODE},
    {"REVFLUT", RCP_PARAM_MONITOR_LUT_REAR_EVF},
    {"PRODUCTN", RCP_PARAM_SLATE_PRODUCTION},
    {"MTMST2", RCP_PARAM_ZOOM_STATE},
    {"BATTMODE", RCP_PARAM_POWER_DISPLAY_MODE},
    {"LCDG", RCP_PARAM_MONITOR_FEED_LCD},
    {"REVFTL", RCP_PARAM_MONITOR_TOOLS_REAR_EVF},
    {"TIMEZONE", RCP_PARAM_TIMEZONE},
    {"CH56ONME", RCP_PARAM_AUDIO_CH56_OUTPUT_NAME},
    {"MMSHCOLR", RCP_PARAM_MM_SHUTTER_COLOR},
    {"HCFOCUS", RCP_PARAM_HAND_CONTROLLER_FOCUS_POS},
    {"DOPNAME", RCP_PARAM_SLATE_DOP},
    {"FILEFMT", RCP_PARAM_RECORD_FILE_FORMAT},
    {"BOFFSET", RCP_PARAM_CDL_OFFSET_BLUE},
    {"RLIFT", RCP_PARAM_LGG_LIFT_RED},
    {"R3DST", RCP_PARAM_RECORD_REDCODE_RAW_STATE},
    {"CUSTMISO", RCP_PARAM_CUSTOM_ISO},
    {"F2SCL", RCP_PARAM_TITLE_GUIDE_SCALE},
    {"BLCDFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD},
    {"CUSTMPHS", RCP_PARAM_CUSTOM_SHUTTER_ANGLE},
    {"REVFM", RCP_PARAM_MONITOR_MODE_REAR_EVF},
    {"RIGSTATE", RCP_PARAM_RIG_STATE},
    {"DIRECTOR", RCP_PARAM_SLATE_DIRECTOR},
    {"RECLIMFR", RCP_PARAM_RECORD_LIMIT_FRAMES},
    {"PRORESH", RCP_PARAM_PRORES_HEIGHT},
    {"SHCOLOR", RCP_PARAM_SHADING_COLOR},
    {"APMOTION", RCP_PARAM_AUTO_PRESET_MOTION},
    {"SHRCKDST", RCP_PARAM_SHOW_RACK_DISTANCES},
    {"MINFRPRM", RCP_PARAM_MIN_FRAME_PROCESSING_MODE},
    {"MINFRPRF", RCP_PARAM_MIN_FRAME_PROCESSING_FRAME_COUNT},
    {"CAMID", RCP_PARAM_CAMERA_ID},
    {"CLPDIR", RCP_PARAM_PLAYBACK_CLIP_DIR},
    {"AFSIZE", RCP_PARAM_AF_SIZE},
    {"TURRGLO", RCP_PARAM_GENLOCK_OFFSET_REDCAST},
    {"R3DSTD", RCP_PARAM_RECORD_REDCODE_RAW_STATE_DETAILED},
    {"BGAMMA", RCP_PARAM_LGG_GAMMA_BLUE},
    {"F0NUM", RCP_PARAM_FRAME_GUIDE_USER_AR_NUM},
    {"AFENHNCD", RCP_PARAM_AF_ENHANCED_ENABLE},
    {"RCPVER", RCP_PARAM_RCP_VERSION},
    {"DIALOGS", RCP_PARAM_DIALOG_LIST},
    {"RCURVE", RCP_PARAM_RED_CURVE},
    {"PWRSRC", RCP_PARAM_POWER_SOURCE},
    {"DPLCD3", RCP_PARAM_DISPLAY_PRESET_LCD3},
    {"VCODECG", RCP_PARAM_RECORD_VIDEO_CODEC_FEED},
    {"TSRVSPR", RCP_PARAM_TETHERED_SERVER_SPACE_REMAINING},
    {"TSRVSPT", RCP_PARAM_TETHERED_SERVER_SPACE_TOTAL},
    {"PLCDVF", RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_LCD},
    {"GPOUT", RCP_PARAM_GPO_FUNCTION},
    {"F2COLOR", RCP_PARAM_TITLE_GUIDE_COLOR},
    {"LCURVE", RCP_PARAM_LUMA_CURVE},
    {"F1MODE", RCP_PARAM_ACTION_GUIDE_MODE},
    {"APAUMOTN", RCP_PARAM_AUTO_PRESET_MOTION_AUTO_UPDATE},
    {"CNA1STA", RCP_PARAM_REMOTE_CONTROL_PANEL_STATUS},
    {"GEDHCP", RCP_PARAM_GIGABIT_ETHERNET_DHCP_ENABLE},
    {"HDRMODE", RCP_PARAM_RECORD_HDR_MODE},
    {"GPIN", RCP_PARAM_GPI_FUNCTION},
    {"RECLIMEN", RCP_PARAM_RECORD_LIMIT_ENABLE},
    {"F2LNST", RCP_PARAM_TITLE_GUIDE_LINE_STYLE},
    {"MTMST1", RCP_PARAM_IRIS_STATE},
    {"TSRVSTAT", RCP_PARAM_TETHERED_SERVER_STATE},
    {"F0ABSH", RCP_PARAM_FRAME_GUIDE_ABS_H},
    {"MMNDV", RCP_PARAM_ND_VAL},
    {"RUNTIME", RCP_PARAM_CAMERA_RUNTIME},
    {"APSTILLS", RCP_PARAM_AUTO_PRESET_STILLS},
    {"BLCDOV", RCP_PARAM_MONITOR_OVERLAY_LCD},
    {"DPREVF", RCP_PARAM_DISPLAY_PRESET_REAR_EVF},
    {"AFENHMON", RCP_PARAM_AF_ENHANCED_MONITOR},
    {"TSRVRN", RCP_PARAM_TETHERED_SERVER_REEL_NO},
    {"F2RELF0", RCP_PARAM_TITLE_GUIDE_RELATIVE},
    {"FRSHARP", RCP_PARAM_OUTPUT_SHARPNESS},
    {"REVFF", RCP_PARAM_MONITOR_FREQ_REAR_EVF},
    {"REVFFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_EVF},
    {"CMATGG", RCP_PARAM_USER_MATRIX_GG},
    {"PBISO", RCP_PARAM_PLAYBACK_METADATA_ISO},
    {"F1SCL", RCP_PARAM_ACTION_GUIDE_SCALE},
    {"ACTION", RCP_PARAM_KEY_MAPPING_ACTION_LIST},
    {"POBAE", RCP_PARAM_POWER_OUT_BAT_AUX_ENABLE},
    {"POBAS", RCP_PARAM_POWER_OUT_BAT_AUX_STATUS},
    {"REVFFMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_REAR_EVF},
    {"METACV", RCP_PARAM_RECORD_R3D_METADATA_CURVE},
    {"CNA1ENA", RCP_PARAM_REMOTE_CONTROL_PANEL_ENABLE},
    {"GIOCSEC", RCP_PARAM_GIO_SCOPE_SECONDARY_COLORS},
    {"RLCDFM2", RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_LCD},
    {"GIOZONE", RCP_PARAM_GIO_SCOPE_ZONES},
    {"GEC2C", RCP_PARAM_GIGABIT_ETHERNET_C2C_ENABLE},
    {"TAGGED", RCP_PARAM_FRAME_TAG},
    {"CLUTCH0", RCP_PARAM_LUT_CH_0},
    {"TSRVCN", RCP_PARAM_TETHERED_SERVER_CLIP_NO},
    {"LENSISEN", RCP_PARAM_LENS_IMAGE_STABILIZATION_ENABLED},
    {"POPIOPE", RCP_PARAM_POWER_OUT_PRO_IO_PWR_ENABLE},
    {"POPIOPS", RCP_PARAM_POWER_OUT_PRO_IO_PWR_STATUS},
    {"GLIFT", RCP_PARAM_LGG_LIFT_GREEN},
    {"PRORESW", RCP_PARAM_PRORES_WIDTH},
    {"USECINTL", RCP_PARAM_USE_CUSTOM_INTEGRATION_TIME},
    {"LCDCV", RCP_PARAM_MONITOR_CURVE_LCD},
    {"CLPINPT", RCP_PARAM_PLAYBACK_IN_POINT},
    {"RECPRE", RCP_PARAM_RECORD_PRE_FRAME_COUNT},
    {"POBAC", RCP_PARAM_POWER_OUT_BAT_AUX_CURRENT},
    {"CALINT", RCP_PARAM_CURRENT_CALIBRATION_INTEGRATION_TIME},
    {"QTST", RCP_PARAM_RECORD_QUICKTIME_STATE},
    {"POPIOAE", RCP_PARAM_POWER_OUT_PRO_IO_AUX_ENABLE},
    {"QTSTD", RCP_PARAM_RECORD_QUICKTIME_STATE_DETAILED},
    {"RECPOST", RCP_PARAM_RECORD_POST_FRAME_COUNT},
    {"MONLIST", RCP_PARAM_MONITOR_LIST},
    {"F1COLOR", RCP_PARAM_ACTION_GUIDE_COLOR},
    {"RAWMODE", RCP_PARAM_RAW_MODE},
    {"RSLOPE", RCP_PARAM_CDL_SLOPE_RED},
    {"RECPREA", RCP_PARAM_RECORD_PRE_FRAME_COUNT_AVAILABLE},
    {"TETHERSI", RCP_PARAM_TETHERING_SUPPORTED_ON_THIS_INTERFACE},
    {"F1LNST", RCP_PARAM_ACTION_GUIDE_LINE_STYLE},
    {"SUPPORT", RCP_PARAM_SUPPORT_CONTACT},
    {"MMSHTIME", RCP_PARAM_MM_INTEGRATION_TIME},
    {"LNMTOWNR", RCP_PARAM_LENS_META_OWNER},
    {"CAMPOS", RCP_PARAM_SLATE_CAMERA_POS},
    {"FMTCAMID", RCP_PARAM_MEDIA_FORMAT_CAMERA_ID},
    {"RAMPDFPS", RCP_PARAM_RAMP_D_FPS},
    {"USECISOL", RCP_PARAM_USE_CUSTOM_ISO},
    {"RAMPBFPS", RCP_PARAM_RAMP_B_FPS},
    {"PLAY", RCP_PARAM_PLAYBACK_PLAY},
    {"RECPOSTA", RCP_PARAM_RECORD_POST_FRAME_COUNT_AVAILABLE},
    {"PREVFS", RCP_PARAM_FAN_PREVIEW_SPEED},
    {"PBHDRTRC", RCP_PARAM_PLAYBACK_NUM_HDR_TRACKS},
    {"REVFFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_EVF},
    {"WLANSCRL", RCP_PARAM_WIFI_SCAN_RESULTS},
    {"GCURVE", RCP_PARAM_GREEN_CURVE},
    {"F1RELF0", RCP_PARAM_ACTION_GUIDE_RELATIVE},
    {"ROTF1", RCP_PARAM_FLIP_MIRROR_FEED_1},
    {"BLUEG", RCP_PARAM_BLUE_GAIN},
    {"F0ABSW", RCP_PARAM_FRAME_GUIDE_ABS_W},
    {"FPRDELAY", RCP_PARAM_FAN_DELAY},
    {"VIDEOSRC", RCP_PARAM_VIDEO_SOURCE},
    {"WLANSTAT", RCP_PARAM_WIFI_STATE},
    {"BEVFDM", RCP_PARAM_MONITOR_DOCK_MENUS_EVF},
    {"MMMISOND", RCP_PARAM_MM_ISO_PULL},
    {"BEVFRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF},
    {"CMATGB", RCP_PARAM_USER_MATRIX_GB},
    {"BEVFBR", RCP_PARAM_MONITOR_BRIGHTNESS_EVF},
    {"AESPEED", RCP_PARAM_AE_SPEED},
    {"MINSHT", RCP_PARAM_MIN_EXPOSURE_INTEGRATION_TIME},
    {"APAUSTIL", RCP_PARAM_AUTO_PRESET_STILLS_AUTO_UPDATE},
    {"BEVFLUT", RCP_PARAM_MONITOR_LUT_EVF},
    {"RAMPCFPS", RCP_PARAM_RAMP_C_FPS},
    {"FRMTA2", RCP_PARAM_RECORD_FORMAT_ANA_2},
    {"RAMPDDUR", RCP_PARAM_RAMP_D_DURATION},
    {"RAMPRDUR", RCP_PARAM_RAMP_RESET_DURATION},
    {"SSCANDIR", RCP_PARAM_SENSOR_SCAN_DIRECTION},
    {"CAMINFO", RCP_PARAM_CAMERA_INFO},
    {"RAMPBDUR", RCP_PARAM_RAMP_B_DURATION},
    {"AUTOPEAK", RCP_PARAM_AUTO_FOCUS_PEAK},
    {"DPEVF", RCP_PARAM_DISPLAY_PRESET_EVF},
    {"EVFG", RCP_PARAM_MONITOR_FEED_EVF},
    {"PLAYBACK", RCP_PARAM_PLAYBACK_STATE},
    {"BEVFTL", RCP_PARAM_MONITOR_TOOLS_EVF},
    {"SLHEAD", RCP_PARAM_SLATE_AUTO_HEAD_FRAMES},
    {"MXFDRPFM", RCP_PARAM_MXF_DROPPED_FRAMES},
    {"MXFST", RCP_PARAM_RECORD_MXF_STATE},
    {"CLUTF1", RCP_PARAM_LUT_FEED_1},
    {"MINSHA", RCP_PARAM_MIN_EXPOSURE_ANGLE},
    {"PLAYSPD", RCP_PARAM_PLAYBACK_SPEED},
    {"SMLCKKEY", RCP_PARAM_SIDE_MODULE_LOCK_KEYS},
    {"SYNC", RCP_PARAM_SYNC_STATE},
    {"MIVCODEC", RCP_PARAM_MIN_RECORD_VIDEO_CODEC},
    {"MEDPRSNT", RCP_PARAM_MEDIA_IS_PRESENT},
    {"WLANMAC", RCP_PARAM_WIFI_MAC_ADDRESS},
    {"BLIFT", RCP_PARAM_LGG_LIFT_BLUE},
    {"WLANSCAN", RCP_PARAM_WIFI_SCAN},
    {"POPOPE", RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_ENABLE},
    {"POPOPS", RCP_PARAM_POWER_OUT_PLUS_ONE_PWR_STATUS},
    {"AFZONE", RCP_PARAM_AF_ZONE},
    {"PORXTCE", RCP_PARAM_POWER_OUT_TIMECODE_ENABLE},
    {"PORXTCS", RCP_PARAM_POWER_OUT_TIMECODE_STATUS},
    {"PLPOWER", RCP_PARAM_PL_POWER},
    {"WLANNETM", RCP_PARAM_WIFI_NETMASK},
    {"CAMUNIT", RCP_PARAM_SLATE_UNIT},
    {"FANPCTF", RCP_PARAM_FAN_SPEED_FRONT},
    {"RAMPCDUR", RCP_PARAM_RAMP_C_DURATION},
    {"FANPCTT", RCP_PARAM_FAN_SPEED_TOP},
    {"RGAIN", RCP_PARAM_LGG_GAIN_RED},
    {"POPIOGE", RCP_PARAM_POWER_OUT_PRO_IO_GPIO_ENABLE},
    {"POPIOGS", RCP_PARAM_POWER_OUT_PRO_IO_GPIO_STATUS},
    {"REVFOV", RCP_PARAM_MONITOR_OVERLAY_REAR_EVF},
    {"MEDATCHD", RCP_PARAM_MEDIA_IS_ATTACHED},
    {"PROJINFO", RCP_PARAM_SLATE_COPYRIGHT},
    {"MXFSTD", RCP_PARAM_RECORD_MXF_STATE_DETAILED},
    {"CALENTRY", RCP_PARAM_CALIBRATION_ENTRY},
    {"MAXRC", RCP_PARAM_MAX_REDCODE},
    {"EXPCOMP", RCP_PARAM_EXPOSURE_COMPENSATION},
    {"CLUTF1EN", RCP_PARAM_LUT_FEED_1_ENABLE},
    {"MMSHANGL", RCP_PARAM_MM_SHUTTER_ANGLE},
    {"ROTF0", RCP_PARAM_FLIP_MIRROR_FEED_0},
    {"FMTFSYS", RCP_PARAM_MEDIA_FORMAT_FILE_SYSTEM},
    {"GEEXT", RCP_PARAM_GIGABIT_ETHERNET_EXT_ENABLE},
    {"SLTAIL", RCP_PARAM_SLATE_AUTO_TAIL_FRAMES},
    {"AMBNTCH", RCP_PARAM_AMBIENT_CHANNEL},
    {"BCURVE", RCP_PARAM_BLUE_CURVE},
    {"BLCDVF", RCP_PARAM_MONITOR_VIDEO_FLIP_LCD},
    {"GSLOPE", RCP_PARAM_CDL_SLOPE_GREEN},
    {"VOLTHSDC", RCP_PARAM_VOLTAGE_THRESHOLD_DC_IN},
    {"UHDSDIF", RCP_PARAM_MONITOR_FREQ_REAR_UHDSDI},
    {"MEDIA", RCP_PARAM_MEDIA_ACTIVE_MEDIA},
    {"REVFCV", RCP_PARAM_MONITOR_CURVE_REAR_EVF},
    {"MPITCH", RCP_PARAM_CAMERA_PITCH},
    {"LCD3DM", RCP_PARAM_MONITOR_DOCK_MENUS_LCD3},
    {"LCD3RF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_LCD3},
    {"PWRBATL", RCP_PARAM_POWER_VAL},
    {"LCD3BR", RCP_PARAM_MONITOR_BRIGHTNESS_LCD3},
    {"TCJAM", RCP_PARAM_TIMECODE_STATE},
    {"RPOWER", RCP_PARAM_CDL_POWER_RED},
    {"BSDILUT", RCP_PARAM_MONITOR_LUT_HDSDI},
    {"MEDIAPCT", RCP_PARAM_MEDIA_VAL},
    {"TARGETID", RCP_PARAM_TARGET_ID},
    {"PLAYFMT", RCP_PARAM_PLAYBACK_FILE_FORMAT},
    {"LCD3LUT", RCP_PARAM_MONITOR_LUT_BRAIN_LCD3},
    {"AELOCKEX", RCP_PARAM_AE_LOCK_EXPOSURE},
    {"SERPROTO", RCP_PARAM_SERIAL_PROTOCOL},
    {"PLAYFMTT", RCP_PARAM_PLAYBACK_FILE_FORMAT},
    {"TSRVAD", RCP_PARAM_TETHERED_SERVER_ADDRESS},
    {"LOOP", RCP_PARAM_PLAYBACK_LOOP},
    {"LCD3TL", RCP_PARAM_MONITOR_TOOLS_LCD3},
    {"SMDLG9IN", RCP_PARAM_UI_SMALL_DIALOGS_ON_9_INCH},
    {"BEVFFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF},
    {"MASTRAWB", RCP_PARAM_MASTER_COLOR_TEMPERATURE},
    {"DPHDSDI", RCP_PARAM_DISPLAY_PRESET_HDSDI},
    {"DPHDMI", RCP_PARAM_DISPLAY_PRESET_HDMI},
    {"NWSTAT", RCP_PARAM_GIGE_STATE},
    {"AINSR3ST", RCP_PARAM_AUDIO_CH3_MODE_STATUS},
    {"WLANMODE", RCP_PARAM_WIFI_MODE},
    {"BEVFFMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_BRAIN_EVF},
    {"FORMAT2", RCP_PARAM_RECORD_FORMAT},
    {"HDRFACT", RCP_PARAM_HDR_FACTOR},
    {"LCD3M", RCP_PARAM_MONITOR_MODE_LCD3},
    {"CH34ST", RCP_PARAM_AUDIO_CH34_STATE},
    {"CH34SRC", RCP_PARAM_AUDIO_CH34_SOURCE},
    {"BLCDFM2", RCP_PARAM_MONITOR_FLIP_MIRROR_LCD},
    {"PBTINT", RCP_PARAM_PLAYBACK_METADATA_TINT},
    {"F2NUM", RCP_PARAM_TITLE_GUIDE_USER_AR_NUM},
    {"AINSR2ST", RCP_PARAM_AUDIO_CH2_MODE_STATUS},
    {"REVFG", RCP_PARAM_MONITOR_FEED_REAR_EVF},
    {"MEDIANUM", RCP_PARAM_MEDIA_MODEL_NUMBER},
    {"VCBAKED", RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS},
    {"CNA1ADDR", RCP_PARAM_REMOTE_CONTROL_PANEL_ADDRESS},
    {"EVOLTHDC", RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD_DC_IN},
    {"VCBAKEDT", RCP_PARAM_RECORD_PROXY_BAKED_IN_SETTINGS},
    {"CUSTMAWB", RCP_PARAM_CUSTOM_COLOR_TEMPERATURE},
    {"EVFCV", RCP_PARAM_MONITOR_CURVE_EVF},
    {"PWIBTRT", RCP_PARAM_POWER_IN_RUNTIME_0},
    {"DPPHDSD2", RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI2},
    {"BEEPREC", RCP_PARAM_BEEP_RECORD_START},
    {"RECPREB", RCP_PARAM_RECORD_PRE_FRAME_COUNT_ACTUAL},
    {"MAXFRPRM", RCP_PARAM_MAX_FRAME_PROCESSING_MODE},
    {"MAXFRPRF", RCP_PARAM_MAX_FRAME_PROCESSING_FRAME_COUNT},
    {"F0ABSYOF", RCP_PARAM_FRAME_GUIDE_ABS_Y_OFFSET},
    {"F2ABSH", RCP_PARAM_TITLE_GUIDE_ABS_H},
    {"RECPOSTB", RCP_PARAM_RECORD_POST_FRAME_COUNT_ACTUAL},
    {"PBZOOM", RCP_PARAM_PLAYBACK_METADATA_FOCAL_LENGTH},
    {"GGAIN", RCP_PARAM_LGG_GAIN_GREEN},
    {"AWBMODE", RCP_PARAM_AWB_MODE},
    {"BSLOPE", RCP_PARAM_CDL_SLOPE_BLUE},
    {"CAMVCREV", RCP_PARAM_CAMERA_FIRMWARE_SVN_REVISION},
    {"AUDIOVU", RCP_PARAM_AUDIO_VU_DATA},
    {"CH34ONME", RCP_PARAM_AUDIO_CH34_OUTPUT_NAME},
    {"RAMPAFPS", RCP_PARAM_RAMP_A_FPS},
    {"APPLAY", RCP_PARAM_AUTO_PRESET_PLAYBACK},
    {"BEVFFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF},
    {"CLUTCH3", RCP_PARAM_LUT_CH_3},
    {"BEEPEN", RCP_PARAM_BEEP_ENABLE},
    {"MEDIAMOD", RCP_PARAM_MEDIA_DISPLAY_MODE},
    {"FLENGTH", RCP_PARAM_FOCAL_LENGTH},
    {"CH34OLNK", RCP_PARAM_AUDIO_CH34_LINK_VOL},
    {"LCD3F", RCP_PARAM_MONITOR_FREQ_LCD3},
    {"LNMTFLMX", RCP_PARAM_LENS_META_FLEN_MAX},
    {"LCD3FM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_LCD3},
    {"CLUTCH2", RCP_PARAM_LUT_CH_2},
    {"GPOWER", RCP_PARAM_CDL_POWER_GREEN},
    {"CH3MODE", RCP_PARAM_AUDIO_CH3_MODE},
    {"PHDS2EN", RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI2},
    {"LCD3FMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_LCD3},
    {"RCPPSVER", RCP_PARAM_RCP_PARAMETER_SET_VERSION},
    {"SHANGLE", RCP_PARAM_EXPOSURE_ANGLE},
    {"F1NUM", RCP_PARAM_ACTION_GUIDE_USER_AR_NUM},
    {"AINSR1ST", RCP_PARAM_AUDIO_CH1_MODE_STATUS},
    {"SHANGLET", RCP_PARAM_EXPOSURE_ANGLE},
    {"RAMPADUR", RCP_PARAM_RAMP_A_DURATION},
    {"HDMIR", RCP_PARAM_MONITOR_RESOLUTION_HDMI},
    {"F0ABSXOF", RCP_PARAM_FRAME_GUIDE_ABS_X_OFFSET},
    {"HDSDIM", RCP_PARAM_MONITOR_MODE_HDSDI},
    {"HDSDIF", RCP_PARAM_MONITOR_FREQ_HDSDI},
    {"HDSDIR", RCP_PARAM_MONITOR_RESOLUTION_HDSDI},
    {"WLANAPEN", RCP_PARAM_WIFI_INFRASTRUCTURE_ENCRYPTION},
    {"DSHIST", RCP_PARAM_HISTOGRAM},
    {"CH2MODE", RCP_PARAM_AUDIO_CH2_MODE},
    {"PHDS1EN", RCP_PARAM_MONITOR_ENABLE_REAR_HDSDI1},
    {"SSDTALLY", RCP_PARAM_SSD_TALLY_LIGHT},
    {"SHADOW", RCP_PARAM_SHADOW},
    {"AEEVSHFT", RCP_PARAM_AE_EV_SHIFT},
    {"SHTIME", RCP_PARAM_EXPOSURE_INTEGRATION_TIME},
    {"SHDISP", RCP_PARAM_SHUTTER_DISPLAY_MODE},
    {"REVFVF", RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_EVF},
    {"SHTIMET", RCP_PARAM_EXPOSURE_INTEGRATION_TIME},
    {"DPPHDSD1", RCP_PARAM_DISPLAY_PRESET_REAR_HDSDI1},
    {"SUILPUSR", RCP_PARAM_SIDE_UI_PAGE_USER_LEFT},
    {"SUIRPUSR", RCP_PARAM_SIDE_UI_PAGE_USER_RIGHT},
    {"PORXAE", RCP_PARAM_POWER_OUT_REAR_AUX_ENABLE},
    {"PORXAS", RCP_PARAM_POWER_OUT_REAR_AUX_STATUS},
    {"BEEPSTOP", RCP_PARAM_BEEP_RECORD_STOP},
    {"PORXAC", RCP_PARAM_POWER_OUT_REAR_AUX_CURRENT},
    {"F1ABSH", RCP_PARAM_ACTION_GUIDE_ABS_H},
    {"PSDI2FM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI2},
    {"PSDI2RF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI2},
    {"SUILAH", RCP_PARAM_SIDE_UI_AUTO_HOME_LEFT},
    {"SUIRAH", RCP_PARAM_SIDE_UI_AUTO_HOME_RIGHT},
    {"PSLEVEL3", RCP_PARAM_POWER_SAVE_LEVEL_3},
    {"RSDI2FLT", RCP_PARAM_MONITOR_LUT_REAR_HDSDI2},
    {"BGAIN", RCP_PARAM_LGG_GAIN_BLUE},
    {"F2ABSW", RCP_PARAM_TITLE_GUIDE_ABS_W},
    {"BEVFOV", RCP_PARAM_MONITOR_OVERLAY_EVF},
    {"PSDI2TL", RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI2},
    {"PSDI1FM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_REAR_HDSDI1},
    {"PSDI1RF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_REAR_HDSDI1},
    {"HDMIM", RCP_PARAM_MONITOR_MODE_HDMI},
    {"SENSTVTY", RCP_PARAM_SENSOR_SENSITIVITY},
    {"LDISPM", RCP_PARAM_APERTURE_LIST_MODE},
    {"PSLEVEL2", RCP_PARAM_POWER_SAVE_LEVEL_2},
    {"RSDI1FLT", RCP_PARAM_MONITOR_LUT_REAR_HDSDI1},
    {"CLIPLEN", RCP_PARAM_PLAYBACK_CLIP_LENGTH},
    {"PSDI1TL", RCP_PARAM_MONITOR_TOOLS_REAR_HDSDI1},
    {"USECWBL", RCP_PARAM_USE_CUSTOM_COLOR_TEMPERATURE},
    {"LCD3FO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_LCD3},
    {"MXFH", RCP_PARAM_MXF_HEIGHT},
    {"BHDSDIFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDSDI},
    {"PSDI2DM", RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI2},
    {"BHDSDIRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDSDI},
    {"REVFFM2", RCP_PARAM_MONITOR_FLIP_MIRROR_REAR_EVF},
    {"CLUTCH1", RCP_PARAM_LUT_CH_1},
    {"SUILPAUD", RCP_PARAM_SIDE_UI_PAGE_AUDIO_LEFT},
    {"SUIRPAUD", RCP_PARAM_SIDE_UI_PAGE_AUDIO_RIGHT},
    {"EVF3DM", RCP_PARAM_MONITOR_DOCK_MENUS_EVF3},
    {"OUTPUTTR", RCP_PARAM_OUTPUT_TRANSFORM},
    {"EVF3RF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_EVF3},
    {"BHDSDITL", RCP_PARAM_MONITOR_TOOLS_HDSDI},
    {"PSDI1DM", RCP_PARAM_MONITOR_DOCK_MENUS_REAR_HDSDI1},
    {"EVF3BR", RCP_PARAM_MONITOR_BRIGHTNESS_EVF3},
    {"BEEPTAGS", RCP_PARAM_BEEP_TAG_STILL_FRAME},
    {"HCZOOM", RCP_PARAM_HAND_CONTROLLER_ZOOM_POS},
    {"BPOWER", RCP_PARAM_CDL_POWER_BLUE},
    {"EVF3LUT", RCP_PARAM_MONITOR_LUT_BRAIN_EVF3},
    {"MAXSHT", RCP_PARAM_MAX_EXPOSURE_INTEGRATION_TIME},
    {"CH1MODE", RCP_PARAM_AUDIO_CH1_MODE},
    {"CLIPNMST", RCP_PARAM_CLIP_NAME_STATUS},
    {"EVF3TL", RCP_PARAM_MONITOR_TOOLS_EVF3},
    {"BHDSDIDM", RCP_PARAM_MONITOR_DOCK_MENUS_HDSDI},
    {"TWARN3", RCP_PARAM_CORE_TEMP_WARNING_3},
    {"WLANDHCP", RCP_PARAM_WIFI_DHCP_ENABLE},
    {"PSDI2FO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI2},
    {"BHDSDIEN", RCP_PARAM_MONITOR_ENABLE_HDSDI},
    {"MAXSHA", RCP_PARAM_MAX_EXPOSURE_ANGLE},
    {"CLIPNAME", RCP_PARAM_CLIP_NAME},
    {"KEYACNOT", RCP_PARAM_SHOW_KEY_ACTION_NOTIFICATIONS},
    {"SUILAHTO", RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_LEFT},
    {"SUIRAHTO", RCP_PARAM_SIDE_UI_AUTO_HOME_TIMEOUT_RIGHT},
    {"PWRSAVE", RCP_PARAM_POWER_SAVE_STATE},
    {"TWARN2", RCP_PARAM_CORE_TEMP_WARNING_2},
    {"WLANGATE", RCP_PARAM_WIFI_GATEWAY},
    {"EVF3M", RCP_PARAM_MONITOR_MODE_EVF3},
    {"PSDI1FO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_REAR_HDSDI1},
    {"HDMIF", RCP_PARAM_MONITOR_FREQ_HDMI},
    {"F0OPAC", RCP_PARAM_FRAME_GUIDE_OPACITY},
    {"HDSDIG", RCP_PARAM_MONITOR_FEED_HDSDI},
    {"WSHFOCUS", RCP_PARAM_WSH_FOCUS_WHEEL},
    {"SHUTDOWN", RCP_PARAM_SHUTDOWN},
    {"F1ABSW", RCP_PARAM_ACTION_GUIDE_ABS_W},
    {"MEDIAVER", RCP_PARAM_MEDIA_FIRMWARE_VERSION},
    {"SUILPMON", RCP_PARAM_SIDE_UI_PAGE_MONITOR_LEFT},
    {"SUIRPMON", RCP_PARAM_SIDE_UI_PAGE_MONITOR_RIGHT},
    {"CGOPAC", RCP_PARAM_CENTER_GUIDE_OPACITY},
    {"USECPHSL", RCP_PARAM_USE_CUSTOM_SHUTTER_ANGLE},
    {"PSLEVEL1", RCP_PARAM_POWER_SAVE_LEVEL_1},
    {"LCD3OV", RCP_PARAM_MONITOR_OVERLAY_LCD3},
    {"WLANSIG", RCP_PARAM_WIFI_SIGNAL},
    {"BHDSDIFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDSDI},
    {"CLIPLOAD", RCP_PARAM_PLAYBACK_CLIP_LOAD},
    {"SHSYNC", RCP_PARAM_SENSOR_SYNC_MODE},
    {"PWOLIST", RCP_PARAM_POWER_OUT_LIST},
    {"PWOIST", RCP_PARAM_POWER_OUT_STATUS_0},
    {"F0OFFSY", RCP_PARAM_FRAME_GUIDE_Y_OFFSET},
    {"CGGUIDE", RCP_PARAM_CENTER_GUIDE_GUIDE},
    {"MINFPS", RCP_PARAM_MIN_SENSOR_FRAME_RATE},
    {"AINSR4ST", RCP_PARAM_AUDIO_CH4_MODE_STATUS},
    {"DPEVF3", RCP_PARAM_DISPLAY_PRESET_EVF3},
    {"LCD3CV", RCP_PARAM_MONITOR_CURVE_LCD3},
    {"RCLIP", RCP_PARAM_RED_CLIP},
    {"HORIZON", RCP_PARAM_SHOW_HORIZON_LINE},
    {"BWFENABL", RCP_PARAM_BWF_ENABLE},
    {"CH3_48V", RCP_PARAM_AUDIO_CH3_48V_POWER},
    {"VOLTHSH", RCP_PARAM_VOLTAGE_THRESHOLD},
    {"CH3_48VP", RCP_PARAM_AUDIO_CH3_48V_PRESENT},
    {"PWIAMPS", RCP_PARAM_POWER_IN_CURRENT_0},
    {"WLANIP", RCP_PARAM_WIFI_IP_ADDRESS},
    {"ISOCAL2", RCP_PARAM_ISO_CAL2_ENABLED},
    {"MEDIAMIN", RCP_PARAM_MEDIA_TIME_REMAINING},
    {"CH2_48V", RCP_PARAM_AUDIO_CH2_48V_POWER},
    {"SERPROT2", RCP_PARAM_SERIAL_2_PROTOCOL},
    {"RCURVEMY", RCP_PARAM_RED_CURVE_MIDTONE_Y},
    {"RCURVESY", RCP_PARAM_RED_CURVE_SHADOW_Y},
    {"PWOIEN", RCP_PARAM_POWER_OUT_ENABLE_0},
    {"MXFCMPID", RCP_PARAM_RECORD_VIDEO_MXF_COMPRESSION_ID},
    {"CH2_48VP", RCP_PARAM_AUDIO_CH2_48V_PRESENT},
    {"CAMFWVER", RCP_PARAM_CAMERA_FIRMWARE_VERSION},
    {"WLANCHAN", RCP_PARAM_WIFI_CHANNEL},
    {"CH3NAME", RCP_PARAM_AUDIO_CH3_NAME},
    {"EVF3F", RCP_PARAM_MONITOR_FREQ_EVF3},
    {"EVF3FM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_EVF3},
    {"PWISRCI", RCP_PARAM_POWER_CURRENT_SOURCE_INDEX},
    {"PXFMTH", RCP_PARAM_FORMAT_HEIGHT_PIXELS},
    {"TWARN1", RCP_PARAM_CORE_TEMP_WARNING_1},
    {"LCURVEMY", RCP_PARAM_LUMA_CURVE_MIDTONE_Y},
    {"LCURVESY", RCP_PARAM_LUMA_CURVE_SHADOW_Y},
    {"RCURVELY", RCP_PARAM_RED_CURVE_LIGHT_Y},
    {"VCBAKMIN", RCP_PARAM_MIN_RECORD_PROXY_BAKED_IN_SETTINGS},
    {"EVF3FMSP", RCP_PARAM_MONITOR_FLIP_MIRROR_SUPPORTED_EVF3},
    {"CH2NAME", RCP_PARAM_AUDIO_CH2_NAME},
    {"LCURVELY", RCP_PARAM_LUMA_CURVE_LIGHT_Y},
    {"F2ABSYOF", RCP_PARAM_TITLE_GUIDE_ABS_Y_OFFSET},
    {"PWIBTLVL", RCP_PARAM_POWER_IN_PERCENT_0},
    {"F0OFFSX", RCP_PARAM_FRAME_GUIDE_X_OFFSET},
    {"LCD3G", RCP_PARAM_MONITOR_FEED_LCD3},
    {"BEVFVF", RCP_PARAM_MONITOR_VIDEO_FLIP_EVF},
    {"RCURVEDY", RCP_PARAM_RED_CURVE_DARK_Y},
    {"BHDSGLO", RCP_PARAM_GENLOCK_OFFSET_HDSDI},
    {"CH2MUTE", RCP_PARAM_AUDIO_CH2_MUTE},
    {"PHDSD2CV", RCP_PARAM_MONITOR_CURVE_REAR_HDSDI2},
    {"EVFTALLY", RCP_PARAM_EVF_TALLY_LIGHT},
    {"EVOLTHSH", RCP_PARAM_ENABLE_VOLTAGE_THRESHOLD},
    {"MMNDINSZ", RCP_PARAM_ND_INCREMENT_SIZE},
    {"LCURVEDY", RCP_PARAM_LUMA_CURVE_DARK_Y},
    {"FRMTA13", RCP_PARAM_RECORD_FORMAT_ANA_1_3},
    {"PHDSDI2M", RCP_PARAM_MONITOR_MODE_REAR_HDSDI2},
    {"PHDSDI2F", RCP_PARAM_MONITOR_FREQ_REAR_HDSDI2},
    {"PHDSDI2R", RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI2},
    {"HCIRIS", RCP_PARAM_HAND_CONTROLLER_IRIS_POS},
    {"UHDSDI2M", RCP_PARAM_MONITOR_MODE_REAR_UHDSDI2},
    {"GESTPNCH", RCP_PARAM_UI_GESTURE_PINCH_MAGNIFY},
    {"GGOPAC", RCP_PARAM_GRID_GUIDE_OPACITY},
    {"RCURVEMX", RCP_PARAM_RED_CURVE_MIDTONE_X},
    {"RCURVESX", RCP_PARAM_RED_CURVE_SHADOW_X},
    {"CH4MODE", RCP_PARAM_AUDIO_CH4_MODE},
    {"FRMTA125", RCP_PARAM_RECORD_FORMAT_ANA_1_25},
    {"BHDMIFM", RCP_PARAM_MONITOR_UI_FLIP_MIRROR_HDMI},
    {"BHDMIRF", RCP_PARAM_MONITOR_ALLOW_RETURN_FEED_HDMI},
    {"LCURVEMX", RCP_PARAM_LUMA_CURVE_MIDTONE_X},
    {"LCURVESX", RCP_PARAM_LUMA_CURVE_SHADOW_X},
    {"RCURVELX", RCP_PARAM_RED_CURVE_LIGHT_X},
    {"VLTBLWTH", RCP_PARAM_VOLTAGE_BELOW_THRESHOLD},
    {"HDSDICV", RCP_PARAM_MONITOR_CURVE_HDSDI},
    {"CH1_48V", RCP_PARAM_AUDIO_CH1_48V_POWER},
    {"GGGUIDE", RCP_PARAM_GRID_GUIDE_GUIDE},
    {"BHDMITL", RCP_PARAM_MONITOR_TOOLS_HDMI},
    {"EVF3FO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_EVF3},
    {"WLANAPID", RCP_PARAM_WIFI_INFRASTRUCTURE_SSID},
    {"CH1_48VP", RCP_PARAM_AUDIO_CH1_48V_PRESENT},
    {"LCURVELX", RCP_PARAM_LUMA_CURVE_LIGHT_X},
    {"F2ABSXOF", RCP_PARAM_TITLE_GUIDE_ABS_X_OFFSET},
    {"BEVFFM2", RCP_PARAM_MONITOR_FLIP_MIRROR_BRAIN_EVF},
    {"BHDMILUT", RCP_PARAM_MONITOR_LUT_HDMI},
    {"GCLIP", RCP_PARAM_GREEN_CLIP},
    {"RCURVEDX", RCP_PARAM_RED_CURVE_DARK_X},
    {"PHDS2OV", RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI2},
    {"PSDI2VF", RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI2},
    {"CH1NAME", RCP_PARAM_AUDIO_CH1_NAME},
    {"BHDMIDM", RCP_PARAM_MONITOR_DOCK_MENUS_HDMI},
    {"PXFMTW", RCP_PARAM_FORMAT_WIDTH_PIXELS},
    {"F1ABSYOF", RCP_PARAM_ACTION_GUIDE_ABS_Y_OFFSET},
    {"LCURVEDX", RCP_PARAM_LUMA_CURVE_DARK_X},
    {"HDMICV", RCP_PARAM_MONITOR_CURVE_HDMI},
    {"QTDRPFRM", RCP_PARAM_QT_DROPPED_FRAMES},
    {"BRIGHT", RCP_PARAM_BRIGHTNESS},
    {"PHDS1OV", RCP_PARAM_MONITOR_OVERLAY_REAR_HDSDI1},
    {"PSDI1VF", RCP_PARAM_MONITOR_VIDEO_FLIP_REAR_HDSDI1},
    {"GCURVEMY", RCP_PARAM_GREEN_CURVE_MIDTONE_Y},
    {"GCURVESY", RCP_PARAM_GREEN_CURVE_SHADOW_Y},
    {"CH1MUTE", RCP_PARAM_AUDIO_CH1_MUTE},
    {"PXSFMTH", RCP_PARAM_SHADOW_FORMAT_HEIGHT_PIXELS},
    {"PHDSD1CV", RCP_PARAM_MONITOR_CURVE_REAR_HDSDI1},
    {"PLAYTYPE", RCP_PARAM_PLAYBACK_FILE_FORMAT_TYPE},
    {"GEGWADDR", RCP_PARAM_GIGABIT_ETHERNET_GATEWAY},
    {"LCD3VF", RCP_PARAM_MONITOR_VIDEO_FLIP_LCD3},
    {"ROTF01", RCP_PARAM_FLIP_MIRROR_FEED_0_1},
    {"GCURVELY", RCP_PARAM_GREEN_CURVE_LIGHT_Y},
    {"PLAYPAUS", RCP_PARAM_PLAYBACK_PLAY_PAUSE},
    {"BHDSDIVF", RCP_PARAM_MONITOR_VIDEO_FLIP_HDSDI},
    {"PHDSDI1M", RCP_PARAM_MONITOR_MODE_REAR_HDSDI1},
    {"PHDSDI1F", RCP_PARAM_MONITOR_FREQ_REAR_HDSDI1},
    {"PHDSDI1R", RCP_PARAM_MONITOR_RESOLUTION_REAR_HDSDI1},
    {"UHDSDI1M", RCP_PARAM_MONITOR_MODE_REAR_UHDSDI1},
    {"BHDMIFO", RCP_PARAM_MONITOR_FRAMED_OVERLAY_HDMI},
    {"VRISPDMD", RCP_PARAM_VARISPEED_MODE},
    {"MEDAGCII", RCP_PARAM_MEDIA_CLIP_EXT_INFO},
    {"GCURVEDY", RCP_PARAM_GREEN_CURVE_DARK_Y},
    {"EVF3OV", RCP_PARAM_MONITOR_OVERLAY_EVF3},
    {"CH3LIMPR", RCP_PARAM_AUDIO_CH3_LIMITER_PRESENT},
    {"ZEB2CLR", RCP_PARAM_ZEBRA_2_COLOR},
    {"WLANAHEN", RCP_PARAM_WIFI_AD_HOC_ENCRYPTION},
    {"PWILIST", RCP_PARAM_POWER_IN_LIST},
    {"PROXYFPS", RCP_PARAM_PROXY_ENCODE_FRAMERATE},
    {"HDMIG", RCP_PARAM_MONITOR_FEED_HDMI},
    {"F1ABSXOF", RCP_PARAM_ACTION_GUIDE_ABS_X_OFFSET},
    {"CH2LIMPR", RCP_PARAM_AUDIO_CH2_LIMITER_PRESENT},
    {"PHDSDI2G", RCP_PARAM_MONITOR_FEED_REAR_HDSDI2},
    {"SHOPAC", RCP_PARAM_SHADING_OPACITY},
    {"ZEB1CLR", RCP_PARAM_ZEBRA_1_COLOR},
    {"PWOIAMPS", RCP_PARAM_POWER_OUT_CURRENT_0},
    {"PWIVBT", RCP_PARAM_POWER_IN_VOLTAGE_BELOW_THRESHOLD_0},
    {"GCURVEMX", RCP_PARAM_GREEN_CURVE_MIDTONE_X},
    {"GCURVESX", RCP_PARAM_GREEN_CURVE_SHADOW_X},
    {"PLAYPOS", RCP_PARAM_PLAYBACK_POS},
    {"LCD3FM2", RCP_PARAM_MONITOR_FLIP_MIRROR_LCD3},
    {"MAGNIFY", RCP_PARAM_MAGNIFY_STATE},
    {"CH3VOL", RCP_PARAM_AUDIO_CH3_VOL},
    {"EVF3CV", RCP_PARAM_MONITOR_CURVE_EVF3},
    {"BCLIP", RCP_PARAM_BLUE_CLIP},
    {"CH12ST", RCP_PARAM_AUDIO_CH12_STATE},
    {"HISTTYPE", RCP_PARAM_HISTOGRAM_TYPE},
    {"CH12SRC", RCP_PARAM_AUDIO_CH12_SOURCE},
    {"GCURVELX", RCP_PARAM_GREEN_CURVE_LIGHT_X},
    {"SHGUIDE", RCP_PARAM_SHADING_GUIDE},
    {"IMGSPCRV", RCP_PARAM_MONITOR_SPLIT_CURVE},
    {"MONPRTY", RCP_PARAM_MONITOR_PRIORITY_LIST},
    {"PWIVOLT", RCP_PARAM_POWER_IN_VOLTAGE_0},
    {"CH2VOL", RCP_PARAM_AUDIO_CH2_VOL},
    {"MXFW", RCP_PARAM_MXF_WIDTH},
    {"F2OPAC", RCP_PARAM_TITLE_GUIDE_OPACITY},
    {"MEDIASZ", RCP_PARAM_MEDIA_SIZE},
    {"BCURVEMY", RCP_PARAM_BLUE_CURVE_MIDTONE_Y},
    {"BCURVESY", RCP_PARAM_BLUE_CURVE_SHADOW_Y},
    {"BHDSDIOV", RCP_PARAM_MONITOR_OVERLAY_HDSDI},
    {"GEIPADDR", RCP_PARAM_GIGABIT_ETHERNET_IP_ADDRESS},
    {"GCURVEDX", RCP_PARAM_GREEN_CURVE_DARK_X},
    {"CH34ILNK", RCP_PARAM_AUDIO_CH34_LINK_GAIN},
    {"PXSFMTW", RCP_PARAM_SHADOW_FORMAT_WIDTH_PIXELS},
    {"BCURVELY", RCP_PARAM_BLUE_CURVE_LIGHT_Y},
    {"WLANAPPW", RCP_PARAM_WIFI_INFRASTRUCTURE_PASSPHRASE},
    {"MEDIASZA", RCP_PARAM_MEDIA_SIZE_AVIALABLE},
    {"CH12ONME", RCP_PARAM_AUDIO_CH12_OUTPUT_NAME},
    {"F2OFFSY", RCP_PARAM_TITLE_GUIDE_Y_OFFSET},
    {"EVF3G", RCP_PARAM_MONITOR_FEED_EVF3},
    {"CH4_48V", RCP_PARAM_AUDIO_CH4_48V_POWER},
    {"BCURVEDY", RCP_PARAM_BLUE_CURVE_DARK_Y},
    {"CH4_48VP", RCP_PARAM_AUDIO_CH4_48V_PRESENT},
    {"CH1LIMPR", RCP_PARAM_AUDIO_CH1_LIMITER_PRESENT},
    {"PHDSDI1G", RCP_PARAM_MONITOR_FEED_REAR_HDSDI1},
    {"CH12OLNK", RCP_PARAM_AUDIO_CH12_LINK_VOL},
    {"PWIPRST", RCP_PARAM_POWER_IN_PRESENT_0},
    {"CH4NAME", RCP_PARAM_AUDIO_CH4_NAME},
    {"BCURVEMX", RCP_PARAM_BLUE_CURVE_MIDTONE_X},
    {"BCURVESX", RCP_PARAM_BLUE_CURVE_SHADOW_X},
    {"PWITYPE", RCP_PARAM_POWER_IN_TYPE_0},
    {"MAXFPS", RCP_PARAM_MAX_SENSOR_FRAME_RATE},
    {"CH1VOL", RCP_PARAM_AUDIO_CH1_VOL},
    {"BCURVELX", RCP_PARAM_BLUE_CURVE_LIGHT_X},
    {"F1OPAC", RCP_PARAM_ACTION_GUIDE_OPACITY},
    {"PHYSENSH", RCP_PARAM_SENSOR_HEIGHT_PHY},
    {"LOGVWMDE", RCP_PARAM_LOG_VIEW_MODE},
    {"F2OFFSX", RCP_PARAM_TITLE_GUIDE_X_OFFSET},
    {"GROUPID", RCP_PARAM_GROUP_ID},
    {"POJPUE", RCP_PARAM_POWER_OUT_JETPACK_USB_ENABLE},
    {"POJPUS", RCP_PARAM_POWER_OUT_JETPACK_USB_STATUS},
    {"BCURVEDX", RCP_PARAM_BLUE_CURVE_DARK_X},
    {"VCBAKMAX", RCP_PARAM_MAX_RECORD_PROXY_BAKED_IN_SETTINGS},
    {"GIOCPRI", RCP_PARAM_GIO_SCOPE_PRIMARY_COLORS},
    {"F1OFFSY", RCP_PARAM_ACTION_GUIDE_Y_OFFSET},
    {"BHDMIVF", RCP_PARAM_MONITOR_VIDEO_FLIP_HDMI},
    {"ZEBRA2", RCP_PARAM_ZEBRA_2_ENABLE},
    {"ZEBRA2M", RCP_PARAM_ZEBRA_2_MODE},
    {"EVF3VF", RCP_PARAM_MONITOR_VIDEO_FLIP_EVF3},
    {"ZEBRA2LS", RCP_PARAM_ZEBRA_2_STOPS_LOW},
    {"RCURVEHY", RCP_PARAM_RED_CURVE_HIGHLIGHT_Y},
    {"LCURVEHY", RCP_PARAM_LUMA_CURVE_HIGHLIGHT_Y},
    {"IMGPIPEM", RCP_PARAM_IMAGE_PIPELINE_MODE},
    {"AEEXPRI", RCP_PARAM_AE_EXPOSURE_PRIORITY},
    {"F1OFFSX", RCP_PARAM_ACTION_GUIDE_X_OFFSET},
    {"PHYSENSW", RCP_PARAM_SENSOR_WIDTH_PHY},
    {"EVF3FM2", RCP_PARAM_MONITOR_FLIP_MIRROR_EVF3},
    {"BHDMIOV", RCP_PARAM_MONITOR_OVERLAY_HDMI},
    {"RCURVEHX", RCP_PARAM_RED_CURVE_HIGHLIGHT_X},
    {"APAUPLAY", RCP_PARAM_AUTO_PRESET_PLAYBACK_AUTO_UPDATE},
    {"ZEBRA1", RCP_PARAM_ZEBRA_1_ENABLE},
    {"ZEBRA1M", RCP_PARAM_ZEBRA_1_MODE},
    {"CH4LIMPR", RCP_PARAM_AUDIO_CH4_LIMITER_PRESENT},
    {"LCURVEHX", RCP_PARAM_LUMA_CURVE_HIGHLIGHT_X},
    {"ZEBRA2LO", RCP_PARAM_ZEBRA_2_IRE_LOW},
    {"CH3LIMIT", RCP_PARAM_AUDIO_CH3_LIMITER},
    {"WLANAHID", RCP_PARAM_WIFI_AD_HOC_SSID},
    {"ZEBRA1LS", RCP_PARAM_ZEBRA_1_STOPS_LOW},
    {"CH2LIMIT", RCP_PARAM_AUDIO_CH2_LIMITER},
    {"CH4VOL", RCP_PARAM_AUDIO_CH4_VOL},
    {"GCURVEHY", RCP_PARAM_GREEN_CURVE_HIGHLIGHT_Y},
    {"HDMIMUX", RCP_PARAM_MONITOR_LCD_EVF_2_HDMI_MUX},
    {"ZEBRA1LO", RCP_PARAM_ZEBRA_1_IRE_LOW},
    {"CH1LIMIT", RCP_PARAM_AUDIO_CH1_LIMITER},
    {"GCURVEHX", RCP_PARAM_GREEN_CURVE_HIGHLIGHT_X},
    {"HWCAP", RCP_PARAM_HARDWARE_CAPABILITIES},
    {"AFWPOSY", RCP_PARAM_AF_WINDOW_POS_Y},
    {"BCURVEHY", RCP_PARAM_BLUE_CURVE_HIGHLIGHT_Y},
    {"WLANAHPW", RCP_PARAM_WIFI_AD_HOC_PASSPHRASE},
    {"MIXHDPN3", RCP_PARAM_AUDIO_MIX_MON_PAN3},
    {"MIXHDPN2", RCP_PARAM_AUDIO_MIX_MON_PAN2},
    {"CH3GAIN", RCP_PARAM_AUDIO_CH3_GAIN},
    {"AFWPOSX", RCP_PARAM_AF_WINDOW_POS_X},
    {"CH2GAIN", RCP_PARAM_AUDIO_CH2_GAIN},
    {"BCURVEHX", RCP_PARAM_BLUE_CURVE_HIGHLIGHT_X},
    {"BWFVALID", RCP_PARAM_BWF_VALID},
    {"ZEB2PAT", RCP_PARAM_ZEBRA_2_PATTERN},
    {"MIXHDPN1", RCP_PARAM_AUDIO_MIX_MON_PAN1},
    {"ZEB1PAT", RCP_PARAM_ZEBRA_1_PATTERN},
    {"CH12ILNK", RCP_PARAM_AUDIO_CH12_LINK_GAIN},
    {"ZEBRA2HS", RCP_PARAM_ZEBRA_2_STOPS_HIGH},
    {"CH4LIMIT", RCP_PARAM_AUDIO_CH4_LIMITER},
    {"HDRXMONX", RCP_PARAM_HDR_MONITOR_TRACK},
    {"CH1GAIN", RCP_PARAM_AUDIO_CH1_GAIN},
    {"ZEBRA1HS", RCP_PARAM_ZEBRA_1_STOPS_HIGH},
    {"MIXHDVL3", RCP_PARAM_AUDIO_MIX_MON_VOL3},
    {"MIXHDVL2", RCP_PARAM_AUDIO_MIX_MON_VOL2},
    {"MIXHDPN4", RCP_PARAM_AUDIO_MIX_MON_PAN4},
    {"CH4GAIN", RCP_PARAM_AUDIO_CH4_GAIN},
    {"MIXHDVL1", RCP_PARAM_AUDIO_MIX_MON_VOL1},
    {"MIX34PN3", RCP_PARAM_AUDIO_MIX_CH34_PAN3},
    {"MIX34PN2", RCP_PARAM_AUDIO_MIX_CH34_PAN2},
    {"ZEBRA2HI", RCP_PARAM_ZEBRA_2_IRE_HIGH},
    {"MIX34PN1", RCP_PARAM_AUDIO_MIX_CH34_PAN1},
    {"ZEBRA1HI", RCP_PARAM_ZEBRA_1_IRE_HIGH},
    {"MIX12PN3", RCP_PARAM_AUDIO_MIX_CH12_PAN3},
    {"MIXHDVL4", RCP_PARAM_AUDIO_MIX_MON_VOL4},
    {"MIX12PN2", RCP_PARAM_AUDIO_MIX_CH12_PAN2},
    {"MIX12PN1", RCP_PARAM_AUDIO_MIX_CH12_PAN1},
    {"MIX34VL3", RCP_PARAM_AUDIO_MIX_CH34_VOL3},
    {"MIX34VL2", RCP_PARAM_AUDIO_MIX_CH34_VOL2},
    {"MIX34PN4", RCP_PARAM_AUDIO_MIX_CH34_PAN4},
    {"MIX34VL1", RCP_PARAM_AUDIO_MIX_CH34_VOL1},
    {"MIX12VL3", RCP_PARAM_AUDIO_MIX_CH12_VOL3},
    {"MIX12VL2", RCP_PARAM_AUDIO_MIX_CH12_VOL2},
    {"MIX12PN4", RCP_PARAM_AUDIO_MIX_CH12_PAN4},
    {"MIX12VL1", RCP_PARAM_AUDIO_MIX_CH12_VOL1},
    {"MIX34VL4", RCP_PARAM_AUDIO_MIX_CH34_VOL4},
    {"MIX12VL4", RCP_PARAM_AUDIO_MIX_CH12_VOL4}
  };

#ifdef __GNUC__
__inline
#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
__attribute__ ((__gnu_inline__))
#endif
#endif
const struct rcp_current_table *
_rcp_get_id_from_cur_msg (register const char *str, register unsigned int len)
{
  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          register const struct rcp_current_table *resword;

          switch (key - 20)
            {
              case 0:
                resword = &wordlist[0];
                goto compare;
              case 6:
                resword = &wordlist[1];
                goto compare;
              case 7:
                resword = &wordlist[2];
                goto compare;
              case 9:
                resword = &wordlist[3];
                goto compare;
              case 11:
                resword = &wordlist[4];
                goto compare;
              case 19:
                resword = &wordlist[5];
                goto compare;
              case 24:
                resword = &wordlist[6];
                goto compare;
              case 28:
                resword = &wordlist[7];
                goto compare;
              case 39:
                resword = &wordlist[8];
                goto compare;
              case 41:
                resword = &wordlist[9];
                goto compare;
              case 43:
                resword = &wordlist[10];
                goto compare;
              case 44:
                resword = &wordlist[11];
                goto compare;
              case 45:
                resword = &wordlist[12];
                goto compare;
              case 48:
                resword = &wordlist[13];
                goto compare;
              case 52:
                resword = &wordlist[14];
                goto compare;
              case 53:
                resword = &wordlist[15];
                goto compare;
              case 54:
                resword = &wordlist[16];
                goto compare;
              case 55:
                resword = &wordlist[17];
                goto compare;
              case 56:
                resword = &wordlist[18];
                goto compare;
              case 57:
                resword = &wordlist[19];
                goto compare;
              case 58:
                resword = &wordlist[20];
                goto compare;
              case 59:
                resword = &wordlist[21];
                goto compare;
              case 61:
                resword = &wordlist[22];
                goto compare;
              case 62:
                resword = &wordlist[23];
                goto compare;
              case 63:
                resword = &wordlist[24];
                goto compare;
              case 65:
                resword = &wordlist[25];
                goto compare;
              case 66:
                resword = &wordlist[26];
                goto compare;
              case 69:
                resword = &wordlist[27];
                goto compare;
              case 70:
                resword = &wordlist[28];
                goto compare;
              case 71:
                resword = &wordlist[29];
                goto compare;
              case 72:
                resword = &wordlist[30];
                goto compare;
              case 74:
                resword = &wordlist[31];
                goto compare;
              case 78:
                resword = &wordlist[32];
                goto compare;
              case 79:
                resword = &wordlist[33];
                goto compare;
              case 80:
                resword = &wordlist[34];
                goto compare;
              case 81:
                resword = &wordlist[35];
                goto compare;
              case 82:
                resword = &wordlist[36];
                goto compare;
              case 84:
                resword = &wordlist[37];
                goto compare;
              case 90:
                resword = &wordlist[38];
                goto compare;
              case 101:
                resword = &wordlist[39];
                goto compare;
              case 102:
                resword = &wordlist[40];
                goto compare;
              case 108:
                resword = &wordlist[41];
                goto compare;
              case 110:
                resword = &wordlist[42];
                goto compare;
              case 117:
                resword = &wordlist[43];
                goto compare;
              case 122:
                resword = &wordlist[44];
                goto compare;
              case 129:
                resword = &wordlist[45];
                goto compare;
              case 134:
                resword = &wordlist[46];
                goto compare;
              case 136:
                resword = &wordlist[47];
                goto compare;
              case 137:
                resword = &wordlist[48];
                goto compare;
              case 139:
                resword = &wordlist[49];
                goto compare;
              case 147:
                resword = &wordlist[50];
                goto compare;
              case 148:
                resword = &wordlist[51];
                goto compare;
              case 149:
                resword = &wordlist[52];
                goto compare;
              case 152:
                resword = &wordlist[53];
                goto compare;
              case 158:
                resword = &wordlist[54];
                goto compare;
              case 159:
                resword = &wordlist[55];
                goto compare;
              case 169:
                resword = &wordlist[56];
                goto compare;
              case 171:
                resword = &wordlist[57];
                goto compare;
              case 181:
                resword = &wordlist[58];
                goto compare;
              case 182:
                resword = &wordlist[59];
                goto compare;
              case 202:
                resword = &wordlist[60];
                goto compare;
              case 205:
                resword = &wordlist[61];
                goto compare;
              case 206:
                resword = &wordlist[62];
                goto compare;
              case 208:
                resword = &wordlist[63];
                goto compare;
              case 212:
                resword = &wordlist[64];
                goto compare;
              case 220:
                resword = &wordlist[65];
                goto compare;
              case 221:
                resword = &wordlist[66];
                goto compare;
              case 225:
                resword = &wordlist[67];
                goto compare;
              case 230:
                resword = &wordlist[68];
                goto compare;
              case 232:
                resword = &wordlist[69];
                goto compare;
              case 239:
                resword = &wordlist[70];
                goto compare;
              case 246:
                resword = &wordlist[71];
                goto compare;
              case 262:
                resword = &wordlist[72];
                goto compare;
              case 263:
                resword = &wordlist[73];
                goto compare;
              case 266:
                resword = &wordlist[74];
                goto compare;
              case 267:
                resword = &wordlist[75];
                goto compare;
              case 269:
                resword = &wordlist[76];
                goto compare;
              case 276:
                resword = &wordlist[77];
                goto compare;
              case 279:
                resword = &wordlist[78];
                goto compare;
              case 280:
                resword = &wordlist[79];
                goto compare;
              case 281:
                resword = &wordlist[80];
                goto compare;
              case 289:
                resword = &wordlist[81];
                goto compare;
              case 290:
                resword = &wordlist[82];
                goto compare;
              case 292:
                resword = &wordlist[83];
                goto compare;
              case 296:
                resword = &wordlist[84];
                goto compare;
              case 299:
                resword = &wordlist[85];
                goto compare;
              case 300:
                resword = &wordlist[86];
                goto compare;
              case 306:
                resword = &wordlist[87];
                goto compare;
              case 310:
                resword = &wordlist[88];
                goto compare;
              case 316:
                resword = &wordlist[89];
                goto compare;
              case 318:
                resword = &wordlist[90];
                goto compare;
              case 325:
                resword = &wordlist[91];
                goto compare;
              case 327:
                resword = &wordlist[92];
                goto compare;
              case 328:
                resword = &wordlist[93];
                goto compare;
              case 333:
                resword = &wordlist[94];
                goto compare;
              case 340:
                resword = &wordlist[95];
                goto compare;
              case 341:
                resword = &wordlist[96];
                goto compare;
              case 345:
                resword = &wordlist[97];
                goto compare;
              case 347:
                resword = &wordlist[98];
                goto compare;
              case 357:
                resword = &wordlist[99];
                goto compare;
              case 358:
                resword = &wordlist[100];
                goto compare;
              case 370:
                resword = &wordlist[101];
                goto compare;
              case 376:
                resword = &wordlist[102];
                goto compare;
              case 380:
                resword = &wordlist[103];
                goto compare;
              case 381:
                resword = &wordlist[104];
                goto compare;
              case 382:
                resword = &wordlist[105];
                goto compare;
              case 385:
                resword = &wordlist[106];
                goto compare;
              case 386:
                resword = &wordlist[107];
                goto compare;
              case 389:
                resword = &wordlist[108];
                goto compare;
              case 394:
                resword = &wordlist[109];
                goto compare;
              case 405:
                resword = &wordlist[110];
                goto compare;
              case 409:
                resword = &wordlist[111];
                goto compare;
              case 411:
                resword = &wordlist[112];
                goto compare;
              case 428:
                resword = &wordlist[113];
                goto compare;
              case 451:
                resword = &wordlist[114];
                goto compare;
              case 453:
                resword = &wordlist[115];
                goto compare;
              case 461:
                resword = &wordlist[116];
                goto compare;
              case 465:
                resword = &wordlist[117];
                goto compare;
              case 467:
                resword = &wordlist[118];
                goto compare;
              case 468:
                resword = &wordlist[119];
                goto compare;
              case 477:
                resword = &wordlist[120];
                goto compare;
              case 488:
                resword = &wordlist[121];
                goto compare;
              case 497:
                resword = &wordlist[122];
                goto compare;
              case 508:
                resword = &wordlist[123];
                goto compare;
              case 514:
                resword = &wordlist[124];
                goto compare;
              case 516:
                resword = &wordlist[125];
                goto compare;
              case 517:
                resword = &wordlist[126];
                goto compare;
              case 519:
                resword = &wordlist[127];
                goto compare;
              case 524:
                resword = &wordlist[128];
                goto compare;
              case 525:
                resword = &wordlist[129];
                goto compare;
              case 531:
                resword = &wordlist[130];
                goto compare;
              case 536:
                resword = &wordlist[131];
                goto compare;
              case 543:
                resword = &wordlist[132];
                goto compare;
              case 545:
                resword = &wordlist[133];
                goto compare;
              case 548:
                resword = &wordlist[134];
                goto compare;
              case 551:
                resword = &wordlist[135];
                goto compare;
              case 555:
                resword = &wordlist[136];
                goto compare;
              case 559:
                resword = &wordlist[137];
                goto compare;
              case 563:
                resword = &wordlist[138];
                goto compare;
              case 564:
                resword = &wordlist[139];
                goto compare;
              case 566:
                resword = &wordlist[140];
                goto compare;
              case 569:
                resword = &wordlist[141];
                goto compare;
              case 575:
                resword = &wordlist[142];
                goto compare;
              case 580:
                resword = &wordlist[143];
                goto compare;
              case 588:
                resword = &wordlist[144];
                goto compare;
              case 589:
                resword = &wordlist[145];
                goto compare;
              case 590:
                resword = &wordlist[146];
                goto compare;
              case 605:
                resword = &wordlist[147];
                goto compare;
              case 611:
                resword = &wordlist[148];
                goto compare;
              case 626:
                resword = &wordlist[149];
                goto compare;
              case 630:
                resword = &wordlist[150];
                goto compare;
              case 631:
                resword = &wordlist[151];
                goto compare;
              case 634:
                resword = &wordlist[152];
                goto compare;
              case 636:
                resword = &wordlist[153];
                goto compare;
              case 637:
                resword = &wordlist[154];
                goto compare;
              case 638:
                resword = &wordlist[155];
                goto compare;
              case 645:
                resword = &wordlist[156];
                goto compare;
              case 653:
                resword = &wordlist[157];
                goto compare;
              case 654:
                resword = &wordlist[158];
                goto compare;
              case 657:
                resword = &wordlist[159];
                goto compare;
              case 660:
                resword = &wordlist[160];
                goto compare;
              case 663:
                resword = &wordlist[161];
                goto compare;
              case 676:
                resword = &wordlist[162];
                goto compare;
              case 694:
                resword = &wordlist[163];
                goto compare;
              case 696:
                resword = &wordlist[164];
                goto compare;
              case 701:
                resword = &wordlist[165];
                goto compare;
              case 704:
                resword = &wordlist[166];
                goto compare;
              case 705:
                resword = &wordlist[167];
                goto compare;
              case 707:
                resword = &wordlist[168];
                goto compare;
              case 708:
                resword = &wordlist[169];
                goto compare;
              case 715:
                resword = &wordlist[170];
                goto compare;
              case 720:
                resword = &wordlist[171];
                goto compare;
              case 728:
                resword = &wordlist[172];
                goto compare;
              case 729:
                resword = &wordlist[173];
                goto compare;
              case 734:
                resword = &wordlist[174];
                goto compare;
              case 735:
                resword = &wordlist[175];
                goto compare;
              case 740:
                resword = &wordlist[176];
                goto compare;
              case 749:
                resword = &wordlist[177];
                goto compare;
              case 754:
                resword = &wordlist[178];
                goto compare;
              case 757:
                resword = &wordlist[179];
                goto compare;
              case 772:
                resword = &wordlist[180];
                goto compare;
              case 774:
                resword = &wordlist[181];
                goto compare;
              case 775:
                resword = &wordlist[182];
                goto compare;
              case 780:
                resword = &wordlist[183];
                goto compare;
              case 782:
                resword = &wordlist[184];
                goto compare;
              case 784:
                resword = &wordlist[185];
                goto compare;
              case 788:
                resword = &wordlist[186];
                goto compare;
              case 789:
                resword = &wordlist[187];
                goto compare;
              case 791:
                resword = &wordlist[188];
                goto compare;
              case 793:
                resword = &wordlist[189];
                goto compare;
              case 794:
                resword = &wordlist[190];
                goto compare;
              case 795:
                resword = &wordlist[191];
                goto compare;
              case 797:
                resword = &wordlist[192];
                goto compare;
              case 798:
                resword = &wordlist[193];
                goto compare;
              case 799:
                resword = &wordlist[194];
                goto compare;
              case 801:
                resword = &wordlist[195];
                goto compare;
              case 809:
                resword = &wordlist[196];
                goto compare;
              case 813:
                resword = &wordlist[197];
                goto compare;
              case 814:
                resword = &wordlist[198];
                goto compare;
              case 818:
                resword = &wordlist[199];
                goto compare;
              case 820:
                resword = &wordlist[200];
                goto compare;
              case 825:
                resword = &wordlist[201];
                goto compare;
              case 838:
                resword = &wordlist[202];
                goto compare;
              case 844:
                resword = &wordlist[203];
                goto compare;
              case 849:
                resword = &wordlist[204];
                goto compare;
              case 855:
                resword = &wordlist[205];
                goto compare;
              case 856:
                resword = &wordlist[206];
                goto compare;
              case 861:
                resword = &wordlist[207];
                goto compare;
              case 862:
                resword = &wordlist[208];
                goto compare;
              case 870:
                resword = &wordlist[209];
                goto compare;
              case 873:
                resword = &wordlist[210];
                goto compare;
              case 874:
                resword = &wordlist[211];
                goto compare;
              case 875:
                resword = &wordlist[212];
                goto compare;
              case 878:
                resword = &wordlist[213];
                goto compare;
              case 879:
                resword = &wordlist[214];
                goto compare;
              case 880:
                resword = &wordlist[215];
                goto compare;
              case 882:
                resword = &wordlist[216];
                goto compare;
              case 885:
                resword = &wordlist[217];
                goto compare;
              case 886:
                resword = &wordlist[218];
                goto compare;
              case 887:
                resword = &wordlist[219];
                goto compare;
              case 890:
                resword = &wordlist[220];
                goto compare;
              case 891:
                resword = &wordlist[221];
                goto compare;
              case 893:
                resword = &wordlist[222];
                goto compare;
              case 894:
                resword = &wordlist[223];
                goto compare;
              case 897:
                resword = &wordlist[224];
                goto compare;
              case 901:
                resword = &wordlist[225];
                goto compare;
              case 906:
                resword = &wordlist[226];
                goto compare;
              case 910:
                resword = &wordlist[227];
                goto compare;
              case 917:
                resword = &wordlist[228];
                goto compare;
              case 924:
                resword = &wordlist[229];
                goto compare;
              case 925:
                resword = &wordlist[230];
                goto compare;
              case 927:
                resword = &wordlist[231];
                goto compare;
              case 930:
                resword = &wordlist[232];
                goto compare;
              case 933:
                resword = &wordlist[233];
                goto compare;
              case 936:
                resword = &wordlist[234];
                goto compare;
              case 939:
                resword = &wordlist[235];
                goto compare;
              case 944:
                resword = &wordlist[236];
                goto compare;
              case 951:
                resword = &wordlist[237];
                goto compare;
              case 954:
                resword = &wordlist[238];
                goto compare;
              case 961:
                resword = &wordlist[239];
                goto compare;
              case 962:
                resword = &wordlist[240];
                goto compare;
              case 965:
                resword = &wordlist[241];
                goto compare;
              case 971:
                resword = &wordlist[242];
                goto compare;
              case 973:
                resword = &wordlist[243];
                goto compare;
              case 975:
                resword = &wordlist[244];
                goto compare;
              case 976:
                resword = &wordlist[245];
                goto compare;
              case 996:
                resword = &wordlist[246];
                goto compare;
              case 1001:
                resword = &wordlist[247];
                goto compare;
              case 1007:
                resword = &wordlist[248];
                goto compare;
              case 1010:
                resword = &wordlist[249];
                goto compare;
              case 1013:
                resword = &wordlist[250];
                goto compare;
              case 1014:
                resword = &wordlist[251];
                goto compare;
              case 1024:
                resword = &wordlist[252];
                goto compare;
              case 1034:
                resword = &wordlist[253];
                goto compare;
              case 1035:
                resword = &wordlist[254];
                goto compare;
              case 1042:
                resword = &wordlist[255];
                goto compare;
              case 1044:
                resword = &wordlist[256];
                goto compare;
              case 1046:
                resword = &wordlist[257];
                goto compare;
              case 1048:
                resword = &wordlist[258];
                goto compare;
              case 1050:
                resword = &wordlist[259];
                goto compare;
              case 1052:
                resword = &wordlist[260];
                goto compare;
              case 1053:
                resword = &wordlist[261];
                goto compare;
              case 1056:
                resword = &wordlist[262];
                goto compare;
              case 1061:
                resword = &wordlist[263];
                goto compare;
              case 1062:
                resword = &wordlist[264];
                goto compare;
              case 1064:
                resword = &wordlist[265];
                goto compare;
              case 1065:
                resword = &wordlist[266];
                goto compare;
              case 1066:
                resword = &wordlist[267];
                goto compare;
              case 1068:
                resword = &wordlist[268];
                goto compare;
              case 1070:
                resword = &wordlist[269];
                goto compare;
              case 1074:
                resword = &wordlist[270];
                goto compare;
              case 1086:
                resword = &wordlist[271];
                goto compare;
              case 1088:
                resword = &wordlist[272];
                goto compare;
              case 1089:
                resword = &wordlist[273];
                goto compare;
              case 1091:
                resword = &wordlist[274];
                goto compare;
              case 1094:
                resword = &wordlist[275];
                goto compare;
              case 1095:
                resword = &wordlist[276];
                goto compare;
              case 1096:
                resword = &wordlist[277];
                goto compare;
              case 1099:
                resword = &wordlist[278];
                goto compare;
              case 1100:
                resword = &wordlist[279];
                goto compare;
              case 1102:
                resword = &wordlist[280];
                goto compare;
              case 1104:
                resword = &wordlist[281];
                goto compare;
              case 1106:
                resword = &wordlist[282];
                goto compare;
              case 1110:
                resword = &wordlist[283];
                goto compare;
              case 1113:
                resword = &wordlist[284];
                goto compare;
              case 1122:
                resword = &wordlist[285];
                goto compare;
              case 1134:
                resword = &wordlist[286];
                goto compare;
              case 1137:
                resword = &wordlist[287];
                goto compare;
              case 1138:
                resword = &wordlist[288];
                goto compare;
              case 1139:
                resword = &wordlist[289];
                goto compare;
              case 1141:
                resword = &wordlist[290];
                goto compare;
              case 1144:
                resword = &wordlist[291];
                goto compare;
              case 1146:
                resword = &wordlist[292];
                goto compare;
              case 1147:
                resword = &wordlist[293];
                goto compare;
              case 1149:
                resword = &wordlist[294];
                goto compare;
              case 1153:
                resword = &wordlist[295];
                goto compare;
              case 1155:
                resword = &wordlist[296];
                goto compare;
              case 1157:
                resword = &wordlist[297];
                goto compare;
              case 1160:
                resword = &wordlist[298];
                goto compare;
              case 1164:
                resword = &wordlist[299];
                goto compare;
              case 1165:
                resword = &wordlist[300];
                goto compare;
              case 1167:
                resword = &wordlist[301];
                goto compare;
              case 1172:
                resword = &wordlist[302];
                goto compare;
              case 1175:
                resword = &wordlist[303];
                goto compare;
              case 1182:
                resword = &wordlist[304];
                goto compare;
              case 1185:
                resword = &wordlist[305];
                goto compare;
              case 1190:
                resword = &wordlist[306];
                goto compare;
              case 1200:
                resword = &wordlist[307];
                goto compare;
              case 1213:
                resword = &wordlist[308];
                goto compare;
              case 1216:
                resword = &wordlist[309];
                goto compare;
              case 1225:
                resword = &wordlist[310];
                goto compare;
              case 1226:
                resword = &wordlist[311];
                goto compare;
              case 1231:
                resword = &wordlist[312];
                goto compare;
              case 1233:
                resword = &wordlist[313];
                goto compare;
              case 1234:
                resword = &wordlist[314];
                goto compare;
              case 1235:
                resword = &wordlist[315];
                goto compare;
              case 1236:
                resword = &wordlist[316];
                goto compare;
              case 1237:
                resword = &wordlist[317];
                goto compare;
              case 1239:
                resword = &wordlist[318];
                goto compare;
              case 1240:
                resword = &wordlist[319];
                goto compare;
              case 1244:
                resword = &wordlist[320];
                goto compare;
              case 1249:
                resword = &wordlist[321];
                goto compare;
              case 1252:
                resword = &wordlist[322];
                goto compare;
              case 1258:
                resword = &wordlist[323];
                goto compare;
              case 1264:
                resword = &wordlist[324];
                goto compare;
              case 1265:
                resword = &wordlist[325];
                goto compare;
              case 1266:
                resword = &wordlist[326];
                goto compare;
              case 1272:
                resword = &wordlist[327];
                goto compare;
              case 1281:
                resword = &wordlist[328];
                goto compare;
              case 1282:
                resword = &wordlist[329];
                goto compare;
              case 1287:
                resword = &wordlist[330];
                goto compare;
              case 1288:
                resword = &wordlist[331];
                goto compare;
              case 1297:
                resword = &wordlist[332];
                goto compare;
              case 1298:
                resword = &wordlist[333];
                goto compare;
              case 1299:
                resword = &wordlist[334];
                goto compare;
              case 1302:
                resword = &wordlist[335];
                goto compare;
              case 1303:
                resword = &wordlist[336];
                goto compare;
              case 1306:
                resword = &wordlist[337];
                goto compare;
              case 1308:
                resword = &wordlist[338];
                goto compare;
              case 1309:
                resword = &wordlist[339];
                goto compare;
              case 1310:
                resword = &wordlist[340];
                goto compare;
              case 1313:
                resword = &wordlist[341];
                goto compare;
              case 1315:
                resword = &wordlist[342];
                goto compare;
              case 1318:
                resword = &wordlist[343];
                goto compare;
              case 1320:
                resword = &wordlist[344];
                goto compare;
              case 1331:
                resword = &wordlist[345];
                goto compare;
              case 1333:
                resword = &wordlist[346];
                goto compare;
              case 1334:
                resword = &wordlist[347];
                goto compare;
              case 1336:
                resword = &wordlist[348];
                goto compare;
              case 1339:
                resword = &wordlist[349];
                goto compare;
              case 1340:
                resword = &wordlist[350];
                goto compare;
              case 1347:
                resword = &wordlist[351];
                goto compare;
              case 1348:
                resword = &wordlist[352];
                goto compare;
              case 1349:
                resword = &wordlist[353];
                goto compare;
              case 1350:
                resword = &wordlist[354];
                goto compare;
              case 1356:
                resword = &wordlist[355];
                goto compare;
              case 1358:
                resword = &wordlist[356];
                goto compare;
              case 1367:
                resword = &wordlist[357];
                goto compare;
              case 1368:
                resword = &wordlist[358];
                goto compare;
              case 1369:
                resword = &wordlist[359];
                goto compare;
              case 1371:
                resword = &wordlist[360];
                goto compare;
              case 1374:
                resword = &wordlist[361];
                goto compare;
              case 1377:
                resword = &wordlist[362];
                goto compare;
              case 1390:
                resword = &wordlist[363];
                goto compare;
              case 1394:
                resword = &wordlist[364];
                goto compare;
              case 1395:
                resword = &wordlist[365];
                goto compare;
              case 1396:
                resword = &wordlist[366];
                goto compare;
              case 1399:
                resword = &wordlist[367];
                goto compare;
              case 1401:
                resword = &wordlist[368];
                goto compare;
              case 1402:
                resword = &wordlist[369];
                goto compare;
              case 1404:
                resword = &wordlist[370];
                goto compare;
              case 1405:
                resword = &wordlist[371];
                goto compare;
              case 1406:
                resword = &wordlist[372];
                goto compare;
              case 1411:
                resword = &wordlist[373];
                goto compare;
              case 1412:
                resword = &wordlist[374];
                goto compare;
              case 1413:
                resword = &wordlist[375];
                goto compare;
              case 1415:
                resword = &wordlist[376];
                goto compare;
              case 1416:
                resword = &wordlist[377];
                goto compare;
              case 1417:
                resword = &wordlist[378];
                goto compare;
              case 1421:
                resword = &wordlist[379];
                goto compare;
              case 1424:
                resword = &wordlist[380];
                goto compare;
              case 1429:
                resword = &wordlist[381];
                goto compare;
              case 1430:
                resword = &wordlist[382];
                goto compare;
              case 1431:
                resword = &wordlist[383];
                goto compare;
              case 1434:
                resword = &wordlist[384];
                goto compare;
              case 1435:
                resword = &wordlist[385];
                goto compare;
              case 1438:
                resword = &wordlist[386];
                goto compare;
              case 1439:
                resword = &wordlist[387];
                goto compare;
              case 1443:
                resword = &wordlist[388];
                goto compare;
              case 1450:
                resword = &wordlist[389];
                goto compare;
              case 1451:
                resword = &wordlist[390];
                goto compare;
              case 1465:
                resword = &wordlist[391];
                goto compare;
              case 1466:
                resword = &wordlist[392];
                goto compare;
              case 1473:
                resword = &wordlist[393];
                goto compare;
              case 1475:
                resword = &wordlist[394];
                goto compare;
              case 1476:
                resword = &wordlist[395];
                goto compare;
              case 1477:
                resword = &wordlist[396];
                goto compare;
              case 1479:
                resword = &wordlist[397];
                goto compare;
              case 1480:
                resword = &wordlist[398];
                goto compare;
              case 1483:
                resword = &wordlist[399];
                goto compare;
              case 1487:
                resword = &wordlist[400];
                goto compare;
              case 1488:
                resword = &wordlist[401];
                goto compare;
              case 1495:
                resword = &wordlist[402];
                goto compare;
              case 1496:
                resword = &wordlist[403];
                goto compare;
              case 1497:
                resword = &wordlist[404];
                goto compare;
              case 1500:
                resword = &wordlist[405];
                goto compare;
              case 1501:
                resword = &wordlist[406];
                goto compare;
              case 1506:
                resword = &wordlist[407];
                goto compare;
              case 1512:
                resword = &wordlist[408];
                goto compare;
              case 1524:
                resword = &wordlist[409];
                goto compare;
              case 1530:
                resword = &wordlist[410];
                goto compare;
              case 1532:
                resword = &wordlist[411];
                goto compare;
              case 1533:
                resword = &wordlist[412];
                goto compare;
              case 1537:
                resword = &wordlist[413];
                goto compare;
              case 1540:
                resword = &wordlist[414];
                goto compare;
              case 1545:
                resword = &wordlist[415];
                goto compare;
              case 1547:
                resword = &wordlist[416];
                goto compare;
              case 1549:
                resword = &wordlist[417];
                goto compare;
              case 1552:
                resword = &wordlist[418];
                goto compare;
              case 1553:
                resword = &wordlist[419];
                goto compare;
              case 1562:
                resword = &wordlist[420];
                goto compare;
              case 1563:
                resword = &wordlist[421];
                goto compare;
              case 1566:
                resword = &wordlist[422];
                goto compare;
              case 1567:
                resword = &wordlist[423];
                goto compare;
              case 1568:
                resword = &wordlist[424];
                goto compare;
              case 1571:
                resword = &wordlist[425];
                goto compare;
              case 1573:
                resword = &wordlist[426];
                goto compare;
              case 1582:
                resword = &wordlist[427];
                goto compare;
              case 1584:
                resword = &wordlist[428];
                goto compare;
              case 1586:
                resword = &wordlist[429];
                goto compare;
              case 1589:
                resword = &wordlist[430];
                goto compare;
              case 1593:
                resword = &wordlist[431];
                goto compare;
              case 1598:
                resword = &wordlist[432];
                goto compare;
              case 1599:
                resword = &wordlist[433];
                goto compare;
              case 1600:
                resword = &wordlist[434];
                goto compare;
              case 1603:
                resword = &wordlist[435];
                goto compare;
              case 1607:
                resword = &wordlist[436];
                goto compare;
              case 1610:
                resword = &wordlist[437];
                goto compare;
              case 1612:
                resword = &wordlist[438];
                goto compare;
              case 1613:
                resword = &wordlist[439];
                goto compare;
              case 1615:
                resword = &wordlist[440];
                goto compare;
              case 1622:
                resword = &wordlist[441];
                goto compare;
              case 1624:
                resword = &wordlist[442];
                goto compare;
              case 1631:
                resword = &wordlist[443];
                goto compare;
              case 1643:
                resword = &wordlist[444];
                goto compare;
              case 1644:
                resword = &wordlist[445];
                goto compare;
              case 1645:
                resword = &wordlist[446];
                goto compare;
              case 1647:
                resword = &wordlist[447];
                goto compare;
              case 1653:
                resword = &wordlist[448];
                goto compare;
              case 1654:
                resword = &wordlist[449];
                goto compare;
              case 1657:
                resword = &wordlist[450];
                goto compare;
              case 1659:
                resword = &wordlist[451];
                goto compare;
              case 1664:
                resword = &wordlist[452];
                goto compare;
              case 1666:
                resword = &wordlist[453];
                goto compare;
              case 1678:
                resword = &wordlist[454];
                goto compare;
              case 1680:
                resword = &wordlist[455];
                goto compare;
              case 1684:
                resword = &wordlist[456];
                goto compare;
              case 1687:
                resword = &wordlist[457];
                goto compare;
              case 1689:
                resword = &wordlist[458];
                goto compare;
              case 1690:
                resword = &wordlist[459];
                goto compare;
              case 1691:
                resword = &wordlist[460];
                goto compare;
              case 1692:
                resword = &wordlist[461];
                goto compare;
              case 1693:
                resword = &wordlist[462];
                goto compare;
              case 1694:
                resword = &wordlist[463];
                goto compare;
              case 1703:
                resword = &wordlist[464];
                goto compare;
              case 1705:
                resword = &wordlist[465];
                goto compare;
              case 1710:
                resword = &wordlist[466];
                goto compare;
              case 1711:
                resword = &wordlist[467];
                goto compare;
              case 1723:
                resword = &wordlist[468];
                goto compare;
              case 1728:
                resword = &wordlist[469];
                goto compare;
              case 1729:
                resword = &wordlist[470];
                goto compare;
              case 1735:
                resword = &wordlist[471];
                goto compare;
              case 1740:
                resword = &wordlist[472];
                goto compare;
              case 1742:
                resword = &wordlist[473];
                goto compare;
              case 1744:
                resword = &wordlist[474];
                goto compare;
              case 1745:
                resword = &wordlist[475];
                goto compare;
              case 1749:
                resword = &wordlist[476];
                goto compare;
              case 1760:
                resword = &wordlist[477];
                goto compare;
              case 1765:
                resword = &wordlist[478];
                goto compare;
              case 1768:
                resword = &wordlist[479];
                goto compare;
              case 1770:
                resword = &wordlist[480];
                goto compare;
              case 1776:
                resword = &wordlist[481];
                goto compare;
              case 1777:
                resword = &wordlist[482];
                goto compare;
              case 1786:
                resword = &wordlist[483];
                goto compare;
              case 1789:
                resword = &wordlist[484];
                goto compare;
              case 1791:
                resword = &wordlist[485];
                goto compare;
              case 1801:
                resword = &wordlist[486];
                goto compare;
              case 1819:
                resword = &wordlist[487];
                goto compare;
              case 1823:
                resword = &wordlist[488];
                goto compare;
              case 1829:
                resword = &wordlist[489];
                goto compare;
              case 1833:
                resword = &wordlist[490];
                goto compare;
              case 1839:
                resword = &wordlist[491];
                goto compare;
              case 1843:
                resword = &wordlist[492];
                goto compare;
              case 1853:
                resword = &wordlist[493];
                goto compare;
              case 1857:
                resword = &wordlist[494];
                goto compare;
              case 1858:
                resword = &wordlist[495];
                goto compare;
              case 1859:
                resword = &wordlist[496];
                goto compare;
              case 1864:
                resword = &wordlist[497];
                goto compare;
              case 1873:
                resword = &wordlist[498];
                goto compare;
              case 1875:
                resword = &wordlist[499];
                goto compare;
              case 1876:
                resword = &wordlist[500];
                goto compare;
              case 1879:
                resword = &wordlist[501];
                goto compare;
              case 1882:
                resword = &wordlist[502];
                goto compare;
              case 1883:
                resword = &wordlist[503];
                goto compare;
              case 1884:
                resword = &wordlist[504];
                goto compare;
              case 1885:
                resword = &wordlist[505];
                goto compare;
              case 1891:
                resword = &wordlist[506];
                goto compare;
              case 1892:
                resword = &wordlist[507];
                goto compare;
              case 1895:
                resword = &wordlist[508];
                goto compare;
              case 1896:
                resword = &wordlist[509];
                goto compare;
              case 1897:
                resword = &wordlist[510];
                goto compare;
              case 1898:
                resword = &wordlist[511];
                goto compare;
              case 1899:
                resword = &wordlist[512];
                goto compare;
              case 1900:
                resword = &wordlist[513];
                goto compare;
              case 1909:
                resword = &wordlist[514];
                goto compare;
              case 1910:
                resword = &wordlist[515];
                goto compare;
              case 1911:
                resword = &wordlist[516];
                goto compare;
              case 1913:
                resword = &wordlist[517];
                goto compare;
              case 1915:
                resword = &wordlist[518];
                goto compare;
              case 1916:
                resword = &wordlist[519];
                goto compare;
              case 1917:
                resword = &wordlist[520];
                goto compare;
              case 1918:
                resword = &wordlist[521];
                goto compare;
              case 1923:
                resword = &wordlist[522];
                goto compare;
              case 1925:
                resword = &wordlist[523];
                goto compare;
              case 1928:
                resword = &wordlist[524];
                goto compare;
              case 1932:
                resword = &wordlist[525];
                goto compare;
              case 1933:
                resword = &wordlist[526];
                goto compare;
              case 1939:
                resword = &wordlist[527];
                goto compare;
              case 1940:
                resword = &wordlist[528];
                goto compare;
              case 1942:
                resword = &wordlist[529];
                goto compare;
              case 1944:
                resword = &wordlist[530];
                goto compare;
              case 1953:
                resword = &wordlist[531];
                goto compare;
              case 1956:
                resword = &wordlist[532];
                goto compare;
              case 1958:
                resword = &wordlist[533];
                goto compare;
              case 1964:
                resword = &wordlist[534];
                goto compare;
              case 1965:
                resword = &wordlist[535];
                goto compare;
              case 1973:
                resword = &wordlist[536];
                goto compare;
              case 1980:
                resword = &wordlist[537];
                goto compare;
              case 1984:
                resword = &wordlist[538];
                goto compare;
              case 1987:
                resword = &wordlist[539];
                goto compare;
              case 1989:
                resword = &wordlist[540];
                goto compare;
              case 1990:
                resword = &wordlist[541];
                goto compare;
              case 1991:
                resword = &wordlist[542];
                goto compare;
              case 1993:
                resword = &wordlist[543];
                goto compare;
              case 1994:
                resword = &wordlist[544];
                goto compare;
              case 1996:
                resword = &wordlist[545];
                goto compare;
              case 2005:
                resword = &wordlist[546];
                goto compare;
              case 2008:
                resword = &wordlist[547];
                goto compare;
              case 2015:
                resword = &wordlist[548];
                goto compare;
              case 2020:
                resword = &wordlist[549];
                goto compare;
              case 2025:
                resword = &wordlist[550];
                goto compare;
              case 2028:
                resword = &wordlist[551];
                goto compare;
              case 2038:
                resword = &wordlist[552];
                goto compare;
              case 2039:
                resword = &wordlist[553];
                goto compare;
              case 2040:
                resword = &wordlist[554];
                goto compare;
              case 2041:
                resword = &wordlist[555];
                goto compare;
              case 2042:
                resword = &wordlist[556];
                goto compare;
              case 2050:
                resword = &wordlist[557];
                goto compare;
              case 2057:
                resword = &wordlist[558];
                goto compare;
              case 2061:
                resword = &wordlist[559];
                goto compare;
              case 2062:
                resword = &wordlist[560];
                goto compare;
              case 2070:
                resword = &wordlist[561];
                goto compare;
              case 2071:
                resword = &wordlist[562];
                goto compare;
              case 2072:
                resword = &wordlist[563];
                goto compare;
              case 2074:
                resword = &wordlist[564];
                goto compare;
              case 2076:
                resword = &wordlist[565];
                goto compare;
              case 2077:
                resword = &wordlist[566];
                goto compare;
              case 2080:
                resword = &wordlist[567];
                goto compare;
              case 2084:
                resword = &wordlist[568];
                goto compare;
              case 2087:
                resword = &wordlist[569];
                goto compare;
              case 2098:
                resword = &wordlist[570];
                goto compare;
              case 2100:
                resword = &wordlist[571];
                goto compare;
              case 2103:
                resword = &wordlist[572];
                goto compare;
              case 2108:
                resword = &wordlist[573];
                goto compare;
              case 2119:
                resword = &wordlist[574];
                goto compare;
              case 2125:
                resword = &wordlist[575];
                goto compare;
              case 2126:
                resword = &wordlist[576];
                goto compare;
              case 2131:
                resword = &wordlist[577];
                goto compare;
              case 2135:
                resword = &wordlist[578];
                goto compare;
              case 2139:
                resword = &wordlist[579];
                goto compare;
              case 2140:
                resword = &wordlist[580];
                goto compare;
              case 2147:
                resword = &wordlist[581];
                goto compare;
              case 2151:
                resword = &wordlist[582];
                goto compare;
              case 2153:
                resword = &wordlist[583];
                goto compare;
              case 2154:
                resword = &wordlist[584];
                goto compare;
              case 2159:
                resword = &wordlist[585];
                goto compare;
              case 2161:
                resword = &wordlist[586];
                goto compare;
              case 2163:
                resword = &wordlist[587];
                goto compare;
              case 2168:
                resword = &wordlist[588];
                goto compare;
              case 2170:
                resword = &wordlist[589];
                goto compare;
              case 2171:
                resword = &wordlist[590];
                goto compare;
              case 2172:
                resword = &wordlist[591];
                goto compare;
              case 2174:
                resword = &wordlist[592];
                goto compare;
              case 2176:
                resword = &wordlist[593];
                goto compare;
              case 2177:
                resword = &wordlist[594];
                goto compare;
              case 2180:
                resword = &wordlist[595];
                goto compare;
              case 2183:
                resword = &wordlist[596];
                goto compare;
              case 2188:
                resword = &wordlist[597];
                goto compare;
              case 2189:
                resword = &wordlist[598];
                goto compare;
              case 2198:
                resword = &wordlist[599];
                goto compare;
              case 2199:
                resword = &wordlist[600];
                goto compare;
              case 2201:
                resword = &wordlist[601];
                goto compare;
              case 2204:
                resword = &wordlist[602];
                goto compare;
              case 2218:
                resword = &wordlist[603];
                goto compare;
              case 2219:
                resword = &wordlist[604];
                goto compare;
              case 2233:
                resword = &wordlist[605];
                goto compare;
              case 2235:
                resword = &wordlist[606];
                goto compare;
              case 2240:
                resword = &wordlist[607];
                goto compare;
              case 2243:
                resword = &wordlist[608];
                goto compare;
              case 2244:
                resword = &wordlist[609];
                goto compare;
              case 2247:
                resword = &wordlist[610];
                goto compare;
              case 2262:
                resword = &wordlist[611];
                goto compare;
              case 2269:
                resword = &wordlist[612];
                goto compare;
              case 2272:
                resword = &wordlist[613];
                goto compare;
              case 2275:
                resword = &wordlist[614];
                goto compare;
              case 2276:
                resword = &wordlist[615];
                goto compare;
              case 2277:
                resword = &wordlist[616];
                goto compare;
              case 2278:
                resword = &wordlist[617];
                goto compare;
              case 2285:
                resword = &wordlist[618];
                goto compare;
              case 2290:
                resword = &wordlist[619];
                goto compare;
              case 2302:
                resword = &wordlist[620];
                goto compare;
              case 2303:
                resword = &wordlist[621];
                goto compare;
              case 2306:
                resword = &wordlist[622];
                goto compare;
              case 2316:
                resword = &wordlist[623];
                goto compare;
              case 2317:
                resword = &wordlist[624];
                goto compare;
              case 2320:
                resword = &wordlist[625];
                goto compare;
              case 2327:
                resword = &wordlist[626];
                goto compare;
              case 2328:
                resword = &wordlist[627];
                goto compare;
              case 2329:
                resword = &wordlist[628];
                goto compare;
              case 2332:
                resword = &wordlist[629];
                goto compare;
              case 2334:
                resword = &wordlist[630];
                goto compare;
              case 2337:
                resword = &wordlist[631];
                goto compare;
              case 2340:
                resword = &wordlist[632];
                goto compare;
              case 2343:
                resword = &wordlist[633];
                goto compare;
              case 2344:
                resword = &wordlist[634];
                goto compare;
              case 2345:
                resword = &wordlist[635];
                goto compare;
              case 2347:
                resword = &wordlist[636];
                goto compare;
              case 2351:
                resword = &wordlist[637];
                goto compare;
              case 2352:
                resword = &wordlist[638];
                goto compare;
              case 2354:
                resword = &wordlist[639];
                goto compare;
              case 2355:
                resword = &wordlist[640];
                goto compare;
              case 2356:
                resword = &wordlist[641];
                goto compare;
              case 2357:
                resword = &wordlist[642];
                goto compare;
              case 2362:
                resword = &wordlist[643];
                goto compare;
              case 2367:
                resword = &wordlist[644];
                goto compare;
              case 2379:
                resword = &wordlist[645];
                goto compare;
              case 2384:
                resword = &wordlist[646];
                goto compare;
              case 2387:
                resword = &wordlist[647];
                goto compare;
              case 2388:
                resword = &wordlist[648];
                goto compare;
              case 2391:
                resword = &wordlist[649];
                goto compare;
              case 2397:
                resword = &wordlist[650];
                goto compare;
              case 2412:
                resword = &wordlist[651];
                goto compare;
              case 2414:
                resword = &wordlist[652];
                goto compare;
              case 2419:
                resword = &wordlist[653];
                goto compare;
              case 2422:
                resword = &wordlist[654];
                goto compare;
              case 2425:
                resword = &wordlist[655];
                goto compare;
              case 2433:
                resword = &wordlist[656];
                goto compare;
              case 2437:
                resword = &wordlist[657];
                goto compare;
              case 2438:
                resword = &wordlist[658];
                goto compare;
              case 2441:
                resword = &wordlist[659];
                goto compare;
              case 2452:
                resword = &wordlist[660];
                goto compare;
              case 2456:
                resword = &wordlist[661];
                goto compare;
              case 2457:
                resword = &wordlist[662];
                goto compare;
              case 2458:
                resword = &wordlist[663];
                goto compare;
              case 2460:
                resword = &wordlist[664];
                goto compare;
              case 2461:
                resword = &wordlist[665];
                goto compare;
              case 2465:
                resword = &wordlist[666];
                goto compare;
              case 2470:
                resword = &wordlist[667];
                goto compare;
              case 2475:
                resword = &wordlist[668];
                goto compare;
              case 2476:
                resword = &wordlist[669];
                goto compare;
              case 2487:
                resword = &wordlist[670];
                goto compare;
              case 2489:
                resword = &wordlist[671];
                goto compare;
              case 2490:
                resword = &wordlist[672];
                goto compare;
              case 2492:
                resword = &wordlist[673];
                goto compare;
              case 2502:
                resword = &wordlist[674];
                goto compare;
              case 2503:
                resword = &wordlist[675];
                goto compare;
              case 2504:
                resword = &wordlist[676];
                goto compare;
              case 2510:
                resword = &wordlist[677];
                goto compare;
              case 2511:
                resword = &wordlist[678];
                goto compare;
              case 2513:
                resword = &wordlist[679];
                goto compare;
              case 2519:
                resword = &wordlist[680];
                goto compare;
              case 2524:
                resword = &wordlist[681];
                goto compare;
              case 2526:
                resword = &wordlist[682];
                goto compare;
              case 2529:
                resword = &wordlist[683];
                goto compare;
              case 2530:
                resword = &wordlist[684];
                goto compare;
              case 2531:
                resword = &wordlist[685];
                goto compare;
              case 2534:
                resword = &wordlist[686];
                goto compare;
              case 2539:
                resword = &wordlist[687];
                goto compare;
              case 2546:
                resword = &wordlist[688];
                goto compare;
              case 2551:
                resword = &wordlist[689];
                goto compare;
              case 2561:
                resword = &wordlist[690];
                goto compare;
              case 2562:
                resword = &wordlist[691];
                goto compare;
              case 2563:
                resword = &wordlist[692];
                goto compare;
              case 2572:
                resword = &wordlist[693];
                goto compare;
              case 2575:
                resword = &wordlist[694];
                goto compare;
              case 2579:
                resword = &wordlist[695];
                goto compare;
              case 2580:
                resword = &wordlist[696];
                goto compare;
              case 2588:
                resword = &wordlist[697];
                goto compare;
              case 2589:
                resword = &wordlist[698];
                goto compare;
              case 2590:
                resword = &wordlist[699];
                goto compare;
              case 2594:
                resword = &wordlist[700];
                goto compare;
              case 2597:
                resword = &wordlist[701];
                goto compare;
              case 2598:
                resword = &wordlist[702];
                goto compare;
              case 2603:
                resword = &wordlist[703];
                goto compare;
              case 2604:
                resword = &wordlist[704];
                goto compare;
              case 2615:
                resword = &wordlist[705];
                goto compare;
              case 2617:
                resword = &wordlist[706];
                goto compare;
              case 2618:
                resword = &wordlist[707];
                goto compare;
              case 2621:
                resword = &wordlist[708];
                goto compare;
              case 2622:
                resword = &wordlist[709];
                goto compare;
              case 2627:
                resword = &wordlist[710];
                goto compare;
              case 2628:
                resword = &wordlist[711];
                goto compare;
              case 2632:
                resword = &wordlist[712];
                goto compare;
              case 2642:
                resword = &wordlist[713];
                goto compare;
              case 2647:
                resword = &wordlist[714];
                goto compare;
              case 2649:
                resword = &wordlist[715];
                goto compare;
              case 2650:
                resword = &wordlist[716];
                goto compare;
              case 2651:
                resword = &wordlist[717];
                goto compare;
              case 2654:
                resword = &wordlist[718];
                goto compare;
              case 2669:
                resword = &wordlist[719];
                goto compare;
              case 2675:
                resword = &wordlist[720];
                goto compare;
              case 2681:
                resword = &wordlist[721];
                goto compare;
              case 2689:
                resword = &wordlist[722];
                goto compare;
              case 2692:
                resword = &wordlist[723];
                goto compare;
              case 2694:
                resword = &wordlist[724];
                goto compare;
              case 2700:
                resword = &wordlist[725];
                goto compare;
              case 2702:
                resword = &wordlist[726];
                goto compare;
              case 2704:
                resword = &wordlist[727];
                goto compare;
              case 2709:
                resword = &wordlist[728];
                goto compare;
              case 2711:
                resword = &wordlist[729];
                goto compare;
              case 2727:
                resword = &wordlist[730];
                goto compare;
              case 2729:
                resword = &wordlist[731];
                goto compare;
              case 2733:
                resword = &wordlist[732];
                goto compare;
              case 2734:
                resword = &wordlist[733];
                goto compare;
              case 2735:
                resword = &wordlist[734];
                goto compare;
              case 2742:
                resword = &wordlist[735];
                goto compare;
              case 2749:
                resword = &wordlist[736];
                goto compare;
              case 2750:
                resword = &wordlist[737];
                goto compare;
              case 2751:
                resword = &wordlist[738];
                goto compare;
              case 2753:
                resword = &wordlist[739];
                goto compare;
              case 2754:
                resword = &wordlist[740];
                goto compare;
              case 2758:
                resword = &wordlist[741];
                goto compare;
              case 2760:
                resword = &wordlist[742];
                goto compare;
              case 2763:
                resword = &wordlist[743];
                goto compare;
              case 2765:
                resword = &wordlist[744];
                goto compare;
              case 2770:
                resword = &wordlist[745];
                goto compare;
              case 2772:
                resword = &wordlist[746];
                goto compare;
              case 2773:
                resword = &wordlist[747];
                goto compare;
              case 2779:
                resword = &wordlist[748];
                goto compare;
              case 2783:
                resword = &wordlist[749];
                goto compare;
              case 2785:
                resword = &wordlist[750];
                goto compare;
              case 2789:
                resword = &wordlist[751];
                goto compare;
              case 2790:
                resword = &wordlist[752];
                goto compare;
              case 2795:
                resword = &wordlist[753];
                goto compare;
              case 2803:
                resword = &wordlist[754];
                goto compare;
              case 2810:
                resword = &wordlist[755];
                goto compare;
              case 2813:
                resword = &wordlist[756];
                goto compare;
              case 2817:
                resword = &wordlist[757];
                goto compare;
              case 2818:
                resword = &wordlist[758];
                goto compare;
              case 2825:
                resword = &wordlist[759];
                goto compare;
              case 2830:
                resword = &wordlist[760];
                goto compare;
              case 2836:
                resword = &wordlist[761];
                goto compare;
              case 2839:
                resword = &wordlist[762];
                goto compare;
              case 2844:
                resword = &wordlist[763];
                goto compare;
              case 2846:
                resword = &wordlist[764];
                goto compare;
              case 2859:
                resword = &wordlist[765];
                goto compare;
              case 2861:
                resword = &wordlist[766];
                goto compare;
              case 2877:
                resword = &wordlist[767];
                goto compare;
              case 2882:
                resword = &wordlist[768];
                goto compare;
              case 2885:
                resword = &wordlist[769];
                goto compare;
              case 2897:
                resword = &wordlist[770];
                goto compare;
              case 2903:
                resword = &wordlist[771];
                goto compare;
              case 2914:
                resword = &wordlist[772];
                goto compare;
              case 2922:
                resword = &wordlist[773];
                goto compare;
              case 2926:
                resword = &wordlist[774];
                goto compare;
              case 2939:
                resword = &wordlist[775];
                goto compare;
              case 2953:
                resword = &wordlist[776];
                goto compare;
              case 2956:
                resword = &wordlist[777];
                goto compare;
              case 2964:
                resword = &wordlist[778];
                goto compare;
              case 2965:
                resword = &wordlist[779];
                goto compare;
              case 2971:
                resword = &wordlist[780];
                goto compare;
              case 2972:
                resword = &wordlist[781];
                goto compare;
              case 2988:
                resword = &wordlist[782];
                goto compare;
              case 2993:
                resword = &wordlist[783];
                goto compare;
              case 3003:
                resword = &wordlist[784];
                goto compare;
              case 3013:
                resword = &wordlist[785];
                goto compare;
              case 3018:
                resword = &wordlist[786];
                goto compare;
              case 3029:
                resword = &wordlist[787];
                goto compare;
              case 3037:
                resword = &wordlist[788];
                goto compare;
              case 3043:
                resword = &wordlist[789];
                goto compare;
              case 3044:
                resword = &wordlist[790];
                goto compare;
              case 3050:
                resword = &wordlist[791];
                goto compare;
              case 3072:
                resword = &wordlist[792];
                goto compare;
              case 3073:
                resword = &wordlist[793];
                goto compare;
              case 3075:
                resword = &wordlist[794];
                goto compare;
              case 3097:
                resword = &wordlist[795];
                goto compare;
              case 3108:
                resword = &wordlist[796];
                goto compare;
              case 3110:
                resword = &wordlist[797];
                goto compare;
              case 3115:
                resword = &wordlist[798];
                goto compare;
              case 3142:
                resword = &wordlist[799];
                goto compare;
              case 3145:
                resword = &wordlist[800];
                goto compare;
              case 3172:
                resword = &wordlist[801];
                goto compare;
              case 3181:
                resword = &wordlist[802];
                goto compare;
              case 3194:
                resword = &wordlist[803];
                goto compare;
              case 3222:
                resword = &wordlist[804];
                goto compare;
              case 3240:
                resword = &wordlist[805];
                goto compare;
              case 3242:
                resword = &wordlist[806];
                goto compare;
              case 3275:
                resword = &wordlist[807];
                goto compare;
              case 3292:
                resword = &wordlist[808];
                goto compare;
              case 3294:
                resword = &wordlist[809];
                goto compare;
              case 3301:
                resword = &wordlist[810];
                goto compare;
              case 3303:
                resword = &wordlist[811];
                goto compare;
              case 3306:
                resword = &wordlist[812];
                goto compare;
              case 3319:
                resword = &wordlist[813];
                goto compare;
              case 3320:
                resword = &wordlist[814];
                goto compare;
              case 3326:
                resword = &wordlist[815];
                goto compare;
              case 3331:
                resword = &wordlist[816];
                goto compare;
              case 3335:
                resword = &wordlist[817];
                goto compare;
              case 3361:
                resword = &wordlist[818];
                goto compare;
              case 3372:
                resword = &wordlist[819];
                goto compare;
              case 3420:
                resword = &wordlist[820];
                goto compare;
              case 3425:
                resword = &wordlist[821];
                goto compare;
              case 3513:
                resword = &wordlist[822];
                goto compare;
              case 3554:
                resword = &wordlist[823];
                goto compare;
              case 3567:
                resword = &wordlist[824];
                goto compare;
              case 3596:
                resword = &wordlist[825];
                goto compare;
              case 3610:
                resword = &wordlist[826];
                goto compare;
              case 3634:
                resword = &wordlist[827];
                goto compare;
              case 3661:
                resword = &wordlist[828];
                goto compare;
              case 3662:
                resword = &wordlist[829];
                goto compare;
              case 3697:
                resword = &wordlist[830];
                goto compare;
              case 3725:
                resword = &wordlist[831];
                goto compare;
              case 3757:
                resword = &wordlist[832];
                goto compare;
              case 3760:
                resword = &wordlist[833];
                goto compare;
              case 3781:
                resword = &wordlist[834];
                goto compare;
              case 3825:
                resword = &wordlist[835];
                goto compare;
              case 3884:
                resword = &wordlist[836];
                goto compare;
              case 3890:
                resword = &wordlist[837];
                goto compare;
              case 3919:
                resword = &wordlist[838];
                goto compare;
              case 3925:
                resword = &wordlist[839];
                goto compare;
              case 3930:
                resword = &wordlist[840];
                goto compare;
              case 3938:
                resword = &wordlist[841];
                goto compare;
              case 3947:
                resword = &wordlist[842];
                goto compare;
              case 3953:
                resword = &wordlist[843];
                goto compare;
              case 4123:
                resword = &wordlist[844];
                goto compare;
              case 4183:
                resword = &wordlist[845];
                goto compare;
              case 4218:
                resword = &wordlist[846];
                goto compare;
              case 4274:
                resword = &wordlist[847];
                goto compare;
              case 4337:
                resword = &wordlist[848];
                goto compare;
              case 4411:
                resword = &wordlist[849];
                goto compare;
              case 4489:
                resword = &wordlist[850];
                goto compare;
              case 4524:
                resword = &wordlist[851];
                goto compare;
              case 4572:
                resword = &wordlist[852];
                goto compare;
              case 4717:
                resword = &wordlist[853];
                goto compare;
              case 4765:
                resword = &wordlist[854];
                goto compare;
              case 4770:
                resword = &wordlist[855];
                goto compare;
              case 4795:
                resword = &wordlist[856];
                goto compare;
              case 4805:
                resword = &wordlist[857];
                goto compare;
              case 4998:
                resword = &wordlist[858];
                goto compare;
              case 5010:
                resword = &wordlist[859];
                goto compare;
              case 5045:
                resword = &wordlist[860];
                goto compare;
              case 5101:
                resword = &wordlist[861];
                goto compare;
              case 5238:
                resword = &wordlist[862];
                goto compare;
              case 5291:
                resword = &wordlist[863];
                goto compare;
              case 5326:
                resword = &wordlist[864];
                goto compare;
              case 5382:
                resword = &wordlist[865];
                goto compare;
              case 5519:
                resword = &wordlist[866];
                goto compare;
              case 5622:
                resword = &wordlist[867];
                goto compare;
              case 5903:
                resword = &wordlist[868];
                goto compare;
            }
          return 0;
        compare:
          {
            register const char *s = resword->msg;

            if (*str == *s && !strcmp (str + 1, s + 1))
              return resword;
          }
        }
    }
  return 0;
}
#endif
/********** End file: rcp_api_parameters_hash_table.c ***************************/

